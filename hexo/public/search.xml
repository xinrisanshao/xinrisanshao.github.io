<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[引用&指针&const]]></title>
    <url>%2F2017%2F09%2F01%2F%E5%BC%95%E7%94%A8%26%E6%8C%87%E9%92%88%26const%2F</url>
    <content type="text"><![CDATA[本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。 引用一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 int a; 基本数据类型 声明符（其实就是变量名） //更复杂的声明符 ----接下来的指针和引用 int *b; //指针可以不初始化，没语法错误 int &amp;b = a; //引用必须初始化 引用（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 123int ival = 1024;int &amp;refVal = ival; //refVal指向ival(是ival的另一个名字)int &amp;refVal2; //报错，引用必须初始化 一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用注意细节 无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。 引用本身不是对象，所以不能定义引用的引用。 引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（两种例外，一种是对常量的引用 const int &amp;） int &amp;refVal4 = 10; //错误，引用类型的初始值必须是一个对象 double dval = 3.14; int &amp;refVal5 = dval; //错误：此处引用类型初始值必须是int型对象 代码示例12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 2; int c = 4; int &amp;b = a; //b是a的引用，即b是a的别名 //&amp;b = c; 错误,无法令引用重新绑定到另外一个对象上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = 5; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; b = 6; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = c; //将a的值改变，b的值也相应改变，但&amp;a和&amp;b还是一样的 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; b = c; //同上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; return 0;&#125; 2 2 0x28fef8 0x28fef8 5 5 0x28fef8 0x28fef8 6 6 0x28fef8 0x28fef8 4 4 0x28fef8 0x28fef8 0x28fef4 4 4 0x28fef8 0x28fef8 0x28fef4 指针指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。 指针和引用的不同点： 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&amp;）. 12int ival = 42;int *p = &amp;ival; //指针变量p存放变量ival的地址,也即p是指向变量ival的指针 注意细节 引用不是对象，没有实际地址，所有不能定义指向引用的指针。 指针的类型要和它指向的对象严格匹配(两种例外，一种是指向常量的指针)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。 指针值指针的值（即地址）应属下列4种状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值） 注意：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。 利用指针访问对象使用解引用符（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。 空指针空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法： 123int *p1 = nullptr; //等价于int *p1 = 0;int *p2 = 0; //直接将p2初始化为字面常量0int *p3 = NULL; //等价于int *p1 = 0; C++程序最好使用nullptr,同时尽量避免使用NULL。 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。 int zero = 0 ,*p; pi = zero; // 错误：不能把int变量直接赋给指针 note:建立初始化所有指针 原因：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。 void* 指针void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解： 123double obj = 3.14, *pd = &amp;obj; // 正确：void*能存放任意类型对象的地址void *pv = &amp;obj; // obj可以是任意类型的对象pv = pd; // pv可以存放任意类型的指针 利用void指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象 代码示例1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; double obj = 3.14,*pd = &amp;obj; void *pv = &amp;obj; cout&lt;&lt;&amp;obj&lt;&lt;" "&lt;&lt;obj&lt;&lt;endl; cout&lt;&lt;&amp;pd&lt;&lt;" "&lt;&lt;pd&lt;&lt;" "&lt;&lt;*pd&lt;&lt;endl; cout&lt;&lt;&amp;pv&lt;&lt;" "&lt;&lt;pv&lt;&lt;" "&lt;&lt;endl; //不能直接操作void* 指针所指的对象，即*pv是不合法的 return 0;&#125; 0x28ff08 3.14 0x28ff04 0x28ff08 3.14 0x28ff00 0x28ff08 理解复合类型的声明修饰符（或&amp;）和变量标识符写在一起，修饰符(或者&amp;)都是修饰变量的。 1int *p1,*p2; //p1和p2都是指向int的指针 指向指针的指针指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。 通过的个数可以区分指针的级别。也就是说，表示指向指针的指针，表示指向指针的指针的指，依次类推： 123456int ival = 1024;int *pi = &amp;ival; //pi指向一个int型的数int **ppi = &amp;pi; //ppi指向一个int型的指针//解引用cout&lt;&lt;ival&lt;&lt;" "&lt;&lt;*pi&lt;&lt;" "&lt;&lt;**ppi&lt;&lt;endl; 指向指针的引用引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。 123456int i = 42;int *p; //p是一个int型指针int *&amp;r = p; //r是一个对指针p的引用, 此时r和p指针同名r = &amp;i; //r引用了一个指针，因此给r赋值&amp;i就是令指向i*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0 要理解r的类型到底是什么，最简单的方法就是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。 const限定符const定义有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字const对变量的类型加以限制： 1const int bufSize = 512; //输入缓冲区大小 这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。 123const int i = get_size(); //正确：运行时初始化const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 const类型能参与的操作：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。 默认状态下，const对象仅在文件内有效当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： 1const int bufSize = 512; //输入缓冲区大小 编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在多个文件中声明并使用它。 解决办法： 对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了：1234//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问extern const int bufferSize = function();//file1.h头文件extern const int bufferSize; //与file1.cpp中定义的是同一个note：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。## const引用可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。1234const int ci = 1024;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1时对常量的引用int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。## 初始化和对const的引用引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。 尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：12345int i = 42; const int &amp;r1 = i; //允许将const int &amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确：r1是一个常量引用const int &amp;r3 = r1*2; //正确：r3是一个常量引用int &amp;r4 = r1*2; //错误：r4是一个普通的非常量y如果int &amp;r4 = r12合法，那么就可以通过r4改变r1的值，而r1是常量引用。常量引用被绑定到另外一种类型上时到底发生了什么：1234567double dval = 3.14;const int &amp;ri = dval;//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：const int temp = dval; //由双精度浮点数生成一个临时的整形常量const int &amp;ri = temp; //让ri绑定这个临时量总结：常量引用（const &amp;）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。## 对const的引用可能引用一个并非const的对象必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：12345int i = 42;int &amp;r1 = i; // 引用r1绑定对象iconst int &amp;r2 = i； // r2也绑定对象i，但是不允许通过r2修改i的值r1 = 0; // r1并非常量引用，i的值修改为0r2 = 0; // 错误：r2是一个常量引用r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。## 指针和const(指向常量的指针 const double cptr)指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。123456const double pi = 3.14; //pi是一个常量，它的值不能改变double *ptr = &amp;pi; //错误，ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值double dval = 3.2;cptr = &amp;dval; //对的注意：之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象：12double dval = 3.14;const double *ptr = &amp;dval;和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。 const指针（常量指针 int *const curErr）指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值： 1234int errNumb = 0;int *const curErr = &amp;errNumb; //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; //pip是一个指向常量对象的常量指针 从右向左阅读 此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。 指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值： 1234567*pip = 2.72; // 错误：pip是一个指向常量的指针//如果curErr所指的对象（也就是errNumb）的值不为0if(*curErr)&#123; errorHandler(); *curErr = 0; //正确，把curErr所值得对象的值重置&#125; 总结指向常量的指针（const doubel cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。 12const double pi = 3.14const double *const pip = &amp;pi; 则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primers</tag>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结之排序算法]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中… 注：这里实现的算法都是递增排序，也就是从小到大排序。 初级排序算法1.选择排序思想：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 1234567891011121314public static int [] sort(int a[],int length)&#123; //选择排序 for(int i=0;i&lt;length;i++)&#123; int minIndex = i; //初始化最小元素的索引 for(int j=i+1;j&lt;length;j++)&#123; if(a[minIndex]&gt;a[j])&#123; minIndex = j; //找到最小元素的索引 &#125; &#125; int tem = a[i]; a[i] = a[minIndex]; a[minIndex] = tem; &#125; return a;&#125; 2.直接插入排序思想： 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。 代码： 第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。12345678910public static int [] sort(int a[],int length)&#123; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i;j&gt;0&amp;&amp;a[j]&lt;a[j-1];j--)&#123; int tem = a[j-1]; a[j-1] = a[j]; a[j] = tem; &#125; &#125; return a;&#125; 第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。1234567891011public static int [] sort(int a[],int length)&#123; //不需要交换的插入排序 for(int i=1;i&lt;a.length;i++)&#123; int tem = a[i]; //待插入的元素 int j; for(j=i-1;j&gt;=0&amp;&amp;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; //元素后移,直到找到待插入的元素的位置 &#125; a[j+1] = tem; //将带插入元素插入到查找到的位置 &#125; return a;&#125; 第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j&gt;0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。 1234567891011121314151617181920public static int [] sort(int a[],int length)&#123; int minIndex =0; for(int i=1;i&lt;length;i++)&#123; if(a[minIndex]&gt;a[i])&#123; minIndex = i; &#125; &#125; int tem = a[0]; a[0] = a[minIndex]; a[minIndex] = tem; for(int i=2;i&lt;length;i++)&#123; tem = a[i]; int j; for(j=i-1;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; &#125; a[j+1] = tem; &#125; return a;&#125; 3.希尔排序思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。 我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 代码：12345678910111213141516public static int[] sort(int a[],int length)&#123; int h = length/2; //初始增量 while(h&gt;=1)&#123; //将数组变为h有序 for(int i=h;i&lt;length;i++) &#123; //将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中 for(int j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h)&#123; int tem = a[j-h]; a[j-h] = a[j]; a[j] = tem; &#125; &#125; h = h/2; //每次排完序后,增量减少 &#125; return a;&#125; 参考：dreamcatcher-cx 归并排序简介归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。 2-路归并排序2-路归并排序:假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 该图显示的就是循环2-路归并排序算法的过程： 2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。 递归算法：自顶向下的2-路归并排序中归并结果的轨迹： 循环算法：自底向上的2-路归并排序中归并结果的轨迹： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Mergesort &#123; //2-路归并排序 public static int [] aux; //辅助数组 public static void merge(int a[],int lo,int mid,int hi)&#123; //核心算法 //将a[lo..mid]和a[mid+1,hi](已有序)归并 int i = lo, j = mid+1; for(int k = lo;k&lt;=hi;k++)&#123; //将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid) a[k] = aux[j++]; //左半边用尽，取右半边的元素复制到a中 else if(j&gt;hi) a[k] = aux[i++]; //右半边用尽，取左半边的元素复制到a中 else if(aux[i]&lt;aux[j]) a[k] = aux[i++]; //左半边元素小于右半边元素，取左半边元素复制到a中 else a[k] = aux[j++]; //右半边元素小于左半边元素，取右半边元素复制到a中 &#125; &#125; public static void Mergesort(int a[])&#123; //二路归并递归算法 aux = new int [a.length]; //一次性分配空间 sort(a,0,a.length-1); &#125; private static void sort(int[] a, int lo, int hi) &#123; // 将数组a[lo..hi]排序 if(lo&gt;=hi) return ; int mid = lo + (hi-lo)/2; sort(a,lo,mid); //递归将左半边排序 sort(a,mid+1,hi); //递归将右半边排序 merge(a, lo, mid, hi); //归并结果 &#125; public static void Mergesort1(int [] a) &#123; //二路归并非递归算法 //进行lgN次两两归并 int N = a.length; aux = new int [N]; for(int sz = 1; sz&lt;N;sz = 2*sz)&#123; //sz的子数组大小 for(int lo =0;lo&lt;N-sz; lo+=2*sz)&#123; //子数组的索引 merge(a, lo, lo+sz-1, Math.max(lo+2*sz-1, N-1)); &#125; &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123;2,3,5,1,4,0,7,6&#125;; //Mergesort(a); //调用2-路归并递归排序函数 Mergesort1(a); //调用2-路归并非递归排序函数 for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125; 一些改进1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。 2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。 3.不将元素复制到辅助数组（暂时不太明白）。 快速排序简介快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。 关键算法该方法的关键在于切分，这个过程使得数组满足下面的三个条件： 1.对于某个j,a[j]已经排定； 2.a[lo]到a[j-1]中的所有元素都不大于a[j]； 3.a[j+1]到a[hi]中的所有元素都不小于a[j]。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class QuickSort &#123; public static int[] quicksort(int a[])&#123; sort(a,0,a.length-1); return a; &#125; private static void sort(int[] a, int lo, int hi) &#123; if(hi&lt;=lo) return ; int j=partition(a,lo,hi); //切分 //第j个位置已经在它所在的排好序的位置 sort(a,lo,j-1); sort(a,j+1,hi); &#125; private static int partition(int[] a, int lo, int hi) &#123; int part = a[lo]; //切分元素 int i = lo,j=hi+1; //左右扫描指针 int tem; while(true)&#123; //扫描左右，检查扫描是否结束并交换元素 while(a[++i]&lt;part) &#123; //从左到右(第一个元素除外)找到大于等于part的元素 if(i==hi) break; &#125; while(a[--j]&gt;part)&#123; //从右到左找到小于等于part的元素 if(j==lo) break; &#125; if(i&gt;=j) break; tem = a[i]; a[i] = a[j]; a[j] = tem; &#125; tem = a[lo]; //将part=a[j]放入正确的位置 a[lo] = a[j]; a[j] = tem; return j; &#125; public static void main(String[] args) &#123; int []a = &#123;4,5,4,6,1,3&#125;; a = quicksort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网-剑指offer]]></title>
    <url>%2F2017%2F08%2F19%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[前言牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：点击查看 题目一：二维数组中的查找 （数组）题目描述:在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。 注：时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。 代码： 123456789101112131415161718192021222324252627public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array[0].length==0) &#123; //[[]]的情况 return false; &#125; //判断二维数组是否为空 for(int i=0;i&lt;array.length;i++) &#123; // 找出target所在二维数组的行 if(target&gt;=array[i][0]&amp;&amp;target&lt;=array[i][array[i].length-1]) &#123; //找到所在行之后，因为该行是有序的，此时使用二分查找即可 int low = 0; int high = array[i].length-1; int mid; while(low&lt;=high) &#123; mid = (high + low)/2; if(array[i][mid]&gt;target) &#123; high = mid - 1; &#125;else if(array[i][mid]&lt;target)&#123; low = mid + 1; &#125;else &#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125; 题目二：替换空格 （字符串）题目描述:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路： 第一种： 直接用StringBuffer提供的replace函数。(不可取，得自己搞) 1replace(int start, int end, String str); Replaces the characters in a substring of this sequence with characters in the specified String. 第二种： 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，从后向前遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。 注：从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。 代码： 1234567891011121314151617181920212223public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int oldlength = str.length()-1; int newlength = oldlength; //替换之后新数组的大小 for(int i=0;i&lt;str.length();i++) &#123; if(str.charAt(i)==' ')&#123; newlength += 2; //由一个' '变为"%20",长度增加2 &#125; &#125; str.setLength(newlength+1); //扩展str的长度,多余的位置是空字符 //此时oldlength和newlength都是数组的长度-1 for(;oldlength&gt;=0&amp;&amp;oldlength&lt;newlength;oldlength--)&#123; if(str.charAt(oldlength)==' ')&#123; str.setCharAt(newlength--, '0'); str.setCharAt(newlength--, '2'); str.setCharAt(newlength--, '%'); &#125;else&#123; str.setCharAt(newlength--, str.charAt(oldlength)); &#125; &#125; return str.toString(); &#125;&#125; 题目三：从尾到头打印链表 （链表）题目描述:输入一个链表，从尾到头打印链表每个节点的值。 思路： 第一种： 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low) 第二种： 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。 代码： 1234567891011121314151617181920212223242526272829/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); int count=0; while(listNode != null) &#123; vals.add(listNode.val); listNode = listNode.next; count++; &#125; for(int i=0;i&lt;count/2;i++) &#123; int tem = vals.get(i); vals.set(i, vals.get(count-i-1)); vals.set(count-i-1, tem); &#125; return vals; &#125;&#125; 12345678910public class linklist&#123; public static ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); public static void printListFromTailToHead(ListNode listNode) &#123; if(listNode != null) &#123; printListFromTailToHead(listNode.next); vals.add(listNode.val); &#125; &#125; //return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。&#125; 题目四：重建二叉树 （树）题目五：用两个栈实现队列 （栈、队列）题目描述:用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路： 入队push:将元素进栈A。 出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。 注： 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。 代码： 1234567891011121314151617181920public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; while(stack1.empty()&amp;&amp;stack2.empty())&#123; System.out.println("队列为空!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 题目十一：二进制中1的个数 （位运算）题目描述:输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路： 方法一： 通过n&amp;n-1可以消除整数最右边的1。多次执行n=n&amp;n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。 分析：为啥n&amp;n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 n=12 1100 n-1=11 1011 n=12&amp;11 1000 n=8 1000 n-1=7 0111 n=8&amp;7 0000 代码：12345678public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; n &amp;= n-1; count++; &#125; return count;&#125; 更多参考点击：算法-求二进制数中1的个数 题目十二：数值的整数次方 （代码的完整性）题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路： 方法一：估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。 方法二： 快速幂，快速幂能将复杂度降至O(logb)，确实是快了不少。 原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下： a^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)*a^(2^1)*a^(2^3) 通过使用&amp;和&gt;&gt;位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。 更多信息：快速幂 代码：123456789101112131415161718public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1.0; int e = exponent; exponent = Math.abs(exponent); if(exponent == 0)&#123; return result; &#125; while(exponent!=0)&#123; if((exponent&amp;1)==1)&#123; result *= base; &#125; base *= base; //每移动一位，该为代表的乘数都翻倍 exponent = exponent &gt;&gt; 1; //右移一位 &#125; return e&gt;0?result:1/result; &#125;&#125; 题目十三：调整数组顺序使奇数位于偶数前面 （数组）题目描述:输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路： 方法一： 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。 方法二：重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。 代码：12345678910111213141516public class Solution &#123; public void reOrderArray(int [] array) &#123; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]%2==0)&#123; //偶数的话，继续下一个数 continue; &#125;else&#123; int tem = array[i]; //保存待插入到偶数之前的奇数 int j; for(j=i-1;j&gt;=0&amp;&amp;(array[j]%2==0);j--)&#123; //找到偶数之前插入的位置 array[j+1] = array[j]; //偶数集体后移一位 &#125; array[j+1] = tem; //将奇数插入到该位置上 &#125; &#125; &#125;&#125; 题目十四：链表中倒数第k个结点题目描述:输入一个链表，输出该链表中倒数第k个结点。 思路： 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count&gt;=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。 代码：1234567891011121314151617181920212223242526/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; int count = 0; ListNode p = head; ListNode node = null; //head为空，返回null if(k&lt;=0) return node; //k&lt;=0无效，返回null while(head!=null)&#123; count++; head = head.next; if(count &gt;= k) &#123; //相对第一个元素为k-1的间隔时,head和p同时往后走 node = p; p = p.next; &#125; &#125; return node; &#125;&#125; 题目十五：反转链表题目描述:输入一个链表，反转链表后，输出链表的所有元素。 思路： 依次遍历每个结点，同时通过头插法再重新创建新的链表 注：可以利用之前的结点，而不需要重新创建新的结点，以后改进。 代码：123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode p = null; if(head == null) &#123; return p; &#125;else&#123; p = new ListNode(head.val); &#125; ListNode q = head.next; while(q!=null)&#123; ListNode s = new ListNode(q.val); s.next = p; p = s; q = q.next; &#125; return p; &#125;&#125; 题目十六：合并两个排序的链表题目描述:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。 注：可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode p = new ListNode(0); //创建一个头结点,数据域初始化为0，不存储数据,指针域为null ListNode head = p ; //头指针,指向头结点 if(list1 == null &amp;&amp; list2 == null) return null; while(list1!=null &amp;&amp; list2!=null)&#123; if(list1.val &lt; list2.val)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125;else &#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; &#125; while(list1!=null)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125; while(list2!=null)&#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; return head.next; //头结点不存储元素,head.next指向第一个元素节点，返回 &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>剑指offer</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[样先]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%A0%B7%E5%85%88%2F</url>
    <content type="text"><![CDATA[仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）新日左右： 余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。 予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。 大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。 新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！ 样先 2015.2.18 真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！]]></content>
      <categories>
        <category>兄弟</category>
      </categories>
      <tags>
        <tag>兄弟</tag>
        <tag>朋友</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（二） 提升篇]]></title>
    <url>%2F2017%2F08%2F07%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%20%20%E6%8F%90%E5%8D%87%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言在之前的初级篇中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。 二、更换主题在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。 在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下（此处为G:\GitHub\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件，后者称为主题配置文件。 1. 安装NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 1) 下载主题如果你熟悉Git，建议你使用克隆最新版本的方式，之后的更新可以通过git pull来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了） 在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：12cd G:\GitHub\hexogit clone https://github.com/iissnan/hexo-theme-next themes/next #后面意思是clone到该目录下themes/next文件夹中 2) 启用主题与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。 1theme: next 此时我们在主题配置文件中设置语言。修改language字段。在主题的languages文件夹中选择语言，此处目录为G:\GitHub\hexo\themes\next\languages 。 1language: zh-Hans #选择汉语，选择其他语言填写其他值即可 到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 3) 验证主题进入到博客文件夹根目录，此处为G:\GitHub\hexo，执行如下命令： 123hexo clean #更换主题，最好先清除Hexo缓存hexo generate #生成静态页面hexo server # hexo server -p **** 更换默认4000端口为**** 此时即可使用浏览器访问 http://localhost:4000。 检查站点是否正确运行，如长时间访问不了，更改端口。 现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 三、主题设定NexT官网和网上资料非常丰富，就不细说了，参考如下： 官方参考：NexT使用文档 网上资源：hexo的next主题个性化教程：打造炫酷网站 补充几点： 1. 添加评论功能我选择的是来比力，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。 编辑主题配置文件， 编辑 livere_uid 字段，设置如下： 1livere_uid: #your livere_uid 2. 修改背景图片首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下； 然后进入hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。 12345// Custom styles.body &#123; background:url(/images/background.jpeg); background-attachment: fixed; #固定背景图，使得不随页面移动&#125; 3. 修改博客内容宽度Pisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加 12$main-desktop = 1200px $content-desktop = 900px 可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。 参考：感觉浏览器留白太多，代码块看起来比较麻烦 4. 添加菜单栏在个人网站根目录下使用hexo命令hexo new page “photo” 就直接创建了.\Hexo\source\photo\index.md文件。 在主题配置文件_config.yml中找到meun:字段，添加photo字段123456789menu: home: / categories: /categories/ tags: /tags/ archives: /archives/ photo: /photo/ about: /about/ #sitemap: /sitemap.xml #commonweal: /404.html 给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加photo字段： 123456789101112menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat photo: photo 在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为photo：点击选择图标 将网站中的photo字段显示为中文照片字段 在\themes\next\languages\zh-Hans.yml添加： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 photo: 照片 5. 调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条1.调整文档摘要的高度 在/next/source/css/_common/components/post/post-meta.styl中修改margin的值 123.posts-expand .post-meta &#123; margin: 3px 0 10px 0; color: $grey-dark; 2.调整阅读全文按钮高度 在\next\source\css_common\components\post\post-button.styl中修改margin-top的值 123.post-button &#123; margin-top: 10px; .btn &#123; 3.去除首页文档与文档之间居中灰色的线条 在\next\source\css_common\components\post\post-eof.styl中注释掉如下样式 123456789101112.posts-expand &#123; .post-eof &#123; /* display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 8%; height: 1px; background: $grey-light; text-align: center; */ &#125;&#125; 最终效果如下： 6. 归档页博文列表高度调整在\next\source\css_common\components\post\post-collapse.styl中修改.post 1.post &#123; margin: 0px 0; &#125; 到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。 四、博客管理维护1. 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 注： .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：1.deploy*/ #只忽略上传.deploy*/开头的文件 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 2. 博客搭建流程 1.创建仓库，xinrisanshao.github.io； 2.创建两个分支：master 与 hexo； 3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 4.使用如下命令拷贝仓库 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 6.修改_config.yml中的deploy参数，分支应为master； 7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）； 8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。 这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。 注：流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\xinrisanshao.github.io\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。 3. 博客管理流程1. 编辑与修改博客在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 2.然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 2. 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：1.首先安装Git，Node.js和Hexo。 2.使用下面命令拷贝仓库（默认分支为hexo）； 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。 以上博客管理参考：点击查看 3. 博客图片存放（补）如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。 我选择的是七牛云存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。 五、总结不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（一） 初级篇]]></title>
    <url>%2F2017%2F08%2F06%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%20%20%E5%88%9D%E7%BA%A7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。 今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！ 二、环境准备1. 注册github账号这个就不多说了，账号注册好后，登陆，在首页右边有一个 + 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。 2. 安装Git我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是图形化界面（GUI）,另外一种是通过命令行。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， GitHub和Git Shell,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！ Github for Windows: 点击下载 下载安装完后，桌面上生成GitHub和Git Shell两个图标，然后点击GitHub图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。 Github for Windows 安装配置使用教程: 参考 3. 安装Node.js安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。 点击进入Node.js官网 我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。 4. 安装Hexo以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。 打开终端，输入： 1npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。 1npm config set registry https://registry.npm.taobao.org 安装好Hexo以后，在终端输入： 1hexo 若出现下图，说明hexo安装成功： 三、使用Hexo建站1. 初始化博客新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。 1hexo init [folder] 接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包 1npm install 2. 配置网站的主配置文件为hexo根目录下的_config.yml文件： 默认配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle:description:author: John Doelanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 这些配置项所代表的意思可以参考Hexo中文网：_config.yml配置 ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。 1). 修改网站相关信息123456title: 新日三少的博客 subtitle: Big big pig description: Love Coding,Enjoy Lifeauthor: 新日三少language: zh-CN #themes主题文件夹下的languages下面有很多语言可选timezone: Asia/Shanghai 注意：每一项的填写，其:后面都要保留一个空格，下同。 2). 配置统一资源定位符（个人域名）1url: http://www.wangxinri.cn 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。如无个人域名，无需修改这一项。 3). 配置部署1234deploy: type: git repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git branch: master 其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到： 3. 本地发布博客接下来，在网站中建立第一篇文章，打开终端，进入到博客文件夹根目录，这里是E:Github/hexo，然后输入 1hexo new "文章标题" 我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。 MarkdownPad2：点击下载 Markdown语法：Markdown中文网 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1npm install hexo-deployer-git --save 接下来,我们进行本地发布：12hexo generatehexo server 执行完后，打开浏览器，输入：1http://localhost:4000/ 我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。 4. 发布博客至github仓库但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。 打开终端，进入到博客文件夹根目录，这里还是E:Github/hexo，执行如下命令： 12hexo generatehexo deploy 输入我们的网址：xinrisanshao.github.io ,即可访问博客了。 此时查看github中的仓库，发现我们博客文件夹根目录中的public文件夹里面的文件已经发布到仓库中了。 此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。 好累啊，先休息下，果然还是写博客最累啊。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>