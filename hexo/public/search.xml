<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[顺序容器概述]]></title>
    <url>%2F2017%2F10%2F26%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、前言介绍顺序容器的种类及基本操作。 顺序容器一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的是11章的有序和无序关联容器，它们根据关键字的值来存储元素。 所有顺序容器都提供了快速访问元素的能力，但是，这些容器在以下方面都有不同的性能折中。 向容器添加或从容器中删除元素的代价。 非顺序访问容器中的元素。 顺序容器类型： 123456vector 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。list 双向链表。只支持双向顺序访问。在list中任何位置插入/删除都很快forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快。array 固定大小数组。支持快速随机访问。不能添加或删除元素。string 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。 除了array外，其他容器都提供高效、灵活的内存管理。 string和vector将元素保存在连续的内存空间中。因为连续，所以下标访问非常快。但在中间插入、删除较慢（O(n)）。有时添加一个元素还可能需要分配的额外空间，这种情况所有元素必须移动到新的存储空间中 forward_list和array是新C++标准增加的类型。array比内置数组更安全。forward_list没有size()操作。新标准库的容器比旧版本的快得多。 确定使用哪种顺序容器通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。 一般用vector。 如果程序有很多小元素，且空间的额外开销很重要，则不要用list或forward_list。 要随机访问元素用vector或deque。 如果要在中间插入或删除元素，应用list或forward_list。 如果要在头尾插入或删除元素。但不会在中间插入或删除元素，用deque。 如果程序只有在读取输入的时候才需要在容器中间位置插入元素，随后需要随机访问元素。如果确实需要，则考虑在输入阶段用list，一旦输入完成，将list中的元素拷贝到一个vector中。 如果程序既需要随机访问元素，又需要在容器中间插入元素，该怎么办？ 一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。 容器库概述容器类型上的操作形成了一种层次： 某些操作是所有容器类型都提供的。 另外一些操作仅针对顺序容器、关联容器或无序容器。 还有一些操作只适用于一小部分容器。 对容器可以保存的元素类型的限制顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另外一个容器。 1vector&lt;vector&lt;string&gt;&gt; lines; //lines是一个vector，其元类型是string的vector 某些类没有默认的构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数： 123//假定noDefault是一个没有默认构造函数的类型vector&lt;noDefault&gt; v1(10,init); //正确：提供了元素初始化器vector&lt;noDefault&gt; v2(10); //错误：必须提供一个元素初始化器 容器操作：(待补充) 迭代器标准库array具有固定大小与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小： 12array&lt;int,42&gt; //类型为：保存42个int的数组array&lt;string,10&gt; //类型为：保存10个string的数组 为了使用array类型，我们必须同时指定元素类型和大小：12array&lt;int,10&gt;::size_type i; //数组类型包括元素类型和大小array&lt;int&gt;::size_type j; //错误：array&lt;int&gt;不是一个类型 初始化array： 123array&lt;int,10&gt; ia1; //10个默认初始化的intarray&lt;int,10&gt; ia2 = &#123;0,1,2,3,4,5,6,7,8,9&#125;; //列表初始化array&lt;int,10&gt; ia3 = &#123;42&#125;; //ia3[0]为42，剩余元素为0 值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并无此限制。1234int digs[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int cpy[10] = digs; //错误，内置数组不支持拷贝或赋值array&lt;int,10&gt; digits = &#123;0,1,2,3,4,5,6,7,8,9&#125;;array&lt;int,10&gt; copy = digits; //正确，只要数组类型匹配即合法 赋值和swap赋值相关的运算符可用于所有的容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。 12c1 = c2; //将c1的内容替换为c2中元素的拷贝c1 = &#123;a,b,c&#125;; //赋值后，c1大小为3 如果两个容器原来的大小不同，赋值运算后两者的大小都与右边容器的原大小相同。 与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。也就是array进行赋值，左右两边数组大小必须相等。 1.assign(仅顺序容器) 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，我们可以用assign实现将一个vector中的一段char *值赋予一个list中的string： 12345list&lt;string&gt; names;vector&lt;const char *&gt; oldstyle;name = oldstyle; //错误，容器类型不匹配，赋值，类型必须完全一样//正确：可以将const char * 转化为stringnames.assign(oldstyle.cbegin(),oldstyle.cend()); assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素： 1234//等价于slist1.clear();//后跟slist1.insert(slist1.begin(),10,"Hiya!");list&lt;string&gt; slist1(1); //1个元素，为空stringslist1.assign(10,"Hiya!"); 2.使用swap swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。 123vector&lt;string&gt; svec1(10); //10个元素的vectorvector&lt;string&gt; svec2(24); //24个元素的vectorswap(svec1,svec2); 除array外，swap不对任何元素进行拷贝、删除或插入操作。因此可以保证在常数时间内完成。 在新标准中，容器既提供成员版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。 关系运算符每个容器类型都支持相等运算符（== 和 ！=）；除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器。且必须保存相同类型的元素。 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。 容器的关系运算符使用元素的关系运算符完成比较：容器的相等运算符实际上是使用元素的==运算符 来实现比较的，而其他关系运算符 是使用元素的&lt;运算符 。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算符。 12vector&lt;Sale_data&gt; storeA, storeB;if(storeA &lt; storeB) // 错误：Sales_data没有&lt;运算符 注意： 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。 顺序容器的操作顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。上一节介绍了所有容器都支持的操作。本章剩余部分将介绍顺序容器所特有的操作。 向顺序容器添加元素除了array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。 123456789101112131415向顺序容器添加元素的操作：操作会改变容器的大小；array不支持这些操作。forward_list有自己专有版本的insert和emplace；forward_list不支持push_back和emplace_backvector和string不支持push_front和emplace_frontc.push_back(t) 在c的尾部创建一个值为t或由args创建的元素，返回voidc.emplace_back(args)c.push_front(t) 在c的头部创建一个值为t或由args创建的元素，返回voidc.emplace_front(args)c.insert(p,t) 在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器c.emplace(p,args)c.insert(p,n,t) 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回pc.insert(p,b,e) 将迭代器b和e指向的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回pc.insert(p,il) il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器：若列表为空，则返回p 向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。 当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque的首位之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。 使用push_back我们看到push_back将一个元素追加到一个vector的尾部。除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。 例如，下面的循环每次读取一个string到word中，然后追加到容器尾部： 1234//从标准输入读取数据，将每个单词放到容器末尾string word;while(cin&gt;&gt;word) container.push_back(word); 对push_back的调用在container尾部创建了一个新的元素，将container的size增大了1。该元素的值为word的一个拷贝，container的类型可以是list、vector或deque。 关键概念：当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。 使用push_front除了push_back, list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部： 1234list&lt;int&gt; ilist;//将元素添加到Ilist开头for(size_t ix=0;ix!=4;++ix) ilist.push_front(ix); 此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的新的开始位置。即，当我们插入1时，它会被放置在0之前，2被放置在1之前，依次类推。因此，在循环中以这种方式将元素添加到容器中，最终会形成逆序。 注意： deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首部进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置插入元素会很耗时。 在容器中的特定位置添加元素（insert）push_back和push_front操作提供了一种方便地在顺序容器尾部或头部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。 每个insert函数都接受一个迭代器作为其一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能， 所有insert函数将元素插入到迭代器所指定的位置之前 。例如，下面的语句 1slist.insert(iter,"Hello!"); //将hello添加到iter之前的位置 虽然某些容器不支持push_front操作，但他们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front: 1234567vector&lt;string&gt; svec;list&lt;string&gt; slist;//等价于调用slist.push_front("Hello!");slist.insert(slist.begin(),"Hello!");//vector不支持push_front，但我们可以插入到begin()之前//警告：插入到vector末尾之外的任何位置都可能很慢svec.insert(svec.begin(),"Hello!"); 将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。 插入范围内元素除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函数类似。其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素够按给定值初始化： 1svec.insert(svec.end(),10,"Anna"); 这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string“Anna”。 接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前： 12345vector&lt;string&gt; v=&#123;"quasi","simba","frollo","scar"&#125;;//将v的最后两个元素添加到slist的开始位置slist.insert(slist.begin(),v.end()-2,v.end());slist.insert(slist.end(),&#123;"these","words","will","go","at","the","end"&#125;);slist.insert(slist.begin(),slist.begin(),slist.end()); //运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器 如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。 使用insert的返回值通过使用insert的返回值，可以在容器中一个特定的位置反复插入元素： 1234list&lt;string&gt; lst;auto iter=lst.begin();while(cin&gt;&gt;word) iter=lst.insert(iter,word); //等价于调用push_front 在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，读取下一个单词。 使用emplace操作使用emplace操作 新标准引入了三个成员——emplace_front、emplace和emplace_back，这些操作（构造而不是拷贝元素）。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定的位置之前或容器尾部。 当调用push或insert成员函数时，我们将元素类型对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素： 123456//在c的末尾构造一个Sales_data对象//使用三个参数的Sales_data的构造函数c.emplace_back("978-0590353403",25,15.99);c.push_back("978-0590353403",25,15.99); //错误：没有接受三个参数的push_back版本//正确：创建一个临时的Sales_data对象传递给push_backc.push_back(Sales_data(("978-0590353403",25,15.99)); 其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。 emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配 ：12345//iter指向c中一个元素，其中保存了Sales_data元素c.emplace_back();//使用Sales_data的默认构造函数c.emplace(iter,"999-999999999"); //使用Sales_data(string)//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数c.emplace_front("978-0590353403",25,15.99);emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。## 访问元素 （访问成员函数返回的是引用）下表列出了我们可以用来在顺序容器值访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。包括array在内的每个顺序容器都有一个front成员函数，而除了forward_list之外的所以顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用：12345678//在解引用一个迭代器或调用front或back之前检查是否有元素if(!c.empty())&#123; //val和val2是c中第一个元素值的拷贝 auto val=*c.begin(),val2=c.front(); //val3和val4是c中最后一个元素值的拷贝 auto last=c.end(); auto val3=*(--last); //不能递减forward_list迭代器 auto val4=c.back(); //forward_list不支持此程序用两种不同方式来获取c中的首元素和尾元素的引用。 直接的方式是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获取尾元素的引用。 在顺序容器中访问元素的操作 123456at和下标操作只适用于string、vector、deque和array。back不适用于forward_list。c.back() 返回c中尾元素的引用。若c为空，函数行为未定义c.front() 返回c中首元素的引用。若c为空，函数行为未定义c[n] 返回c中下标为n的元素的引用，n是一个无符号整数。若n&gt;c.size(),则函数的行为未定义c.at[n] 返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常 对一个空容器调用front和back，就像使用一个越界的下标一样。是一种严重的程序设计错误。 访问成员函数返回的是引用在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值： 1234567if(!c.empty())&#123; c.front() = 42; //将42赋予c中的第一个元素 auto &amp;v = c.back(); //获得指向最后一个元素的引用 v = 1024; //改变c中的元素 auto v2 = c.back(); //v2不是一个引用，它是c.back()的一个拷贝 v2 = 0;&#125; 与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。 下标操作和安全的随机访问提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们已经看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。 我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常： 123vector&lt;string&gt; svec; //空vectorcout&lt;&lt;svec[0]; //运行时错误：svec中没有元素cout&lt;&lt;svec.at[0]; //抛出一个out_of_range异常 删除元素与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下表所示： 顺序容器的删除操作 12345678这些操作会改变容器的大小，所以不适用于arrayforward_list有特殊版本的eraseforward_list不支持pop_back；vector和string不支持pop_frontc.pop_back() 删除c中尾元素，若c为空，则函数行为未定义，函数返回voidc.pop_front() 删除c中首元素，若c为空，则函数行为未定义，函数返回voidc.erase(p) 删除迭代器p所指的元素，返回以指向被删除元素之后的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数的行为未定义c.erase(b,e) 删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器c.clear() 删除c中的所以元素，返回void 删除deque中除首位元素之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。 pop_front和pop_back成员函数pop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似的，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。 这些操作返回void，如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它： 1234while(!ilist.empty())&#123; process(ilist.front()); //对ilist的首元素进行一些处理 ilist.pop_front(); //完成处理后删除首元素&#125; 从容器内部删除一个元素成员函数erase从容器中指定位置删除元素，我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。 例如，下面的循环删除一个list中的所有奇数元素： 1234567list&lt;int&gt; lst=(0,1,2,3,4,5,6,7,8,9&#125;;auto it=lst.begin();while(it!=lst.end()) if(*it%2) it=lst.erase(it); //删除此元素 else ++it; 每个循环步中，首先检查当前元素是否是奇数，如果是，就删除该元素，并将it设置为我们所删除的元素之后的元素。如果*it为偶数，我们将it递增，从而在下一步循环检查下一个元素。 删除多个元素接受一对迭代器的erase版本允许我们删除一个范围内的元素： 123//删除两个迭代器表示的范围内的元素//返回指向最后一个被删除元素之后位置的迭代器elem1=slist.erase(elem1,elem2); //调用后，elem1==elem2 迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。 为了删除一个容器中的所有元素，我们既可以调用clear，也可以用begin和end获得的迭代器作为参数调用erase： 12slist.clear() ;//删除容器中的所有元素slist.erase(slist.begin(),slist.end()); //等价调用]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>顺序容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O流与string流]]></title>
    <url>%2F2017%2F10%2F23%2FIO%E6%B5%81%E4%B8%8Estring%E6%B5%81%2F</url>
    <content type="text"><![CDATA[一、前言介绍I/O流和string流及其基本使用。 IO类IO对象无拷贝或赋值由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 条件状态12345678910111213141516171819#include &lt;iostream&gt;using namespace std;istream&amp; func(istream &amp;is)&#123; string buf; while (is &gt;&gt; buf) cout &lt;&lt; buf &lt;&lt; endl; is.clear(); //将流的状态设置为有效 return is;&#125;int main()&#123; istream&amp; is = func(std::cin); cout &lt;&lt; is.rdstate() &lt;&lt; std::endl; cout&lt;&lt;"hi!"&lt;&lt;endl; //输出hi和一个换行，然后刷新缓冲区 cout&lt;&lt;"hi!"&lt;&lt;flush; //输出hi，然后刷新缓冲区，不附加任何额外的字符串 cout&lt;&lt;"hi!"&lt;&lt;ends; //输出hi和一个空字符，然后刷新缓冲区 return 0;&#125; 文件输入输出头文件fstream定义了三个类型来支持文件IO：ifstream从给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写文件。 这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样，特别是，我们可以用IO运算符（&lt;&lt;和&gt;&gt;）来读写文件，可以用getline从一个ifstream读取数据。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;void readfile(string filename,vector&lt;string&gt;&amp; svec)&#123; //从文件中读取数据到svec中 ifstream input; //从一个给定文件读取数据 input.open(filename); if(input)&#123; /* string line; while(getline(input,line))&#123; //按行读取文件，input当成输入流cin处理就行 svec.push_back(line); &#125;*/ string word; while(input&gt;&gt;word)&#123; //按单词读取文件，input当成输入流cin处理就行 svec.push_back(word); &#125; &#125;else&#123; cout&lt;&lt;"couldn't open: " + filename&lt;&lt;endl; &#125; input.close();&#125;void writefile(string filename,const vector&lt;string&gt;&amp; svec)&#123; //从文件中读取数据到svec中 ofstream out; //ofstream向一个给定文件写入数据 out.open(filename,ofstream::app); //不清空文件，末尾追加写入 if(out)&#123; for(auto word : svec)&#123; out&lt;&lt;word&lt;&lt;endl; //输出流，也就将word写入到文件中 &#125; &#125;else&#123; cout&lt;&lt;"couldn't open: " + filename&lt;&lt;endl; &#125; out.close();&#125;int main()&#123; string filename = "STRING.txt"; vector&lt;string&gt; svec; readfile(filename,svec); for(auto line : svec)&#123; cout&lt;&lt;line&lt;&lt;endl; &#125; //从svec写入数据到文件中 filename = "WRITE.txt"; writefile(filename,svec); return 0;&#125; 文件模式每个流都有一个关联的文件模式（mode），用来指出如何使用文件。具体的mode有哪些呢？123456in 以读方式打开out 以写方式打开app 每次写操作前均定位到文件末尾（从文件尾开始写，不覆盖前面写的）ate 打开文件后立即定位到文件末尾trunc 截断文件binary 以二进制方式进行IO 不管用哪种方式打开文件，我们都可以指定文件模式，调用open显式打开或者用一个文件名初始化文件流来隐式打开文件都可指定文件模式。但是上述模式间有限制关系： 只可以对ifstream和ifstream对象设定in模式 只可以对ofstream和fstream对象设定out模式 只有当out被设定时才能设定trunc模式 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式打开 默认情况下，即使我们没有指定trunc模式，以out模式打开的文件也会被截断。为了保留以out模式打开的文件内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。 每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开，与ofstream关联的文件默认以out模式打开，与fstream关联的文件默认以in和out模式打开。 此外，有两点需要特别注意： 1：以out模式打开文件会丢弃已有数据 默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止清空文件的方法是同时指定app模式。 1234567// 这三条语句中，file都将被截断ofstream out("file"); // 隐含以输出模式打开文件并截断文件ofstream out("file",ofstream::out); // 隐含地截断文件ofstream out("file",ofstream::out|ofstream::trunc); //这两条语句中，文件内容将被保存ofstream out("file",ofstream::app); //隐含为输出模式ofstream app("file",ofstream::out|ofstream::app); 小结：保留被ofstream打开的文件中内容的唯一方法是显示指定app或in模式。 2 ：每次调用open时都会确定文件模式 对于一个给个流，每当打开文件时，都可以改变其文件模式。 12345ofstream out; // 未指定文件打开模式out.open("file"); // 隐含设置为输出和截断out.close(); // 与out绑定的名为file的文件被关闭，以便我们将对象out用于其他文件out.open("preFile",ofstream::app); //模式为输出和文件尾追加out.close(); 名为file的文件内容将被清空，名为preFile的文件中已有的数据将都被保存。 小结：每次打开文件时，都要设置文件模式，可以是显式的设置，也可以是隐式的设置。当文件未指定模式时，都是使用默认值。 String流sstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。 istringstream从string读取数据，ostreamstream向string写入数据，而头文件stringstream既可以读数据也可向string写数据。 头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。 12345stringstream特有的操作sstream strm； strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型sstream strm(s); strm是一个sstream对象，保存strings的一个拷贝。此构造函数是explicit的strm.str（） 返回strm所保存的string类型strm.str(s) 将string的s拷贝到strm中，返回void 使用istringstream当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的某个单词时，通常可以使用istringstream。 考虑如下文件，列出了一些人和他们的电话号码（电话号码多选）123morgan 20155555 685522drew 5524566lee 425422 542122 55444222 我们定义一个简单的类来描述输入数据： 1234struct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125; 我们从文本中读入输入数据，并将输入数据写入到vector容器中： 以下是完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace std;//成员默认公有struct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125;;int main()&#123; string filename = "Info.txt"; ifstream input; //从文件中读取数据 vector&lt;PersonInfo&gt; Pvec; input.open(filename); if(input)&#123; string line; string phone; while(getline(input,line))&#123; PersonInfo info; istringstream record(line); //将记录绑定到刚读入的行 record&gt;&gt;info.name; //读取名字 while(record&gt;&gt;phone)&#123; //读取电话号码 info.phones.push_back(phone); &#125; Pvec.push_back(info); //将记录追加到people末尾 &#125; &#125;else&#123; cout&lt;&lt;"couldn't not open file"&lt;&lt;endl; &#125; input.close(); for(auto people : Pvec)&#123; //输出 cout&lt;&lt;people.name; for(auto phone : people.phones)&#123; cout&lt;&lt;" "&lt;&lt;phone; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 使用ostringstream当我们逐步构造输出，希望最后一起打印是，ostringstream是很有用的。 12345ostringstream badNums;string num = "123";string name = "xin";badNums&lt;&lt;num&lt;&lt;name; //将数的字符串的形式存入badNumscout&lt;&lt;badNums.str()&lt;&lt;endl; //输出123xin 输出badNums.str()!]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>I/O流</tag>
        <tag>string流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的基本概念]]></title>
    <url>%2F2017%2F10%2F22%2F%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[一、前言介绍一些类的基本概念，包括类的基本思想，函数成员和数据成员，static成员，友元等。 类类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。 定义成员函数尽管所有成员函数都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。 Sales_data的一个成员函数 1string isbn() const &#123; return bookNo;&#125; 引入this指针12Sales_data total;total.isbn(); 在这里，使用点运算符来访问total对象的isbn成员，然后再调用它。 当我们调用成员函数时，实际上是在替某个对象调用它。它隐式地指向调用该函数的对象的成员。实际上隐式地返回 total.bookNo。 成员函数通过一个名为this的额外参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。 1total.isbn() 相当于： 12//伪代码，用于说明调用成员函数的实际执行过程Sales_data::isbn(&amp;total) 其中调用Sales_data的isbn成员时传入了total地址。 this是一个常量指针，我们不允许改变。 引入const成员函数默认情况下，this的类型是指向类类型非常量版本的常量指针。意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使我们不能在一个常量对象上调用普通的成员函数。 C++允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针（const Sales_data const this）。*像这样使用const的成员函数被称作常量成员函数。 因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内存。 常量对象、以及常量对象的引用或指针都只能调用常量成员函数。 ，非常量对象可以调用常量成员函数。 类作用域和成员函数编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。 因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。 类外部定义的成员的名字必须包含它所属的类名。 定义类相关的非成员函数一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。 点运算符和箭头运算符（. -&gt;)123Person p1 ,*p2;p1.getname(); //针对于对象来使用的p2-&gt;getname(); //针对于指针来使用的，等价于*p2.getname(); 构造函数类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。 构造函数不能被声明成const。 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。 知识点1：构造函数—特殊的成员函数，用来控制对象的初始化过程。无返回类型，可重载，不能被声明为const. 知识点2：若无，则有默认的构造函数，是编译器自己隐式的定义的。又称合成的默认构造函数。 知识点3：某些类是不能使用默认的构造函数的，以下三个原因： 1：在未声明任何构造函数的前提下，类内对象的初始化将不受控制 2：合成的默认构造函数可能会造成不必要的错误，如若没有类内初始值来初始化成员，可能这些成员将是未定义的。 3：如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该对象。 所以，在撰写类的时候，最好定义一个自己的构造函数。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person; //前向声明Person类istream&amp; read(istream&amp; is,Person&amp; person); //声明read函数class Person&#123;public: Person() = default; //默认构造函数 等价于Person()&#123;&#125;; Person(string name,string address); //重载构造函数 Person(istream &amp;is)&#123; //重载构造函数，通过调用非成员函数read对其进行赋值 read(is,*this); &#125; void show(); const string&amp; getname()&#123; return this-&gt;name; &#125; const string&amp; getaddress()&#123; return this-&gt;address; &#125; void setname(string name)&#123; this-&gt;name = name; &#125; void setaddress(string address)&#123; this-&gt;address = address; &#125; Person&amp; combine(const Person &amp;person);private: string name; string address;&#125;;void Person::show()&#123; cout&lt;&lt;"name:"&lt;&lt;this-&gt;name&lt;&lt;" address:"&lt;&lt;this-&gt;address&lt;&lt;endl;&#125;Person::Person(string name,string address):name(name),address(address)&#123;&#125;Person&amp; Person::combine(const Person &amp;person)&#123; name += person.name; return *this;&#125;istream&amp; read(istream&amp; is,Person&amp; person)&#123; //非成员函数 string name ,address; is&gt;&gt;name&gt;&gt;address; person.setname(name); person.setaddress(address); return is;&#125;int main()&#123; Person p1("wangxinri","cqu"); p1.show(); Person p2("ri","cqu"); p1.combine(p2); p1.show(); cout&lt;&lt;p2.getname()&lt;&lt;endl; cout&lt;&lt;p2.getaddress()&lt;&lt;endl; Person p3(cin); p3.show(); return 0;&#125; 拷贝、赋值和析构如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。 对于某些类来说合成的版本无法正常工作，管理动态内存的类通常不能依赖于上述操作的合成版本。 使用vector或者string的类能避免分配和释放内存带来的复杂性。如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。 类的静态成员有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。例如，一个银行账号类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。 声明静态成员我们通过在成员的声明之前加上关键字static使得其与类关联在一起，和其他成员一样，静态成员可以使public得或private的。静态数据成员的类型可以使常量、引用、指针、类类型等。 举个例子，我们定义一个类，用它表示银行的账户记录： 1234567891011class Account&#123;public: void calculate() &#123;amount+=amount*interestRate;&#125; static double rate() &#123;return interestRate;&#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。 因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。 类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的（const是用来修饰this指针类型的），而且我们也不能在static函数体内使用this指针，这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。静态成员函数不可以同时声明为 virtual、const、volatile函数。 12345class base&#123; virtual static void func1();//错误 static void func2() const;//错误 static void func3() volatile;//错误 &#125;; 使用类的静态成员我们使用作用域运算符直接访问静态成员：12double r;r=Account::rate(); //使用作用域运算符访问静态成员 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针类访问静态成员：12345Account ac1;Account *ac2=&amp;ac1;//调用静态成员函数rate的等价形式r=ac1.rate(); //通过Account的对象或引用r=ac2-&gt;rate(); //通过指向Account对象的指针 成员函数不用通过作用域运算符就能直接使用静态成员。 123456class Account&#123;public: void calculate() &#123;amount+=amount*interestRate;&#125;private: static double interestRate;&#125;; 定义静态成员和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：1234void Account::rate(double newRate)&#123; interestRate=newRate;&#125; 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态数据成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。 类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在于程序的整个生命周期中。 我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字： 12//定义并初始化一个静态成员double Account::interestRate=initRate(); 这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用initRate函数。注意，虽然initRate是私有的，我们也能使用它初始化interestRate。和其他成员的定义一样，interestRate的定义也可以访问类的私有成员。 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一文件中。 静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适用于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员执行数组成员的维度： 12345678class Account&#123;public: static double rate() &#123; return interestRate;&#125; static void rate(double);private: static constexpr int period=30; double daily_tbl[period]; //period是常量表达式&#125;; 如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了： 12//一个不带初始值的静态成员的定义constexpr int Account::period; //初始值在类的定义内提供 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态成员能用于某些场景，而普遍成员不能如我们所见，静态成员独立于任何对象。因为，在某些非静态数据成员可能非法的场合，静态 成员却可以正常地使用。举个例子，静态数据成员可以是不完全类型。特别地，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。 12345678class Bar&#123;public: //......private: static Bar mem1; //正确：静态成员可以是不完全类型 Bar *mem2; //正确：指针成员可以使不完全类型 Bar mem3; //错误：数据成员必须是完全类型&#125;; 静态成员和普通成员的另一个区别是我们可以使用静态成员作为默认实参： 1234567class Screen&#123;public: //bkground 不是一个在类中稍后定义的静态成员 Screen &amp;clear(char =bkground);private: static const char bkground;&#125;; 非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以从中获取成员的值，最终引发错误。 简单代码示例1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Account&#123;public: static double rate() &#123; return interestRate; &#125; static void rate(double Rate);private: string owner; static double interestRate ; static const int aa = 0; //正确 static constexpr int bb = 0; //正确，constexpr类型可以类内初始化 //static double cc = 0; //错误&#125;;//外层定义static成员不需要加上staticdouble Account::interestRate = 1.0; //定义并初始化一个成员void Account::rate(double Rate)&#123; interestRate = Rate;&#125;int main()&#123; Account a1,a2; cout&lt;&lt;a1.rate()&lt;&lt;" "&lt;&lt;a2.rate()&lt;&lt;endl; a1.rate(2.0); cout&lt;&lt;a1.rate()&lt;&lt;" "&lt;&lt;a2.rate()&lt;&lt;endl; return 0;&#125; 友元（friend）友元：类允许其他类或者函数访问其非公有成员，方法是令其他类或者函数成为它的友元（friend)。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。 友元函数只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员函数也不受它所在区域访问控制级别的约束。 一般来说，最好在类定义开始或者结束前的位置集中声明友元。 友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 友元再探类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数时隐式内联的。 类之间的友元关系12345class Screen&#123; //Window_megr的成员可以访问Screen类的私有部分。 friend class Window_megr; 把Window_megr指定成Screen的友元 //Screen类的剩余部分&#125; 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 必须注意的是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。 令成员函数作为友元除了令整个Window_mgr作为友元之外，Screen还可以只为Window_mgr成员函数clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类： 12345class Screen&#123; //Window_mgr::clear必须在Screen类之前被声明 friend void Window_mgr::clear(ScreenIndex); //Screen类的剩余部分&#125;; 要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序： 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明 最后定义clear，此时它才可以使用Screen的成员。 函数重载和友元尽管重载函数的名字相同，但他们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明： 1234567//重载的storeOn函数extern ostream&amp; storeOn(ostream＆ ,Screen &amp;);extern BitMap &amp;storeOn(BitMap&amp; ,Screen &amp;);class Screen&#123; //StoreOnde ostream版本能访问Screen对象的私有部分 friend ostream::ostream&amp; storeOn(ostream&amp; ,Screen);&#125;; Screen类把接受ostream&amp;的storeOn函数声明成它的友元，但是接受BitMap&amp;作为参数的版本仍然不能访问Screen。 友元声明和作用域类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。 换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的： 123456789struct X&#123; friend void f() &#123; /*友元函数可以定义在类的内部*/&#125; X() &#123;f();&#125; //错误：f还没有被声明 void g(); void h();&#125;;void X::g()&#123;return f();&#125; //错误：f还没有被声明void f(); //声明那个定义在X中的函数void X::h() &#123;return f();&#125; //正确：现在f的声明在作用域中了 关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。 简单友元类示例1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class student&#123;friend class teacher;public: void show_info()&#123; cout&lt;&lt;"name:"&lt;&lt;name&lt;&lt;" address"&lt;&lt;endl; &#125;private: string name = "xin"; string address = "cqu";&#125;;class teacher&#123;public: void show_info()&#123; cout&lt;&lt;"name:"&lt;&lt;name&lt;&lt;" address"&lt;&lt;endl; &#125; void showStudent(student &amp;STD);private: string name; string address;&#125;;void teacher::showStudent(student &amp;STD)&#123; cout&lt;&lt;STD.name&lt;&lt;" "&lt;&lt;STD.address&lt;&lt;endl;&#125;int main()&#123; student STD; STD.show_info(); teacher TEA; TEA.showStudent(STD); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>static成员</tag>
        <tag>C++</tag>
        <tag>类定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数基础]]></title>
    <url>%2F2017%2F10%2F19%2F%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[函数基础一个典型的函数定义包括以下部分：返回类型、函数名、由0个或多个形参组成的列表以及函数体。 函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。 形参和实参函数有几个形参，我们就必须提供相同数量的实参。 局部对象形参和函数体内部定义的变量（含｛｝块域）统称为局部变量。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。 自动对象对于普通局部变量对应的对象来说, 当函数的控制路径经过变量定义语句时创建该对象, 当到达定义所在的块末尾时销毁它. 我们把只存在于块执行期间的对象称为自动对象, 当块的执行结束后, 块中创建的自动对象的值就变成未定义的了. 形参是一种自动对象, 函数开始时候为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以函数终止, 形参被销毁. 对于局部变量对应的自动对象来说, 分两种情况：如果变量定义本身含初始值, 就用这个初始值初始化;否则, 如果变量定义本身不含初始值, 执行默认初始化.意味着内置类型的未初始化局部变量将产生未定义的值. 局部静态对象当有些时候, 有必要令局部变量的生命周期贯穿函数调用及之后的时间,可以将局部变量定义为static 类型, 局部静态变量在程序执行路径第一次经过对象定义语句时候初始化,并直到程序终止才被销毁。 123456789101112size_t count_calls()&#123; static size_t ctr=0; eturn ++ctr;&#125;int main()&#123; for(size_t i=0; i!=10; i++) cout&lt;&lt; count_calls() &lt;&lt; endl; return 0;&#125; 在控制流第一次经过ctr的定义之前, ctr被创建且初始化为0; 每次调用ctr加1. 每次执行函数, 变量ctr的值已经存在并等于函数上一次退出的时候的值。 函数声明函数只能定义一次，但可以声明多次。（有例外），如果一个函数永远不可能给我们用到，那他可以只有声明没有定义。 函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息，函数声明也称作函数原型。 best practices: 在头文件中进行函数声明，含有函数声明的头文件应该包含到定义函数的源文件中。 分离式编译分离式编译，C++允许我们将程序分割到几个文件中去，每个文件独立编译。 简单的示例： 目录树： source facc.cpp main.cpp header myHead.h 12345678910111213141516171819202122232425262728//facc.cpp#include &lt;iostream&gt;#include "MyHead.h" //定义fac函数，肯定要包含其声明using namespace std;int fac(int n)&#123; if (n==1)&#123; return 1; &#125;else &#123; return n*fac(n-1); &#125;&#125;//main.cpp#include &lt;iostream&gt;#include "MyHead.h" //使用fac，肯定也要包含其声明using namespace std;int main()&#123; cout&lt;&lt;fac(5)&lt;&lt;endl; return 0;&#125;//myHead.h //头文件中只有函数的声明#ifndef MYHEAD_H_INCLUDED#define MYHEAD_H_INCLUDEDint fac(int n); #endif // MYHEAD_H_INCLUDED const形参和实参实参初始化形参会忽略掉顶层const，也就是当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。 我们可以使用非常量初始化底层const，但是反过来不行。 数组形参数组的两个特殊点： 不允许拷贝数组，所以不可以使用传值的方式使用数组参数(传值即为拷贝)。 通常数组的传递使用的是指针形式，传递的是指针的首地址。 尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式： 12345//尽管形式不同，但这三个print函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10]) //这里的维度表示我们期望数组含有多少元素，实际不一定 当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型： 1234int i = 2;int j[2] = &#123;1,2&#125;;print(&amp;i); //正确，&amp;i的类型是int*print(j); //正确，j被转换成int*并指向j[0] 如果我们传给print函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。 由于数组实际上是以指针的形式传递给函数的，因此一开始函数并不知道数组的确切尺寸，调用者应该为此提供额外的一些信息。 管理指针形参有三种常用的技术： 1.使用标记指定数组长度 这种方法要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符就停止： 12345678void print(const char *cp)&#123; if(cp)&#123; //若cp不是空指针 while(*cp)&#123; //只要指针所指字符不是空字符 cout&lt;&lt;*cp++; //输出当前字符并将指针前移 &#125; &#125;&#125; 这个方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。 2.显示传递一个表示数组大小的形参 这种方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。 12345678//const int ia[]等价于const int *ia//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问void print(const int ia[],size_t size)&#123; for(size_t i = 0; i != size; ++i)&#123; cout&lt;&lt;ia[i]&lt;&lt;" "; &#125;&#125; 这种方法通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值：12int j[] = &#123;1,2,3&#125;;print(j,3); 3.使用标准库函数begin和end C++11标准引入两个名为begin和end的函数，begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一位置的指针，这两个函数定义在iterator头文件中。示例代码如下：123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3,4,5,6,7,8,9,-1,5,3,4&#125;; int *pbeg = begin(arr); //指向arr首元素的指针 int *pend = end(arr); //指向arr尾元素的指针 //寻找第一个负值元素，如果已经检查完全部元素则结束循环 while(pbeg != pend &amp;&amp; *pbeg &gt;= 0)&#123; ++pbeg; &#125; cout&lt;&lt;*pbeg&lt;&lt;endl; //输出第一个负数的值&#125; 对于本文的print函数，可以写成如下形式: 123456void print(const int *beg, const int *end)&#123; //输出beg到end之间（不含end）的所有元素 while(beg != end) cout&lt;&lt;*beg++&lt;&lt;" ";&#125; 为了调用这两个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。使用方法如下：12int a[] = &#123;1,2,3&#125;;print(begin(j),end(j)); 数组形参和const当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。 数组引用形参形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上： 12345void print(int (&amp;arr)[10]) &#123; for(auto elem : arr)&#123; cout&lt;&lt;elem&lt;&lt;endl; &#125;&#125; 注意：12f(int &amp;arr[10])//错误,将arr声明为引用的数组f(int (&amp;arr)[10])//正确, arr是有10个整形的数组引用 传递多维数组和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是指向数组的指针，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分, 不能省略: 1234//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组void print(int (*matrix)[10], int rowsize)&#123;...&#125;//等价于void print(int matrix[][10], int rowsize)&#123;...&#125; 我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。 main: 处理命令行选项C/C++语言中的main函数，经常带有参数argc，argv，如下： 12int main(int argc, char** argv)int main(int argc, char* argv[]) 第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。 下面的程序演示argc和argv的使用： 1234567891011#include &lt;iostream&gt;using namespace std;int main(int argc,char *argv[])&#123; int i; for (i=0; i &lt; argc; i++) &#123; cout&lt;&lt;"Argument "&lt;&lt;i&lt;&lt;" is "&lt;&lt;argv[i]&lt;&lt;endl; &#125; return 0;&#125; 假如上述代码编译为hello.exe，那么运行hello.exe a b c d e 将得到 Argument 0 is hello.exe. Argument 1 is a. Argument 2 is b. Argument 3 is c. Argument 4 is d. Argument 5 is e. 含有可变形参的参数（先知道有这么个东西，后面详细了解）返回函数指针函数重载（重点，待完善）对于函数重载来说，形参数量或形参类型上有所不同。 不允许两个函数除了返回类型外，其他所有的要素都相同。 特殊用途语言特性默认实参知识点1：函数反复调用的过程中重复出现的形参，这样的值被称为默认实参。该参数在使用过程中可以被用户指定，也可以使用默认数值 知识点2：调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。 知识点3：一旦某个形参被赋予了默认值，其后所有形参都必须有默认值。 知识点4：顺序很重要！在设计函数时，将默认值的形参放在后面。 知识点5：在给定的作用域中，一个形参只能被赋予一次默认实参，且局部变量不能作为默认实参。 内联函数（inline）调用函数函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。 内联函数可以避免函数调用的开销。 将函数指定为“内联函数(inline)”，将它在每个调用点上“内联的展开”，该说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。一般来说，内联的机制用于优化规模较小、流程直接、频繁调用的函数，建议不大于75行。 constexpr函数constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。 12constexpr int new_sz()&#123; return 42;&#125;constexpr int foo = new_sz(); //正确：foo是一个常量表达式 constexpr函数不一定返回常量表达式 程序的调试帮助：assert和NDEBUG知识点1：预处理宏assert(expr)：包含一个表达式，expr为真时，assert什么也不做，为假时输出信息并终止程序。包含在cassert头文件中。通常用于检查不能发生的条件 知识点2：assert依赖于一个NDEBUG的预处理变量的状态，如果定义了NDEBUG，assert什么也不做，默认状态下NDEBUG是未定义的。编译器也可以预先定义该变量。 知识点3：也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef到#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略。 1234567void pp() &#123; #ifndef NDEBUG cerr&lt;&lt;"my name is:"&lt;&lt;__func__&lt;&lt;endl; #endif //其他代码 &#125; 一些C++编译器定义的调试有用的名字： _ func _ :一个静态数组，存放函数的名字 _ FILE _ :存放文件名的字符串字面值 _ LINE _ :存放当前行号的整形字面值 _ TIME _ :存放文件编译时间的字符串字面值 _ DATE _ :存放文件编译日期的字符串字面值 函数匹配 首先确定候选函数：候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。 接着选出可行函数：可行函数具备两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。 如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。 如果没有找到可行函数，编译器将报告无匹配函数的错误。 3.寻找最佳匹配：它的基本思想是，实参类型与形参类型越接近，他们匹配得越好。 编译器一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功： 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 至少有一个实参的匹配优于其他可行函数提供的匹配。 如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。 函数指针函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：1bool lengthCompare(const string &amp;,const string &amp;); 该函数的类型是bool(const string&amp;,const string&amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。 12//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型bool (*pf) const string&amp; ,const string &amp;); //未初始化 从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 注意： *pf两端的括号必不可少。 知识点2：当我们把函数名当作一个值使用时，函数自动的转换为指针，直接赋予或者取址皆可。可以直接使用只想该函数的指针调用该函数。 知识点3：给指针赋予nullptr或者0时，指针不指向任何函数。 知识点4：函数重载时，指针的类型必须与重载函数精确匹配，包括形参类型数量和返回值类型。 知识点5：虽然不能返回一个函数，但是可以返回一个指向函数的指针。 返回指向函数的指针1int (*f1(int)) (int *,int) 我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int. 出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。 1auto f1(int) -&gt; int (*)(int *,int); 例子12345678910111213141516171819202122#include &lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; int add(int a, int b) &#123; return a+b; &#125; int subtract(int a, int b) &#123; return a - b; &#125; int multiply(int a, int b) &#123; return a * b; &#125; int divide(int a, int b) &#123; return b != 0 ? a / b : 0; &#125;//声明定义函数 int main(int argc, char** argv) &#123; typedef int(*p)(int a, int b); //声明函数指针，未初始化,p为指向函数的指针。使用typedef的声明语句定义的不再是变量而是类型别名 //就是将变量转化为类型别名的一种方式，p原来是指向函数的指针变量，现在变成了指向函数的指针变量的类型别名 vector&lt;p&gt; vec&#123;add, subtract, multiply, divide&#125;;//vector初始化的C++11新特性 for (auto f : vec) cout &lt;&lt; f(2, 2) &lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try语句块和异常处理]]></title>
    <url>%2F2017%2F10%2F15%2Ftry%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、前言简单介绍try语句块和异常处理。 异常异常处理机制为程序中异常检测和异常处理这两部分的协作提供了支持。在C++语言中，异常处理包括： throw表达式（throw expression），异常检测部分使用throw表达式来表示它遇到的了无法处理的问题，我们说throw引发了异常。 try语句块（try block）,异常处理部分使用try语句处理异常。try语句块以关键字try开始，并以一个或多个catch字句结束。try语句块中代码抛出的异常通常会被某个catch字句处理。因为catch字句”处理“异常，所以它们也被称作异常处理代码。 一套异常类（exception class），用于在throw表达式和相关的catch字句之间传递异常具体信息。 throw表达式程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。 try语句块1234567try&#123; program-staments&#125;catch(exception-declaration)&#123; handler-staments&#125;catch(exception-declaration)&#123; handler-staments&#125; ... 代码示例12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stdexcept&gt; //标准异常库using namespace std;int main()&#123; int a,b; cout&lt;&lt;&quot;请输入相除的两个整数：&quot;; while(cin&gt;&gt;a&gt;&gt;b) &#123; try &#123; if (b == 0) throw std::runtime_error(&quot;被除数不能为0&quot;);//runtime_error异常类:只有在运行时才能检测出的问题 cout&lt;&lt;static_cast&lt;double&gt;(a)/b&lt;&lt;endl;//考虑到不可以整除产生小数的情况,先将a强制转化为double类型 &#125; catch (runtime_error err)//err是runtime_error类的一个实例 &#123; cout &lt;&lt; err.what() ; //实例的成员函数，返回内容由编译其决定 cout &lt;&lt; &quot;\n是否需要重新输入? Enter y or n:&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (!cin || c == &apos;n&apos;) break;//break只能用在开关体或者循环体中 &#125;//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理 //如果没有catch部分，仅有try，仍然会报错 cout&lt;&lt;&quot;请输入相除的两个整数：&quot;; &#125; return 0 ;&#125; 输出结果： 请输入相除的两个整数：2 4 0.5 请输入相除的两个整数：2 0 被除数不能为0 是否需要重新输入? n 简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理，如果没有catch部分，仅有try，仍然会报错。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式基础]]></title>
    <url>%2F2017%2F10%2F14%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、前言介绍C++中常见的表达式。 基础概念组合运算符和运算对象对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级、结合律以及运算对象的求值顺序。 重载运算符左值和右值左值可以位于赋值语句的左侧、右值则不能。 当一个对象被用于右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的为止）。 求值顺序（重点）优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。 1int i = f1()*f2(); 我们是无法知道到底f1在f2之前调用还是f2在f1之前调用。 对于那些没有指定执行顺序的运算符来讲，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，比如： 12int i = 0;cout&lt;&lt;i&lt;&lt;" "&lt;&lt;++i&lt;&lt;endl; 表达是的行为不可预知，编译器执行i或者++i的顺序是未知的。 以下4中运算符明确规定了运算对象的求值顺序：&amp;&amp;(逻辑与) ||(逻辑或) ?:(条件运算符) ,(逗号运算符)。 求值顺序、优先级、结合律运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中： 优先级规定，g()的返回值和h()的返回值相乘。 结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。 对于这些函数的调用顺序没有明确规定。 如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。 建议： 处理复合表达式以下两条经验准则对书写复合表达式有益： 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。 算术运算符%运算符如果m%n不等于0，则它的符号和m相同。 m%(-n) 等于 m%n (-m)%n 等于 -(m%n) -21 % -8 = -5 21 % -5 = 1 逻辑和关系运算符逻辑与(&amp;&amp;)和逻辑或(||) 都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 短路求值。 text是存储这string对象的vector，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。123456789//s是对常量的引用；元素既没有被拷贝也不会被改变for(const auto &amp;s : text) &#123; cout&lt;&lt;s; if(s.empty()||s[s.size()-1] == '.')&#123; cout&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;" "; &#125;&#125; 值得注意的是，s被声明成对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以声明成对常量的引用。 优先级注意 算数运算符&gt;关系运算符&gt;逻辑运算符 赋值运算符满足右结合律赋值运算符满足右结合律，这一点与其他二元运算符不太一样。 12int ival,jval;ival = jval = 0; //正确，都被赋值为0 因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0作为靠左的赋值运算符的右侧运算对象。又因为赋值运算符返回的是其左侧运算对象，所以靠右的赋值运算的结果（jval=2返回的结果为左侧运算对象jval）被赋给了ival。1cout&lt;&lt;(jval = 2)&lt;&lt;endl; // 输出2 赋值运算符优先级较低12345int i ;//一种很好的写法while((i=get_value()) != 42) &#123; //其他处理&#125; 注意： 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。 递增和递减运算符递增和递减有两种形式：前置版本和后置版本。 123int i =0,j;j = ++i; //j = 1,i = 1; 前置版本得到递增之后的值j = i++; //j = 1,i = 2; 后置版本得到递增之前的值 区别：前置版本将对象本身作为左值返回，后置版本则将对象的原始副本作为右值返回。 建议：除非必须，否则不用递增递减运算符的后置版本 有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。 对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。 混用解引用和递增运算符12//推荐写法cout&lt;&lt;*iter++&lt;&lt;endl; //等价于*(iter++) 后置运算符的优先级高于解引用运算符。 1vec[ival++] &lt;= vec[ival]; //未定义的错误，先求左侧的值还是先求右侧的值不确定 成员访问运算符点运算符和箭头运算符都可用与访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr-&gt;men等价于(*ptr)mem : 1234string s1 = "a string", *p = &amp;s1;auto n = s1.size(); n = (*p).size(); //运行p所指对象的size成员n = p-&gt;size(); //等价于(*p).size() 注意：解引用运算符的优先级低于点运算符。 1*p.size() // 错误，p是一个指针，它没有名为size的成员 条件运算符优先级 条件运算符优先级高于赋值、逗号运算符，低于其他运算符。 例如：123m&lt;n ? x : a+3 等价于：(m&lt;n) ?(x) :(a+3)a++&gt;=10 &amp;&amp; b--&gt;20 ? a : b 等价于：(a++&gt;=10 &amp;&amp; b--&gt;20) ? a : bx=3+a&gt;5 ? 100 : 200 等价于：x= (( 3+a&gt;5 ) ? 100 : 200 ) 结合性 条件运算符具有右结合性。 当一个表达式中出现多个条件运算符时，应该将位于最右边的问号与离它最近的冒号配对，并按这一原则正确区分各条件运算符的运算对象。 例如： w&lt;x ? x+w : x&lt;y ? x : y 与 w&lt;x ? x+w : ( x&lt;y ? x : y) 等价 与 (w&lt;x ? x+w : x&lt;y) ? x : y 不等价 注意： 随着条件运算嵌套的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。 位运算符（基础，待补充）一个使用位运算符的例子 假设一个班级有30个学生,我们用一个二进制位来代表某个学生在依次测试中是否通过，显然全班的测试结果可以用一个无符号整数来表示： 1unsigned long quizl = 0 ; //我们把这个值当成是位的集合来使用 将quizl类型定义位unsigned long，这样，quizl在任何机器上都将至少拥有32位；给quizl赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。 1234567//1UL是一个unsigned long类型的整数字面值1//1UL&lt;&lt;27; 生成一个值，该值只有第27位为1quizl |= 1UL&lt;&lt;27; //表示学生27通过了测试quizl &amp;= ~(1UL&lt;&lt;27); //学生27未通过测试bool status = quizl &amp; (1UL&lt;&lt;27); //学生27是否通过了测试？ sizeofsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得到的值是一个size_t类型的常量表达式。 sizeof的三种语法形式： 123sizeof(object); //sizeof(对象);sizeof(type_name); //sizeof(类型);sizeof object; //sizeof对象; 12345int i;sizeof(i); //oksizeof i; //oksizeof(int); //oksizeof int; //error 既然写法3可以用写法1代替，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。 1sizeof(*p); //指针所占的空间大小，与指针指向的类型无关 sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针也不会有什么影响，在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。 C++11新标准允许我们使用作用域来获取成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象。因为要想知道类成员的大小无须真的获取该成员。 sizeof运算符的结果部分地依赖于其作用的类型： 对char或者类型为char的表达式指向sizeof运算，结果为1； 对引用类型执行sizeof运算得到被引用对象所占空间的大小； 对指针指向sizeof运算得到指针本身所占空间的大小； 对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效。 对数组执行sizeof运算限制得到整个数组所占空间的大小，等价于对数组这所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数： 123// sizeof(ia)/sizeof(*ia)返回ia的元素数量 constexpr size_t sz = sizeof(ia)/sizeof(*ia); int arr2[sz]; // 正确：sizeof返回一个常量表达式 因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组&指针&string]]></title>
    <url>%2F2017%2F10%2F14%2F%E6%95%B0%E7%BB%84%26%E6%8C%87%E9%92%88%26string%2F</url>
    <content type="text"><![CDATA[一、前言介绍使用数组的基本方法，同时介绍C++中string的初始化和一些常用函数。 数组数组与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是相对地也损失了一些灵活性。 note： 如果不清楚元素的确切个数，请使用vector。 定义和初始化内置数组数组是一种复合类型，数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。 123456unsigned cnt = 42; //不是常量表达式constexpr unsigned sz = 42; //常量表达式int arr[10]; //含有10个整型的数组int *parr[sz]; //含有42个整型指针的数组string bad[cnt]; //错误：cnt不是常量表达式string strs[get_size()]; //当gett_size是constexpr时正确；否则错误 默认情况下，数组的元素被默认初始化。另外数组的元素应为对象，因此不存在引用的数组。 显式初始化数组元素可以对数组的元素进行列表初始化，此时允许忽略数组的纬度。 123456const unsigned sz = 3;int ial[sz] = &#123;0,1,2&#125;; //含有三个元素的数组，元素值分别是０１２int a2[] = &#123;0 ,1 , 2&#125;; //维度是３的数组int a3[5] = &#123;0,1,2&#125;; // 等价于&#123;0,1,2,0,0&#125;string a4[3] = &#123;“hi” , “bye”&#125;; //&#123;“hi”,”bye” ,”“&#125;int a5[2] = &#123;0,1,2&#125; //错误， 初始值太多 字符数组的特殊性（用字符串字面值对数组进行初始化）字符数组可以用字符串字面值初始化，但是特殊的是结束符（’\0’）也会被拷贝进去1234char a1[] = &#123;‘C’,’+’ ,’+’&#125;; //列表初始化没有空字符char a2[] = &#123;‘C’,’+’,‘+’,’\0’&#125;; //列表初始化，含有显示的空字符char a3[] = “C++”; //自动添加表示字符串结束的空字符const char a4[6] =”Daniel”; //错了，没有空间可以存放空字符 a4数组的大小必须至少是7。 数组不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： 123int a[] = &#123;0,1,2&#125;;int a2[] = a; //错误：不允许使用一个数组初始化另一个数组a2 = a; //错误：不能把一个数组直接赋值给另一个数组 理解复杂的数组声明可以定义一个存放指针的数组。又因为数组本身是对象，所以允许定义数组的指针（指向数组的指针）及数组的引用（对数组的引用）。 1234//[]的优先级比*高int *ptrs[10]; //ptrs是含有10个整型指针的数组int (*Parray)[10] = &amp;arr; //Parray指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组 默认情况下，类型修饰符从右向左一次绑定， 对于ptrs来说，首先知道我们定义了一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 Parray的含义：首先*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。最终，Parray是一个指针，它指向一个int数组，数组中包含10个元素。 当然，对修饰符的数量并没有特殊限制： 1int *(&amp;array)[10] = ptrs; //array是数组的引用，该数组含有10个指针 访问数组元素数组的元素也能使用范围for语句或下标运算符来访问。 当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。 123for(auto i : scores) &#123; cout&lt;&lt;i&lt;&lt;" ";&#125; 指针和数组在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。 12string nums[] = &#123;"one","two","three"&#125;; //数组的元素是string对象string *p = &amp;nums[0]; //p指向nums的第一个元素 数组的一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。 1string *p = nums; //等价于p2=&amp;nums[0]; auto 和 decltype1234int ia[] = &#123;0,1,2,3,4,5&#125;;auto ia2(ia); //ia2是一个整型指针，指向ia的第一个元素decltype(ia) ia3 = &#123;3,4,5,6,7,8&#125;; //ia3类型是由10个整数构成的数组，并对该数组进行赋值 指针也是迭代器123int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p = arr; //p指向arr的第一个元素++p; 遍历数组元素，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址： 1234int *e = &amp;arr[10]; //指向尾元素的下一位置的指针for(int *b = arr; b!=e; ++b)&#123; cout&lt;&lt;*b&lt;&lt;end; //输出arr的元素&#125; note: 尽管能计算得到尾后指针，但是这种用法极易出错，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似。 begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。 正确的使用形式：123456int ia[] = &#123;1,2,3,4,5&#125;;int *beg = begin(ia); //指向ia首元素的指针int *last = end(ia); //指向arr尾元素的下一位置的指针for(beg;beg!=last;++beg)&#123; cout&lt;&lt;*beg&lt;&lt;" ";&#125; note: 一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end()函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。 下标和指针12345678int ia[] = &#123;0,2,4,6,8&#125;; //含有5个整数的数组int i = ia[2]; //ia[2]得到(ia+2)所指的元素，即*(ia+2)int *p = ia;i = *(p+2); //等价于i = ia[2];只要指针指向的是数组中的元素(或者数组中尾元素的下一位置，此时下标需要为负值)，都可以执行下标运算。int *p = &amp;ia[2]; //p指向索引为2的元素int j = p[1]; //j = ia[3]int k = p[-2]; //k = ia[0] 注意： 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。 C风格字符串C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\0’）。 C风格字符字符串函数 12345\\p,p1,p2都是字符数组的形式，在string.h头文件中strlen(p) 返回p的长度，空字符不计算在内strcmp(p1,p2) 比较p1和p2的相等。如果p1==p2，返回0；如果p1&gt;p2,返回一个正值；如果p1&lt;p2，返回一个负值strcat(p1,p2) 将p2附加到p1之后，返回p1strcpy(p1,p2) 将p2拷贝给p1,返回p1 对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。 与旧代码的接口现代的C++ 程序不得不与那些充满了数组或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。 混用string对象和C风格字符串允许使用字符串字面值来初始化对象： 1string s("Hello world"); //s的内容是Hello world 更一般的情况，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代： 允许使用空字符结束的字符数组来初始化string对象或为string对象赋值。 在string对象的加法运算过程中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中匀速使用以空字符串结束的字符数组作为右侧的运算对象。 上述性质反过来就不成立，比如不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数。 123string s = "wangxinri";char *p = s ; //错误，不能用string对象直接初始化指向字符的指针const char *str = s.c_str(); //正确 我们无法保证c_str()返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效果。因此使用最好将c_str()返回的数组拷贝一份。 使用数组初始化vector对象不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象 12345int int_arr[] = &#123;0,1,2,3,4,5&#125;;vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));//拷贝三个元素：int_arr[1],int_arr[2],int_arr[3]vector&lt;int&gt; subVec(int_arr+1,int_arr4); 注意： 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。 多维数组（待补充）stringstring表示可变长的字符序列，使用string类型必须首先包含string头文件。 初始化string对象的方式123456string s1 默认初始化，s1是一个空串string s2(s1) s2是s1的副本string s2 = s1 等价于s2(s1)，s2是s1的副本string s3("value") s3是字面值"value"的副本，除了字面值最后的那个空字符外string s3 = "value" 等价于s3("value")，s3是字面值"value"的副本string s4(n, 'c') 把s4初始化为由连续n个字符c组成的串 string对象上的操作1234567891011os&lt;&lt;s 将s写到输出流os当中，返回osis&gt;&gt;s 从is中读取字符串赋给s，字符串以空白分隔，返回isgetline(is, s) 从is中读取一行赋给s，返回iss.empty() s为空赋返回true，否则返回falses.size() 返回s中的字符的个数s[n] 返回s中第n个字符的引用，位置n从0计起s1+s2 返回s1和s2连接后的结果s1=s2 用s2的副本代替s1中原来的字符s1==s2 如果s1和s2中所含的字符完全一样，则它们相等，返回trues1!=s2 如果s1和s2中所含的字符不一样，返回true&lt;, &lt;=, &gt;, &gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 代码示例12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; string str; while(cin&gt;&gt;str)&#123; cout&lt;&lt;str&lt;&lt;endl; &#125; return 0;&#125;#include&lt;iostream&gt;using namespace std;int main() &#123; string line; while(getline(cin,line))&#123; cout&lt;&lt;line&lt;&lt;endl; &#125; return 0;&#125; 处理string对象中的字符对字符处理的一些方法，在cctype头文件中定义了一组标准库函数处理这部分工作12345678910111213isalnmu(c) 当c是字母或数字为真isalpha(c) 当c是字母为真iscntrl(c) 当c是控字符时为真isdigit(c) 当c是数字为真isgraph(c) 当c不是空格但可打印为真islower(c) 当c是小写字母为真isprint(c) 当c是可打印字符为真(即c是空格或c具有可视形式)ispunct(c) 当c是标点符号为真(即c不是控字符、数字、字母、可打印空白中的一种)isspace(c) 当c是空白为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进制符中一种)issupper(c) 当c是大写字母为真isxdigit(c) 当c是十六进制数字为真tolower(c) 若c是大写字母，输出对应小写字母；否则原样输出ctoupper(c) 若c是小写字母，输出对应大写字母；否则原样输出c 处理string每个字符，使用基于范围的for语句12345678910111213141516171819202122232425262728// 用范围for语句和ispunct函数统计string对象中标点符号的个数（使用范围for语句遍历给定序列的每个元素）#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s("Hello World!!!");decltype(s.size()) punct_cnt = 0; //punct_cnt的类型同s.size()，即为string :: size_typefor (auto c : s) // 对于s中的每个字符 if (ispunct(c)) // 如果该字符是标点符号 ++ispunct_cnt; // 计数cout &lt;&lt; punct_cnt &lt;&lt; " punctuation characters in " &lt;&lt; s &lt;&lt; endl;return 0;&#125;// 用范围for语句将字符串改写为大写字母的形式（使用范围for语句改变字符串中的字符）#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s ("Hello World!!!")// 转换成大写形式for (auto &amp;c : s) // 对于s中的每个字符(c是引用) c = toupper(c); // c是一个引用，赋值语句改变了c绑定的字符的值，标准库函数toupper将小写的参数c改为大写cout &lt;&lt; s &lt;&lt; endl;return 0;&#125; 只处理string一部分字符要想访问string对象总的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。 注意：检查下标的合法性 一种简便易行的方法是：总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。 1234const string s = "keep out";for(auto &amp;c :s)&#123; //C的类型是常量引用，不能通过C修改其绑定的对象 cout&lt;&lt;c&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用&指针&const]]></title>
    <url>%2F2017%2F09%2F01%2F%E5%BC%95%E7%94%A8%26%E6%8C%87%E9%92%88%26const%2F</url>
    <content type="text"><![CDATA[本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。 引用一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 12345int a;基本数据类型 声明符（其实就是变量名）//更复杂的声明符 ----接下来的指针和引用int *b; //指针可以不初始化，没语法错误int &amp;b = a; //引用必须初始化 引用（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 123int ival = 1024;int &amp;refVal = ival; //refVal指向ival(是ival的另一个名字)int &amp;refVal2; //报错，引用必须初始化 一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用注意细节 无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。 引用本身不是对象，所以不能定义引用的引用。 引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（两种例外，一种是对常量的引用 const int &amp;） 123int &amp;refVal4 = 10; //错误，引用类型的初始值必须是一个对象double dval = 3.14;int &amp;refVal5 = dval; //错误：此处引用类型初始值必须是int型对象 代码示例12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 2; int c = 4; int &amp;b = a; //b是a的引用，即b是a的别名 //&amp;b = c; 错误,无法令引用重新绑定到另外一个对象上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = 5; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; b = 6; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = c; //将a的值改变，b的值也相应改变，但&amp;a和&amp;b还是一样的 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; b = c; //同上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; return 0;&#125; 2 2 0x28fef8 0x28fef8 5 5 0x28fef8 0x28fef8 6 6 0x28fef8 0x28fef8 4 4 0x28fef8 0x28fef8 0x28fef4 4 4 0x28fef8 0x28fef8 0x28fef4 指针指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。 指针和引用的不同点： 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&amp;）. 12int ival = 42;int *p = &amp;ival; //指针变量p存放变量ival的地址,也即p是指向变量ival的指针 注意细节 引用不是对象，没有实际地址，所有不能定义指向引用的指针。 指针的类型要和它指向的对象严格匹配(两种例外，一种是指向常量的指针)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。 指针值指针的值（即地址）应属下列4种状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值） 注意：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。 利用指针访问对象使用解引用符（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。 空指针空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法： 123int *p1 = nullptr; //等价于int *p1 = 0;int *p2 = 0; //直接将p2初始化为字面常量0int *p3 = NULL; //等价于int *p1 = 0; C++程序最好使用nullptr,同时尽量避免使用NULL。 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。 12int zero = 0 ,*p;pi = zero; // 错误：不能把int变量直接赋给指针 note:建立初始化所有指针 原因：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。 void* 指针void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解： 123double obj = 3.14, *pd = &amp;obj; // 正确：void*能存放任意类型对象的地址void *pv = &amp;obj; // obj可以是任意类型的对象pv = pd; // pv可以存放任意类型的指针 利用void指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象 代码示例1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; double obj = 3.14,*pd = &amp;obj; void *pv = &amp;obj; cout&lt;&lt;&amp;obj&lt;&lt;" "&lt;&lt;obj&lt;&lt;endl; cout&lt;&lt;&amp;pd&lt;&lt;" "&lt;&lt;pd&lt;&lt;" "&lt;&lt;*pd&lt;&lt;endl; cout&lt;&lt;&amp;pv&lt;&lt;" "&lt;&lt;pv&lt;&lt;" "&lt;&lt;endl; //不能直接操作void* 指针所指的对象，即*pv是不合法的 return 0;&#125; 0x28ff08 3.14 0x28ff04 0x28ff08 3.14 0x28ff00 0x28ff08 理解复合类型的声明修饰符（或&amp;）和变量标识符写在一起，修饰符(或者&amp;)都是修饰变量的。 1int *p1,*p2; //p1和p2都是指向int的指针 指向指针的指针指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。 通过的个数可以区分指针的级别。也就是说，表示指向指针的指针，表示指向指针的指针的指，依次类推： 12345int ival = 1024;int *pi = &amp;ival; //pi指向一个int型的数int **ppi = &amp;pi; //ppi指向一个int型的指针//解引用cout&lt;&lt;ival&lt;&lt;" "&lt;&lt;*pi&lt;&lt;" "&lt;&lt;**ppi&lt;&lt;endl; 指向指针的引用引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。 12345int i = 42;int *p; //p是一个int型指针int *&amp;r = p; //r是一个对指针p的引用, 此时r和p指针同名r = &amp;i; //r引用了一个指针，因此给r赋值&amp;i就是令指向i*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0 要理解r的类型到底是什么，最简单的方法就是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。 const限定符const定义有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字const对变量的类型加以限制： 1const int bufSize = 512; //输入缓冲区大小 这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。 123const int i = get_size(); //正确：运行时初始化const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 const类型能参与的操作：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。 默认状态下，const对象仅在文件内有效当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： 1const int bufSize = 512; //输入缓冲区大小 编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在多个文件中声明并使用它。 解决办法： 对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了： 1234//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问extern const int bufferSize = function();//file1.h头文件extern const int bufferSize; //与file1.cpp中定义的是同一个 note：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。 const引用可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 1234const int ci = 1024;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1时对常量的引用int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象 因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。 初始化和对const的引用引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。 尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式： 12345int i = 42; const int &amp;r1 = i; //允许将const int &amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确：r1是一个常量引用const int &amp;r3 = r1*2; //正确：r3是一个常量引用int &amp;r4 = r1*2; //错误：r4是一个普通的非常量y 如果int &amp;r4 = r1*2合法，那么就可以通过r4改变r1的值，而r1是常量引用。 常量引用被绑定到另外一种类型上时到底发生了什么： 12345double dval = 3.14;const int &amp;ri = dval;//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：const int temp = dval; //由双精度浮点数生成一个临时的整形常量const int &amp;ri = temp; //让ri绑定这个临时量 总结：常量引用（const &amp;）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。 对const的引用可能引用一个并非const的对象必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值： 12345int i = 42;int &amp;r1 = i; // 引用r1绑定对象iconst int &amp;r2 = i； // r2也绑定对象i，但是不允许通过r2修改i的值r1 = 0; // r1并非常量引用，i的值修改为0r2 = 0; // 错误：r2是一个常量引用 r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。 指针和const(指向常量的指针 const double *cptr)指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 123456const double pi = 3.14; //pi是一个常量，它的值不能改变double *ptr = &amp;pi; //错误，ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值double dval = 3.2;cptr = &amp;dval; //对的 注意：之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象： 12double dval = 3.14;const double *ptr = &amp;dval; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。 const指针（常量指针 int *const curErr）指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值： 1234int errNumb = 0;int *const curErr = &amp;errNumb; //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; //pip是一个指向常量对象的常量指针 从右向左阅读 此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。 指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值： 1234567*pip = 2.72; // 错误：pip是一个指向常量的指针//如果curErr所指的对象（也就是errNumb）的值不为0if(*curErr)&#123; errorHandler(); *curErr = 0; //正确，把curErr所值得对象的值重置&#125; 总结指向常量的指针（const doubel cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。 12const double pi = 3.14const double *const pip = &amp;pi; 则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primers</tag>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结之排序算法]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中… 注：这里实现的算法都是递增排序，也就是从小到大排序。 初级排序算法1.选择排序思想：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 1234567891011121314public static int [] sort(int a[],int length)&#123; //选择排序 for(int i=0;i&lt;length;i++)&#123; int minIndex = i; //初始化最小元素的索引 for(int j=i+1;j&lt;length;j++)&#123; if(a[minIndex]&gt;a[j])&#123; minIndex = j; //找到最小元素的索引 &#125; &#125; int tem = a[i]; a[i] = a[minIndex]; a[minIndex] = tem; &#125; return a;&#125; 2.直接插入排序思想： 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。 代码： 第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。12345678910public static int [] sort(int a[],int length)&#123; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i;j&gt;0&amp;&amp;a[j]&lt;a[j-1];j--)&#123; int tem = a[j-1]; a[j-1] = a[j]; a[j] = tem; &#125; &#125; return a;&#125; 第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。1234567891011public static int [] sort(int a[],int length)&#123; //不需要交换的插入排序 for(int i=1;i&lt;a.length;i++)&#123; int tem = a[i]; //待插入的元素 int j; for(j=i-1;j&gt;=0&amp;&amp;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; //元素后移,直到找到待插入的元素的位置 &#125; a[j+1] = tem; //将带插入元素插入到查找到的位置 &#125; return a;&#125; 第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j&gt;0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。 1234567891011121314151617181920public static int [] sort(int a[],int length)&#123; int minIndex =0; for(int i=1;i&lt;length;i++)&#123; if(a[minIndex]&gt;a[i])&#123; minIndex = i; &#125; &#125; int tem = a[0]; a[0] = a[minIndex]; a[minIndex] = tem; for(int i=2;i&lt;length;i++)&#123; tem = a[i]; int j; for(j=i-1;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; &#125; a[j+1] = tem; &#125; return a;&#125; 3.希尔排序思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。 我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 代码：12345678910111213141516public static int[] sort(int a[],int length)&#123; int h = length/2; //初始增量 while(h&gt;=1)&#123; //将数组变为h有序 for(int i=h;i&lt;length;i++) &#123; //将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中 for(int j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h)&#123; int tem = a[j-h]; a[j-h] = a[j]; a[j] = tem; &#125; &#125; h = h/2; //每次排完序后,增量减少 &#125; return a;&#125; 参考：dreamcatcher-cx 归并排序简介归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。 2-路归并排序2-路归并排序:假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 该图显示的就是循环2-路归并排序算法的过程： 2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。 递归算法：自顶向下的2-路归并排序中归并结果的轨迹： 循环算法：自底向上的2-路归并排序中归并结果的轨迹： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Mergesort &#123; //2-路归并排序 public static int [] aux; //辅助数组 public static void merge(int a[],int lo,int mid,int hi)&#123; //核心算法 //将a[lo..mid]和a[mid+1,hi](已有序)归并 int i = lo, j = mid+1; for(int k = lo;k&lt;=hi;k++)&#123; //将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid) a[k] = aux[j++]; //左半边用尽，取右半边的元素复制到a中 else if(j&gt;hi) a[k] = aux[i++]; //右半边用尽，取左半边的元素复制到a中 else if(aux[i]&lt;aux[j]) a[k] = aux[i++]; //左半边元素小于右半边元素，取左半边元素复制到a中 else a[k] = aux[j++]; //右半边元素小于左半边元素，取右半边元素复制到a中 &#125; &#125; public static void Mergesort(int a[])&#123; //二路归并递归算法 aux = new int [a.length]; //一次性分配空间 sort(a,0,a.length-1); &#125; private static void sort(int[] a, int lo, int hi) &#123; // 将数组a[lo..hi]排序 if(lo&gt;=hi) return ; int mid = lo + (hi-lo)/2; sort(a,lo,mid); //递归将左半边排序 sort(a,mid+1,hi); //递归将右半边排序 merge(a, lo, mid, hi); //归并结果 &#125; public static void Mergesort1(int [] a) &#123; //二路归并非递归算法 //进行lgN次两两归并 int N = a.length; aux = new int [N]; for(int sz = 1; sz&lt;N;sz = 2*sz)&#123; //sz的子数组大小 for(int lo =0;lo&lt;N-sz; lo+=2*sz)&#123; //子数组的索引 merge(a, lo, lo+sz-1, Math.max(lo+2*sz-1, N-1)); &#125; &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123;2,3,5,1,4,0,7,6&#125;; //Mergesort(a); //调用2-路归并递归排序函数 Mergesort1(a); //调用2-路归并非递归排序函数 for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125; 一些改进1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。 2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。 3.不将元素复制到辅助数组（暂时不太明白）。 快速排序简介快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。 关键算法该方法的关键在于切分，这个过程使得数组满足下面的三个条件： 1.对于某个j,a[j]已经排定； 2.a[lo]到a[j-1]中的所有元素都不大于a[j]； 3.a[j+1]到a[hi]中的所有元素都不小于a[j]。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class QuickSort &#123; public static int[] quicksort(int a[])&#123; sort(a,0,a.length-1); return a; &#125; private static void sort(int[] a, int lo, int hi) &#123; if(hi&lt;=lo) return ; int j=partition(a,lo,hi); //切分 //第j个位置已经在它所在的排好序的位置 sort(a,lo,j-1); sort(a,j+1,hi); &#125; private static int partition(int[] a, int lo, int hi) &#123; int part = a[lo]; //切分元素 int i = lo,j=hi+1; //左右扫描指针 int tem; while(true)&#123; //扫描左右，检查扫描是否结束并交换元素 while(a[++i]&lt;part) &#123; //从左到右(第一个元素除外)找到大于等于part的元素 if(i==hi) break; &#125; while(a[--j]&gt;part)&#123; //从右到左找到小于等于part的元素 if(j==lo) break; &#125; if(i&gt;=j) break; tem = a[i]; a[i] = a[j]; a[j] = tem; &#125; tem = a[lo]; //将part=a[j]放入正确的位置 a[lo] = a[j]; a[j] = tem; return j; &#125; public static void main(String[] args) &#123; int []a = &#123;4,5,4,6,1,3&#125;; a = quicksort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网-剑指offer]]></title>
    <url>%2F2017%2F08%2F19%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[前言牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：点击查看 题目一：二维数组中的查找 （数组）题目描述:在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。 注：时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。 代码： 123456789101112131415161718192021222324252627public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array[0].length==0) &#123; //[[]]的情况 return false; &#125; //判断二维数组是否为空 for(int i=0;i&lt;array.length;i++) &#123; // 找出target所在二维数组的行 if(target&gt;=array[i][0]&amp;&amp;target&lt;=array[i][array[i].length-1]) &#123; //找到所在行之后，因为该行是有序的，此时使用二分查找即可 int low = 0; int high = array[i].length-1; int mid; while(low&lt;=high) &#123; mid = (high + low)/2; if(array[i][mid]&gt;target) &#123; high = mid - 1; &#125;else if(array[i][mid]&lt;target)&#123; low = mid + 1; &#125;else &#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125; 题目二：替换空格 （字符串）题目描述:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路： 第一种： 直接用StringBuffer提供的replace函数。(不可取，得自己搞) 1replace(int start, int end, String str); Replaces the characters in a substring of this sequence with characters in the specified String. 第二种： 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，从后向前遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。 注：从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。 代码： 1234567891011121314151617181920212223public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int oldlength = str.length()-1; int newlength = oldlength; //替换之后新数组的大小 for(int i=0;i&lt;str.length();i++) &#123; if(str.charAt(i)==' ')&#123; newlength += 2; //由一个' '变为"%20",长度增加2 &#125; &#125; str.setLength(newlength+1); //扩展str的长度,多余的位置是空字符 //此时oldlength和newlength都是数组的长度-1 for(;oldlength&gt;=0&amp;&amp;oldlength&lt;newlength;oldlength--)&#123; if(str.charAt(oldlength)==' ')&#123; str.setCharAt(newlength--, '0'); str.setCharAt(newlength--, '2'); str.setCharAt(newlength--, '%'); &#125;else&#123; str.setCharAt(newlength--, str.charAt(oldlength)); &#125; &#125; return str.toString(); &#125;&#125; 题目三：从尾到头打印链表 （链表）题目描述:输入一个链表，从尾到头打印链表每个节点的值。 思路： 第一种： 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low) 第二种： 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。 代码： 1234567891011121314151617181920212223242526272829/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); int count=0; while(listNode != null) &#123; vals.add(listNode.val); listNode = listNode.next; count++; &#125; for(int i=0;i&lt;count/2;i++) &#123; int tem = vals.get(i); vals.set(i, vals.get(count-i-1)); vals.set(count-i-1, tem); &#125; return vals; &#125;&#125; 12345678910public class linklist&#123; public static ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); public static void printListFromTailToHead(ListNode listNode) &#123; if(listNode != null) &#123; printListFromTailToHead(listNode.next); vals.add(listNode.val); &#125; &#125; //return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。&#125; 题目四：重建二叉树 （树）题目五：用两个栈实现队列 （栈、队列）题目描述:用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路： 入队push:将元素进栈A。 出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。 注： 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。 代码： 1234567891011121314151617181920public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; while(stack1.empty()&amp;&amp;stack2.empty())&#123; System.out.println("队列为空!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 题目十一：二进制中1的个数 （位运算）题目描述:输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路： 方法一： 通过n&amp;n-1可以消除整数最右边的1。多次执行n=n&amp;n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。 分析：为啥n&amp;n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 n=12 1100 n-1=11 1011 n=12&amp;11 1000 n=8 1000 n-1=7 0111 n=8&amp;7 0000 代码：12345678public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; n &amp;= n-1; count++; &#125; return count;&#125; 更多参考点击：算法-求二进制数中1的个数 题目十二：数值的整数次方 （代码的完整性）题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路： 方法一：估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。 方法二： 快速幂，快速幂能将复杂度降至O(logb)，确实是快了不少。 原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下： a^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)*a^(2^1)*a^(2^3) 通过使用&amp;和&gt;&gt;位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。 更多信息：快速幂 代码：123456789101112131415161718public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1.0; int e = exponent; exponent = Math.abs(exponent); if(exponent == 0)&#123; return result; &#125; while(exponent!=0)&#123; if((exponent&amp;1)==1)&#123; result *= base; &#125; base *= base; //每移动一位，该为代表的乘数都翻倍 exponent = exponent &gt;&gt; 1; //右移一位 &#125; return e&gt;0?result:1/result; &#125;&#125; 题目十三：调整数组顺序使奇数位于偶数前面 （数组）题目描述:输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路： 方法一： 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。 方法二：重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。 代码：12345678910111213141516public class Solution &#123; public void reOrderArray(int [] array) &#123; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]%2==0)&#123; //偶数的话，继续下一个数 continue; &#125;else&#123; int tem = array[i]; //保存待插入到偶数之前的奇数 int j; for(j=i-1;j&gt;=0&amp;&amp;(array[j]%2==0);j--)&#123; //找到偶数之前插入的位置 array[j+1] = array[j]; //偶数集体后移一位 &#125; array[j+1] = tem; //将奇数插入到该位置上 &#125; &#125; &#125;&#125; 题目十四：链表中倒数第k个结点题目描述:输入一个链表，输出该链表中倒数第k个结点。 思路： 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count&gt;=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。 代码：1234567891011121314151617181920212223242526/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; int count = 0; ListNode p = head; ListNode node = null; //head为空，返回null if(k&lt;=0) return node; //k&lt;=0无效，返回null while(head!=null)&#123; count++; head = head.next; if(count &gt;= k) &#123; //相对第一个元素为k-1的间隔时,head和p同时往后走 node = p; p = p.next; &#125; &#125; return node; &#125;&#125; 题目十五：反转链表题目描述:输入一个链表，反转链表后，输出链表的所有元素。 思路： 依次遍历每个结点，同时通过头插法再重新创建新的链表 注：可以利用之前的结点，而不需要重新创建新的结点，以后改进。 代码：123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode p = null; if(head == null) &#123; return p; &#125;else&#123; p = new ListNode(head.val); &#125; ListNode q = head.next; while(q!=null)&#123; ListNode s = new ListNode(q.val); s.next = p; p = s; q = q.next; &#125; return p; &#125;&#125; 题目十六：合并两个排序的链表题目描述:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。 注：可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode p = new ListNode(0); //创建一个头结点,数据域初始化为0，不存储数据,指针域为null ListNode head = p ; //头指针,指向头结点 if(list1 == null &amp;&amp; list2 == null) return null; while(list1!=null &amp;&amp; list2!=null)&#123; if(list1.val &lt; list2.val)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125;else &#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; &#125; while(list1!=null)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125; while(list2!=null)&#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; return head.next; //头结点不存储元素,head.next指向第一个元素节点，返回 &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>剑指offer</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[样先]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%A0%B7%E5%85%88%2F</url>
    <content type="text"><![CDATA[仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）新日左右： 余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。 予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。 大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。 新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！ 样先 2015.2.18 真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！]]></content>
      <categories>
        <category>兄弟</category>
      </categories>
      <tags>
        <tag>兄弟</tag>
        <tag>朋友</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（二） 提升篇]]></title>
    <url>%2F2017%2F08%2F07%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%20%20%E6%8F%90%E5%8D%87%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言在之前的初级篇中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。 二、更换主题在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。 在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下（此处为G:\GitHub\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件，后者称为主题配置文件。 1. 安装NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 1) 下载主题如果你熟悉Git，建议你使用克隆最新版本的方式，之后的更新可以通过git pull来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了） 在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：12cd G:\GitHub\hexogit clone https://github.com/iissnan/hexo-theme-next themes/next #后面意思是clone到该目录下themes/next文件夹中 2) 启用主题与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。 1theme: next 此时我们在主题配置文件中设置语言。修改language字段。在主题的languages文件夹中选择语言，此处目录为G:\GitHub\hexo\themes\next\languages 。 1language: zh-Hans #选择汉语，选择其他语言填写其他值即可 到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 3) 验证主题进入到博客文件夹根目录，此处为G:\GitHub\hexo，执行如下命令： 123hexo clean #更换主题，最好先清除Hexo缓存hexo generate #生成静态页面hexo server # hexo server -p **** 更换默认4000端口为**** 此时即可使用浏览器访问 http://localhost:4000。 检查站点是否正确运行，如长时间访问不了，更改端口。 现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 三、主题设定NexT官网和网上资料非常丰富，就不细说了，参考如下： 官方参考：NexT使用文档 网上资源：hexo的next主题个性化教程：打造炫酷网站 补充几点： 1. 添加评论功能我选择的是来比力，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。 编辑主题配置文件， 编辑 livere_uid 字段，设置如下： 1livere_uid: #your livere_uid 2. 修改背景图片首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下； 然后进入hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。 12345// Custom styles.body &#123; background:url(/images/background.jpeg); background-attachment: fixed; #固定背景图，使得不随页面移动&#125; 3. 修改博客内容宽度Pisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加 12$main-desktop = 1200px $content-desktop = 900px 可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。 参考：感觉浏览器留白太多，代码块看起来比较麻烦 4. 添加菜单栏在个人网站根目录下使用hexo命令hexo new page “photo” 就直接创建了.\Hexo\source\photo\index.md文件。 在主题配置文件_config.yml中找到meun:字段，添加photo字段123456789menu: home: / categories: /categories/ tags: /tags/ archives: /archives/ photo: /photo/ about: /about/ #sitemap: /sitemap.xml #commonweal: /404.html 给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加photo字段： 123456789101112menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat photo: photo 在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为photo：点击选择图标 将网站中的photo字段显示为中文照片字段 在\themes\next\languages\zh-Hans.yml添加： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 photo: 照片 5. 调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条1.调整文档摘要的高度 在/next/source/css/_common/components/post/post-meta.styl中修改margin的值 123.posts-expand .post-meta &#123; margin: 3px 0 10px 0; color: $grey-dark; 2.调整阅读全文按钮高度 在\next\source\css_common\components\post\post-button.styl中修改margin-top的值 123.post-button &#123; margin-top: 10px; .btn &#123; 3.去除首页文档与文档之间居中灰色的线条 在\next\source\css_common\components\post\post-eof.styl中注释掉如下样式 123456789101112.posts-expand &#123; .post-eof &#123; /* display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 8%; height: 1px; background: $grey-light; text-align: center; */ &#125;&#125; 最终效果如下： 6. 归档页博文列表高度调整在\next\source\css_common\components\post\post-collapse.styl中修改.post 1.post &#123; margin: 0px 0; &#125; 到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。 四、博客管理维护1. 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 注： .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：1.deploy*/ #只忽略上传.deploy*/开头的文件 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 2. 博客搭建流程 1.创建仓库，xinrisanshao.github.io； 2.创建两个分支：master 与 hexo； 3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 4.使用如下命令拷贝仓库 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 6.修改_config.yml中的deploy参数，分支应为master； 7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）； 8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。 这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。 注：流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\xinrisanshao.github.io\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。 3. 博客管理流程1. 编辑与修改博客在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 2.然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 2. 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：1.首先安装Git，Node.js和Hexo。 2.使用下面命令拷贝仓库（默认分支为hexo）； 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。 以上博客管理参考：点击查看 3. 博客图片存放（补）如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。 我选择的是七牛云存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。 五、总结不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（一） 初级篇]]></title>
    <url>%2F2017%2F08%2F06%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%20%20%E5%88%9D%E7%BA%A7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。 今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！ 二、环境准备1. 注册github账号这个就不多说了，账号注册好后，登陆，在首页右边有一个 + 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。 2. 安装Git我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是图形化界面（GUI）,另外一种是通过命令行。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， GitHub和Git Shell,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！ Github for Windows: 点击下载 下载安装完后，桌面上生成GitHub和Git Shell两个图标，然后点击GitHub图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。 Github for Windows 安装配置使用教程: 参考 3. 安装Node.js安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。 点击进入Node.js官网 我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。 4. 安装Hexo以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。 打开终端，输入： 1npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。 1npm config set registry https://registry.npm.taobao.org 安装好Hexo以后，在终端输入： 1hexo 若出现下图，说明hexo安装成功： 三、使用Hexo建站1. 初始化博客新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。 1hexo init [folder] 接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包 1npm install 2. 配置网站的主配置文件为hexo根目录下的_config.yml文件： 默认配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle:description:author: John Doelanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 这些配置项所代表的意思可以参考Hexo中文网：_config.yml配置 ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。 1). 修改网站相关信息123456title: 新日三少的博客 subtitle: Big big pig description: Love Coding,Enjoy Lifeauthor: 新日三少language: zh-CN #themes主题文件夹下的languages下面有很多语言可选timezone: Asia/Shanghai 注意：每一项的填写，其:后面都要保留一个空格，下同。 2). 配置统一资源定位符（个人域名）1url: http://www.wangxinri.cn 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。如无个人域名，无需修改这一项。 3). 配置部署1234deploy: type: git repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git branch: master 其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到： 3. 本地发布博客接下来，在网站中建立第一篇文章，打开终端，进入到博客文件夹根目录，这里是E:Github/hexo，然后输入 1hexo new "文章标题" 我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。 MarkdownPad2：点击下载 Markdown语法：Markdown中文网 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1npm install hexo-deployer-git --save 接下来,我们进行本地发布：12hexo generatehexo server 执行完后，打开浏览器，输入：1http://localhost:4000/ 我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。 4. 发布博客至github仓库但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。 打开终端，进入到博客文件夹根目录，这里还是E:Github/hexo，执行如下命令： 12hexo generatehexo deploy 输入我们的网址：xinrisanshao.github.io ,即可访问博客了。 此时查看github中的仓库，发现我们博客文件夹根目录中的public文件夹里面的文件已经发布到仓库中了。 此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。 好累啊，先休息下，果然还是写博客最累啊。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>