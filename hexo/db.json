{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar1.gif","path":"images/avatar1.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/love.js","path":"js/src/love.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1512633540426},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1512633540428},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1512633540439},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1512633540430},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1512633540441},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1512633540451},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1512633540444},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1512633540449},{"_id":"themes/next/_config.yml","hash":"fa51bf8304179c5ba526c616bff411c74b23c686","modified":1516196425648},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1512633540454},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1512633540459},{"_id":"themes/next/README.en.md","hash":"953873fe2ee79bfc567b16dcdf8f91c1410444f8","modified":1512633540456},{"_id":"themes/next/bower.json","hash":"936b9aed1934471bb74cdaacc3fb8031eb01fe23","modified":1512633540463},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1512633540466},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1512633540447},{"_id":"source/_posts/IO流与string流.md","hash":"ae05c64320d3250de9d357ef81ab21dde2ed835a","modified":1516192794849},{"_id":"source/_posts/github Pages + Hexo搭建个人博客（一）  初级篇.md","hash":"87a23906bfd5121577bee0cd94bad02d79b9773c","modified":1516072118007},{"_id":"source/_posts/github Pages + Hexo搭建个人博客（二）  提升篇.md","hash":"2c78440159afbe12bb933214d4ef96f81fabd6cf","modified":1512633540074},{"_id":"source/_posts/个人总结之排序算法.md","hash":"40a2908057899d1eb4e7cbd0b3eea263ee1d7cab","modified":1512633540081},{"_id":"source/_posts/函数基础.md","hash":"5f3464197efb7aa4ce5d01c42cfe6fb867ac2769","modified":1516108288527},{"_id":"source/_posts/剑指offer.md","hash":"45c1e30265db96cd9ccfd0a138eb1e46fa1ddef4","modified":1512633540084},{"_id":"source/_posts/引用&指针&const.md","hash":"133b31f1b057264874422e497f844faeec712d2e","modified":1516084225588},{"_id":"source/_posts/类的基本概念.md","hash":"64d6364ed5ffca8391ad44cac2acc7fa12f7ea5e","modified":1516192780280},{"_id":"source/_posts/顺序容器概述.md","hash":"286a0bb2f1aaac7f9730d93a3830609795498f6f","modified":1516192990734},{"_id":"themes/next/package.json","hash":"55305ae40690c059cb9140900eb20f9e7f3a7707","modified":1512633540683},{"_id":"source/about/index.md","hash":"62f3e450c3e3e74415064686346457733d37c0b2","modified":1516067987168},{"_id":"source/categories/index.md","hash":"708932a56a5845cadce978e617367a0dfb450f47","modified":1512633540092},{"_id":"source/_posts/样先.md","hash":"0290b9fbd81f8f634ae06678adeddd356f200d9d","modified":1512633540086},{"_id":"source/photo/index.md","hash":"9e903787ed48748ae1e34690998567a982eff8ad","modified":1516193256138},{"_id":"source/tags/index.md","hash":"849f45b782658f74ffbaf2efef4da536e5b5bae0","modified":1512633540099},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1512633540433},{"_id":"source/resume/index.md","hash":"90f65043d865c5cee26a73fc628586d2e80562fd","modified":1516193297152},{"_id":"source/_posts/数组&指针&string.md","hash":"d42ecf040ee0c9651ee0017d320baa7d2e2fadf0","modified":1516106582720},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"3178cadcec94bfad651bdf320d83946b4e0ac932","modified":1512633540435},{"_id":"source/_posts/try语句块和异常处理.md","hash":"2bed53dbe6c0844a332819b65aaea640d0e49545","modified":1516107174455},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"55091b1aab0b472d3f3e239c8d93306c751e4c1c","modified":1512633540437},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1512633540470},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1512633540468},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1512633540473},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1512633540480},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1512633540475},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1512633540482},{"_id":"themes/next/languages/zh-Hans.yml","hash":"4aae5354d7af4a70f515ed54369e37b58b1753fd","modified":1516196468535},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1512633540484},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1512633540478},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1512633540486},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1512633540488},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1512633540493},{"_id":"themes/next/layout/_layout.swig","hash":"d53d896255e5f3131d131e1d40d53e7ef52bd476","modified":1512633540503},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1512633540495},{"_id":"source/_posts/表达式基础.md","hash":"2fae597d842eaaddcd2c494c9aabcd347bcf5abe","modified":1516106979438},{"_id":"themes/next/layout/category.swig","hash":"f315f12651de8065fdad73b003da4335ef177173","modified":1512633540669},{"_id":"themes/next/layout/index.swig","hash":"4bf29f44ca9519a005671f2f2a79a48a148b435b","modified":1512633540671},{"_id":"themes/next/layout/page.swig","hash":"22ba721a9688d490fc66f360e5a319288b63b05a","modified":1512633540673},{"_id":"themes/next/layout/archive.swig","hash":"a1d1e91013baaaeb7deaf35c6d3975971ce38e02","modified":1512633540667},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1512633540688},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1512633540685},{"_id":"themes/next/layout/post.swig","hash":"182a99b1f6db0350106c6bb480fede0bbdb7e40f","modified":1512633540676},{"_id":"themes/next/layout/schedule.swig","hash":"8086f1163b10460258ecbbbe48b057b22bb2f02e","modified":1512633540678},{"_id":"themes/next/layout/tag.swig","hash":"cc9878932580c890f8f3e569225e29bb37e25b49","modified":1512633540680},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1512633541282},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1512633541284},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1512633541287},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512633540954},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1512633540498},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"396feef13c2f0a2241d70b28a304e6583d3d32f8","modified":1512633540506},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1512633540501},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1512633540509},{"_id":"themes/next/layout/_macro/post.swig","hash":"26e7a82306d9acafa253129d7a424acd59ac39a5","modified":1512633540523},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"506feb56e9b1091187d2014742f63a17758df933","modified":1512633540521},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1512633540531},{"_id":"themes/next/layout/_partials/footer.swig","hash":"800a9d2e3fa5255b5503bb9cbb642cd625c46cd0","modified":1512633540535},{"_id":"themes/next/layout/_macro/reward.swig","hash":"e61758ce836cf9e546e0e626757a74e53b5bd07f","modified":1512633540525},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"a1a1430d942396d89503f449f10c010f33573077","modified":1512633540527},{"_id":"themes/next/layout/_partials/comments.swig","hash":"7a229b569743555215a4f2561997ad496d81e938","modified":1512633540533},{"_id":"themes/next/layout/_partials/head.swig","hash":"5de59a250fbbae89142ad7c4b81fbce79a5d1034","modified":1512633540539},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1512633540546},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1512633540550},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1512633540548},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1512633540552},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1512633540641},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1512633540638},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1512633540636},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1512633540649},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1512633540647},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1512633540644},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1512633540575},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1512633540572},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1512633540577},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"53c894e6f3573c662dc4e4f7b5a6f1a32f1a8c94","modified":1512633540591},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1512633540691},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1512633540693},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1512633540695},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1512633540702},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1512633540698},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1512633540700},{"_id":"themes/next/scripts/tags/note.js","hash":"fc4958427ca7bdb47a7d830077f432ed824973e4","modified":1512633540704},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1512633540951},{"_id":"themes/next/source/images/alipay.jpg","hash":"9302886ec2ab2e8b37bdbe56500fa254fdc12130","modified":1512633540958},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1512633540956},{"_id":"themes/next/source/images/avatar.jpg","hash":"ab206e80ecb5e80dad727c257354317c4372b98e","modified":1512633540965},{"_id":"themes/next/source/images/avatar.gif","hash":"fb1ffdbf506b0899c8e034301c4607bb86060d9d","modified":1512633540963},{"_id":"themes/next/source/images/avatar1.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1512633540969},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1512633540974},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1512633540977},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1512633540972},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1512633540979},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1512633540982},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512633540992},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512633540994},{"_id":"themes/next/source/images/favicon.ico","hash":"4774eaead8875445645b8f4688f218da73156382","modified":1512633540990},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1512633540984},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1512633540987},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1512633540997},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1512633541000},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"ef74102d3f35bca552eb09337ff37b2df218f01f","modified":1512633541004},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1512633541002},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512633540583},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512633540585},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512633540871},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512633540873},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512633540880},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512633540940},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1512633540542},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1512633540555},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1512633540558},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1512633540544},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1512633540560},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1512633540563},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1512633540596},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1512633540601},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1512633540567},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1512633540603},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1512633540605},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1512633540607},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1512633540565},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1512633540612},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1512633540614},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1512633540570},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1512633540593},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1512633540598},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1512633540616},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1512633540610},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"be2aaeb8f05979e2ba501248480d5294256d61f2","modified":1512633540628},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1512633540619},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1512633540621},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1512633540626},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1512633540633},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1512633540624},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1512633540631},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1512633540664},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1512633540656},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1512633540659},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1512633540661},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1512633540580},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1512633540588},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"ee18e99ad2cdc869fce1bda9f50d098db0abbe40","modified":1516069593717},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1512633540875},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1512633540878},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1512633540938},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"5d082fb45408fdcb342e7c88537ade6aa54311a9","modified":1516069777647},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"09534b68bd1a708729b3cfffe17737e3af457757","modified":1512633540944},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1512633541011},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1512633541008},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0ad83d5e453501f7c16785662d8803792aacd22a","modified":1512633541014},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1512633541016},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1512633541019},{"_id":"themes/next/source/css/_variables/base.styl","hash":"c016b15d1f340d21a8b8e2077dd3ee5b31ea1c49","modified":1512633540946},{"_id":"themes/next/source/js/src/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1512633541024},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1512633541021},{"_id":"themes/next/source/js/src/motion.js","hash":"dda8c76fce91d7f140c06de2583ba806810f12c2","modified":1512633541027},{"_id":"themes/next/source/js/src/post-details.js","hash":"50fa390554f0fb467d8eb84ac8eff2cffb13fe67","modified":1512633541029},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1512633541035},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1512633541037},{"_id":"themes/next/source/js/src/utils.js","hash":"e7465a22b536ed15006a5f5556d9a4e633f6bd71","modified":1512633541040},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1512633541077},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1512633541121},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"82fee688910efc644d3d1c3305c6ae28ba3f38f9","modified":1512633541080},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1512633541138},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1512633541126},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1512633541123},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1512633541141},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1512633541143},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1512633541136},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1512633541146},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1512633541192},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1512633541199},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1512633541190},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1512633541183},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1512633541196},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1512633541202},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1512633541128},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1512633541205},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1512633541208},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1512633541210},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1512633541213},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1512633541216},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1512633541229},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1512633541226},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1512633541218},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1512633541221},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1512633541238},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1512633541223},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1512633541231},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1512633541236},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1512633541241},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1512633541247},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1512633541244},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1512633541250},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1512633541265},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1512633541268},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1512633541275},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1512633541277},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1512633541279},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1512633541067},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1512633541233},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1512633541187},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1512633540652},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1512633540715},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1512633540718},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1512633540654},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d68bdfcdb9d9e0bf60ed9a2df88e0b55cbfcc1e6","modified":1512633540708},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1512633540710},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1512633540755},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1512633540817},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"eec22651977ea25b5e65e8cb1b4906eef69ec588","modified":1512633540855},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1512633540861},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1512633540863},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1512633540713},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1512633540858},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1512633540883},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1512633540889},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1512633540865},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1512633540852},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1512633540886},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1512633540896},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1512633540923},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1512633540894},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1512633540892},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1512633540931},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1512633540926},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1512633540935},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1512633540907},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1512633540928},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1512633540913},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1512633540915},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1512633540918},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1512633540910},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1512633541033},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1512633540933},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1512633541054},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1512633540899},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1512633541063},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1512633541083},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1512633541086},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1512633541089},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1512633541091},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1512633541096},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1512633541060},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1512633541093},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1512633541114},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1512633541116},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1512633541119},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1512633541133},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1512633541131},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1512633541157},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1512633541150},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1512633541153},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1512633541260},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1512633541263},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1512633541057},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1512633541272},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1512633541180},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1512633541177},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1512633540720},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1512633540723},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1512633540725},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1512633540732},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1512633540734},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1512633540727},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"c607db489cabe130887ed0e031a82bcbb62bfd65","modified":1512633540758},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1512633540763},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1512633540730},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"452d9bc5ece8212df219a470c4991d49a843c3cf","modified":1512633540766},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1512633540737},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1512633540771},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1512633540739},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"3d5d8bb463251b990b47ae91462c25e9c878be46","modified":1512633540760},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"58f9e6aba94733244a87d2ba5966c5a009486509","modified":1512633540768},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1512633540781},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"88ff693cc0fe6b37d437894c72e95090d016f278","modified":1512633540773},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1512633540785},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"2cb09973d29a8e34e2a3425ac6e0938296970d8e","modified":1512633540788},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"268c9704481fdb0b4d1e646196386143990fe235","modified":1512633540790},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1512633540776},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1512633540742},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"ada33db53f46c080133c17780cbdd10cf37b2777","modified":1512633540744},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1512633540747},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1512633540750},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1512633540779},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1512633540795},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1512633540783},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1512633540802},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1512633540804},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"2b3e1039a58a79f7da5c72542263413782b37fc9","modified":1512633540792},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"d82732ba94562c45728aa753c3150eea8c03494f","modified":1512633540752},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1512633540797},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1512633540809},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1512633540806},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1512633540811},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1512633540822},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1512633540824},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e00d9a0bdf35ffc0a7fa387fa294b953c2d28fc","modified":1512633540813},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1512633540815},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"e3ad37f2da35e330616a044621ffa50565a20c88","modified":1512633540831},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1512633540820},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1512633540839},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1512633540836},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1512633540826},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1512633540845},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1512633540843},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74019008ba973ab30f0f4a6b3c2cd33c66d3a4b4","modified":1512633540829},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"37e406ec42b7a53c72395bdbaa434270019e7179","modified":1512633540850},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1512633540800},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1512633540902},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1512633540904},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1512633540834},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1512633540841},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1512633540848},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1512633540920},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1512633541044},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1512633541046},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1512633541048},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1512633541098},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1512633541051},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1512633541101},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1512633541107},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1512633541160},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1512633541104},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1512633541165},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1512633541111},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1512633541109},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1512633541174},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1512633541074},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1512633541256},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1512633541170},{"_id":"public/baidusitemap.xml","hash":"fac2219541534c2fc10b006d58b233b387536fb2","modified":1522332354276},{"_id":"public/atom.xml","hash":"311f996760a63b1801508e9dcabc67ce34234518","modified":1522332354246},{"_id":"public/search.xml","hash":"af1824a360b46c34da713d3866197768ce4e3fe4","modified":1522332354277},{"_id":"public/sitemap.xml","hash":"6ccbd51fa9fb3637710a89ec9ac3aa5418df5f5f","modified":1522332354277},{"_id":"public/categories/index.html","hash":"51f19a303fcd667d5a41b382086615927e441749","modified":1522332365064},{"_id":"public/about/index.html","hash":"8849fec0db6af7e244bf2f47cd5953e6a83ff04b","modified":1522332365085},{"_id":"public/photo/index.html","hash":"6014ff22dc24e737cd74e1b8d7d90849c27843bd","modified":1522332365086},{"_id":"public/2017/10/19/函数基础/index.html","hash":"a0a9d62016c5009c1e32022dce016a11ab052f68","modified":1522332365092},{"_id":"public/2017/10/15/try语句块和异常处理/index.html","hash":"e3654c2eb427dc1faad43c6e9a4c58c139e094ec","modified":1522332365092},{"_id":"public/2017/10/14/表达式基础/index.html","hash":"3c4a039ac125fc69664ab17b32ad1e527fa91f7a","modified":1522332365092},{"_id":"public/2017/10/14/数组&指针&string/index.html","hash":"a32b156e5fb21bcd31f03ba74061a37acdf16cf7","modified":1522332365092},{"_id":"public/2017/09/01/引用&指针&const/index.html","hash":"c870bc1d436ae15dafb990e87359ea3d27515417","modified":1522332365092},{"_id":"public/2017/08/21/个人总结之排序算法/index.html","hash":"29c2d8fd57d0b1a89ea7f4e0db1e2c56b683cddf","modified":1522332365092},{"_id":"public/2017/08/19/剑指offer/index.html","hash":"ffeb563074c21fe6f1bae7502314a62b433d6b39","modified":1522332365093},{"_id":"public/2017/08/12/样先/index.html","hash":"172f0b9fc0be846686a92f1540664787854c406a","modified":1522332365093},{"_id":"public/2017/08/07/github Pages + Hexo搭建个人博客（二）  提升篇/index.html","hash":"9e9b2484b9447fb36177b48d145df10863e8ccc7","modified":1522332365093},{"_id":"public/2017/08/06/github Pages + Hexo搭建个人博客（一）  初级篇/index.html","hash":"a865736c53f0c11491813f9864c7fe77c29edee5","modified":1522332365093},{"_id":"public/categories/C/index.html","hash":"93e89c1c2b61fcf9b5da6ec6a889cefc916a3ea8","modified":1522332365093},{"_id":"public/categories/hexo/index.html","hash":"9d60ab1125628883b0752d6c47d626ba774f5642","modified":1522332365093},{"_id":"public/tags/index.html","hash":"e0577fa194d9b460491868901d19707609a7ddab","modified":1522332365085},{"_id":"public/categories/算法/index.html","hash":"6375bc6ebba30d9e8b2e3ea7f8996437502779ea","modified":1522332365094},{"_id":"public/categories/刷题/index.html","hash":"52f93b67873029f0a25e712d481128fd194a0928","modified":1522332365094},{"_id":"public/categories/兄弟/index.html","hash":"b24b91c5260af174b51bc65f9f95e644ff9eaac6","modified":1522332365094},{"_id":"public/index.html","hash":"d23b0a2f190b305a56ebdb0fb34e708ddb8ef116","modified":1522332365309},{"_id":"public/page/2/index.html","hash":"9bcde962e0bd1c0dff2d93f9e1593d0fcae6562e","modified":1522332365309},{"_id":"public/tags/hexo/index.html","hash":"0b1c02180ba52bc4ba1a355fccde83cf81bbab8b","modified":1522332365309},{"_id":"public/tags/github/index.html","hash":"d244c3a57f44e6ff9b2ae210136bee6fa88703cd","modified":1522332365309},{"_id":"public/tags/排序/index.html","hash":"0580b6d0458dd38b5509cdb63c18b01127d0d486","modified":1522332365310},{"_id":"public/tags/编程/index.html","hash":"9765cb3311d9476c288f33afa2bca0f9d1b428aa","modified":1522332365311},{"_id":"public/tags/函数/index.html","hash":"945b94801c4611f740da4a048e53f021b5e22f57","modified":1522332365311},{"_id":"public/tags/剑指offer/index.html","hash":"8409a2441fc8acf36e78d1e0bdf06c3271f88da8","modified":1522332365310},{"_id":"public/tags/刷题/index.html","hash":"83aef76ef8393cab32b404e357afea9c12493167","modified":1522332365310},{"_id":"public/tags/C-Primers/index.html","hash":"98dc28202e3581faa6692d26a472089862fc4813","modified":1522332365310},{"_id":"public/tags/C-基础知识/index.html","hash":"617cfa2c1e8c7fe354b428ebd5d7796448c1b1ac","modified":1522332365311},{"_id":"public/tags/C/index.html","hash":"a337089c7327608df79917e163ea6a61951bc81e","modified":1522332365311},{"_id":"public/tags/兄弟/index.html","hash":"30449b315e9ec21be94869bbe9539daa5f3df6c9","modified":1522332365311},{"_id":"public/tags/朋友/index.html","hash":"34490990ab2fcb5650b492c1e788b7cdc6295128","modified":1522332365311},{"_id":"public/tags/数组/index.html","hash":"d052a6c016aa8691ce5d3718dde7acca43a04f83","modified":1522332365312},{"_id":"public/tags/指针/index.html","hash":"916c8c70842b9c274577f27c7ad7e968010b520c","modified":1522332365312},{"_id":"public/tags/异常处理/index.html","hash":"076845e1ab28656ce934c597674a4a6a88bd384a","modified":1522332365312},{"_id":"public/archives/index.html","hash":"226ac00cbd00435a71d87ae6649dd5b5efeee76e","modified":1522332365094},{"_id":"public/archives/page/2/index.html","hash":"ac6c5ef4f2930db59daf297ca03edb9dc4f9b3ca","modified":1522332365308},{"_id":"public/archives/2017/index.html","hash":"0b2adc45716e729b95d462a6bccc755aadf69ea2","modified":1522332365308},{"_id":"public/archives/2017/page/2/index.html","hash":"e90b114f3cfab07fa947e08510068147aa27b100","modified":1522332365308},{"_id":"public/archives/2017/08/index.html","hash":"a9165615df14e5c7855fb8b9b2cdf878b1e61457","modified":1522332365308},{"_id":"public/archives/2017/09/index.html","hash":"7569d75bfd45a3d80440f5280fc1572954cdbf14","modified":1522332365310},{"_id":"public/resume/index.html","hash":"0cea1070d9eed7b377fc40f54e58b025a41728f1","modified":1522332365086},{"_id":"public/2017/10/26/顺序容器概述/index.html","hash":"0c0251076bf087f2d1d88bcb2c12b59bf3ad5e5a","modified":1522332365093},{"_id":"public/2017/10/23/IO流与string流/index.html","hash":"4f76ef28d5cf752cf1237f424f92fd369379475e","modified":1522332365092},{"_id":"public/2017/10/22/类的基本概念/index.html","hash":"d7070349b7a23e2fadf31053b2a89f4d35cb512f","modified":1522332365092},{"_id":"public/tags/I-O流/index.html","hash":"2e84ece316d52ce7446f0c285567b3905f4e2fd8","modified":1522332365309},{"_id":"public/tags/string流/index.html","hash":"23f04e2001ed77a660c4184fe36f2b3a80bde8e7","modified":1522332365309},{"_id":"public/tags/static成员/index.html","hash":"77b13fa9e6a327908b80be2c719c993093a1f148","modified":1522332365311},{"_id":"public/tags/类定义/index.html","hash":"55244dba32400d9e314e3ec9cc3658ddf30e308a","modified":1522332365311},{"_id":"public/tags/顺序容器/index.html","hash":"e0f228feb4ebf0576360d11ef87309af12df9467","modified":1522332365311},{"_id":"public/archives/2017/10/index.html","hash":"6bee5aceada54c75707e9ce6e3214c02821e258c","modified":1522332365309},{"_id":"public/images/alipay.jpg","hash":"9302886ec2ab2e8b37bdbe56500fa254fdc12130","modified":1516196022749},{"_id":"public/images/avatar.gif","hash":"fb1ffdbf506b0899c8e034301c4607bb86060d9d","modified":1516196022749},{"_id":"public/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1516196022749},{"_id":"public/images/avatar.jpg","hash":"ab206e80ecb5e80dad727c257354317c4372b98e","modified":1516196022749},{"_id":"public/images/avatar1.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1516196022749},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1516196022749},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1516196022749},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1516196022749},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1516196022749},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1516196022749},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1516196022749},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1516196022749},{"_id":"public/images/favicon.ico","hash":"4774eaead8875445645b8f4688f218da73156382","modified":1516196022749},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1516196022749},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1516196022749},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1516196022749},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1516196022749},{"_id":"public/images/wechatpay.jpg","hash":"ef74102d3f35bca552eb09337ff37b2df218f01f","modified":1516196022749},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1516196022749},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1516196022749},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1516196022749},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1516196022749},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1516196022749},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1516196022749},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1516196022749},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1516196022749},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1516196022750},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1516196022750},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1516196022750},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1516196022750},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1516196022750},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1516196022750},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1516196022750},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1516196023686},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1516196023692},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1516196023717},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1516196023717},{"_id":"public/js/src/bootstrap.js","hash":"03190d70e2347a0b29d185295445c6762a4455e8","modified":1516196023717},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1516196023717},{"_id":"public/js/src/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1516196023717},{"_id":"public/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1516196023717},{"_id":"public/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1516196023717},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1516196023717},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1516196023717},{"_id":"public/js/src/utils.js","hash":"0fcb80ec11e6df05ed1a07b9338bef2669f93a70","modified":1516196023717},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1516196023717},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1516196023717},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1516196023717},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1516196023717},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1516196023717},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1516196023717},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1516196023717},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1516196023718},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1516196023718},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1516196023718},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1516196023718},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1516196023718},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1516196023718},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1516196023718},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1516196023718},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1516196023718},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1516196023719},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1516196023719},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1516196023719},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1516196023719},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1516196023719},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1516196023719},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1516196023720},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1516196023720},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1516196023720},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1516196023720},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1516196023720},{"_id":"public/css/main.css","hash":"8b8bec65094b36480b4b529f26cd77d623d7b67b","modified":1516196023720},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1516196023720},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1516196023720},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1516196023720},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1516196023720},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1516196023720},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1516196023720},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1516196023720},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1516196023720},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1516196023720},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1516196023720},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1516196023720},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1516196023720},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1516196023720},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1516196023721},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1516196023721},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1516196023721},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1516196023721},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1516196023721},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1516196023721},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1516196023721},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1516196023721},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1516196023832},{"_id":"source/_posts/OOP概述（object-oriented-programming）.md","hash":"3be3dcfd72b2ca20270a2e3c968c2e0a075931c7","modified":1519305787219},{"_id":"source/_posts/对象移动.md","hash":"8e0fa2209e0e4c5bb1f3205b8ed209764c0d26f9","modified":1519302197708},{"_id":"source/_posts/关联容器概述.md","hash":"eb13a5c05ed4ddec4805e6f40fa9546bae7bcb75","modified":1519300886900},{"_id":"source/_posts/动态内存与智能指针.md","hash":"fedffa2becd0f1f8c4042b85ec678ecfce0fedc9","modified":1519301897254},{"_id":"source/_posts/构造函数和拷贝控制.md","hash":"982dcc66de81bf161b023202b3fa22748cdfd9be","modified":1519347547606},{"_id":"source/_posts/虚函数与抽象基类.md","hash":"4a7b0fd5b86a450d965824bf76c2ba384f8b199f","modified":1519347521576},{"_id":"source/_posts/泛型算法概述.md","hash":"57f8f9aeb9a843e6aa46dc08658181ba039e01c9","modified":1519301234500},{"_id":"source/_posts/常用运算符重载.md","hash":"13d19acf78e163eaf0de8214ee0d04d89fe4f999","modified":1519302478644},{"_id":"public/2017/11/23/虚函数与抽象基类/index.html","hash":"c36cca09976e2f8da513ebf3feabd360961ea3f7","modified":1522332365086},{"_id":"public/2017/11/19/OOP概述（object-oriented-programming）/index.html","hash":"70738dd7a8045da10988087867b7fc49a5bd2922","modified":1522332365086},{"_id":"public/2017/11/18/常用运算符重载/index.html","hash":"7777d3b3f58b84e2e5968eea962da7ee965c9389","modified":1522332365091},{"_id":"public/2017/11/15/对象移动/index.html","hash":"41159da082a58b21b6b0afb3e7ab0bb471a160c4","modified":1522332365092},{"_id":"public/2017/11/10/动态内存与智能指针/index.html","hash":"a88b6e2f58a4748bc4e84fbf9da7836bd2e558db","modified":1522332365087},{"_id":"public/2017/11/04/关联容器概述/index.html","hash":"49ec020a1df5dc8b70cc7d79b10f596f58e31d47","modified":1522332365087},{"_id":"public/2017/10/30/泛型算法概述/index.html","hash":"19e836fe88cc0d07a99ff603cbed93fd11944d38","modified":1522332365088},{"_id":"public/2017/10/26/构造函数和拷贝控制/index.html","hash":"6ab55bcfeda1a675247af5521b323da121b31440","modified":1522332365093},{"_id":"public/categories/C/page/2/index.html","hash":"5a2805b91e7669a442c20a67773036d881810436","modified":1522332365093},{"_id":"public/page/3/index.html","hash":"e875e9a8623fd28ac15fa2ab4e0c00f7320786df","modified":1522332365309},{"_id":"public/tags/OOP/index.html","hash":"506b9b6b15ab7922f237e7262b6f7161702b3d48","modified":1522332365312},{"_id":"public/tags/右值引用/index.html","hash":"95ab1b63938cf9244ea80564e2508a4d1d7b339e","modified":1522332365312},{"_id":"public/tags/关联容器/index.html","hash":"7340b0428574ad0bfb0c968887c4de49e8e31e62","modified":1522332365312},{"_id":"public/tags/智能指针/index.html","hash":"c8a54472d910d145e1ab0f70b4b75e4b70ce27ed","modified":1522332365312},{"_id":"public/tags/内存分配/index.html","hash":"f3eb8c285aceafaaf9065b6d466d14cdf98b3e60","modified":1522332365312},{"_id":"public/tags/虚函数/index.html","hash":"6132a5e61f7c99470461add48248a1f7b365d7aa","modified":1522332365312},{"_id":"public/tags/构造函数/index.html","hash":"29bf8bf4fb686d360dfdd68010cc341728f359f0","modified":1522332365312},{"_id":"public/tags/拷贝控制/index.html","hash":"6a1a90dab5016bf608927dbe56faeaf85414446f","modified":1522332365312},{"_id":"public/tags/泛型/index.html","hash":"38e498b9e6f36723f056c2a73aeea9e8a98d7fd0","modified":1522332365312},{"_id":"public/tags/运算符重载/index.html","hash":"dc8390deaed64432f7661831207ac1891696d47d","modified":1522332365312},{"_id":"public/archives/page/3/index.html","hash":"29bead19663068e6b750c672b09a3fdd092f6ca6","modified":1522332365308},{"_id":"public/archives/2017/page/3/index.html","hash":"769c952bb51adc1316ccad24ef812f1868981577","modified":1522332365310},{"_id":"public/archives/2017/11/index.html","hash":"da7e3379188aada86d4a7f2c1a2709f440aa34b0","modified":1522332365309},{"_id":"source/_posts/函数模版和类模板.md","hash":"6d11ff7ab637fe3cd83319daffc56bc06dc15876","modified":1519370519655},{"_id":"source/_posts/多重继承与虚继承.md","hash":"fe692b25a30f685be7a9bd3acb45b99f5b8ee520","modified":1519372841355},{"_id":"source/_posts/异常处理与命令空间.md","hash":"bc118054aa87766817195b78c3fd79344b2bbe30","modified":1519372997685},{"_id":"source/_posts/访问控制与继承.md","hash":"d3ddca2ed9cfbc2e9789d62a7a1ed7684fa571c5","modified":1519373590483},{"_id":"source/_posts/模板参数与成员模版.md","hash":"be0b71eaf8edd62d72e12f9614e8b45089dd62a9","modified":1519373303493},{"_id":"public/archives/2017/12/index.html","hash":"18c73d6fd0bddfeffd7d03023d1ee61914704035","modified":1522332365309},{"_id":"public/2017/12/04/多重继承与虚继承/index.html","hash":"a66493a97847c858164f1488b80bc8d4dd275240","modified":1522332365086},{"_id":"public/2017/12/03/异常处理与命令空间/index.html","hash":"dbd765f12b6a4c9eed8e76a430f09371d54c9827","modified":1522332365086},{"_id":"public/2017/12/01/函数模版和类模板/index.html","hash":"7df1df7a281fbe4181c18ea3a00cf09527b2ac0e","modified":1522332365086},{"_id":"public/2017/12/01/模板参数与成员模版/index.html","hash":"2792b3698f6a5454ba5570d7019922629a1d7cb3","modified":1522332365086},{"_id":"public/2017/11/23/访问控制与继承/index.html","hash":"11cfe6779ab8d692b5b0ab9b32e917dcae954f89","modified":1522332365086},{"_id":"public/categories/C/page/3/index.html","hash":"ec246cc4297a72cd87436ecb0f1e559086430e02","modified":1522332365093},{"_id":"public/tags/模板/index.html","hash":"3fa5b99624f26ce6ba2f82ffcfbf262a03a613f8","modified":1522332365312},{"_id":"public/tags/虚继承/index.html","hash":"326e5ee15f6244e5e192a8c053a4e705d79304da","modified":1522332365312},{"_id":"public/tags/面向对象/index.html","hash":"47092fc38825d45ace016d2d4668db0c4ebba01d","modified":1522332365312},{"_id":"source/_posts/2019华为春招实习机试题.md","hash":"09d1c472f8dfc7c8086e725280e26fabfcf00f16","modified":1522332090427},{"_id":"public/2018/03/29/2019华为春招实习机试题/index.html","hash":"0bdcfeb6084c77d0f06497e9f73f5aa5e6de77d4","modified":1522332365308},{"_id":"public/categories/春招笔试/index.html","hash":"5b52210e3cdb590b62df0721b4c90a2515ae0fb7","modified":1522332365308},{"_id":"public/archives/2018/index.html","hash":"d3b502d3b207a83add542a031b6fc9362317e651","modified":1522332365309},{"_id":"public/archives/2018/03/index.html","hash":"127bf6448812547e6c4102999ef7711aa9c9e93a","modified":1522332365316}],"Category":[{"name":"C++","_id":"cjcj3yifz0002jgc9bguctzwf"},{"name":"hexo","_id":"cjcj3yigd0007jgc93z1g8zjj"},{"name":"算法","_id":"cjcj3yigq000ijgc9ukau0xuf"},{"name":"刷题","_id":"cjcj3yigt000mjgc9giavsatu"},{"name":"兄弟","_id":"cjcj3yipe001ljgc9e35us5e9"},{"name":"春招笔试","_id":"cjfclddsl0001u4c9wf05dtaf"}],"Data":[],"Page":[{"title":"categories","date":"2017-08-01T02:20:50.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-08-01 10:20:50\ntype: categories\ncomments: false\n---\n","updated":"2017-12-07T07:59:00.092Z","path":"categories/index.html","layout":"page","_id":"cjcj3yioy001cjgc9nnkk9uf5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2017-08-01T02:21:04.000Z","type":"about","_content":"## 王新日\n\n\n邮箱：xinrisanshao@163.com\t\nQQ：415595161\n现居地：沙坪坝重庆大学A区\n\n\n\n我的歌单\n<div id=\"music163player\">\n   <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=0&id=866649915&auto=0&height=430\"></iframe>\n</div>","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-08-01 10:21:04\ntype: about\n---\n## 王新日\n\n\n邮箱：xinrisanshao@163.com\t\nQQ：415595161\n现居地：沙坪坝重庆大学A区\n\n\n\n我的歌单\n<div id=\"music163player\">\n   <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=0&id=866649915&auto=0&height=430\"></iframe>\n</div>","updated":"2018-01-16T01:59:47.168Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjcj3yip2001ejgc9hs3ueqap","content":"<h2 id=\"王新日\"><a href=\"#王新日\" class=\"headerlink\" title=\"王新日\"></a>王新日</h2><p>邮箱：xinrisanshao@163.com<br>QQ：415595161<br>现居地：沙坪坝重庆大学A区</p>\n<p>我的歌单</p>\n<div id=\"music163player\"><br>   <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"450\" src=\"//music.163.com/outchain/player?type=0&id=866649915&auto=0&height=430\"></iframe><br></div>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"王新日\"><a href=\"#王新日\" class=\"headerlink\" title=\"王新日\"></a>王新日</h2><p>邮箱：xinrisanshao@163.com<br>QQ：415595161<br>现居地：沙坪坝重庆大学A区</p>\n<p>我的歌单</p>\n<div id=\"music163player\"><br>   <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"450\" src=\"//music.163.com/outchain/player?type=0&id=866649915&auto=0&height=430\"></iframe><br></div>"},{"title":"tags","date":"2017-08-01T02:20:57.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-08-01 10:20:57\ntype: tags\ncomments: false\n---\n","updated":"2017-12-07T07:59:00.099Z","path":"tags/index.html","layout":"page","_id":"cjcj3yip6001hjgc98wh3fw7e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"相册","date":"2017-08-15T11:49:43.000Z","type":"photo","comments":0,"_content":"\n","source":"photo/index.md","raw":"---\ntitle: 相册\ndate: 2017-08-15 19:49:43\ntype: photo\ncomments: false\n---\n\n","updated":"2018-01-17T12:47:36.138Z","path":"photo/index.html","layout":"page","_id":"cjcj3yipc001kjgc9c0pgmkwh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"简历","date":"2018-01-15T11:49:43.000Z","type":"resume","comments":0,"_content":"\n![个人简历](http://ou6yob3zd.bkt.clouddn.com/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.png)\n\n[pdf下载链接](http://ou6yob3zd.bkt.clouddn.com/%E7%8E%8B%E6%96%B0%E6%97%A5_%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.pdf?attname=)","source":"resume/index.md","raw":"---\ntitle: 简历\ndate: 2018-01-15 19:49:43\ntype: resume\ncomments: false\n---\n\n![个人简历](http://ou6yob3zd.bkt.clouddn.com/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.png)\n\n[pdf下载链接](http://ou6yob3zd.bkt.clouddn.com/%E7%8E%8B%E6%96%B0%E6%97%A5_%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.pdf?attname=)","updated":"2018-01-17T12:48:17.152Z","path":"resume/index.html","layout":"page","_id":"cjcj3yipg001pjgc9hmwdhqgj","content":"<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.png\" alt=\"个人简历\"></p>\n<p><a href=\"http://ou6yob3zd.bkt.clouddn.com/%E7%8E%8B%E6%96%B0%E6%97%A5_%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.pdf?attname=\" target=\"_blank\" rel=\"external\">pdf下载链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.png\" alt=\"个人简历\"></p>\n<p><a href=\"http://ou6yob3zd.bkt.clouddn.com/%E7%8E%8B%E6%96%B0%E6%97%A5_%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.pdf?attname=\" target=\"_blank\" rel=\"external\">pdf下载链接</a></p>\n"}],"Post":[{"title":"I/O流与string流","date":"2017-10-23T13:59:00.000Z","update":null,"comments":1,"_content":"# 一、前言\n介绍I/O流和string流及其基本使用。\n<!--more-->\n\n# IO类\n\n## IO对象无拷贝或赋值\n\n由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。\n\n## 条件状态\n\n```C++\n#include <iostream>\nusing namespace std;\nistream& func(istream &is)\n{\n    string buf;\n    while (is >> buf)\n        cout << buf << endl;\n    is.clear();   //将流的状态设置为有效\n    return is;\n}\nint main()\n{\n    istream& is = func(std::cin);\n    cout << is.rdstate() << std::endl;\n    cout<<\"hi!\"<<endl;   //输出hi和一个换行，然后刷新缓冲区\n    cout<<\"hi!\"<<flush;  //输出hi，然后刷新缓冲区，不附加任何额外的字符串\n    cout<<\"hi!\"<<ends;   //输出hi和一个空字符，然后刷新缓冲区\n    return 0;\n}\n```\n\n## 文件输入输出\n\n头文件**fstream**定义了三个类型来支持文件IO：**ifstream**从给定文件读取数据，**ofstream**向一个给定文件写入数据，以及**fstream**可以读写文件。\n\n这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样，特别是，我们可以用IO运算符（<<和>>）来读写文件，可以用getline从一个ifstream读取数据。\n\n**代码示例：**\n```C++\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\nusing namespace std;\nvoid readfile(string filename,vector<string>& svec){   //从文件中读取数据到svec中\n    ifstream input;   //从一个给定文件读取数据\n    input.open(filename);\n    if(input){\n        /*\n        string line;\n        while(getline(input,line)){   //按行读取文件，input当成输入流cin处理就行\n            svec.push_back(line);\n        }*/\n        string word;\n        while(input>>word){   //按单词读取文件，input当成输入流cin处理就行\n            svec.push_back(word);\n        }\n\n    }else{\n        cout<<\"couldn't open: \" + filename<<endl;\n    }\n    input.close();\n}\n\nvoid writefile(string filename,const vector<string>& svec){   //从文件中读取数据到svec中\n    ofstream out;  //ofstream向一个给定文件写入数据\n    out.open(filename,ofstream::app);  //不清空文件，末尾追加写入\n    if(out){\n       for(auto word : svec){\n           out<<word<<endl;   //输出流，也就将word写入到文件中\n       }\n    }else{\n        cout<<\"couldn't open: \" + filename<<endl;\n    }\n    out.close();\n}\nint main()\n{\n    string filename = \"STRING.txt\";\n    vector<string> svec;\n    readfile(filename,svec);\n    for(auto line : svec){\n        cout<<line<<endl;\n    }\n    //从svec写入数据到文件中\n    filename = \"WRITE.txt\";\n    writefile(filename,svec);\n    return 0;\n}\n```\n\n## 文件模式\n\n每个流都有一个关联的文件模式（mode），用来指出如何使用文件。具体的mode有哪些呢？\n```C++\nin       以读方式打开\nout      以写方式打开\napp      每次写操作前均定位到文件末尾（从文件尾开始写，不覆盖前面写的）\nate      打开文件后立即定位到文件末尾\ntrunc     截断文件\nbinary    以二进制方式进行IO\n```\n\n\n不管用哪种方式打开文件，我们都可以指定文件模式，调用open显式打开或者用一个文件名初始化文件流来隐式打开文件都可指定文件模式。\n但是上述模式间有限制关系：\n\n- 只可以对ifstream和ifstream对象设定in模式\n- 只可以对ofstream和fstream对象设定out模式\n- 只有当out被设定时才能设定trunc模式\n- 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式打开\n- 默认情况下，即使我们没有指定trunc模式，以out模式打开的文件也会被截断。为了保留以out模式打开的文件内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。\n\n\n每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。**与ifstream关联的文件默认以in模式打开，与ofstream关联的文件默认以out模式打开，与fstream关联的文件默认以in和out模式打开。**\n\n \n此外，有两点需要特别注意：\n\n**1：以out模式打开文件会丢弃已有数据**\n\n默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止清空文件的方法是同时指定app模式。\n\n```C++\n// 这三条语句中，file都将被截断\nofstream out(\"file\");     // 隐含以输出模式打开文件并截断文件\nofstream out(\"file\",ofstream::out);   // 隐含地截断文件\nofstream out(\"file\",ofstream::out|ofstream::trunc); \n//这两条语句中，文件内容将被保存\nofstream out(\"file\",ofstream::app);     //隐含为输出模式\nofstream app(\"file\",ofstream::out|ofstream::app);\n```\n \n**小结：保留被ofstream打开的文件中内容的唯一方法是显示指定app或in模式。**\n\n**2 ：每次调用open时都会确定文件模式**\n\n对于一个给个流，每当打开文件时，都可以改变其文件模式。\n\n```C++\nofstream  out;         // 未指定文件打开模式\nout.open(\"file\");      // 隐含设置为输出和截断\nout.close();          // 与out绑定的名为file的文件被关闭，以便我们将对象out用于其他文件\nout.open(\"preFile\",ofstream::app);      //模式为输出和文件尾追加\nout.close();\n```\n\n名为file的文件内容将被清空，名为preFile的文件中已有的数据将都被保存。\n\n**小结：每次打开文件时，都要设置文件模式，可以是显式的设置，也可以是隐式的设置。当文件未指定模式时，都是使用默认值。**  \n\n\n# String流\n\nsstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。\n\n**istringstream从string读取数据，ostreamstream向string写入数据，而头文件stringstream既可以读数据也可向string写数据。**\n\n头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。\n\n```C++\nstringstream特有的操作\nsstream strm； strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型\nsstream strm(s); strm是一个sstream对象，保存strings的一个拷贝。此构造函数是explicit的\nstrm.str（） 返回strm所保存的string类型\nstrm.str(s) 将string的s拷贝到strm中，返回void\n```\n\n## 使用istringstream\n\n当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的某个单词时，通常可以使用istringstream。\n\n考虑如下文件，列出了一些人和他们的电话号码（电话号码多选）\n```\nmorgan 20155555 685522\ndrew 5524566\nlee 425422 542122 55444222\n```\n我们定义一个简单的类来描述输入数据：\n\n```C++\nstruct PersonInfo{\n    string name;\n    vector<string> phones;\n}\n```\n我们从文本中读入输入数据，并将输入数据写入到vector<PersonInfo>容器中：\n\n以下是完整代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\n#include <sstream>\nusing namespace std;\n//成员默认公有\nstruct PersonInfo{\n    string name;\n    vector<string> phones;\n};\nint main()\n{\n    string filename = \"Info.txt\";\n    ifstream input;   //从文件中读取数据\n    vector<PersonInfo> Pvec;\n    input.open(filename);\n    if(input){\n        string line;\n        string phone;\n        while(getline(input,line)){\n            PersonInfo info;\n            istringstream record(line);   //将记录绑定到刚读入的行\n            record>>info.name;     //读取名字\n            while(record>>phone){  //读取电话号码\n                info.phones.push_back(phone);\n            }\n            Pvec.push_back(info);   //将记录追加到people末尾\n        }\n    }else{\n        cout<<\"couldn't not open file\"<<endl;\n    }\n    input.close();\n    for(auto people : Pvec){   //输出\n        cout<<people.name;\n        for(auto phone : people.phones){\n            cout<<\" \"<<phone;\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n## 使用ostringstream\n**\n当我们逐步构造输出，希望最后一起打印是，ostringstream是很有用的。**\n\n```C++\nostringstream badNums;\nstring num = \"123\";\nstring name = \"xin\";\nbadNums<<num<<name;     //将数的字符串的形式存入badNums\ncout<<badNums.str()<<endl;    //输出123xin\n```\n\n**输出badNums.str()!**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/IO流与string流.md","raw":"---\ntitle: I/O流与string流\ndate: 2017-10-23 21:59:00\nupdate: \ntags: [I/O流,string流]\ncategories: C++\ncomments: true\n---\n# 一、前言\n介绍I/O流和string流及其基本使用。\n<!--more-->\n\n# IO类\n\n## IO对象无拷贝或赋值\n\n由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。\n\n## 条件状态\n\n```C++\n#include <iostream>\nusing namespace std;\nistream& func(istream &is)\n{\n    string buf;\n    while (is >> buf)\n        cout << buf << endl;\n    is.clear();   //将流的状态设置为有效\n    return is;\n}\nint main()\n{\n    istream& is = func(std::cin);\n    cout << is.rdstate() << std::endl;\n    cout<<\"hi!\"<<endl;   //输出hi和一个换行，然后刷新缓冲区\n    cout<<\"hi!\"<<flush;  //输出hi，然后刷新缓冲区，不附加任何额外的字符串\n    cout<<\"hi!\"<<ends;   //输出hi和一个空字符，然后刷新缓冲区\n    return 0;\n}\n```\n\n## 文件输入输出\n\n头文件**fstream**定义了三个类型来支持文件IO：**ifstream**从给定文件读取数据，**ofstream**向一个给定文件写入数据，以及**fstream**可以读写文件。\n\n这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样，特别是，我们可以用IO运算符（<<和>>）来读写文件，可以用getline从一个ifstream读取数据。\n\n**代码示例：**\n```C++\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\nusing namespace std;\nvoid readfile(string filename,vector<string>& svec){   //从文件中读取数据到svec中\n    ifstream input;   //从一个给定文件读取数据\n    input.open(filename);\n    if(input){\n        /*\n        string line;\n        while(getline(input,line)){   //按行读取文件，input当成输入流cin处理就行\n            svec.push_back(line);\n        }*/\n        string word;\n        while(input>>word){   //按单词读取文件，input当成输入流cin处理就行\n            svec.push_back(word);\n        }\n\n    }else{\n        cout<<\"couldn't open: \" + filename<<endl;\n    }\n    input.close();\n}\n\nvoid writefile(string filename,const vector<string>& svec){   //从文件中读取数据到svec中\n    ofstream out;  //ofstream向一个给定文件写入数据\n    out.open(filename,ofstream::app);  //不清空文件，末尾追加写入\n    if(out){\n       for(auto word : svec){\n           out<<word<<endl;   //输出流，也就将word写入到文件中\n       }\n    }else{\n        cout<<\"couldn't open: \" + filename<<endl;\n    }\n    out.close();\n}\nint main()\n{\n    string filename = \"STRING.txt\";\n    vector<string> svec;\n    readfile(filename,svec);\n    for(auto line : svec){\n        cout<<line<<endl;\n    }\n    //从svec写入数据到文件中\n    filename = \"WRITE.txt\";\n    writefile(filename,svec);\n    return 0;\n}\n```\n\n## 文件模式\n\n每个流都有一个关联的文件模式（mode），用来指出如何使用文件。具体的mode有哪些呢？\n```C++\nin       以读方式打开\nout      以写方式打开\napp      每次写操作前均定位到文件末尾（从文件尾开始写，不覆盖前面写的）\nate      打开文件后立即定位到文件末尾\ntrunc     截断文件\nbinary    以二进制方式进行IO\n```\n\n\n不管用哪种方式打开文件，我们都可以指定文件模式，调用open显式打开或者用一个文件名初始化文件流来隐式打开文件都可指定文件模式。\n但是上述模式间有限制关系：\n\n- 只可以对ifstream和ifstream对象设定in模式\n- 只可以对ofstream和fstream对象设定out模式\n- 只有当out被设定时才能设定trunc模式\n- 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式打开\n- 默认情况下，即使我们没有指定trunc模式，以out模式打开的文件也会被截断。为了保留以out模式打开的文件内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。\n\n\n每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。**与ifstream关联的文件默认以in模式打开，与ofstream关联的文件默认以out模式打开，与fstream关联的文件默认以in和out模式打开。**\n\n \n此外，有两点需要特别注意：\n\n**1：以out模式打开文件会丢弃已有数据**\n\n默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止清空文件的方法是同时指定app模式。\n\n```C++\n// 这三条语句中，file都将被截断\nofstream out(\"file\");     // 隐含以输出模式打开文件并截断文件\nofstream out(\"file\",ofstream::out);   // 隐含地截断文件\nofstream out(\"file\",ofstream::out|ofstream::trunc); \n//这两条语句中，文件内容将被保存\nofstream out(\"file\",ofstream::app);     //隐含为输出模式\nofstream app(\"file\",ofstream::out|ofstream::app);\n```\n \n**小结：保留被ofstream打开的文件中内容的唯一方法是显示指定app或in模式。**\n\n**2 ：每次调用open时都会确定文件模式**\n\n对于一个给个流，每当打开文件时，都可以改变其文件模式。\n\n```C++\nofstream  out;         // 未指定文件打开模式\nout.open(\"file\");      // 隐含设置为输出和截断\nout.close();          // 与out绑定的名为file的文件被关闭，以便我们将对象out用于其他文件\nout.open(\"preFile\",ofstream::app);      //模式为输出和文件尾追加\nout.close();\n```\n\n名为file的文件内容将被清空，名为preFile的文件中已有的数据将都被保存。\n\n**小结：每次打开文件时，都要设置文件模式，可以是显式的设置，也可以是隐式的设置。当文件未指定模式时，都是使用默认值。**  \n\n\n# String流\n\nsstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。\n\n**istringstream从string读取数据，ostreamstream向string写入数据，而头文件stringstream既可以读数据也可向string写数据。**\n\n头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。\n\n```C++\nstringstream特有的操作\nsstream strm； strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型\nsstream strm(s); strm是一个sstream对象，保存strings的一个拷贝。此构造函数是explicit的\nstrm.str（） 返回strm所保存的string类型\nstrm.str(s) 将string的s拷贝到strm中，返回void\n```\n\n## 使用istringstream\n\n当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的某个单词时，通常可以使用istringstream。\n\n考虑如下文件，列出了一些人和他们的电话号码（电话号码多选）\n```\nmorgan 20155555 685522\ndrew 5524566\nlee 425422 542122 55444222\n```\n我们定义一个简单的类来描述输入数据：\n\n```C++\nstruct PersonInfo{\n    string name;\n    vector<string> phones;\n}\n```\n我们从文本中读入输入数据，并将输入数据写入到vector<PersonInfo>容器中：\n\n以下是完整代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\n#include <sstream>\nusing namespace std;\n//成员默认公有\nstruct PersonInfo{\n    string name;\n    vector<string> phones;\n};\nint main()\n{\n    string filename = \"Info.txt\";\n    ifstream input;   //从文件中读取数据\n    vector<PersonInfo> Pvec;\n    input.open(filename);\n    if(input){\n        string line;\n        string phone;\n        while(getline(input,line)){\n            PersonInfo info;\n            istringstream record(line);   //将记录绑定到刚读入的行\n            record>>info.name;     //读取名字\n            while(record>>phone){  //读取电话号码\n                info.phones.push_back(phone);\n            }\n            Pvec.push_back(info);   //将记录追加到people末尾\n        }\n    }else{\n        cout<<\"couldn't not open file\"<<endl;\n    }\n    input.close();\n    for(auto people : Pvec){   //输出\n        cout<<people.name;\n        for(auto phone : people.phones){\n            cout<<\" \"<<phone;\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n## 使用ostringstream\n**\n当我们逐步构造输出，希望最后一起打印是，ostringstream是很有用的。**\n\n```C++\nostringstream badNums;\nstring num = \"123\";\nstring name = \"xin\";\nbadNums<<num<<name;     //将数的字符串的形式存入badNums\ncout<<badNums.str()<<endl;    //输出123xin\n```\n\n**输出badNums.str()!**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"IO流与string流","published":1,"updated":"2018-01-17T12:39:54.849Z","layout":"post","photos":[],"link":"","_id":"cjcj3yifq0000jgc9460lm50w","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍I/O流和string流及其基本使用。<br><a id=\"more\"></a></p>\n<h1 id=\"IO类\"><a href=\"#IO类\" class=\"headerlink\" title=\"IO类\"></a>IO类</h1><h2 id=\"IO对象无拷贝或赋值\"><a href=\"#IO对象无拷贝或赋值\" class=\"headerlink\" title=\"IO对象无拷贝或赋值\"></a>IO对象无拷贝或赋值</h2><p>由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>\n<h2 id=\"条件状态\"><a href=\"#条件状态\" class=\"headerlink\" title=\"条件状态\"></a>条件状态</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">func</span><span class=\"params\">(istream &amp;is)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> buf;</div><div class=\"line\">    <span class=\"keyword\">while</span> (is &gt;&gt; buf)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buf &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    is.clear();   <span class=\"comment\">//将流的状态设置为有效</span></div><div class=\"line\">    <span class=\"keyword\">return</span> is;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    istream&amp; is = func(<span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; is.rdstate() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hi!\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//输出hi和一个换行，然后刷新缓冲区</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hi!\"</span>&lt;&lt;flush;  <span class=\"comment\">//输出hi，然后刷新缓冲区，不附加任何额外的字符串</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hi!\"</span>&lt;&lt;ends;   <span class=\"comment\">//输出hi和一个空字符，然后刷新缓冲区</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h2><p>头文件<strong>fstream</strong>定义了三个类型来支持文件IO：<strong>ifstream</strong>从给定文件读取数据，<strong>ofstream</strong>向一个给定文件写入数据，以及<strong>fstream</strong>可以读写文件。</p>\n<p>这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样，特别是，我们可以用IO运算符（&lt;&lt;和&gt;&gt;）来读写文件，可以用getline从一个ifstream读取数据。</p>\n<p><strong>代码示例：</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readfile</span><span class=\"params\">(<span class=\"built_in\">string</span> filename,<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; svec)</span></span>&#123;   <span class=\"comment\">//从文件中读取数据到svec中</span></div><div class=\"line\">    ifstream input;   <span class=\"comment\">//从一个给定文件读取数据</span></div><div class=\"line\">    input.open(filename);</div><div class=\"line\">    <span class=\"keyword\">if</span>(input)&#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">        string line;</span></div><div class=\"line\"><span class=\"comment\">        while(getline(input,line))&#123;   //按行读取文件，input当成输入流cin处理就行</span></div><div class=\"line\"><span class=\"comment\">            svec.push_back(line);</span></div><div class=\"line\"><span class=\"comment\">        &#125;*/</span></div><div class=\"line\">        <span class=\"built_in\">string</span> word;</div><div class=\"line\">        <span class=\"keyword\">while</span>(input&gt;&gt;word)&#123;   <span class=\"comment\">//按单词读取文件，input当成输入流cin处理就行</span></div><div class=\"line\">            svec.push_back(word);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"couldn't open: \"</span> + filename&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    input.close();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writefile</span><span class=\"params\">(<span class=\"built_in\">string</span> filename,<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; svec)</span></span>&#123;   <span class=\"comment\">//从文件中读取数据到svec中</span></div><div class=\"line\">    ofstream out;  <span class=\"comment\">//ofstream向一个给定文件写入数据</span></div><div class=\"line\">    out.open(filename,ofstream::app);  <span class=\"comment\">//不清空文件，末尾追加写入</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(out)&#123;</div><div class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> word : svec)&#123;</div><div class=\"line\">           out&lt;&lt;word&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//输出流，也就将word写入到文件中</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"couldn't open: \"</span> + filename&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    out.close();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> filename = <span class=\"string\">\"STRING.txt\"</span>;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec;</div><div class=\"line\">    readfile(filename,svec);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> line : svec)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;line&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//从svec写入数据到文件中</span></div><div class=\"line\">    filename = <span class=\"string\">\"WRITE.txt\"</span>;</div><div class=\"line\">    writefile(filename,svec);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"文件模式\"><a href=\"#文件模式\" class=\"headerlink\" title=\"文件模式\"></a>文件模式</h2><p>每个流都有一个关联的文件模式（mode），用来指出如何使用文件。具体的mode有哪些呢？<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">in       以读方式打开</div><div class=\"line\">out      以写方式打开</div><div class=\"line\">app      每次写操作前均定位到文件末尾（从文件尾开始写，不覆盖前面写的）</div><div class=\"line\">ate      打开文件后立即定位到文件末尾</div><div class=\"line\">trunc     截断文件</div><div class=\"line\">binary    以二进制方式进行IO</div></pre></td></tr></table></figure></p>\n<p>不管用哪种方式打开文件，我们都可以指定文件模式，调用open显式打开或者用一个文件名初始化文件流来隐式打开文件都可指定文件模式。<br>但是上述模式间有限制关系：</p>\n<ul>\n<li>只可以对ifstream和ifstream对象设定in模式</li>\n<li>只可以对ofstream和fstream对象设定out模式</li>\n<li>只有当out被设定时才能设定trunc模式</li>\n<li>只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式打开</li>\n<li>默认情况下，即使我们没有指定trunc模式，以out模式打开的文件也会被截断。为了保留以out模式打开的文件内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。</li>\n</ul>\n<p>每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。<strong>与ifstream关联的文件默认以in模式打开，与ofstream关联的文件默认以out模式打开，与fstream关联的文件默认以in和out模式打开。</strong></p>\n<p>此外，有两点需要特别注意：</p>\n<p><strong>1：以out模式打开文件会丢弃已有数据</strong></p>\n<p>默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止清空文件的方法是同时指定app模式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这三条语句中，file都将被截断</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>)</span></span>;     <span class=\"comment\">// 隐含以输出模式打开文件并截断文件</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::out)</span></span>;   <span class=\"comment\">// 隐含地截断文件</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::out|ofstream::trunc)</span></span>; </div><div class=\"line\"><span class=\"comment\">//这两条语句中，文件内容将被保存</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::app)</span></span>;     <span class=\"comment\">//隐含为输出模式</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">app</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::out|ofstream::app)</span></span>;</div></pre></td></tr></table></figure>\n<p><strong>小结：保留被ofstream打开的文件中内容的唯一方法是显示指定app或in模式。</strong></p>\n<p><strong>2 ：每次调用open时都会确定文件模式</strong></p>\n<p>对于一个给个流，每当打开文件时，都可以改变其文件模式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ofstream  out;         <span class=\"comment\">// 未指定文件打开模式</span></div><div class=\"line\">out.open(<span class=\"string\">\"file\"</span>);      <span class=\"comment\">// 隐含设置为输出和截断</span></div><div class=\"line\">out.close();          <span class=\"comment\">// 与out绑定的名为file的文件被关闭，以便我们将对象out用于其他文件</span></div><div class=\"line\">out.open(<span class=\"string\">\"preFile\"</span>,ofstream::app);      <span class=\"comment\">//模式为输出和文件尾追加</span></div><div class=\"line\">out.close();</div></pre></td></tr></table></figure>\n<p>名为file的文件内容将被清空，名为preFile的文件中已有的数据将都被保存。</p>\n<p><strong>小结：每次打开文件时，都要设置文件模式，可以是显式的设置，也可以是隐式的设置。当文件未指定模式时，都是使用默认值。</strong>  </p>\n<h1 id=\"String流\"><a href=\"#String流\" class=\"headerlink\" title=\"String流\"></a>String流</h1><p>sstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。</p>\n<p><strong>istringstream从string读取数据，ostreamstream向string写入数据，而头文件stringstream既可以读数据也可向string写数据。</strong></p>\n<p>头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">stringstream</span>特有的操作</div><div class=\"line\">sstream strm； strm是一个未绑定的<span class=\"built_in\">stringstream</span>对象。sstream是头文件sstream中定义的一个类型</div><div class=\"line\"><span class=\"function\">sstream <span class=\"title\">strm</span><span class=\"params\">(s)</span></span>; strm是一个sstream对象，保存strings的一个拷贝。此构造函数是<span class=\"keyword\">explicit</span>的</div><div class=\"line\">strm.str（） 返回strm所保存的<span class=\"built_in\">string</span>类型</div><div class=\"line\">strm.str(s) 将<span class=\"built_in\">string</span>的s拷贝到strm中，返回<span class=\"keyword\">void</span></div></pre></td></tr></table></figure>\n<h2 id=\"使用istringstream\"><a href=\"#使用istringstream\" class=\"headerlink\" title=\"使用istringstream\"></a>使用istringstream</h2><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的某个单词时，通常可以使用istringstream。</p>\n<p>考虑如下文件，列出了一些人和他们的电话号码（电话号码多选）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">morgan 20155555 685522</div><div class=\"line\">drew 5524566</div><div class=\"line\">lee 425422 542122 55444222</div></pre></td></tr></table></figure></p>\n<p>我们定义一个简单的类来描述输入数据：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PersonInfo</span>&#123;</span></div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; phones;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们从文本中读入输入数据，并将输入数据写入到vector<personinfo>容器中：</personinfo></p>\n<p>以下是完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"comment\">//成员默认公有</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PersonInfo</span>&#123;</span></div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; phones;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> filename = <span class=\"string\">\"Info.txt\"</span>;</div><div class=\"line\">    ifstream input;   <span class=\"comment\">//从文件中读取数据</span></div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;PersonInfo&gt; Pvec;</div><div class=\"line\">    input.open(filename);</div><div class=\"line\">    <span class=\"keyword\">if</span>(input)&#123;</div><div class=\"line\">        <span class=\"built_in\">string</span> line;</div><div class=\"line\">        <span class=\"built_in\">string</span> phone;</div><div class=\"line\">        <span class=\"keyword\">while</span>(getline(input,line))&#123;</div><div class=\"line\">            PersonInfo info;</div><div class=\"line\">            <span class=\"function\"><span class=\"built_in\">istringstream</span> <span class=\"title\">record</span><span class=\"params\">(line)</span></span>;   <span class=\"comment\">//将记录绑定到刚读入的行</span></div><div class=\"line\">            record&gt;&gt;info.name;     <span class=\"comment\">//读取名字</span></div><div class=\"line\">            <span class=\"keyword\">while</span>(record&gt;&gt;phone)&#123;  <span class=\"comment\">//读取电话号码</span></div><div class=\"line\">                info.phones.push_back(phone);</div><div class=\"line\">            &#125;</div><div class=\"line\">            Pvec.push_back(info);   <span class=\"comment\">//将记录追加到people末尾</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"couldn't not open file\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    input.close();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> people : Pvec)&#123;   <span class=\"comment\">//输出</span></div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;people.name;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> phone : people.phones)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;phone;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用ostringstream\"><a href=\"#使用ostringstream\" class=\"headerlink\" title=\"使用ostringstream\"></a>使用ostringstream</h2><p><strong><br>当我们逐步构造输出，希望最后一起打印是，ostringstream是很有用的。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">ostringstream</span> badNums;</div><div class=\"line\"><span class=\"built_in\">string</span> num = <span class=\"string\">\"123\"</span>;</div><div class=\"line\"><span class=\"built_in\">string</span> name = <span class=\"string\">\"xin\"</span>;</div><div class=\"line\">badNums&lt;&lt;num&lt;&lt;name;     <span class=\"comment\">//将数的字符串的形式存入badNums</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;badNums.str()&lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//输出123xin</span></div></pre></td></tr></table></figure>\n<p><strong>输出badNums.str()!</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍I/O流和string流及其基本使用。<br>","more":"</p>\n<h1 id=\"IO类\"><a href=\"#IO类\" class=\"headerlink\" title=\"IO类\"></a>IO类</h1><h2 id=\"IO对象无拷贝或赋值\"><a href=\"#IO对象无拷贝或赋值\" class=\"headerlink\" title=\"IO对象无拷贝或赋值\"></a>IO对象无拷贝或赋值</h2><p>由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>\n<h2 id=\"条件状态\"><a href=\"#条件状态\" class=\"headerlink\" title=\"条件状态\"></a>条件状态</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">func</span><span class=\"params\">(istream &amp;is)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> buf;</div><div class=\"line\">    <span class=\"keyword\">while</span> (is &gt;&gt; buf)</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buf &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    is.clear();   <span class=\"comment\">//将流的状态设置为有效</span></div><div class=\"line\">    <span class=\"keyword\">return</span> is;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    istream&amp; is = func(<span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; is.rdstate() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hi!\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//输出hi和一个换行，然后刷新缓冲区</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hi!\"</span>&lt;&lt;flush;  <span class=\"comment\">//输出hi，然后刷新缓冲区，不附加任何额外的字符串</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hi!\"</span>&lt;&lt;ends;   <span class=\"comment\">//输出hi和一个空字符，然后刷新缓冲区</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h2><p>头文件<strong>fstream</strong>定义了三个类型来支持文件IO：<strong>ifstream</strong>从给定文件读取数据，<strong>ofstream</strong>向一个给定文件写入数据，以及<strong>fstream</strong>可以读写文件。</p>\n<p>这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样，特别是，我们可以用IO运算符（&lt;&lt;和&gt;&gt;）来读写文件，可以用getline从一个ifstream读取数据。</p>\n<p><strong>代码示例：</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">readfile</span><span class=\"params\">(<span class=\"built_in\">string</span> filename,<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; svec)</span></span>&#123;   <span class=\"comment\">//从文件中读取数据到svec中</span></div><div class=\"line\">    ifstream input;   <span class=\"comment\">//从一个给定文件读取数据</span></div><div class=\"line\">    input.open(filename);</div><div class=\"line\">    <span class=\"keyword\">if</span>(input)&#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">        string line;</span></div><div class=\"line\"><span class=\"comment\">        while(getline(input,line))&#123;   //按行读取文件，input当成输入流cin处理就行</span></div><div class=\"line\"><span class=\"comment\">            svec.push_back(line);</span></div><div class=\"line\"><span class=\"comment\">        &#125;*/</span></div><div class=\"line\">        <span class=\"built_in\">string</span> word;</div><div class=\"line\">        <span class=\"keyword\">while</span>(input&gt;&gt;word)&#123;   <span class=\"comment\">//按单词读取文件，input当成输入流cin处理就行</span></div><div class=\"line\">            svec.push_back(word);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"couldn't open: \"</span> + filename&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    input.close();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">writefile</span><span class=\"params\">(<span class=\"built_in\">string</span> filename,<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; svec)</span></span>&#123;   <span class=\"comment\">//从文件中读取数据到svec中</span></div><div class=\"line\">    ofstream out;  <span class=\"comment\">//ofstream向一个给定文件写入数据</span></div><div class=\"line\">    out.open(filename,ofstream::app);  <span class=\"comment\">//不清空文件，末尾追加写入</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(out)&#123;</div><div class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> word : svec)&#123;</div><div class=\"line\">           out&lt;&lt;word&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//输出流，也就将word写入到文件中</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"couldn't open: \"</span> + filename&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    out.close();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> filename = <span class=\"string\">\"STRING.txt\"</span>;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec;</div><div class=\"line\">    readfile(filename,svec);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> line : svec)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;line&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//从svec写入数据到文件中</span></div><div class=\"line\">    filename = <span class=\"string\">\"WRITE.txt\"</span>;</div><div class=\"line\">    writefile(filename,svec);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"文件模式\"><a href=\"#文件模式\" class=\"headerlink\" title=\"文件模式\"></a>文件模式</h2><p>每个流都有一个关联的文件模式（mode），用来指出如何使用文件。具体的mode有哪些呢？<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">in       以读方式打开</div><div class=\"line\">out      以写方式打开</div><div class=\"line\">app      每次写操作前均定位到文件末尾（从文件尾开始写，不覆盖前面写的）</div><div class=\"line\">ate      打开文件后立即定位到文件末尾</div><div class=\"line\">trunc     截断文件</div><div class=\"line\">binary    以二进制方式进行IO</div></pre></td></tr></table></figure></p>\n<p>不管用哪种方式打开文件，我们都可以指定文件模式，调用open显式打开或者用一个文件名初始化文件流来隐式打开文件都可指定文件模式。<br>但是上述模式间有限制关系：</p>\n<ul>\n<li>只可以对ifstream和ifstream对象设定in模式</li>\n<li>只可以对ofstream和fstream对象设定out模式</li>\n<li>只有当out被设定时才能设定trunc模式</li>\n<li>只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式打开</li>\n<li>默认情况下，即使我们没有指定trunc模式，以out模式打开的文件也会被截断。为了保留以out模式打开的文件内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。</li>\n</ul>\n<p>每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。<strong>与ifstream关联的文件默认以in模式打开，与ofstream关联的文件默认以out模式打开，与fstream关联的文件默认以in和out模式打开。</strong></p>\n<p>此外，有两点需要特别注意：</p>\n<p><strong>1：以out模式打开文件会丢弃已有数据</strong></p>\n<p>默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止清空文件的方法是同时指定app模式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这三条语句中，file都将被截断</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>)</span></span>;     <span class=\"comment\">// 隐含以输出模式打开文件并截断文件</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::out)</span></span>;   <span class=\"comment\">// 隐含地截断文件</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::out|ofstream::trunc)</span></span>; </div><div class=\"line\"><span class=\"comment\">//这两条语句中，文件内容将被保存</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">out</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::app)</span></span>;     <span class=\"comment\">//隐含为输出模式</span></div><div class=\"line\"><span class=\"function\">ofstream <span class=\"title\">app</span><span class=\"params\">(<span class=\"string\">\"file\"</span>,ofstream::out|ofstream::app)</span></span>;</div></pre></td></tr></table></figure>\n<p><strong>小结：保留被ofstream打开的文件中内容的唯一方法是显示指定app或in模式。</strong></p>\n<p><strong>2 ：每次调用open时都会确定文件模式</strong></p>\n<p>对于一个给个流，每当打开文件时，都可以改变其文件模式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ofstream  out;         <span class=\"comment\">// 未指定文件打开模式</span></div><div class=\"line\">out.open(<span class=\"string\">\"file\"</span>);      <span class=\"comment\">// 隐含设置为输出和截断</span></div><div class=\"line\">out.close();          <span class=\"comment\">// 与out绑定的名为file的文件被关闭，以便我们将对象out用于其他文件</span></div><div class=\"line\">out.open(<span class=\"string\">\"preFile\"</span>,ofstream::app);      <span class=\"comment\">//模式为输出和文件尾追加</span></div><div class=\"line\">out.close();</div></pre></td></tr></table></figure>\n<p>名为file的文件内容将被清空，名为preFile的文件中已有的数据将都被保存。</p>\n<p><strong>小结：每次打开文件时，都要设置文件模式，可以是显式的设置，也可以是隐式的设置。当文件未指定模式时，都是使用默认值。</strong>  </p>\n<h1 id=\"String流\"><a href=\"#String流\" class=\"headerlink\" title=\"String流\"></a>String流</h1><p>sstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。</p>\n<p><strong>istringstream从string读取数据，ostreamstream向string写入数据，而头文件stringstream既可以读数据也可向string写数据。</strong></p>\n<p>头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">stringstream</span>特有的操作</div><div class=\"line\">sstream strm； strm是一个未绑定的<span class=\"built_in\">stringstream</span>对象。sstream是头文件sstream中定义的一个类型</div><div class=\"line\"><span class=\"function\">sstream <span class=\"title\">strm</span><span class=\"params\">(s)</span></span>; strm是一个sstream对象，保存strings的一个拷贝。此构造函数是<span class=\"keyword\">explicit</span>的</div><div class=\"line\">strm.str（） 返回strm所保存的<span class=\"built_in\">string</span>类型</div><div class=\"line\">strm.str(s) 将<span class=\"built_in\">string</span>的s拷贝到strm中，返回<span class=\"keyword\">void</span></div></pre></td></tr></table></figure>\n<h2 id=\"使用istringstream\"><a href=\"#使用istringstream\" class=\"headerlink\" title=\"使用istringstream\"></a>使用istringstream</h2><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的某个单词时，通常可以使用istringstream。</p>\n<p>考虑如下文件，列出了一些人和他们的电话号码（电话号码多选）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">morgan 20155555 685522</div><div class=\"line\">drew 5524566</div><div class=\"line\">lee 425422 542122 55444222</div></pre></td></tr></table></figure></p>\n<p>我们定义一个简单的类来描述输入数据：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PersonInfo</span>&#123;</span></div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; phones;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们从文本中读入输入数据，并将输入数据写入到vector<personinfo>容器中：</personinfo></p>\n<p>以下是完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"comment\">//成员默认公有</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PersonInfo</span>&#123;</span></div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; phones;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> filename = <span class=\"string\">\"Info.txt\"</span>;</div><div class=\"line\">    ifstream input;   <span class=\"comment\">//从文件中读取数据</span></div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;PersonInfo&gt; Pvec;</div><div class=\"line\">    input.open(filename);</div><div class=\"line\">    <span class=\"keyword\">if</span>(input)&#123;</div><div class=\"line\">        <span class=\"built_in\">string</span> line;</div><div class=\"line\">        <span class=\"built_in\">string</span> phone;</div><div class=\"line\">        <span class=\"keyword\">while</span>(getline(input,line))&#123;</div><div class=\"line\">            PersonInfo info;</div><div class=\"line\">            <span class=\"function\"><span class=\"built_in\">istringstream</span> <span class=\"title\">record</span><span class=\"params\">(line)</span></span>;   <span class=\"comment\">//将记录绑定到刚读入的行</span></div><div class=\"line\">            record&gt;&gt;info.name;     <span class=\"comment\">//读取名字</span></div><div class=\"line\">            <span class=\"keyword\">while</span>(record&gt;&gt;phone)&#123;  <span class=\"comment\">//读取电话号码</span></div><div class=\"line\">                info.phones.push_back(phone);</div><div class=\"line\">            &#125;</div><div class=\"line\">            Pvec.push_back(info);   <span class=\"comment\">//将记录追加到people末尾</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"couldn't not open file\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    input.close();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> people : Pvec)&#123;   <span class=\"comment\">//输出</span></div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;people.name;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> phone : people.phones)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;phone;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用ostringstream\"><a href=\"#使用ostringstream\" class=\"headerlink\" title=\"使用ostringstream\"></a>使用ostringstream</h2><p><strong><br>当我们逐步构造输出，希望最后一起打印是，ostringstream是很有用的。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">ostringstream</span> badNums;</div><div class=\"line\"><span class=\"built_in\">string</span> num = <span class=\"string\">\"123\"</span>;</div><div class=\"line\"><span class=\"built_in\">string</span> name = <span class=\"string\">\"xin\"</span>;</div><div class=\"line\">badNums&lt;&lt;num&lt;&lt;name;     <span class=\"comment\">//将数的字符串的形式存入badNums</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;badNums.str()&lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//输出123xin</span></div></pre></td></tr></table></figure>\n<p><strong>输出badNums.str()!</strong></p>"},{"title":"github Pages + Hexo搭建个人博客（一）  初级篇","date":"2017-08-06T13:59:00.000Z","update":null,"comments":1,"_content":"# 一、前言\n之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！\n<!--more-->\n这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。\n\n今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！\n\n\n# 二、环境准备\n## 1. 注册github账号\n这个就不多说了，账号注册好后，登陆，在首页右边有一个 **+** 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。\n## 2. 安装Git\n我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是**图形化界面（GUI）**,另外一种是通过**命令行**。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， **GitHub和Git Shell**,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！\n\nGithub for Windows: [点击下载](http://download.csdn.net/detail/devsplash/9666012)\n\n下载安装完后，桌面上生成**GitHub和Git Shell**两个图标，然后点击**GitHub**图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。\n\nGithub for Windows 安装配置使用教程: [参考](http://blog.csdn.net/chenxun_2010/article/details/43670651)\n\n## 3. 安装Node.js\n\n安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。\n\n点击进入[Node.js官网](https://nodejs.org/en/)\n\n我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。\n\n## 4. 安装Hexo\n\n以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。\n\n打开终端，输入：\n\n``` bash\nnpm install -g hexo-cli\n```\n\n如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。\n\n``` bash\nnpm config set registry https://registry.npm.taobao.org\n```\n\n安装好Hexo以后，在终端输入：\n\n``` bash\nhexo\n```\n\n若出现下图，说明hexo安装成功：\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170806141617.png)\n\n# 三、使用Hexo建站\n\n## 1. 初始化博客\n\n新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。\n\n``` bash\nhexo init [folder]\n```\n\n接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包\n\n``` bash\nnpm install\n```\n\n## 2. 配置\n\n网站的主配置文件为hexo根目录下的**_config.yml**文件：\n\n默认配置如下：\n\n{% codeblock %}\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Hexo\nsubtitle:\ndescription:\nauthor: John Doe\nlanguage:\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n  \n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n  \n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: landscape\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type:\n\n{% endcodeblock %}\n\n这些配置项所代表的意思可以参考Hexo中文网：[_config.yml配置](https://hexo.io/zh-cn/docs/configuration.html) ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。\n\n### 1). 修改网站相关信息\n\n``` bash\ntitle: 新日三少的博客 \nsubtitle: Big big pig   \ndescription: Love Coding,Enjoy Life\nauthor: 新日三少\nlanguage: zh-CN      #themes主题文件夹下的languages下面有很多语言可选\ntimezone: Asia/Shanghai\n```\n\n**注意**：每一项的填写，其:后面都要保留一个空格，下同。\n\n### 2). 配置统一资源定位符（个人域名）\n\n``` bash\nurl: http://www.wangxinri.cn\n```\n\n对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。\n如无个人域名，无需修改这一项。\n\n### 3). 配置部署\n\n``` bash\ndeploy: \n  type: git\n  repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git\n  branch: master\n```\n其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到：\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170806151918.png)\n\n## 3.  本地发布博客\n\n接下来，在网站中建立第一篇文章，**打开终端，进入到博客文件夹根目录**，这里是E:Github/hexo，然后输入\n\n``` bash\nhexo new \"文章标题\"\n```\n\n我们可以在本地博客文件夹source->_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。\n\nMarkdownPad2：[点击下载](http://download.csdn.net/detail/rentongtmd/8333707)\n\nMarkdown语法：[Markdown中文网](http://www.markdown.cn/)\n\n为了能够使Hexo部署到GitHub上，需要安装一个插件：\n\n``` bash\nnpm install hexo-deployer-git --save\n```\n\n接下来,我们进行本地发布：\n``` bash\nhexo generate\nhexo server      \n```\n\n执行完后，打开浏览器，输入：\n``` bash\nhttp://localhost:4000/\n```\n\n我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。\n![](http://ou6yob3zd.bkt.clouddn.com/20170806161241.png)\n\n## 4. 发布博客至github仓库\n\n但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。\n\n打开终端，进入到博客文件夹根目录，这里还是**E:Github/hexo**，执行如下命令：\n\n``` bash\nhexo generate\nhexo deploy      \n```\n\n输入我们的网址：[xinrisanshao.github.io](http://xinrisanshao.github.io) ,即可访问博客了。\n\n此时查看github中的仓库，发现我们博客文件夹根目录中的**public文件夹**里面的文件已经发布到仓库中了。\n\n此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。\n\n好累啊，先休息下，果然还是写博客最累啊。","source":"_posts/github Pages + Hexo搭建个人博客（一）  初级篇.md","raw":"---\ntitle: github Pages + Hexo搭建个人博客（一）  初级篇\ndate: 2017-08-06 21:59:00\nupdate: \ntags: [hexo,github]\ncategories: hexo\ncomments: true\n---\n# 一、前言\n之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！\n<!--more-->\n这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。\n\n今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！\n\n\n# 二、环境准备\n## 1. 注册github账号\n这个就不多说了，账号注册好后，登陆，在首页右边有一个 **+** 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。\n## 2. 安装Git\n我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是**图形化界面（GUI）**,另外一种是通过**命令行**。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， **GitHub和Git Shell**,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！\n\nGithub for Windows: [点击下载](http://download.csdn.net/detail/devsplash/9666012)\n\n下载安装完后，桌面上生成**GitHub和Git Shell**两个图标，然后点击**GitHub**图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。\n\nGithub for Windows 安装配置使用教程: [参考](http://blog.csdn.net/chenxun_2010/article/details/43670651)\n\n## 3. 安装Node.js\n\n安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。\n\n点击进入[Node.js官网](https://nodejs.org/en/)\n\n我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。\n\n## 4. 安装Hexo\n\n以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。\n\n打开终端，输入：\n\n``` bash\nnpm install -g hexo-cli\n```\n\n如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。\n\n``` bash\nnpm config set registry https://registry.npm.taobao.org\n```\n\n安装好Hexo以后，在终端输入：\n\n``` bash\nhexo\n```\n\n若出现下图，说明hexo安装成功：\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170806141617.png)\n\n# 三、使用Hexo建站\n\n## 1. 初始化博客\n\n新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。\n\n``` bash\nhexo init [folder]\n```\n\n接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包\n\n``` bash\nnpm install\n```\n\n## 2. 配置\n\n网站的主配置文件为hexo根目录下的**_config.yml**文件：\n\n默认配置如下：\n\n{% codeblock %}\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Hexo\nsubtitle:\ndescription:\nauthor: John Doe\nlanguage:\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n  \n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n  \n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: landscape\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type:\n\n{% endcodeblock %}\n\n这些配置项所代表的意思可以参考Hexo中文网：[_config.yml配置](https://hexo.io/zh-cn/docs/configuration.html) ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。\n\n### 1). 修改网站相关信息\n\n``` bash\ntitle: 新日三少的博客 \nsubtitle: Big big pig   \ndescription: Love Coding,Enjoy Life\nauthor: 新日三少\nlanguage: zh-CN      #themes主题文件夹下的languages下面有很多语言可选\ntimezone: Asia/Shanghai\n```\n\n**注意**：每一项的填写，其:后面都要保留一个空格，下同。\n\n### 2). 配置统一资源定位符（个人域名）\n\n``` bash\nurl: http://www.wangxinri.cn\n```\n\n对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。\n如无个人域名，无需修改这一项。\n\n### 3). 配置部署\n\n``` bash\ndeploy: \n  type: git\n  repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git\n  branch: master\n```\n其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到：\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170806151918.png)\n\n## 3.  本地发布博客\n\n接下来，在网站中建立第一篇文章，**打开终端，进入到博客文件夹根目录**，这里是E:Github/hexo，然后输入\n\n``` bash\nhexo new \"文章标题\"\n```\n\n我们可以在本地博客文件夹source->_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。\n\nMarkdownPad2：[点击下载](http://download.csdn.net/detail/rentongtmd/8333707)\n\nMarkdown语法：[Markdown中文网](http://www.markdown.cn/)\n\n为了能够使Hexo部署到GitHub上，需要安装一个插件：\n\n``` bash\nnpm install hexo-deployer-git --save\n```\n\n接下来,我们进行本地发布：\n``` bash\nhexo generate\nhexo server      \n```\n\n执行完后，打开浏览器，输入：\n``` bash\nhttp://localhost:4000/\n```\n\n我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。\n![](http://ou6yob3zd.bkt.clouddn.com/20170806161241.png)\n\n## 4. 发布博客至github仓库\n\n但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。\n\n打开终端，进入到博客文件夹根目录，这里还是**E:Github/hexo**，执行如下命令：\n\n``` bash\nhexo generate\nhexo deploy      \n```\n\n输入我们的网址：[xinrisanshao.github.io](http://xinrisanshao.github.io) ,即可访问博客了。\n\n此时查看github中的仓库，发现我们博客文件夹根目录中的**public文件夹**里面的文件已经发布到仓库中了。\n\n此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。\n\n好累啊，先休息下，果然还是写博客最累啊。","slug":"github Pages + Hexo搭建个人博客（一）  初级篇","published":1,"updated":"2018-01-16T03:08:38.007Z","layout":"post","photos":[],"link":"","_id":"cjcj3yifw0001jgc9i9owkvzn","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！<br><a id=\"more\"></a><br>这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。</p>\n<p>今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！</p>\n<h1 id=\"二、环境准备\"><a href=\"#二、环境准备\" class=\"headerlink\" title=\"二、环境准备\"></a>二、环境准备</h1><h2 id=\"1-注册github账号\"><a href=\"#1-注册github账号\" class=\"headerlink\" title=\"1. 注册github账号\"></a>1. 注册github账号</h2><p>这个就不多说了，账号注册好后，登陆，在首页右边有一个 <strong>+</strong> 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。</p>\n<h2 id=\"2-安装Git\"><a href=\"#2-安装Git\" class=\"headerlink\" title=\"2. 安装Git\"></a>2. 安装Git</h2><p>我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是<strong>图形化界面（GUI）</strong>,另外一种是通过<strong>命令行</strong>。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， <strong>GitHub和Git Shell</strong>,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！</p>\n<p>Github for Windows: <a href=\"http://download.csdn.net/detail/devsplash/9666012\" target=\"_blank\" rel=\"external\">点击下载</a></p>\n<p>下载安装完后，桌面上生成<strong>GitHub和Git Shell</strong>两个图标，然后点击<strong>GitHub</strong>图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。</p>\n<p>Github for Windows 安装配置使用教程: <a href=\"http://blog.csdn.net/chenxun_2010/article/details/43670651\" target=\"_blank\" rel=\"external\">参考</a></p>\n<h2 id=\"3-安装Node-js\"><a href=\"#3-安装Node-js\" class=\"headerlink\" title=\"3. 安装Node.js\"></a>3. 安装Node.js</h2><p>安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。</p>\n<p>点击进入<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js官网</a></p>\n<p>我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。</p>\n<h2 id=\"4-安装Hexo\"><a href=\"#4-安装Hexo\" class=\"headerlink\" title=\"4. 安装Hexo\"></a>4. 安装Hexo</h2><p>以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。</p>\n<p>打开终端，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</div></pre></td></tr></table></figure>\n<p>安装好Hexo以后，在终端输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo</div></pre></td></tr></table></figure>\n<p>若出现下图，说明hexo安装成功：</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170806141617.png\" alt=\"\"></p>\n<h1 id=\"三、使用Hexo建站\"><a href=\"#三、使用Hexo建站\" class=\"headerlink\" title=\"三、使用Hexo建站\"></a>三、使用Hexo建站</h1><h2 id=\"1-初始化博客\"><a href=\"#1-初始化博客\" class=\"headerlink\" title=\"1. 初始化博客\"></a>1. 初始化博客</h2><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init [folder]</div></pre></td></tr></table></figure>\n<p>接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><p>网站的主配置文件为hexo根目录下的<strong>_config.yml</strong>文件：</p>\n<p>默认配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: https://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: Hexo</div><div class=\"line\">subtitle:</div><div class=\"line\">description:</div><div class=\"line\">author: John Doe</div><div class=\"line\">language:</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: false</div><div class=\"line\">  tab_replace:</div><div class=\"line\">  </div><div class=\"line\"># Home page setting</div><div class=\"line\"># path: Root path for your blogs index page. (default = &apos;&apos;)</div><div class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</div><div class=\"line\"># order_by: Posts order. (Order by date descending by default)</div><div class=\"line\">index_generator:</div><div class=\"line\">  path: &apos;&apos;</div><div class=\"line\">  per_page: 10</div><div class=\"line\">  order_by: -date</div><div class=\"line\">  </div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 10</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: https://hexo.io/plugins/</div><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: landscape</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type:</div><div class=\"line\"></div></pre></td></tr></table></figure>\n<p>这些配置项所代表的意思可以参考Hexo中文网：<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"external\">_config.yml配置</a> ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。</p>\n<h3 id=\"1-修改网站相关信息\"><a href=\"#1-修改网站相关信息\" class=\"headerlink\" title=\"1). 修改网站相关信息\"></a>1). 修改网站相关信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: 新日三少的博客 </div><div class=\"line\">subtitle: Big big pig   </div><div class=\"line\">description: Love Coding,Enjoy Life</div><div class=\"line\">author: 新日三少</div><div class=\"line\">language: zh-CN      <span class=\"comment\">#themes主题文件夹下的languages下面有很多语言可选</span></div><div class=\"line\">timezone: Asia/Shanghai</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>：每一项的填写，其:后面都要保留一个空格，下同。</p>\n<h3 id=\"2-配置统一资源定位符（个人域名）\"><a href=\"#2-配置统一资源定位符（个人域名）\" class=\"headerlink\" title=\"2). 配置统一资源定位符（个人域名）\"></a>2). 配置统一资源定位符（个人域名）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">url: http://www.wangxinri.cn</div></pre></td></tr></table></figure>\n<p>对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。<br>如无个人域名，无需修改这一项。</p>\n<h3 id=\"3-配置部署\"><a href=\"#3-配置部署\" class=\"headerlink\" title=\"3). 配置部署\"></a>3). 配置部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy: </div><div class=\"line\">  <span class=\"built_in\">type</span>: git</div><div class=\"line\">  repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到：</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170806151918.png\" alt=\"\"></p>\n<h2 id=\"3-本地发布博客\"><a href=\"#3-本地发布博客\" class=\"headerlink\" title=\"3.  本地发布博客\"></a>3.  本地发布博客</h2><p>接下来，在网站中建立第一篇文章，<strong>打开终端，进入到博客文件夹根目录</strong>，这里是E:Github/hexo，然后输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new <span class=\"string\">\"文章标题\"</span></div></pre></td></tr></table></figure>\n<p>我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。</p>\n<p>MarkdownPad2：<a href=\"http://download.csdn.net/detail/rentongtmd/8333707\" target=\"_blank\" rel=\"external\">点击下载</a></p>\n<p>Markdown语法：<a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"external\">Markdown中文网</a></p>\n<p>为了能够使Hexo部署到GitHub上，需要安装一个插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>接下来,我们进行本地发布：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>执行完后，打开浏览器，输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:4000/</div></pre></td></tr></table></figure></p>\n<p>我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。<br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170806161241.png\" alt=\"\"></p>\n<h2 id=\"4-发布博客至github仓库\"><a href=\"#4-发布博客至github仓库\" class=\"headerlink\" title=\"4. 发布博客至github仓库\"></a>4. 发布博客至github仓库</h2><p>但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。</p>\n<p>打开终端，进入到博客文件夹根目录，这里还是<strong>E:Github/hexo</strong>，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div></pre></td></tr></table></figure>\n<p>输入我们的网址：<a href=\"http://xinrisanshao.github.io\" target=\"_blank\" rel=\"external\">xinrisanshao.github.io</a> ,即可访问博客了。</p>\n<p>此时查看github中的仓库，发现我们博客文件夹根目录中的<strong>public文件夹</strong>里面的文件已经发布到仓库中了。</p>\n<p>此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。</p>\n<p>好累啊，先休息下，果然还是写博客最累啊。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！<br>","more":"<br>这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。</p>\n<p>今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！</p>\n<h1 id=\"二、环境准备\"><a href=\"#二、环境准备\" class=\"headerlink\" title=\"二、环境准备\"></a>二、环境准备</h1><h2 id=\"1-注册github账号\"><a href=\"#1-注册github账号\" class=\"headerlink\" title=\"1. 注册github账号\"></a>1. 注册github账号</h2><p>这个就不多说了，账号注册好后，登陆，在首页右边有一个 <strong>+</strong> 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。</p>\n<h2 id=\"2-安装Git\"><a href=\"#2-安装Git\" class=\"headerlink\" title=\"2. 安装Git\"></a>2. 安装Git</h2><p>我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是<strong>图形化界面（GUI）</strong>,另外一种是通过<strong>命令行</strong>。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， <strong>GitHub和Git Shell</strong>,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！</p>\n<p>Github for Windows: <a href=\"http://download.csdn.net/detail/devsplash/9666012\" target=\"_blank\" rel=\"external\">点击下载</a></p>\n<p>下载安装完后，桌面上生成<strong>GitHub和Git Shell</strong>两个图标，然后点击<strong>GitHub</strong>图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。</p>\n<p>Github for Windows 安装配置使用教程: <a href=\"http://blog.csdn.net/chenxun_2010/article/details/43670651\" target=\"_blank\" rel=\"external\">参考</a></p>\n<h2 id=\"3-安装Node-js\"><a href=\"#3-安装Node-js\" class=\"headerlink\" title=\"3. 安装Node.js\"></a>3. 安装Node.js</h2><p>安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。</p>\n<p>点击进入<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js官网</a></p>\n<p>我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。</p>\n<h2 id=\"4-安装Hexo\"><a href=\"#4-安装Hexo\" class=\"headerlink\" title=\"4. 安装Hexo\"></a>4. 安装Hexo</h2><p>以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。</p>\n<p>打开终端，输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</div></pre></td></tr></table></figure>\n<p>安装好Hexo以后，在终端输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo</div></pre></td></tr></table></figure>\n<p>若出现下图，说明hexo安装成功：</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170806141617.png\" alt=\"\"></p>\n<h1 id=\"三、使用Hexo建站\"><a href=\"#三、使用Hexo建站\" class=\"headerlink\" title=\"三、使用Hexo建站\"></a>三、使用Hexo建站</h1><h2 id=\"1-初始化博客\"><a href=\"#1-初始化博客\" class=\"headerlink\" title=\"1. 初始化博客\"></a>1. 初始化博客</h2><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init [folder]</div></pre></td></tr></table></figure>\n<p>接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><p>网站的主配置文件为hexo根目录下的<strong>_config.yml</strong>文件：</p>\n<p>默认配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: https://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: Hexo</div><div class=\"line\">subtitle:</div><div class=\"line\">description:</div><div class=\"line\">author: John Doe</div><div class=\"line\">language:</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: false</div><div class=\"line\">  tab_replace:</div><div class=\"line\">  </div><div class=\"line\"># Home page setting</div><div class=\"line\"># path: Root path for your blogs index page. (default = &apos;&apos;)</div><div class=\"line\"># per_page: Posts displayed per page. (0 = disable pagination)</div><div class=\"line\"># order_by: Posts order. (Order by date descending by default)</div><div class=\"line\">index_generator:</div><div class=\"line\">  path: &apos;&apos;</div><div class=\"line\">  per_page: 10</div><div class=\"line\">  order_by: -date</div><div class=\"line\">  </div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 10</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: https://hexo.io/plugins/</div><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: landscape</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type:</div><div class=\"line\"></div></pre></td></tr></table></figure>\n<p>这些配置项所代表的意思可以参考Hexo中文网：<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"external\">_config.yml配置</a> ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。</p>\n<h3 id=\"1-修改网站相关信息\"><a href=\"#1-修改网站相关信息\" class=\"headerlink\" title=\"1). 修改网站相关信息\"></a>1). 修改网站相关信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: 新日三少的博客 </div><div class=\"line\">subtitle: Big big pig   </div><div class=\"line\">description: Love Coding,Enjoy Life</div><div class=\"line\">author: 新日三少</div><div class=\"line\">language: zh-CN      <span class=\"comment\">#themes主题文件夹下的languages下面有很多语言可选</span></div><div class=\"line\">timezone: Asia/Shanghai</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>：每一项的填写，其:后面都要保留一个空格，下同。</p>\n<h3 id=\"2-配置统一资源定位符（个人域名）\"><a href=\"#2-配置统一资源定位符（个人域名）\" class=\"headerlink\" title=\"2). 配置统一资源定位符（个人域名）\"></a>2). 配置统一资源定位符（个人域名）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">url: http://www.wangxinri.cn</div></pre></td></tr></table></figure>\n<p>对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。<br>如无个人域名，无需修改这一项。</p>\n<h3 id=\"3-配置部署\"><a href=\"#3-配置部署\" class=\"headerlink\" title=\"3). 配置部署\"></a>3). 配置部署</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy: </div><div class=\"line\">  <span class=\"built_in\">type</span>: git</div><div class=\"line\">  repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到：</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170806151918.png\" alt=\"\"></p>\n<h2 id=\"3-本地发布博客\"><a href=\"#3-本地发布博客\" class=\"headerlink\" title=\"3.  本地发布博客\"></a>3.  本地发布博客</h2><p>接下来，在网站中建立第一篇文章，<strong>打开终端，进入到博客文件夹根目录</strong>，这里是E:Github/hexo，然后输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new <span class=\"string\">\"文章标题\"</span></div></pre></td></tr></table></figure>\n<p>我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。</p>\n<p>MarkdownPad2：<a href=\"http://download.csdn.net/detail/rentongtmd/8333707\" target=\"_blank\" rel=\"external\">点击下载</a></p>\n<p>Markdown语法：<a href=\"http://www.markdown.cn/\" target=\"_blank\" rel=\"external\">Markdown中文网</a></p>\n<p>为了能够使Hexo部署到GitHub上，需要安装一个插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>接下来,我们进行本地发布：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>执行完后，打开浏览器，输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:4000/</div></pre></td></tr></table></figure></p>\n<p>我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。<br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170806161241.png\" alt=\"\"></p>\n<h2 id=\"4-发布博客至github仓库\"><a href=\"#4-发布博客至github仓库\" class=\"headerlink\" title=\"4. 发布博客至github仓库\"></a>4. 发布博客至github仓库</h2><p>但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。</p>\n<p>打开终端，进入到博客文件夹根目录，这里还是<strong>E:Github/hexo</strong>，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div></pre></td></tr></table></figure>\n<p>输入我们的网址：<a href=\"http://xinrisanshao.github.io\" target=\"_blank\" rel=\"external\">xinrisanshao.github.io</a> ,即可访问博客了。</p>\n<p>此时查看github中的仓库，发现我们博客文件夹根目录中的<strong>public文件夹</strong>里面的文件已经发布到仓库中了。</p>\n<p>此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。</p>\n<p>好累啊，先休息下，果然还是写博客最累啊。</p>"},{"title":"github Pages + Hexo搭建个人博客（二）  提升篇","date":"2017-08-07T04:59:25.000Z","update":null,"comments":1,"_content":"# 一、前言\n在之前的**初级篇**中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。\n<!--more-->\n# 二、更换主题\n在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。\n\n在Hexo中有两份主要的配置文件，其名称都是**_config.yml**。其中，一份位于站点根目录下（此处为G:\\GitHub\\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。\n\n为了描述方便，在以下说明中，将前者称为**站点配置文件**，后者称为**主题配置文件**。 \n\n## 1. 安装NexT\nHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 \n### 1) 下载主题\n如果你熟悉Git，建议你使用**克隆最新版本**的方式，之后的更新可以通过**git pull**来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了）\n\n在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：\n``` bash\ncd G:\\GitHub\\hexo\ngit clone https://github.com/iissnan/hexo-theme-next themes/next  #后面意思是clone到该目录下themes/next文件夹中\n```\n### 2) 启用主题\n与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开**站点配置文件**，找到**theme**字段，并将其值更改为**next**。 \n\n``` bash\ntheme: next\n```\n此时我们在**主题配置文件**中设置语言。修改**language**字段。在主题的languages文件夹中选择语言，此处目录为G:\\GitHub\\hexo\\themes\\next\\languages 。\n\n``` bash\nlanguage: zh-Hans   #选择汉语，选择其他语言填写其他值即可\n```\n\n到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 \n\n### 3) 验证主题\n\n进入到博客文件夹根目录，此处为G:\\GitHub\\hexo，执行如下命令：\n\n``` bash\nhexo clean  #更换主题，最好先清除Hexo缓存\nhexo generate  #生成静态页面\nhexo server   # hexo server -p **** 更换默认4000端口为****\n```\n\n此时即可使用浏览器访问 http://localhost:4000。\n\n检查站点是否正确运行，如长时间访问不了，更改端口。\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170808201948.png)\n\n现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。\n\n# 三、主题设定\n\nNexT官网和网上资料非常丰富，就不细说了，参考如下：\n\n官方参考：[NexT使用文档](http://theme-next.iissnan.com/getting-started.html)\n\n网上资源：[hexo的next主题个性化教程：打造炫酷网站](http://blog.csdn.net/qq_33699981/article/details/72716951)\n\n**补充几点：**\n## 1. 添加评论功能\n我选择的是**来比力**，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。\n\n编辑主题配置文件， 编辑 livere_uid 字段，设置如下：\n\n``` bash\nlivere_uid: #your livere_uid\n```\n\n## 2. 修改背景图片\n\n首先找到一个背景图片放到 hexo（hexo工程文件）-> themes -> next -> source -> images 的路径下；\n\n然后进入hexo（hexo工程文件）-> themes -> next -> source -> css -> _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。\n\n``` bash\n// Custom styles.\nbody {\n  background:url(/images/background.jpeg);\n  background-attachment: fixed;   #固定背景图，使得不随页面移动\n}\n```\n\n## 3. 修改博客内容宽度\nPisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加\n\n``` bash\n$main-desktop = 1200px \n$content-desktop = 900px\n```\n\n可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。\n\n参考：[感觉浏览器留白太多，代码块看起来比较麻烦](https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848)\n\n## 4. 添加菜单栏\n在个人网站根目录下使用hexo命令hexo new page \"photo\" 就直接创建了.\\Hexo\\source\\photo\\index.md\n文件。\n\n在主题配置文件_config.yml中找到meun:字段，添加**photo**字段\n```xml\nmenu:\n  home: /\n  categories: /categories/\n  tags: /tags/\n  archives: /archives/\n  photo: /photo/\n  about: /about/\n  #sitemap: /sitemap.xml\n  #commonweal: /404.html\n```\n给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加**photo**字段：\n\n```xml\nmenu_icons:\n  enable: true\n  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome\n  home: home\n  about: user\n  categories: th\n  schedule: calendar\n  tags: tags\n  archives: archive\n  sitemap: sitemap\n  commonweal: heartbeat\n  photo: photo\n\n```\n\n在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为**photo**：[点击选择图标](http://fontawesome.io/icons/)\n\n将网站中的**photo**字段显示为中文**照片**字段\n\n在\\themes\\next\\languages\\zh-Hans.yml添加：\n\n```xml\nmenu:\n  home: 首页\n  archives: 归档\n  categories: 分类\n  tags: 标签\n  about: 关于\n  search: 搜索\n  schedule: 日程表\n  sitemap: 站点地图\n  commonweal: 公益404\n  photo: 照片\n\n```\n\n## 5. 调整首页**文档摘要**和**阅读全文**按钮高度并删除居中灰色线条\n\n1.调整文档摘要的高度\n\n在/next/source/css/_common/components/post/post-meta.styl中修改**margin**的值\n\n```css\n.posts-expand .post-meta {\n  margin: 3px 0 10px 0;\n  color: $grey-dark;\n```\n\n2.调整阅读全文按钮高度\n\n在\\next\\source\\css\\_common\\components\\post\\post-button.styl中修改**margin-top**的值\n\n```css\n.post-button {\n  margin-top: 10px;\n  .btn {\n```\n\n3.去除首页文档与文档之间居中灰色的线条\n\n在\\next\\source\\css\\_common\\components\\post\\post-eof.styl中注释掉如下样式\n\n```css\n.posts-expand {\n  .post-eof {\n  /*\n    display: block;\n    margin: $post-eof-margin-top auto $post-eof-margin-bottom;\n    width: 8%;\n    height: 1px;\n    background: $grey-light;\n    text-align: center;\n  */\n  }\n}\n```\n\n最终效果如下：\n![](http://ou6yob3zd.bkt.clouddn.com/20170904100438.png)\n\n## 6. 归档页博文列表高度调整\n\n在\\next\\source\\css\\_common\\components\\post\\post-collapse.styl中修改.post\n\n```css\n  .post { margin: 0px 0; }\n```\n\n\n到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。\n\n# 四、博客管理维护\n\n## 1. 概述\n\nHexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。\n\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。\n\n**注：** .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：\n``` bash\n.deploy*/    #只忽略上传.deploy*/开头的文件\n```\n\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。\n\n所以，我利用了分支！！！\n\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n\n下面以我的博客作为例子详细地讲述。\n\n## 2. 博客搭建流程\n\n  1.创建仓库，xinrisanshao.github.io；\n\n  2.创建两个分支：master 与 hexo；\n\n  3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n\n  4.使用如下命令拷贝仓库\n\n``` bash\ngit clone https://github.com/xinrisanshao/xinrisanshao.github.io.git \n```\n  \n  5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm  \n   install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n\n  6.修改_config.yml中的deploy参数，分支应为master；\n  \n  7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）；\n\n  8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。\n\n这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。\n\n**注：**流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\\xinrisanshao.github.io\\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。\n\n## 3. 博客管理流程\n\n### 1. 编辑与修改博客\n\n在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：\n\n1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；\n\n2.然后才执行hexo generate -d发布网站到master分支上。\n\n虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。\n\n### 2. 本地资料丢失\n当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n1.首先安装Git，Node.js和Hexo。\n\n2.使用下面命令拷贝仓库（默认分支为hexo）；\n\n``` bash\ngit clone https://github.com/xinrisanshao/xinrisanshao.github.io.git\n```\n\n3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。\n\n以上博客管理参考：[点击查看](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\n\n### 3. 博客图片存放（补）\n如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。\n\n我选择的是**七牛云**存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。\n\n\n# 五、总结\n\n不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。\n\n\n\n\n\n","source":"_posts/github Pages + Hexo搭建个人博客（二）  提升篇.md","raw":"---\ntitle: github Pages + Hexo搭建个人博客（二）  提升篇\ndate: 2017-08-07 12:59:25\nupdate:\ntags: [hexo,github]\ncategories: hexo\ncomments: true\n---\n# 一、前言\n在之前的**初级篇**中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。\n<!--more-->\n# 二、更换主题\n在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。\n\n在Hexo中有两份主要的配置文件，其名称都是**_config.yml**。其中，一份位于站点根目录下（此处为G:\\GitHub\\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。\n\n为了描述方便，在以下说明中，将前者称为**站点配置文件**，后者称为**主题配置文件**。 \n\n## 1. 安装NexT\nHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 \n### 1) 下载主题\n如果你熟悉Git，建议你使用**克隆最新版本**的方式，之后的更新可以通过**git pull**来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了）\n\n在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：\n``` bash\ncd G:\\GitHub\\hexo\ngit clone https://github.com/iissnan/hexo-theme-next themes/next  #后面意思是clone到该目录下themes/next文件夹中\n```\n### 2) 启用主题\n与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开**站点配置文件**，找到**theme**字段，并将其值更改为**next**。 \n\n``` bash\ntheme: next\n```\n此时我们在**主题配置文件**中设置语言。修改**language**字段。在主题的languages文件夹中选择语言，此处目录为G:\\GitHub\\hexo\\themes\\next\\languages 。\n\n``` bash\nlanguage: zh-Hans   #选择汉语，选择其他语言填写其他值即可\n```\n\n到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 \n\n### 3) 验证主题\n\n进入到博客文件夹根目录，此处为G:\\GitHub\\hexo，执行如下命令：\n\n``` bash\nhexo clean  #更换主题，最好先清除Hexo缓存\nhexo generate  #生成静态页面\nhexo server   # hexo server -p **** 更换默认4000端口为****\n```\n\n此时即可使用浏览器访问 http://localhost:4000。\n\n检查站点是否正确运行，如长时间访问不了，更改端口。\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170808201948.png)\n\n现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。\n\n# 三、主题设定\n\nNexT官网和网上资料非常丰富，就不细说了，参考如下：\n\n官方参考：[NexT使用文档](http://theme-next.iissnan.com/getting-started.html)\n\n网上资源：[hexo的next主题个性化教程：打造炫酷网站](http://blog.csdn.net/qq_33699981/article/details/72716951)\n\n**补充几点：**\n## 1. 添加评论功能\n我选择的是**来比力**，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。\n\n编辑主题配置文件， 编辑 livere_uid 字段，设置如下：\n\n``` bash\nlivere_uid: #your livere_uid\n```\n\n## 2. 修改背景图片\n\n首先找到一个背景图片放到 hexo（hexo工程文件）-> themes -> next -> source -> images 的路径下；\n\n然后进入hexo（hexo工程文件）-> themes -> next -> source -> css -> _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。\n\n``` bash\n// Custom styles.\nbody {\n  background:url(/images/background.jpeg);\n  background-attachment: fixed;   #固定背景图，使得不随页面移动\n}\n```\n\n## 3. 修改博客内容宽度\nPisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加\n\n``` bash\n$main-desktop = 1200px \n$content-desktop = 900px\n```\n\n可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。\n\n参考：[感觉浏览器留白太多，代码块看起来比较麻烦](https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848)\n\n## 4. 添加菜单栏\n在个人网站根目录下使用hexo命令hexo new page \"photo\" 就直接创建了.\\Hexo\\source\\photo\\index.md\n文件。\n\n在主题配置文件_config.yml中找到meun:字段，添加**photo**字段\n```xml\nmenu:\n  home: /\n  categories: /categories/\n  tags: /tags/\n  archives: /archives/\n  photo: /photo/\n  about: /about/\n  #sitemap: /sitemap.xml\n  #commonweal: /404.html\n```\n给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加**photo**字段：\n\n```xml\nmenu_icons:\n  enable: true\n  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome\n  home: home\n  about: user\n  categories: th\n  schedule: calendar\n  tags: tags\n  archives: archive\n  sitemap: sitemap\n  commonweal: heartbeat\n  photo: photo\n\n```\n\n在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为**photo**：[点击选择图标](http://fontawesome.io/icons/)\n\n将网站中的**photo**字段显示为中文**照片**字段\n\n在\\themes\\next\\languages\\zh-Hans.yml添加：\n\n```xml\nmenu:\n  home: 首页\n  archives: 归档\n  categories: 分类\n  tags: 标签\n  about: 关于\n  search: 搜索\n  schedule: 日程表\n  sitemap: 站点地图\n  commonweal: 公益404\n  photo: 照片\n\n```\n\n## 5. 调整首页**文档摘要**和**阅读全文**按钮高度并删除居中灰色线条\n\n1.调整文档摘要的高度\n\n在/next/source/css/_common/components/post/post-meta.styl中修改**margin**的值\n\n```css\n.posts-expand .post-meta {\n  margin: 3px 0 10px 0;\n  color: $grey-dark;\n```\n\n2.调整阅读全文按钮高度\n\n在\\next\\source\\css\\_common\\components\\post\\post-button.styl中修改**margin-top**的值\n\n```css\n.post-button {\n  margin-top: 10px;\n  .btn {\n```\n\n3.去除首页文档与文档之间居中灰色的线条\n\n在\\next\\source\\css\\_common\\components\\post\\post-eof.styl中注释掉如下样式\n\n```css\n.posts-expand {\n  .post-eof {\n  /*\n    display: block;\n    margin: $post-eof-margin-top auto $post-eof-margin-bottom;\n    width: 8%;\n    height: 1px;\n    background: $grey-light;\n    text-align: center;\n  */\n  }\n}\n```\n\n最终效果如下：\n![](http://ou6yob3zd.bkt.clouddn.com/20170904100438.png)\n\n## 6. 归档页博文列表高度调整\n\n在\\next\\source\\css\\_common\\components\\post\\post-collapse.styl中修改.post\n\n```css\n  .post { margin: 0px 0; }\n```\n\n\n到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。\n\n# 四、博客管理维护\n\n## 1. 概述\n\nHexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。\n\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。\n\n**注：** .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：\n``` bash\n.deploy*/    #只忽略上传.deploy*/开头的文件\n```\n\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。\n\n所以，我利用了分支！！！\n\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n\n下面以我的博客作为例子详细地讲述。\n\n## 2. 博客搭建流程\n\n  1.创建仓库，xinrisanshao.github.io；\n\n  2.创建两个分支：master 与 hexo；\n\n  3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n\n  4.使用如下命令拷贝仓库\n\n``` bash\ngit clone https://github.com/xinrisanshao/xinrisanshao.github.io.git \n```\n  \n  5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm  \n   install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n\n  6.修改_config.yml中的deploy参数，分支应为master；\n  \n  7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）；\n\n  8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。\n\n这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。\n\n**注：**流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\\xinrisanshao.github.io\\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。\n\n## 3. 博客管理流程\n\n### 1. 编辑与修改博客\n\n在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：\n\n1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；\n\n2.然后才执行hexo generate -d发布网站到master分支上。\n\n虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。\n\n### 2. 本地资料丢失\n当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n1.首先安装Git，Node.js和Hexo。\n\n2.使用下面命令拷贝仓库（默认分支为hexo）；\n\n``` bash\ngit clone https://github.com/xinrisanshao/xinrisanshao.github.io.git\n```\n\n3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。\n\n以上博客管理参考：[点击查看](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\n\n### 3. 博客图片存放（补）\n如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。\n\n我选择的是**七牛云**存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。\n\n\n# 五、总结\n\n不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。\n\n\n\n\n\n","slug":"github Pages + Hexo搭建个人博客（二）  提升篇","published":1,"updated":"2017-12-07T07:59:00.074Z","layout":"post","photos":[],"link":"","_id":"cjcj3yig30004jgc9gcpbt36a","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>在之前的<strong>初级篇</strong>中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。<br><a id=\"more\"></a></p>\n<h1 id=\"二、更换主题\"><a href=\"#二、更换主题\" class=\"headerlink\" title=\"二、更换主题\"></a>二、更换主题</h1><p>在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。</p>\n<p>在Hexo中有两份主要的配置文件，其名称都是<strong>_config.yml</strong>。其中，一份位于站点根目录下（此处为G:\\GitHub\\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>\n<p>为了描述方便，在以下说明中，将前者称为<strong>站点配置文件</strong>，后者称为<strong>主题配置文件</strong>。 </p>\n<h2 id=\"1-安装NexT\"><a href=\"#1-安装NexT\" class=\"headerlink\" title=\"1. 安装NexT\"></a>1. 安装NexT</h2><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 </p>\n<h3 id=\"1-下载主题\"><a href=\"#1-下载主题\" class=\"headerlink\" title=\"1) 下载主题\"></a>1) 下载主题</h3><p>如果你熟悉Git，建议你使用<strong>克隆最新版本</strong>的方式，之后的更新可以通过<strong>git pull</strong>来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了）</p>\n<p>在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> G:\\GitHub\\hexo</div><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next  <span class=\"comment\">#后面意思是clone到该目录下themes/next文件夹中</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"2-启用主题\"><a href=\"#2-启用主题\" class=\"headerlink\" title=\"2) 启用主题\"></a>2) 启用主题</h3><p>与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开<strong>站点配置文件</strong>，找到<strong>theme</strong>字段，并将其值更改为<strong>next</strong>。 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: next</div></pre></td></tr></table></figure>\n<p>此时我们在<strong>主题配置文件</strong>中设置语言。修改<strong>language</strong>字段。在主题的languages文件夹中选择语言，此处目录为G:\\GitHub\\hexo\\themes\\next\\languages 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">language: zh-Hans   <span class=\"comment\">#选择汉语，选择其他语言填写其他值即可</span></div></pre></td></tr></table></figure>\n<p>到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 </p>\n<h3 id=\"3-验证主题\"><a href=\"#3-验证主题\" class=\"headerlink\" title=\"3) 验证主题\"></a>3) 验证主题</h3><p>进入到博客文件夹根目录，此处为G:\\GitHub\\hexo，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean  <span class=\"comment\">#更换主题，最好先清除Hexo缓存</span></div><div class=\"line\">hexo generate  <span class=\"comment\">#生成静态页面</span></div><div class=\"line\">hexo server   <span class=\"comment\"># hexo server -p **** 更换默认4000端口为****</span></div></pre></td></tr></table></figure>\n<p>此时即可使用浏览器访问 <a href=\"http://localhost:4000。\" target=\"_blank\" rel=\"external\">http://localhost:4000。</a></p>\n<p>检查站点是否正确运行，如长时间访问不了，更改端口。</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170808201948.png\" alt=\"\"></p>\n<p>现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p>\n<h1 id=\"三、主题设定\"><a href=\"#三、主题设定\" class=\"headerlink\" title=\"三、主题设定\"></a>三、主题设定</h1><p>NexT官网和网上资料非常丰富，就不细说了，参考如下：</p>\n<p>官方参考：<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"external\">NexT使用文档</a></p>\n<p>网上资源：<a href=\"http://blog.csdn.net/qq_33699981/article/details/72716951\" target=\"_blank\" rel=\"external\">hexo的next主题个性化教程：打造炫酷网站</a></p>\n<p><strong>补充几点：</strong></p>\n<h2 id=\"1-添加评论功能\"><a href=\"#1-添加评论功能\" class=\"headerlink\" title=\"1. 添加评论功能\"></a>1. 添加评论功能</h2><p>我选择的是<strong>来比力</strong>，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。</p>\n<p>编辑主题配置文件， 编辑 livere_uid 字段，设置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">livere_uid: <span class=\"comment\">#your livere_uid</span></div></pre></td></tr></table></figure>\n<h2 id=\"2-修改背景图片\"><a href=\"#2-修改背景图片\" class=\"headerlink\" title=\"2. 修改背景图片\"></a>2. 修改背景图片</h2><p>首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下；</p>\n<p>然后进入hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Custom styles.</div><div class=\"line\">body &#123;</div><div class=\"line\">  background:url(/images/background.jpeg);</div><div class=\"line\">  background-attachment: fixed;   <span class=\"comment\">#固定背景图，使得不随页面移动</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-修改博客内容宽度\"><a href=\"#3-修改博客内容宽度\" class=\"headerlink\" title=\"3. 修改博客内容宽度\"></a>3. 修改博客内容宽度</h2><p>Pisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$main</span>-desktop = 1200px </div><div class=\"line\"><span class=\"variable\">$content</span>-desktop = 900px</div></pre></td></tr></table></figure>\n<p>可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。</p>\n<p>参考：<a href=\"https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848\" target=\"_blank\" rel=\"external\">感觉浏览器留白太多，代码块看起来比较麻烦</a></p>\n<h2 id=\"4-添加菜单栏\"><a href=\"#4-添加菜单栏\" class=\"headerlink\" title=\"4. 添加菜单栏\"></a>4. 添加菜单栏</h2><p>在个人网站根目录下使用hexo命令hexo new page “photo” 就直接创建了.\\Hexo\\source\\photo\\index.md<br>文件。</p>\n<p>在主题配置文件_config.yml中找到meun:字段，添加<strong>photo</strong>字段<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu:</div><div class=\"line\">  home: /</div><div class=\"line\">  categories: /categories/</div><div class=\"line\">  tags: /tags/</div><div class=\"line\">  archives: /archives/</div><div class=\"line\">  photo: /photo/</div><div class=\"line\">  about: /about/</div><div class=\"line\">  #sitemap: /sitemap.xml</div><div class=\"line\">  #commonweal: /404.html</div></pre></td></tr></table></figure></p>\n<p>给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加<strong>photo</strong>字段：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu_icons:</div><div class=\"line\">  enable: true</div><div class=\"line\">  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</div><div class=\"line\">  home: home</div><div class=\"line\">  about: user</div><div class=\"line\">  categories: th</div><div class=\"line\">  schedule: calendar</div><div class=\"line\">  tags: tags</div><div class=\"line\">  archives: archive</div><div class=\"line\">  sitemap: sitemap</div><div class=\"line\">  commonweal: heartbeat</div><div class=\"line\">  photo: photo</div></pre></td></tr></table></figure>\n<p>在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为<strong>photo</strong>：<a href=\"http://fontawesome.io/icons/\" target=\"_blank\" rel=\"external\">点击选择图标</a></p>\n<p>将网站中的<strong>photo</strong>字段显示为中文<strong>照片</strong>字段</p>\n<p>在\\themes\\next\\languages\\zh-Hans.yml添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu:</div><div class=\"line\">  home: 首页</div><div class=\"line\">  archives: 归档</div><div class=\"line\">  categories: 分类</div><div class=\"line\">  tags: 标签</div><div class=\"line\">  about: 关于</div><div class=\"line\">  search: 搜索</div><div class=\"line\">  schedule: 日程表</div><div class=\"line\">  sitemap: 站点地图</div><div class=\"line\">  commonweal: 公益404</div><div class=\"line\">  photo: 照片</div></pre></td></tr></table></figure>\n<h2 id=\"5-调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条\"><a href=\"#5-调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条\" class=\"headerlink\" title=\"5. 调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条\"></a>5. 调整首页<strong>文档摘要</strong>和<strong>阅读全文</strong>按钮高度并删除居中灰色线条</h2><p>1.调整文档摘要的高度</p>\n<p>在/next/source/css/_common/components/post/post-meta.styl中修改<strong>margin</strong>的值</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.posts-expand</span> <span class=\"selector-class\">.post-meta</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">3px</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">color</span>: $grey-dark;</div></pre></td></tr></table></figure>\n<p>2.调整阅读全文按钮高度</p>\n<p>在\\next\\source\\css_common\\components\\post\\post-button.styl中修改<strong>margin-top</strong>的值</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.post-button</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">  .btn &#123;</div></pre></td></tr></table></figure>\n<p>3.去除首页文档与文档之间居中灰色的线条</p>\n<p>在\\next\\source\\css_common\\components\\post\\post-eof.styl中注释掉如下样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.posts-expand</span> &#123;</div><div class=\"line\">  .post-eof &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">    display: block;</span></div><div class=\"line\"><span class=\"comment\">    margin: $post-eof-margin-top auto $post-eof-margin-bottom;</span></div><div class=\"line\"><span class=\"comment\">    width: 8%;</span></div><div class=\"line\"><span class=\"comment\">    height: 1px;</span></div><div class=\"line\"><span class=\"comment\">    background: $grey-light;</span></div><div class=\"line\"><span class=\"comment\">    text-align: center;</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终效果如下：<br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170904100438.png\" alt=\"\"></p>\n<h2 id=\"6-归档页博文列表高度调整\"><a href=\"#6-归档页博文列表高度调整\" class=\"headerlink\" title=\"6. 归档页博文列表高度调整\"></a>6. 归档页博文列表高度调整</h2><p>在\\next\\source\\css_common\\components\\post\\post-collapse.styl中修改.post</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.post</span> &#123; <span class=\"attribute\">margin</span>: <span class=\"number\">0px</span> <span class=\"number\">0</span>; &#125;</div></pre></td></tr></table></figure>\n<p>到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。</p>\n<h1 id=\"四、博客管理维护\"><a href=\"#四、博客管理维护\" class=\"headerlink\" title=\"四、博客管理维护\"></a>四、博客管理维护</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。</p>\n<p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。</p>\n<p><strong>注：</strong> .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.deploy*/    <span class=\"comment\">#只忽略上传.deploy*/开头的文件</span></div></pre></td></tr></table></figure></p>\n<p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。</p>\n<p>所以，我利用了分支！！！</p>\n<p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p>\n<p>下面以我的博客作为例子详细地讲述。</p>\n<h2 id=\"2-博客搭建流程\"><a href=\"#2-博客搭建流程\" class=\"headerlink\" title=\"2. 博客搭建流程\"></a>2. 博客搭建流程</h2><p>  1.创建仓库，xinrisanshao.github.io；</p>\n<p>  2.创建两个分支：master 与 hexo；</p>\n<p>  3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</p>\n<p>  4.使用如下命令拷贝仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xinrisanshao/xinrisanshao.github.io.git</div></pre></td></tr></table></figure>\n<p>  5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm<br>   install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</p>\n<p>  6.修改_config.yml中的deploy参数，分支应为master；</p>\n<p>  7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）；</p>\n<p>  8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。</p>\n<p>这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。</p>\n<p><strong>注：</strong>流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\\xinrisanshao.github.io\\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。</p>\n<h2 id=\"3-博客管理流程\"><a href=\"#3-博客管理流程\" class=\"headerlink\" title=\"3. 博客管理流程\"></a>3. 博客管理流程</h2><h3 id=\"1-编辑与修改博客\"><a href=\"#1-编辑与修改博客\" class=\"headerlink\" title=\"1. 编辑与修改博客\"></a>1. 编辑与修改博客</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p>\n<p>1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</p>\n<p>2.然后才执行hexo generate -d发布网站到master分支上。</p>\n<p>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>\n<h3 id=\"2-本地资料丢失\"><a href=\"#2-本地资料丢失\" class=\"headerlink\" title=\"2. 本地资料丢失\"></a>2. 本地资料丢失</h3><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：<br>1.首先安装Git，Node.js和Hexo。</p>\n<p>2.使用下面命令拷贝仓库（默认分支为hexo）；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xinrisanshao/xinrisanshao.github.io.git</div></pre></td></tr></table></figure>\n<p>3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。</p>\n<p>以上博客管理参考：<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"external\">点击查看</a></p>\n<h3 id=\"3-博客图片存放（补）\"><a href=\"#3-博客图片存放（补）\" class=\"headerlink\" title=\"3. 博客图片存放（补）\"></a>3. 博客图片存放（补）</h3><p>如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。</p>\n<p>我选择的是<strong>七牛云</strong>存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。</p>\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><p>不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>在之前的<strong>初级篇</strong>中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。<br>","more":"</p>\n<h1 id=\"二、更换主题\"><a href=\"#二、更换主题\" class=\"headerlink\" title=\"二、更换主题\"></a>二、更换主题</h1><p>在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。</p>\n<p>在Hexo中有两份主要的配置文件，其名称都是<strong>_config.yml</strong>。其中，一份位于站点根目录下（此处为G:\\GitHub\\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>\n<p>为了描述方便，在以下说明中，将前者称为<strong>站点配置文件</strong>，后者称为<strong>主题配置文件</strong>。 </p>\n<h2 id=\"1-安装NexT\"><a href=\"#1-安装NexT\" class=\"headerlink\" title=\"1. 安装NexT\"></a>1. 安装NexT</h2><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 </p>\n<h3 id=\"1-下载主题\"><a href=\"#1-下载主题\" class=\"headerlink\" title=\"1) 下载主题\"></a>1) 下载主题</h3><p>如果你熟悉Git，建议你使用<strong>克隆最新版本</strong>的方式，之后的更新可以通过<strong>git pull</strong>来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了）</p>\n<p>在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> G:\\GitHub\\hexo</div><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next  <span class=\"comment\">#后面意思是clone到该目录下themes/next文件夹中</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"2-启用主题\"><a href=\"#2-启用主题\" class=\"headerlink\" title=\"2) 启用主题\"></a>2) 启用主题</h3><p>与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开<strong>站点配置文件</strong>，找到<strong>theme</strong>字段，并将其值更改为<strong>next</strong>。 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: next</div></pre></td></tr></table></figure>\n<p>此时我们在<strong>主题配置文件</strong>中设置语言。修改<strong>language</strong>字段。在主题的languages文件夹中选择语言，此处目录为G:\\GitHub\\hexo\\themes\\next\\languages 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">language: zh-Hans   <span class=\"comment\">#选择汉语，选择其他语言填写其他值即可</span></div></pre></td></tr></table></figure>\n<p>到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 </p>\n<h3 id=\"3-验证主题\"><a href=\"#3-验证主题\" class=\"headerlink\" title=\"3) 验证主题\"></a>3) 验证主题</h3><p>进入到博客文件夹根目录，此处为G:\\GitHub\\hexo，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean  <span class=\"comment\">#更换主题，最好先清除Hexo缓存</span></div><div class=\"line\">hexo generate  <span class=\"comment\">#生成静态页面</span></div><div class=\"line\">hexo server   <span class=\"comment\"># hexo server -p **** 更换默认4000端口为****</span></div></pre></td></tr></table></figure>\n<p>此时即可使用浏览器访问 <a href=\"http://localhost:4000。\" target=\"_blank\" rel=\"external\">http://localhost:4000。</a></p>\n<p>检查站点是否正确运行，如长时间访问不了，更改端口。</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170808201948.png\" alt=\"\"></p>\n<p>现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p>\n<h1 id=\"三、主题设定\"><a href=\"#三、主题设定\" class=\"headerlink\" title=\"三、主题设定\"></a>三、主题设定</h1><p>NexT官网和网上资料非常丰富，就不细说了，参考如下：</p>\n<p>官方参考：<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"external\">NexT使用文档</a></p>\n<p>网上资源：<a href=\"http://blog.csdn.net/qq_33699981/article/details/72716951\" target=\"_blank\" rel=\"external\">hexo的next主题个性化教程：打造炫酷网站</a></p>\n<p><strong>补充几点：</strong></p>\n<h2 id=\"1-添加评论功能\"><a href=\"#1-添加评论功能\" class=\"headerlink\" title=\"1. 添加评论功能\"></a>1. 添加评论功能</h2><p>我选择的是<strong>来比力</strong>，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。</p>\n<p>编辑主题配置文件， 编辑 livere_uid 字段，设置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">livere_uid: <span class=\"comment\">#your livere_uid</span></div></pre></td></tr></table></figure>\n<h2 id=\"2-修改背景图片\"><a href=\"#2-修改背景图片\" class=\"headerlink\" title=\"2. 修改背景图片\"></a>2. 修改背景图片</h2><p>首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下；</p>\n<p>然后进入hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Custom styles.</div><div class=\"line\">body &#123;</div><div class=\"line\">  background:url(/images/background.jpeg);</div><div class=\"line\">  background-attachment: fixed;   <span class=\"comment\">#固定背景图，使得不随页面移动</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-修改博客内容宽度\"><a href=\"#3-修改博客内容宽度\" class=\"headerlink\" title=\"3. 修改博客内容宽度\"></a>3. 修改博客内容宽度</h2><p>Pisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$main</span>-desktop = 1200px </div><div class=\"line\"><span class=\"variable\">$content</span>-desktop = 900px</div></pre></td></tr></table></figure>\n<p>可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。</p>\n<p>参考：<a href=\"https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848\" target=\"_blank\" rel=\"external\">感觉浏览器留白太多，代码块看起来比较麻烦</a></p>\n<h2 id=\"4-添加菜单栏\"><a href=\"#4-添加菜单栏\" class=\"headerlink\" title=\"4. 添加菜单栏\"></a>4. 添加菜单栏</h2><p>在个人网站根目录下使用hexo命令hexo new page “photo” 就直接创建了.\\Hexo\\source\\photo\\index.md<br>文件。</p>\n<p>在主题配置文件_config.yml中找到meun:字段，添加<strong>photo</strong>字段<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu:</div><div class=\"line\">  home: /</div><div class=\"line\">  categories: /categories/</div><div class=\"line\">  tags: /tags/</div><div class=\"line\">  archives: /archives/</div><div class=\"line\">  photo: /photo/</div><div class=\"line\">  about: /about/</div><div class=\"line\">  #sitemap: /sitemap.xml</div><div class=\"line\">  #commonweal: /404.html</div></pre></td></tr></table></figure></p>\n<p>给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加<strong>photo</strong>字段：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu_icons:</div><div class=\"line\">  enable: true</div><div class=\"line\">  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</div><div class=\"line\">  home: home</div><div class=\"line\">  about: user</div><div class=\"line\">  categories: th</div><div class=\"line\">  schedule: calendar</div><div class=\"line\">  tags: tags</div><div class=\"line\">  archives: archive</div><div class=\"line\">  sitemap: sitemap</div><div class=\"line\">  commonweal: heartbeat</div><div class=\"line\">  photo: photo</div></pre></td></tr></table></figure>\n<p>在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为<strong>photo</strong>：<a href=\"http://fontawesome.io/icons/\" target=\"_blank\" rel=\"external\">点击选择图标</a></p>\n<p>将网站中的<strong>photo</strong>字段显示为中文<strong>照片</strong>字段</p>\n<p>在\\themes\\next\\languages\\zh-Hans.yml添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu:</div><div class=\"line\">  home: 首页</div><div class=\"line\">  archives: 归档</div><div class=\"line\">  categories: 分类</div><div class=\"line\">  tags: 标签</div><div class=\"line\">  about: 关于</div><div class=\"line\">  search: 搜索</div><div class=\"line\">  schedule: 日程表</div><div class=\"line\">  sitemap: 站点地图</div><div class=\"line\">  commonweal: 公益404</div><div class=\"line\">  photo: 照片</div></pre></td></tr></table></figure>\n<h2 id=\"5-调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条\"><a href=\"#5-调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条\" class=\"headerlink\" title=\"5. 调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条\"></a>5. 调整首页<strong>文档摘要</strong>和<strong>阅读全文</strong>按钮高度并删除居中灰色线条</h2><p>1.调整文档摘要的高度</p>\n<p>在/next/source/css/_common/components/post/post-meta.styl中修改<strong>margin</strong>的值</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.posts-expand</span> <span class=\"selector-class\">.post-meta</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">3px</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">color</span>: $grey-dark;</div></pre></td></tr></table></figure>\n<p>2.调整阅读全文按钮高度</p>\n<p>在\\next\\source\\css_common\\components\\post\\post-button.styl中修改<strong>margin-top</strong>的值</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.post-button</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">  .btn &#123;</div></pre></td></tr></table></figure>\n<p>3.去除首页文档与文档之间居中灰色的线条</p>\n<p>在\\next\\source\\css_common\\components\\post\\post-eof.styl中注释掉如下样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.posts-expand</span> &#123;</div><div class=\"line\">  .post-eof &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">    display: block;</span></div><div class=\"line\"><span class=\"comment\">    margin: $post-eof-margin-top auto $post-eof-margin-bottom;</span></div><div class=\"line\"><span class=\"comment\">    width: 8%;</span></div><div class=\"line\"><span class=\"comment\">    height: 1px;</span></div><div class=\"line\"><span class=\"comment\">    background: $grey-light;</span></div><div class=\"line\"><span class=\"comment\">    text-align: center;</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终效果如下：<br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170904100438.png\" alt=\"\"></p>\n<h2 id=\"6-归档页博文列表高度调整\"><a href=\"#6-归档页博文列表高度调整\" class=\"headerlink\" title=\"6. 归档页博文列表高度调整\"></a>6. 归档页博文列表高度调整</h2><p>在\\next\\source\\css_common\\components\\post\\post-collapse.styl中修改.post</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.post</span> &#123; <span class=\"attribute\">margin</span>: <span class=\"number\">0px</span> <span class=\"number\">0</span>; &#125;</div></pre></td></tr></table></figure>\n<p>到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。</p>\n<h1 id=\"四、博客管理维护\"><a href=\"#四、博客管理维护\" class=\"headerlink\" title=\"四、博客管理维护\"></a>四、博客管理维护</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。</p>\n<p>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。</p>\n<p><strong>注：</strong> .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">.deploy*/    <span class=\"comment\">#只忽略上传.deploy*/开头的文件</span></div></pre></td></tr></table></figure></p>\n<p>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。</p>\n<p>所以，我利用了分支！！！</p>\n<p>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p>\n<p>下面以我的博客作为例子详细地讲述。</p>\n<h2 id=\"2-博客搭建流程\"><a href=\"#2-博客搭建流程\" class=\"headerlink\" title=\"2. 博客搭建流程\"></a>2. 博客搭建流程</h2><p>  1.创建仓库，xinrisanshao.github.io；</p>\n<p>  2.创建两个分支：master 与 hexo；</p>\n<p>  3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</p>\n<p>  4.使用如下命令拷贝仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xinrisanshao/xinrisanshao.github.io.git</div></pre></td></tr></table></figure>\n<p>  5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm<br>   install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</p>\n<p>  6.修改_config.yml中的deploy参数，分支应为master；</p>\n<p>  7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）；</p>\n<p>  8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。</p>\n<p>这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。</p>\n<p><strong>注：</strong>流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\\xinrisanshao.github.io\\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。</p>\n<h2 id=\"3-博客管理流程\"><a href=\"#3-博客管理流程\" class=\"headerlink\" title=\"3. 博客管理流程\"></a>3. 博客管理流程</h2><h3 id=\"1-编辑与修改博客\"><a href=\"#1-编辑与修改博客\" class=\"headerlink\" title=\"1. 编辑与修改博客\"></a>1. 编辑与修改博客</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p>\n<p>1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</p>\n<p>2.然后才执行hexo generate -d发布网站到master分支上。</p>\n<p>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>\n<h3 id=\"2-本地资料丢失\"><a href=\"#2-本地资料丢失\" class=\"headerlink\" title=\"2. 本地资料丢失\"></a>2. 本地资料丢失</h3><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：<br>1.首先安装Git，Node.js和Hexo。</p>\n<p>2.使用下面命令拷贝仓库（默认分支为hexo）；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xinrisanshao/xinrisanshao.github.io.git</div></pre></td></tr></table></figure>\n<p>3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。</p>\n<p>以上博客管理参考：<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"external\">点击查看</a></p>\n<h3 id=\"3-博客图片存放（补）\"><a href=\"#3-博客图片存放（补）\" class=\"headerlink\" title=\"3. 博客图片存放（补）\"></a>3. 博客图片存放（补）</h3><p>如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。</p>\n<p>我选择的是<strong>七牛云</strong>存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。</p>\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><p>不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。</p>"},{"title":"个人总结之排序算法","date":"2017-08-21T11:30:25.000Z","update":null,"comments":1,"_content":"\n# 前言\n回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中...\n<!--more-->\n\n**注：**这里实现的算法都是递增排序，也就是从小到大排序。\n\n## 初级排序算法\n\n### 1.选择排序\n**思想：**首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。\n\n```java\npublic static int [] sort(int a[],int length){    //选择排序\n    for(int i=0;i<length;i++){\n        int minIndex = i; //初始化最小元素的索引\n        for(int j=i+1;j<length;j++){\n            if(a[minIndex]>a[j]){\n                minIndex = j;  //找到最小元素的索引\n            }\n        }\n        int tem = a[i];\n        a[i] = a[minIndex];\n        a[minIndex] = tem;\n    }\n    return a;\n}\n```\n### 2.直接插入排序\n**思想：** 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。\n![](http://ou6yob3zd.bkt.clouddn.com/20170821195323.png)\n\n**代码：**\n\n第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。\n```java\npublic static int [] sort(int a[],int length){\n\tfor(int i=1;i<a.length;i++){\n\t\tfor(int j=i;j>0&&a[j]<a[j-1];j--){  \n\t\t\tint tem = a[j-1];\n\t\t\ta[j-1] = a[j];\n\t\t\ta[j] = tem;\n\t\t}\n\t}\n\treturn a;\n}\n```\n\n第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。\n```java\npublic static int [] sort(int a[],int length){    //不需要交换的插入排序\n\tfor(int i=1;i<a.length;i++){\n\t\tint tem = a[i];  //待插入的元素\n\t\tint j;\n\t\tfor(j=i-1;j>=0&&tem<a[j];j--){\n\t\t\ta[j+1] = a[j];   //元素后移,直到找到待插入的元素的位置\n\t\t}\n\t\ta[j+1] = tem;  //将带插入元素插入到查找到的位置\n\t}\n\treturn a;\n}\n```\n\n第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j>0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。\n\n```java\npublic static int [] sort(int a[],int length){\n\tint minIndex =0;\n\tfor(int i=1;i<length;i++){\n\t\tif(a[minIndex]>a[i]){\n\t\t\tminIndex = i;\n\t\t}\n\t}\n\tint tem = a[0];\n\ta[0] = a[minIndex];\n\ta[minIndex] = tem;\n\tfor(int i=2;i<length;i++){\n\t\ttem = a[i];\n\t\tint j;\n\t\tfor(j=i-1;tem<a[j];j--){\n\t\t\ta[j+1] = a[j];\n\t\t}\n\t\ta[j+1] = tem;\n\t}\n\treturn a;\n}\n```\n\n### 3.希尔排序\n\n**思想：**希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n\n简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。\n\n我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170821203528.png)\n\n**代码：**\n```java\npublic static int[] sort(int a[],int length){\n\tint h = length/2; //初始增量\n\twhile(h>=1){\n\t\t//将数组变为h有序\n\t\tfor(int i=h;i<length;i++) {\n\t\t\t//将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中\n\t\t\tfor(int j=i;j>=h&&a[j]<a[j-h];j-=h){\n\t\t\t\tint tem = a[j-h];\n\t\t\t\ta[j-h] = a[j];\n\t\t\t\ta[j] = tem;\n\t\t\t}\n\t\t}\n\t\th = h/2; //每次排完序后,增量减少\n\t}\t\n\treturn a;\n}\n```\n\n参考：[dreamcatcher-cx](http://www.cnblogs.com/chengxiao/p/6104371.html)\n\n## 归并排序\n\n### 简介\n\n归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。\n\n### 2-路归并排序\n\n**2-路归并排序:**假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，......，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 \n\n**该图显示的就是循环2-路归并排序算法的过程：**\n![](http://ou6yob3zd.bkt.clouddn.com/20170827211130.png)\n\n2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。\n\n**递归算法：自顶向下的2-路归并排序中归并结果的轨迹：**\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170827220032.png)\n\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170827212542.png)\n\n**循环算法：自底向上的2-路归并排序中归并结果的轨迹：**\n![](http://ou6yob3zd.bkt.clouddn.com/20170827215932.png)\n\n### 代码\n\n```java\npublic class Mergesort {  //2-路归并排序\n\tpublic static int [] aux;  //辅助数组\n\tpublic static void merge(int a[],int lo,int mid,int hi){   //核心算法\n\t\t//将a[lo..mid]和a[mid+1,hi](已有序)归并 \n\t\tint i = lo, j = mid+1;\n\t\tfor(int k = lo;k<=hi;k++){ //将a[lo..hi]复制到aux[lo..hi]\n\t\t\taux[k] = a[k];\n\t\t}\n\t\tfor(int k=lo;k<=hi;k++){\n\t\t\tif(i>mid) a[k] = aux[j++];  //左半边用尽，取右半边的元素复制到a中\n\t\t\telse if(j>hi) a[k] = aux[i++];   //右半边用尽，取左半边的元素复制到a中\n\t\t\telse if(aux[i]<aux[j]) a[k] = aux[i++];  //左半边元素小于右半边元素，取左半边元素复制到a中\n\t\t\telse a[k] = aux[j++]; //右半边元素小于左半边元素，取右半边元素复制到a中\n\t\t}\n\t}\n\tpublic static void Mergesort(int a[]){   //二路归并递归算法\n\t\taux = new int [a.length];   //一次性分配空间\n\t\tsort(a,0,a.length-1);\n\t}\n\tprivate static void sort(int[] a, int lo, int hi) {\n\t\t// 将数组a[lo..hi]排序\n\t\tif(lo>=hi) return ;\n\t\tint mid = lo + (hi-lo)/2;\n\t\tsort(a,lo,mid);     //递归将左半边排序\n\t\tsort(a,mid+1,hi);   //递归将右半边排序\n\t\tmerge(a, lo, mid, hi);  //归并结果\n\t}\n\t\n\tpublic static void Mergesort1(int [] a) {  //二路归并非递归算法\n\t\t//进行lgN次两两归并\n\t\tint N = a.length;\n\t\taux = new int [N];\n\t\tfor(int sz = 1; sz<N;sz = 2*sz){  //sz的子数组大小\n\t\t\tfor(int lo =0;lo<N-sz; lo+=2*sz){  //子数组的索引\n\t\t\t\tmerge(a, lo, lo+sz-1, Math.max(lo+2*sz-1, N-1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint a[] = {2,3,5,1,4,0,7,6};\n\t\t//Mergesort(a);  //调用2-路归并递归排序函数\n\t\tMergesort1(a);  //调用2-路归并非递归排序函数\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\t}\n\t}\n}\n\n```\n\n### 一些改进\n\n1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。\n\n2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。\n\n3.不将元素复制到辅助数组（暂时不太明白）。\n\n## 快速排序\n\n### 简介\n\n快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。\n\n### 关键算法\n\n该方法的关键在于切分，这个过程使得数组满足下面的三个条件：\n\n1.对于某个j,a[j]已经排定；\n\n2.a[lo]到a[j-1]中的所有元素都不大于a[j]；\n\n3.a[j+1]到a[hi]中的所有元素都不小于a[j]。\n\n### 代码\n\n```java\npublic class QuickSort {\n\tpublic static int[] quicksort(int a[]){\n\t\tsort(a,0,a.length-1);\n\t\treturn a;\n\t}\n\tprivate static void sort(int[] a, int lo, int hi) {\n\t\tif(hi<=lo) return ;\n\t\tint j=partition(a,lo,hi);   //切分\n\t\t//第j个位置已经在它所在的排好序的位置\n\t\tsort(a,lo,j-1);\n\t\tsort(a,j+1,hi);\n\t}\n\tprivate static int partition(int[] a, int lo, int hi) {\n\t    int part = a[lo];   //切分元素\n\t    int i = lo,j=hi+1;  //左右扫描指针\n\t    int tem;\n\t    while(true){\n\t    \t//扫描左右，检查扫描是否结束并交换元素\n\t    \twhile(a[++i]<part) {  //从左到右(第一个元素除外)找到大于等于part的元素\n\t    \t\tif(i==hi) break;    \n\t    \t}\n\t    \twhile(a[--j]>part){  //从右到左找到小于等于part的元素\n\t    \t\tif(j==lo) break;\n\t    \t}\n\t    \tif(i>=j) break;\n\t    \ttem = a[i];\n\t    \ta[i] = a[j];\n\t    \ta[j] = tem;\n\t    }\n\t    tem = a[lo];   //将part=a[j]放入正确的位置\n    \ta[lo] = a[j];\n    \ta[j] = tem;\n\t\treturn j;\n\t}\n\tpublic static void main(String[] args) {\n\t\tint []a = {4,5,4,6,1,3};\n\t\ta = quicksort(a);\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/个人总结之排序算法.md","raw":"---\ntitle: 个人总结之排序算法\ndate: 2017-08-21 19:30:25\nupdate:\ntags: [排序,编程]\ncategories: 算法\ncomments: true\n---\n\n# 前言\n回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中...\n<!--more-->\n\n**注：**这里实现的算法都是递增排序，也就是从小到大排序。\n\n## 初级排序算法\n\n### 1.选择排序\n**思想：**首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。\n\n```java\npublic static int [] sort(int a[],int length){    //选择排序\n    for(int i=0;i<length;i++){\n        int minIndex = i; //初始化最小元素的索引\n        for(int j=i+1;j<length;j++){\n            if(a[minIndex]>a[j]){\n                minIndex = j;  //找到最小元素的索引\n            }\n        }\n        int tem = a[i];\n        a[i] = a[minIndex];\n        a[minIndex] = tem;\n    }\n    return a;\n}\n```\n### 2.直接插入排序\n**思想：** 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。\n![](http://ou6yob3zd.bkt.clouddn.com/20170821195323.png)\n\n**代码：**\n\n第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。\n```java\npublic static int [] sort(int a[],int length){\n\tfor(int i=1;i<a.length;i++){\n\t\tfor(int j=i;j>0&&a[j]<a[j-1];j--){  \n\t\t\tint tem = a[j-1];\n\t\t\ta[j-1] = a[j];\n\t\t\ta[j] = tem;\n\t\t}\n\t}\n\treturn a;\n}\n```\n\n第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。\n```java\npublic static int [] sort(int a[],int length){    //不需要交换的插入排序\n\tfor(int i=1;i<a.length;i++){\n\t\tint tem = a[i];  //待插入的元素\n\t\tint j;\n\t\tfor(j=i-1;j>=0&&tem<a[j];j--){\n\t\t\ta[j+1] = a[j];   //元素后移,直到找到待插入的元素的位置\n\t\t}\n\t\ta[j+1] = tem;  //将带插入元素插入到查找到的位置\n\t}\n\treturn a;\n}\n```\n\n第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j>0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。\n\n```java\npublic static int [] sort(int a[],int length){\n\tint minIndex =0;\n\tfor(int i=1;i<length;i++){\n\t\tif(a[minIndex]>a[i]){\n\t\t\tminIndex = i;\n\t\t}\n\t}\n\tint tem = a[0];\n\ta[0] = a[minIndex];\n\ta[minIndex] = tem;\n\tfor(int i=2;i<length;i++){\n\t\ttem = a[i];\n\t\tint j;\n\t\tfor(j=i-1;tem<a[j];j--){\n\t\t\ta[j+1] = a[j];\n\t\t}\n\t\ta[j+1] = tem;\n\t}\n\treturn a;\n}\n```\n\n### 3.希尔排序\n\n**思想：**希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n\n简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。\n\n我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170821203528.png)\n\n**代码：**\n```java\npublic static int[] sort(int a[],int length){\n\tint h = length/2; //初始增量\n\twhile(h>=1){\n\t\t//将数组变为h有序\n\t\tfor(int i=h;i<length;i++) {\n\t\t\t//将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中\n\t\t\tfor(int j=i;j>=h&&a[j]<a[j-h];j-=h){\n\t\t\t\tint tem = a[j-h];\n\t\t\t\ta[j-h] = a[j];\n\t\t\t\ta[j] = tem;\n\t\t\t}\n\t\t}\n\t\th = h/2; //每次排完序后,增量减少\n\t}\t\n\treturn a;\n}\n```\n\n参考：[dreamcatcher-cx](http://www.cnblogs.com/chengxiao/p/6104371.html)\n\n## 归并排序\n\n### 简介\n\n归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。\n\n### 2-路归并排序\n\n**2-路归并排序:**假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，......，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 \n\n**该图显示的就是循环2-路归并排序算法的过程：**\n![](http://ou6yob3zd.bkt.clouddn.com/20170827211130.png)\n\n2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。\n\n**递归算法：自顶向下的2-路归并排序中归并结果的轨迹：**\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170827220032.png)\n\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170827212542.png)\n\n**循环算法：自底向上的2-路归并排序中归并结果的轨迹：**\n![](http://ou6yob3zd.bkt.clouddn.com/20170827215932.png)\n\n### 代码\n\n```java\npublic class Mergesort {  //2-路归并排序\n\tpublic static int [] aux;  //辅助数组\n\tpublic static void merge(int a[],int lo,int mid,int hi){   //核心算法\n\t\t//将a[lo..mid]和a[mid+1,hi](已有序)归并 \n\t\tint i = lo, j = mid+1;\n\t\tfor(int k = lo;k<=hi;k++){ //将a[lo..hi]复制到aux[lo..hi]\n\t\t\taux[k] = a[k];\n\t\t}\n\t\tfor(int k=lo;k<=hi;k++){\n\t\t\tif(i>mid) a[k] = aux[j++];  //左半边用尽，取右半边的元素复制到a中\n\t\t\telse if(j>hi) a[k] = aux[i++];   //右半边用尽，取左半边的元素复制到a中\n\t\t\telse if(aux[i]<aux[j]) a[k] = aux[i++];  //左半边元素小于右半边元素，取左半边元素复制到a中\n\t\t\telse a[k] = aux[j++]; //右半边元素小于左半边元素，取右半边元素复制到a中\n\t\t}\n\t}\n\tpublic static void Mergesort(int a[]){   //二路归并递归算法\n\t\taux = new int [a.length];   //一次性分配空间\n\t\tsort(a,0,a.length-1);\n\t}\n\tprivate static void sort(int[] a, int lo, int hi) {\n\t\t// 将数组a[lo..hi]排序\n\t\tif(lo>=hi) return ;\n\t\tint mid = lo + (hi-lo)/2;\n\t\tsort(a,lo,mid);     //递归将左半边排序\n\t\tsort(a,mid+1,hi);   //递归将右半边排序\n\t\tmerge(a, lo, mid, hi);  //归并结果\n\t}\n\t\n\tpublic static void Mergesort1(int [] a) {  //二路归并非递归算法\n\t\t//进行lgN次两两归并\n\t\tint N = a.length;\n\t\taux = new int [N];\n\t\tfor(int sz = 1; sz<N;sz = 2*sz){  //sz的子数组大小\n\t\t\tfor(int lo =0;lo<N-sz; lo+=2*sz){  //子数组的索引\n\t\t\t\tmerge(a, lo, lo+sz-1, Math.max(lo+2*sz-1, N-1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint a[] = {2,3,5,1,4,0,7,6};\n\t\t//Mergesort(a);  //调用2-路归并递归排序函数\n\t\tMergesort1(a);  //调用2-路归并非递归排序函数\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\t}\n\t}\n}\n\n```\n\n### 一些改进\n\n1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。\n\n2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。\n\n3.不将元素复制到辅助数组（暂时不太明白）。\n\n## 快速排序\n\n### 简介\n\n快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。\n\n### 关键算法\n\n该方法的关键在于切分，这个过程使得数组满足下面的三个条件：\n\n1.对于某个j,a[j]已经排定；\n\n2.a[lo]到a[j-1]中的所有元素都不大于a[j]；\n\n3.a[j+1]到a[hi]中的所有元素都不小于a[j]。\n\n### 代码\n\n```java\npublic class QuickSort {\n\tpublic static int[] quicksort(int a[]){\n\t\tsort(a,0,a.length-1);\n\t\treturn a;\n\t}\n\tprivate static void sort(int[] a, int lo, int hi) {\n\t\tif(hi<=lo) return ;\n\t\tint j=partition(a,lo,hi);   //切分\n\t\t//第j个位置已经在它所在的排好序的位置\n\t\tsort(a,lo,j-1);\n\t\tsort(a,j+1,hi);\n\t}\n\tprivate static int partition(int[] a, int lo, int hi) {\n\t    int part = a[lo];   //切分元素\n\t    int i = lo,j=hi+1;  //左右扫描指针\n\t    int tem;\n\t    while(true){\n\t    \t//扫描左右，检查扫描是否结束并交换元素\n\t    \twhile(a[++i]<part) {  //从左到右(第一个元素除外)找到大于等于part的元素\n\t    \t\tif(i==hi) break;    \n\t    \t}\n\t    \twhile(a[--j]>part){  //从右到左找到小于等于part的元素\n\t    \t\tif(j==lo) break;\n\t    \t}\n\t    \tif(i>=j) break;\n\t    \ttem = a[i];\n\t    \ta[i] = a[j];\n\t    \ta[j] = tem;\n\t    }\n\t    tem = a[lo];   //将part=a[j]放入正确的位置\n    \ta[lo] = a[j];\n    \ta[j] = tem;\n\t\treturn j;\n\t}\n\tpublic static void main(String[] args) {\n\t\tint []a = {4,5,4,6,1,3};\n\t\ta = quicksort(a);\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tSystem.out.print(a[i]+\" \");\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n","slug":"个人总结之排序算法","published":1,"updated":"2017-12-07T07:59:00.081Z","layout":"post","photos":[],"link":"","_id":"cjcj3yig70005jgc9xewuxbuq","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中…<br><a id=\"more\"></a></p>\n<p><strong>注：</strong>这里实现的算法都是递增排序，也就是从小到大排序。</p>\n<h2 id=\"初级排序算法\"><a href=\"#初级排序算法\" class=\"headerlink\" title=\"初级排序算法\"></a>初级排序算法</h2><h3 id=\"1-选择排序\"><a href=\"#1-选择排序\" class=\"headerlink\" title=\"1.选择排序\"></a>1.选择排序</h3><p><strong>思想：</strong>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;    <span class=\"comment\">//选择排序</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> minIndex = i; <span class=\"comment\">//初始化最小元素的索引</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;length;j++)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(a[minIndex]&gt;a[j])&#123;</div><div class=\"line\">                minIndex = j;  <span class=\"comment\">//找到最小元素的索引</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> tem = a[i];</div><div class=\"line\">        a[i] = a[minIndex];</div><div class=\"line\">        a[minIndex] = tem;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-直接插入排序\"><a href=\"#2-直接插入排序\" class=\"headerlink\" title=\"2.直接插入排序\"></a>2.直接插入排序</h3><p><strong>思想：</strong> 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。<br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170821195323.png\" alt=\"\"></p>\n<p><strong>代码：</strong></p>\n<p>第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&gt;<span class=\"number\">0</span>&amp;&amp;a[j]&lt;a[j-<span class=\"number\">1</span>];j--)&#123;  </div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tem = a[j-<span class=\"number\">1</span>];</div><div class=\"line\">\t\t\ta[j-<span class=\"number\">1</span>] = a[j];</div><div class=\"line\">\t\t\ta[j] = tem;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;    <span class=\"comment\">//不需要交换的插入排序</span></div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> tem = a[i];  <span class=\"comment\">//待插入的元素</span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(j=i-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>&amp;&amp;tem&lt;a[j];j--)&#123;</div><div class=\"line\">\t\t\ta[j+<span class=\"number\">1</span>] = a[j];   <span class=\"comment\">//元素后移,直到找到待插入的元素的位置</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ta[j+<span class=\"number\">1</span>] = tem;  <span class=\"comment\">//将带插入元素插入到查找到的位置</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j&gt;0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> minIndex =<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;length;i++)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(a[minIndex]&gt;a[i])&#123;</div><div class=\"line\">\t\t\tminIndex = i;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">int</span> tem = a[<span class=\"number\">0</span>];</div><div class=\"line\">\ta[<span class=\"number\">0</span>] = a[minIndex];</div><div class=\"line\">\ta[minIndex] = tem;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;length;i++)&#123;</div><div class=\"line\">\t\ttem = a[i];</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(j=i-<span class=\"number\">1</span>;tem&lt;a[j];j--)&#123;</div><div class=\"line\">\t\t\ta[j+<span class=\"number\">1</span>] = a[j];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ta[j+<span class=\"number\">1</span>] = tem;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-希尔排序\"><a href=\"#3-希尔排序\" class=\"headerlink\" title=\"3.希尔排序\"></a>3.希尔排序</h3><p><strong>思想：</strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>\n<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>\n<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170821203528.png\" alt=\"\"></p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> h = length/<span class=\"number\">2</span>; <span class=\"comment\">//初始增量</span></div><div class=\"line\">\t<span class=\"keyword\">while</span>(h&gt;=<span class=\"number\">1</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//将数组变为h有序</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=h;i&lt;length;i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> tem = a[j-h];</div><div class=\"line\">\t\t\t\ta[j-h] = a[j];</div><div class=\"line\">\t\t\t\ta[j] = tem;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\th = h/<span class=\"number\">2</span>; <span class=\"comment\">//每次排完序后,增量减少</span></div><div class=\"line\">\t&#125;\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>参考：<a href=\"http://www.cnblogs.com/chengxiao/p/6104371.html\" target=\"_blank\" rel=\"external\">dreamcatcher-cx</a></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。</p>\n<h3 id=\"2-路归并排序\"><a href=\"#2-路归并排序\" class=\"headerlink\" title=\"2-路归并排序\"></a>2-路归并排序</h3><p><strong>2-路归并排序:</strong>假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 </p>\n<p><strong>该图显示的就是循环2-路归并排序算法的过程：</strong><br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827211130.png\" alt=\"\"></p>\n<p>2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。</p>\n<p><strong>递归算法：自顶向下的2-路归并排序中归并结果的轨迹：</strong></p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827220032.png\" alt=\"\"></p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827212542.png\" alt=\"\"></p>\n<p><strong>循环算法：自底向上的2-路归并排序中归并结果的轨迹：</strong><br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827215932.png\" alt=\"\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mergesort</span> </span>&#123;  <span class=\"comment\">//2-路归并排序</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] aux;  <span class=\"comment\">//辅助数组</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> lo,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> hi)</span></span>&#123;   <span class=\"comment\">//核心算法</span></div><div class=\"line\">\t\t<span class=\"comment\">//将a[lo..mid]和a[mid+1,hi](已有序)归并 </span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i = lo, j = mid+<span class=\"number\">1</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = lo;k&lt;=hi;k++)&#123; <span class=\"comment\">//将a[lo..hi]复制到aux[lo..hi]</span></div><div class=\"line\">\t\t\taux[k] = a[k];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=lo;k&lt;=hi;k++)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&gt;mid) a[k] = aux[j++];  <span class=\"comment\">//左半边用尽，取右半边的元素复制到a中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j&gt;hi) a[k] = aux[i++];   <span class=\"comment\">//右半边用尽，取左半边的元素复制到a中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(aux[i]&lt;aux[j]) a[k] = aux[i++];  <span class=\"comment\">//左半边元素小于右半边元素，取左半边元素复制到a中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> a[k] = aux[j++]; <span class=\"comment\">//右半边元素小于左半边元素，取右半边元素复制到a中</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Mergesort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span>&#123;   <span class=\"comment\">//二路归并递归算法</span></div><div class=\"line\">\t\taux = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span> [a.length];   <span class=\"comment\">//一次性分配空间</span></div><div class=\"line\">\t\tsort(a,<span class=\"number\">0</span>,a.length-<span class=\"number\">1</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 将数组a[lo..hi]排序</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi-lo)/<span class=\"number\">2</span>;</div><div class=\"line\">\t\tsort(a,lo,mid);     <span class=\"comment\">//递归将左半边排序</span></div><div class=\"line\">\t\tsort(a,mid+<span class=\"number\">1</span>,hi);   <span class=\"comment\">//递归将右半边排序</span></div><div class=\"line\">\t\tmerge(a, lo, mid, hi);  <span class=\"comment\">//归并结果</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Mergesort1</span><span class=\"params\">(<span class=\"keyword\">int</span> [] a)</span> </span>&#123;  <span class=\"comment\">//二路归并非递归算法</span></div><div class=\"line\">\t\t<span class=\"comment\">//进行lgN次两两归并</span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> N = a.length;</div><div class=\"line\">\t\taux = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span> [N];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> sz = <span class=\"number\">1</span>; sz&lt;N;sz = <span class=\"number\">2</span>*sz)&#123;  <span class=\"comment\">//sz的子数组大小</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo =<span class=\"number\">0</span>;lo&lt;N-sz; lo+=<span class=\"number\">2</span>*sz)&#123;  <span class=\"comment\">//子数组的索引</span></div><div class=\"line\">\t\t\t\tmerge(a, lo, lo+sz-<span class=\"number\">1</span>, Math.max(lo+<span class=\"number\">2</span>*sz-<span class=\"number\">1</span>, N-<span class=\"number\">1</span>));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>&#125;;</div><div class=\"line\">\t\t<span class=\"comment\">//Mergesort(a);  //调用2-路归并递归排序函数</span></div><div class=\"line\">\t\tMergesort1(a);  <span class=\"comment\">//调用2-路归并非递归排序函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t\tSystem.out.print(a[i]+<span class=\"string\">\" \"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"一些改进\"><a href=\"#一些改进\" class=\"headerlink\" title=\"一些改进\"></a>一些改进</h3><p>1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。</p>\n<p>2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。</p>\n<p>3.不将元素复制到辅助数组（暂时不太明白）。</p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。</p>\n<h3 id=\"关键算法\"><a href=\"#关键算法\" class=\"headerlink\" title=\"关键算法\"></a>关键算法</h3><p>该方法的关键在于切分，这个过程使得数组满足下面的三个条件：</p>\n<p>1.对于某个j,a[j]已经排定；</p>\n<p>2.a[lo]到a[j-1]中的所有元素都不大于a[j]；</p>\n<p>3.a[j+1]到a[hi]中的所有元素都不小于a[j]。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] quicksort(<span class=\"keyword\">int</span> a[])&#123;</div><div class=\"line\">\t\tsort(a,<span class=\"number\">0</span>,a.length-<span class=\"number\">1</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(hi&lt;=lo) <span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j=partition(a,lo,hi);   <span class=\"comment\">//切分</span></div><div class=\"line\">\t\t<span class=\"comment\">//第j个位置已经在它所在的排好序的位置</span></div><div class=\"line\">\t\tsort(a,lo,j-<span class=\"number\">1</span>);</div><div class=\"line\">\t\tsort(a,j+<span class=\"number\">1</span>,hi);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</div><div class=\"line\">\t    <span class=\"keyword\">int</span> part = a[lo];   <span class=\"comment\">//切分元素</span></div><div class=\"line\">\t    <span class=\"keyword\">int</span> i = lo,j=hi+<span class=\"number\">1</span>;  <span class=\"comment\">//左右扫描指针</span></div><div class=\"line\">\t    <span class=\"keyword\">int</span> tem;</div><div class=\"line\">\t    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</div><div class=\"line\">\t    \t<span class=\"comment\">//扫描左右，检查扫描是否结束并交换元素</span></div><div class=\"line\">\t    \t<span class=\"keyword\">while</span>(a[++i]&lt;part) &#123;  <span class=\"comment\">//从左到右(第一个元素除外)找到大于等于part的元素</span></div><div class=\"line\">\t    \t\t<span class=\"keyword\">if</span>(i==hi) <span class=\"keyword\">break</span>;    </div><div class=\"line\">\t    \t&#125;</div><div class=\"line\">\t    \t<span class=\"keyword\">while</span>(a[--j]&gt;part)&#123;  <span class=\"comment\">//从右到左找到小于等于part的元素</span></div><div class=\"line\">\t    \t\t<span class=\"keyword\">if</span>(j==lo) <span class=\"keyword\">break</span>;</div><div class=\"line\">\t    \t&#125;</div><div class=\"line\">\t    \t<span class=\"keyword\">if</span>(i&gt;=j) <span class=\"keyword\">break</span>;</div><div class=\"line\">\t    \ttem = a[i];</div><div class=\"line\">\t    \ta[i] = a[j];</div><div class=\"line\">\t    \ta[j] = tem;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    tem = a[lo];   <span class=\"comment\">//将part=a[j]放入正确的位置</span></div><div class=\"line\">    \ta[lo] = a[j];</div><div class=\"line\">    \ta[j] = tem;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> j;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> []a = &#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">\t\ta = quicksort(a);</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t\tSystem.out.print(a[i]+<span class=\"string\">\" \"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中…<br>","more":"</p>\n<p><strong>注：</strong>这里实现的算法都是递增排序，也就是从小到大排序。</p>\n<h2 id=\"初级排序算法\"><a href=\"#初级排序算法\" class=\"headerlink\" title=\"初级排序算法\"></a>初级排序算法</h2><h3 id=\"1-选择排序\"><a href=\"#1-选择排序\" class=\"headerlink\" title=\"1.选择排序\"></a>1.选择排序</h3><p><strong>思想：</strong>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;    <span class=\"comment\">//选择排序</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> minIndex = i; <span class=\"comment\">//初始化最小元素的索引</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;length;j++)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(a[minIndex]&gt;a[j])&#123;</div><div class=\"line\">                minIndex = j;  <span class=\"comment\">//找到最小元素的索引</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> tem = a[i];</div><div class=\"line\">        a[i] = a[minIndex];</div><div class=\"line\">        a[minIndex] = tem;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-直接插入排序\"><a href=\"#2-直接插入排序\" class=\"headerlink\" title=\"2.直接插入排序\"></a>2.直接插入排序</h3><p><strong>思想：</strong> 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。<br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170821195323.png\" alt=\"\"></p>\n<p><strong>代码：</strong></p>\n<p>第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&gt;<span class=\"number\">0</span>&amp;&amp;a[j]&lt;a[j-<span class=\"number\">1</span>];j--)&#123;  </div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> tem = a[j-<span class=\"number\">1</span>];</div><div class=\"line\">\t\t\ta[j-<span class=\"number\">1</span>] = a[j];</div><div class=\"line\">\t\t\ta[j] = tem;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;    <span class=\"comment\">//不需要交换的插入排序</span></div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> tem = a[i];  <span class=\"comment\">//待插入的元素</span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(j=i-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>&amp;&amp;tem&lt;a[j];j--)&#123;</div><div class=\"line\">\t\t\ta[j+<span class=\"number\">1</span>] = a[j];   <span class=\"comment\">//元素后移,直到找到待插入的元素的位置</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ta[j+<span class=\"number\">1</span>] = tem;  <span class=\"comment\">//将带插入元素插入到查找到的位置</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j&gt;0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> minIndex =<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;length;i++)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(a[minIndex]&gt;a[i])&#123;</div><div class=\"line\">\t\t\tminIndex = i;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">int</span> tem = a[<span class=\"number\">0</span>];</div><div class=\"line\">\ta[<span class=\"number\">0</span>] = a[minIndex];</div><div class=\"line\">\ta[minIndex] = tem;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;length;i++)&#123;</div><div class=\"line\">\t\ttem = a[i];</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(j=i-<span class=\"number\">1</span>;tem&lt;a[j];j--)&#123;</div><div class=\"line\">\t\t\ta[j+<span class=\"number\">1</span>] = a[j];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ta[j+<span class=\"number\">1</span>] = tem;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-希尔排序\"><a href=\"#3-希尔排序\" class=\"headerlink\" title=\"3.希尔排序\"></a>3.希尔排序</h3><p><strong>思想：</strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>\n<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>\n<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170821203528.png\" alt=\"\"></p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] sort(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> length)&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> h = length/<span class=\"number\">2</span>; <span class=\"comment\">//初始增量</span></div><div class=\"line\">\t<span class=\"keyword\">while</span>(h&gt;=<span class=\"number\">1</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//将数组变为h有序</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=h;i&lt;length;i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> tem = a[j-h];</div><div class=\"line\">\t\t\t\ta[j-h] = a[j];</div><div class=\"line\">\t\t\t\ta[j] = tem;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\th = h/<span class=\"number\">2</span>; <span class=\"comment\">//每次排完序后,增量减少</span></div><div class=\"line\">\t&#125;\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>参考：<a href=\"http://www.cnblogs.com/chengxiao/p/6104371.html\" target=\"_blank\" rel=\"external\">dreamcatcher-cx</a></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。</p>\n<h3 id=\"2-路归并排序\"><a href=\"#2-路归并排序\" class=\"headerlink\" title=\"2-路归并排序\"></a>2-路归并排序</h3><p><strong>2-路归并排序:</strong>假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 </p>\n<p><strong>该图显示的就是循环2-路归并排序算法的过程：</strong><br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827211130.png\" alt=\"\"></p>\n<p>2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。</p>\n<p><strong>递归算法：自顶向下的2-路归并排序中归并结果的轨迹：</strong></p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827220032.png\" alt=\"\"></p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827212542.png\" alt=\"\"></p>\n<p><strong>循环算法：自底向上的2-路归并排序中归并结果的轨迹：</strong><br><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170827215932.png\" alt=\"\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mergesort</span> </span>&#123;  <span class=\"comment\">//2-路归并排序</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> [] aux;  <span class=\"comment\">//辅助数组</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> lo,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> hi)</span></span>&#123;   <span class=\"comment\">//核心算法</span></div><div class=\"line\">\t\t<span class=\"comment\">//将a[lo..mid]和a[mid+1,hi](已有序)归并 </span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i = lo, j = mid+<span class=\"number\">1</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = lo;k&lt;=hi;k++)&#123; <span class=\"comment\">//将a[lo..hi]复制到aux[lo..hi]</span></div><div class=\"line\">\t\t\taux[k] = a[k];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=lo;k&lt;=hi;k++)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&gt;mid) a[k] = aux[j++];  <span class=\"comment\">//左半边用尽，取右半边的元素复制到a中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j&gt;hi) a[k] = aux[i++];   <span class=\"comment\">//右半边用尽，取左半边的元素复制到a中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(aux[i]&lt;aux[j]) a[k] = aux[i++];  <span class=\"comment\">//左半边元素小于右半边元素，取左半边元素复制到a中</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> a[k] = aux[j++]; <span class=\"comment\">//右半边元素小于左半边元素，取右半边元素复制到a中</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Mergesort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span>&#123;   <span class=\"comment\">//二路归并递归算法</span></div><div class=\"line\">\t\taux = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span> [a.length];   <span class=\"comment\">//一次性分配空间</span></div><div class=\"line\">\t\tsort(a,<span class=\"number\">0</span>,a.length-<span class=\"number\">1</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 将数组a[lo..hi]排序</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi-lo)/<span class=\"number\">2</span>;</div><div class=\"line\">\t\tsort(a,lo,mid);     <span class=\"comment\">//递归将左半边排序</span></div><div class=\"line\">\t\tsort(a,mid+<span class=\"number\">1</span>,hi);   <span class=\"comment\">//递归将右半边排序</span></div><div class=\"line\">\t\tmerge(a, lo, mid, hi);  <span class=\"comment\">//归并结果</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Mergesort1</span><span class=\"params\">(<span class=\"keyword\">int</span> [] a)</span> </span>&#123;  <span class=\"comment\">//二路归并非递归算法</span></div><div class=\"line\">\t\t<span class=\"comment\">//进行lgN次两两归并</span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> N = a.length;</div><div class=\"line\">\t\taux = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span> [N];</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> sz = <span class=\"number\">1</span>; sz&lt;N;sz = <span class=\"number\">2</span>*sz)&#123;  <span class=\"comment\">//sz的子数组大小</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo =<span class=\"number\">0</span>;lo&lt;N-sz; lo+=<span class=\"number\">2</span>*sz)&#123;  <span class=\"comment\">//子数组的索引</span></div><div class=\"line\">\t\t\t\tmerge(a, lo, lo+sz-<span class=\"number\">1</span>, Math.max(lo+<span class=\"number\">2</span>*sz-<span class=\"number\">1</span>, N-<span class=\"number\">1</span>));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>&#125;;</div><div class=\"line\">\t\t<span class=\"comment\">//Mergesort(a);  //调用2-路归并递归排序函数</span></div><div class=\"line\">\t\tMergesort1(a);  <span class=\"comment\">//调用2-路归并非递归排序函数</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t\tSystem.out.print(a[i]+<span class=\"string\">\" \"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"一些改进\"><a href=\"#一些改进\" class=\"headerlink\" title=\"一些改进\"></a>一些改进</h3><p>1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。</p>\n<p>2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。</p>\n<p>3.不将元素复制到辅助数组（暂时不太明白）。</p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。</p>\n<h3 id=\"关键算法\"><a href=\"#关键算法\" class=\"headerlink\" title=\"关键算法\"></a>关键算法</h3><p>该方法的关键在于切分，这个过程使得数组满足下面的三个条件：</p>\n<p>1.对于某个j,a[j]已经排定；</p>\n<p>2.a[lo]到a[j-1]中的所有元素都不大于a[j]；</p>\n<p>3.a[j+1]到a[hi]中的所有元素都不小于a[j]。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] quicksort(<span class=\"keyword\">int</span> a[])&#123;</div><div class=\"line\">\t\tsort(a,<span class=\"number\">0</span>,a.length-<span class=\"number\">1</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> a;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(hi&lt;=lo) <span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j=partition(a,lo,hi);   <span class=\"comment\">//切分</span></div><div class=\"line\">\t\t<span class=\"comment\">//第j个位置已经在它所在的排好序的位置</span></div><div class=\"line\">\t\tsort(a,lo,j-<span class=\"number\">1</span>);</div><div class=\"line\">\t\tsort(a,j+<span class=\"number\">1</span>,hi);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</div><div class=\"line\">\t    <span class=\"keyword\">int</span> part = a[lo];   <span class=\"comment\">//切分元素</span></div><div class=\"line\">\t    <span class=\"keyword\">int</span> i = lo,j=hi+<span class=\"number\">1</span>;  <span class=\"comment\">//左右扫描指针</span></div><div class=\"line\">\t    <span class=\"keyword\">int</span> tem;</div><div class=\"line\">\t    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</div><div class=\"line\">\t    \t<span class=\"comment\">//扫描左右，检查扫描是否结束并交换元素</span></div><div class=\"line\">\t    \t<span class=\"keyword\">while</span>(a[++i]&lt;part) &#123;  <span class=\"comment\">//从左到右(第一个元素除外)找到大于等于part的元素</span></div><div class=\"line\">\t    \t\t<span class=\"keyword\">if</span>(i==hi) <span class=\"keyword\">break</span>;    </div><div class=\"line\">\t    \t&#125;</div><div class=\"line\">\t    \t<span class=\"keyword\">while</span>(a[--j]&gt;part)&#123;  <span class=\"comment\">//从右到左找到小于等于part的元素</span></div><div class=\"line\">\t    \t\t<span class=\"keyword\">if</span>(j==lo) <span class=\"keyword\">break</span>;</div><div class=\"line\">\t    \t&#125;</div><div class=\"line\">\t    \t<span class=\"keyword\">if</span>(i&gt;=j) <span class=\"keyword\">break</span>;</div><div class=\"line\">\t    \ttem = a[i];</div><div class=\"line\">\t    \ta[i] = a[j];</div><div class=\"line\">\t    \ta[j] = tem;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    tem = a[lo];   <span class=\"comment\">//将part=a[j]放入正确的位置</span></div><div class=\"line\">    \ta[lo] = a[j];</div><div class=\"line\">    \ta[j] = tem;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> j;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> []a = &#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">\t\ta = quicksort(a);</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</div><div class=\"line\">\t\t\tSystem.out.print(a[i]+<span class=\"string\">\" \"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"函数基础","date":"2017-10-19T02:59:00.000Z","update":null,"comments":1,"_content":"\n# 函数基础\n\n一个典型的函数定义包括以下部分：**返回类型、函数名、由0个或多个形参组成的列表以及函数体**。\n<!--more-->\n\n函数的调用完成两项工作：**一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数**。此时，主调函数的执行被暂时中断，被调函数开始执行。\n\n## 形参和实参\n\n函数有几个形参，我们就必须提供相同数量的实参。\n\n## 局部对象\n\n形参和函数体内部定义的变量（含｛｝块域）统称为**局部变量**。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。\n\n## 自动对象\n\n对于普通局部变量对应的对象来说, 当函数的控制路径经过变量定义语句时创建该对象, 当到达定义所在的块末尾时销毁它. **我们把只存在于块执行期间的对象称为自动对象**, 当块的执行结束后, 块中创建的自动对象的值就变成未定义的了.\n\n形参是一种自动对象, 函数开始时候为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以函数终止, 形参被销毁.\n\n对于局部变量对应的自动对象来说, 分两种情况：\n如果变量定义本身含初始值, 就用这个初始值初始化;否则, 如果变量定义本身不含初始值, 执行默认初始化.意味着内置类型的未初始化局部变量将产生未定义的值.\n\n## 局部静态对象\n\n当有些时候, **有必要令局部变量的生命周期贯穿函数调用及之后的时间**,可以将局部变量定义为**static 类型**, 局部静态变量在程序执行路径第一次经过对象定义语句时候初始化,并直到程序终止才被销毁。\n\n```C++\nsize_t count_calls()\n{\n   static size_t ctr=0;\n   eturn ++ctr;\n}\n\nint main()\n{\n    for(size_t i=0; i!=10; i++)\n        cout<< count_calls() << endl;\n    return 0;\n}\n```\n\n在控制流第一次经过ctr的定义之前, ctr被创建且初始化为0; 每次调用ctr加1. 每次执行函数, 变量ctr的值已经存在并等于函数上一次退出的时候的值。\n\n## 函数声明\n\n函数只能定义一次，但可以声明多次。（有例外），如果一个函数永远不可能给我们用到，那他可以只有声明没有定义。\n\n函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息，函数声明也称作**函数原型**。\n\n**best practices:** 在头文件中进行函数声明，含有函数声明的头文件应该包含到定义函数的源文件中。\n\n\n## 分离式编译\n\n分离式编译，C++允许我们将程序分割到几个文件中去，每个文件独立编译。\n\n**简单的示例：**\n\n**目录树：**\n\n    source \n          facc.cpp\n          main.cpp\n    header\n          myHead.h\n\n```C++\n//facc.cpp\n#include <iostream>\n#include \"MyHead.h\"     //定义fac函数，肯定要包含其声明\nusing namespace std;\nint fac(int n){\n    if (n==1){\n        return 1;\n    }else {\n        return n*fac(n-1);\n    }\n}\n\n//main.cpp\n#include <iostream>\n#include \"MyHead.h\"     //使用fac，肯定也要包含其声明\nusing namespace std;\n\nint main()\n{\n    cout<<fac(5)<<endl;\n    return 0;\n}\n\n//myHead.h    //头文件中只有函数的声明\n#ifndef MYHEAD_H_INCLUDED\n#define MYHEAD_H_INCLUDED\nint fac(int n);     \n#endif // MYHEAD_H_INCLUDED\n```\n\n\n## const形参和实参\n\n实参初始化形参会忽略掉顶层const，也就是当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。\n\n我们可以使用非常量初始化底层const，但是反过来不行。\n\n\n# 数组形参\n\n**数组的两个特殊点：** \n- 不允许拷贝数组，所以不可以使用传值的方式使用数组参数(传值即为拷贝)。\n- 通常数组的传递使用的是指针形式，传递的是指针的首地址。\n\n尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式：\n\n```C++\n//尽管形式不同，但这三个print函数是等价的\n//每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);\nvoid print(const int[10]) //这里的维度表示我们期望数组含有多少元素，实际不一定\n```\n\n当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型：\n\n```C++\nint i = 2;\nint j[2] = {1,2};\nprint(&i);  //正确，&i的类型是int*\nprint(j);   //正确，j被转换成int*并指向j[0]\n```\n\n如果我们传给print函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。\n\n**由于数组实际上是以指针的形式传递给函数的，因此一开始函数并不知道数组的确切尺寸，调用者应该为此提供额外的一些信息。** \n\n管理指针形参有三种常用的技术：\n\n**1.使用标记指定数组长度**\n\n这种方法要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符就停止：\n\n```C++\nvoid print(const char *cp)\n{\n    if(cp){     //若cp不是空指针\n        while(*cp){     //只要指针所指字符不是空字符\n            cout<<*cp++;    //输出当前字符并将指针前移\n        }\n    }\n}\n```\n\n这个方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。\n\n**2.显示传递一个表示数组大小的形参**\n\n这种方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。\n\n```C++\n//const int ia[]等价于const int *ia\n//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问\nvoid print(const int ia[],size_t size)\n{\n    for(size_t i = 0; i != size; ++i){\n        cout<<ia[i]<<\" \";\n    }\n}\n```\n\n这种方法通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值：\n```C++\nint j[] = {1,2,3};\nprint(j,3);\n```\n\n**3.使用标准库函数begin和end**\n\nC++11标准引入两个名为begin和end的函数，begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一位置的指针，这两个函数定义在iterator头文件中。\n示例代码如下：\n```C++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int arr[] = {1,2,3,4,5,6,7,8,9,-1,5,3,4};\n\n    int *pbeg = begin(arr);     //指向arr首元素的指针\n    int *pend = end(arr);       //指向arr尾元素的指针\n\n    //寻找第一个负值元素，如果已经检查完全部元素则结束循环\n    while(pbeg != pend && *pbeg >= 0){\n        ++pbeg;\n    }\n    cout<<*pbeg<<endl;  //输出第一个负数的值\n}\n```\n对于本文的print函数，可以写成如下形式:\n\n```C++\nvoid print(const int *beg, const int *end)\n{\n    //输出beg到end之间（不含end）的所有元素\n    while(beg != end)\n        cout<<*beg++<<\" \";\n}\n```\n\n为了调用这两个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。使用方法如下：\n```C++\nint a[] = {1,2,3};\nprint(begin(j),end(j));\n```\n\n## 数组形参和const\n\n当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。\n\n## 数组引用形参\n\n形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上：\n\n```C++\nvoid print(int (&arr)[10]) {\n    for(auto elem : arr){\n        cout<<elem<<endl;\n    }\n}\n```\n\n**注意：**\n```C++\nf(int &arr[10])//错误,将arr声明为引用的数组\nf(int (&arr)[10])//正确, arr是有10个整形的数组引用\n```\n\n## 传递多维数组\n\n和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，**所以首元素本身就是一个数组，指针就是指向数组的指针，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分, 不能省略:**\n\n```C++\n//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowsize){...}\n//等价于\nvoid print(int matrix[][10], int rowsize){...}\n```\n\n我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。\n\n\n## main: 处理命令行选项\n\n\nC/C++语言中的main函数，经常带有参数argc，argv，如下：\n\n```C++\nint main(int argc, char** argv)\nint main(int argc, char* argv[])\n```\n\n第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。\n\n**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。**\n\n下面的程序演示argc和argv的使用：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc,char *argv[])\n{\n    int i;\n    for (i=0; i < argc; i++) {\n        cout<<\"Argument \"<<i<<\" is \"<<argv[i]<<endl;\n    }\n    return 0;\n}\n```\n\n假如上述代码编译为hello.exe，那么运行\nhello.exe a b c d e\n\n将得到\n\n    Argument 0 is hello.exe.\n    Argument 1 is a.\n    Argument 2 is b.\n    Argument 3 is c.\n    Argument 4 is d.\n    Argument 5 is e.\n    \n## 含有可变形参的参数（先知道有这么个东西，后面详细了解）\n\n\n## 返回函数指针\n\n# 函数重载（重点，待完善）\n\n**对于函数重载来说，形参数量或形参类型上有所不同。**\n\n**不允许两个函数除了返回类型外，其他所有的要素都相同。**\n\n# 特殊用途语言特性\n\n## 默认实参\n\n知识点1：函数反复调用的过程中重复出现的形参，这样的值被称为默认实参。该参数在使用过程中可以被用户指定，也可以使用默认数值\n\n知识点2：调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。\n\n知识点3：一旦某个形参被赋予了默认值，其后所有形参都必须有默认值。\n\n知识点4：顺序很重要！在设计函数时，将默认值的形参放在后面。\n\n知识点5：在给定的作用域中，一个形参只能被赋予一次默认实参，且局部变量不能作为默认实参。\n\n## 内联函数（inline）\n\n调用函数函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。\n\n**内联函数可以避免函数调用的开销。**\n\n将函数指定为“内联函数(inline)”，将它在每个调用点上“内联的展开”，该说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。一般来说，内联的机制用于优化规模较小、流程直接、频繁调用的函数，建议不大于75行。\n\n## constexpr函数\n\nconstexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。\n\n```C++\nconstexpr int new_sz(){ return 42;}\nconstexpr int foo = new_sz();     //正确：foo是一个常量表达式\n```\n\nconstexpr函数不一定返回常量表达式\n\n## 程序的调试帮助：assert和NDEBUG\n\n知识点1：预处理宏assert(expr)：包含一个表达式，expr为真时，assert什么也不做，为假时输出信息并终止程序。包含在cassert头文件中。通常用于检查不能发生的条件\n\n知识点2：assert依赖于一个NDEBUG的预处理变量的状态，如果定义了NDEBUG，assert什么也不做，默认状态下NDEBUG是未定义的。编译器也可以预先定义该变量。\n\n知识点3：也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef到#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略。\n\n```C++\nvoid pp()  \n{  \n    #ifndef NDEBUG  \n        cerr<<\"my name is:\"<<__func__<<endl;  \n    #endif  \n    //其他代码  \n} \n```\n\n一些C++编译器定义的调试有用的名字：\n\n_ _func_ _ :一个静态数组，存放函数的名字\n\n_ _FILE_ _ :存放文件名的字符串字面值\n\n_ _LINE_ _ :存放当前行号的整形字面值\n\n_ _TIME_ _ :存放文件编译时间的字符串字面值\n\n_ _DATE_ _ :存放文件编译日期的字符串字面值\n\n\n## 函数匹配\n\n1. 首先确定**候选函数**：候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。\n2. 接着选出**可行函数**：可行函数具备两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。\n\n如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。\n\n如果没有找到可行函数，编译器将报告无匹配函数的错误。\n\n3.寻找**最佳匹配**：它的基本思想是，**实参类型与形参类型越接近，他们匹配得越好**。\n\n编译器一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：\n\n- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。\n- 至少有一个实参的匹配优于其他可行函数提供的匹配。\n\n如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。\n\n\n# 函数指针\n\n函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：\n```C++\nbool lengthCompare(const string &,const string &);\n```\n\n该函数的类型是bool(const string&,const string&)。**要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可**。\n\n```\n//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型\nbool (*pf) const string& ,const string &);     //未初始化\n```\n\n从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。\n\n**注意：** *pf两端的括号必不可少。\n\n知识点2：当我们把函数名当作一个值使用时，函数自动的转换为指针，直接赋予或者取址皆可。可以直接使用只想该函数的指针调用该函数。\n\n知识点3：给指针赋予nullptr或者0时，指针不指向任何函数。\n\n知识点4：函数重载时，指针的类型必须与重载函数精确匹配，包括形参类型数量和返回值类型。\n\n知识点5：虽然不能返回一个函数，但是可以返回一个指向函数的指针。\n\n## 返回指向函数的指针\n\n```C++\nint (*f1(int)) (int *,int)\n```\n\n我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.\n\n出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。\n\n```C++\nauto f1(int)  -> int (*)(int *,int);\n```\n\n## 例子\n\n```C++\n#include <iostream>  \n#include<string>  \n#include<vector>  \nusing namespace std;  \n      \nint add(int a, int b)  \n{  \n    return a+b;  \n}  \nint subtract(int a, int b) { return a - b; }  \nint multiply(int a, int b) { return a * b; }  \nint divide(int a, int b) { return b != 0 ? a / b : 0; }//声明定义函数  \n      \nint main(int argc, char** argv)  \n{  \n    typedef int(*p)(int a, int b);  //声明函数指针，未初始化,p为指向函数的指针。使用typedef的声明语句定义的不再是变量而是类型别名  \n    //就是将变量转化为类型别名的一种方式，p原来是指向函数的指针变量，现在变成了指向函数的指针变量的类型别名  \n    vector<p> vec{add, subtract, multiply, divide};//vector初始化的C++11新特性  \n    for (auto f : vec)  \n        cout << f(2, 2) <<endl;  \n    return 0;  \n} \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/函数基础.md","raw":"---\ntitle: 函数基础\ndate: 2017-10-19 10:59:00\nupdate: \ntags: [函数]\ncategories: C++\ncomments: true\n---\n\n# 函数基础\n\n一个典型的函数定义包括以下部分：**返回类型、函数名、由0个或多个形参组成的列表以及函数体**。\n<!--more-->\n\n函数的调用完成两项工作：**一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数**。此时，主调函数的执行被暂时中断，被调函数开始执行。\n\n## 形参和实参\n\n函数有几个形参，我们就必须提供相同数量的实参。\n\n## 局部对象\n\n形参和函数体内部定义的变量（含｛｝块域）统称为**局部变量**。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。\n\n## 自动对象\n\n对于普通局部变量对应的对象来说, 当函数的控制路径经过变量定义语句时创建该对象, 当到达定义所在的块末尾时销毁它. **我们把只存在于块执行期间的对象称为自动对象**, 当块的执行结束后, 块中创建的自动对象的值就变成未定义的了.\n\n形参是一种自动对象, 函数开始时候为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以函数终止, 形参被销毁.\n\n对于局部变量对应的自动对象来说, 分两种情况：\n如果变量定义本身含初始值, 就用这个初始值初始化;否则, 如果变量定义本身不含初始值, 执行默认初始化.意味着内置类型的未初始化局部变量将产生未定义的值.\n\n## 局部静态对象\n\n当有些时候, **有必要令局部变量的生命周期贯穿函数调用及之后的时间**,可以将局部变量定义为**static 类型**, 局部静态变量在程序执行路径第一次经过对象定义语句时候初始化,并直到程序终止才被销毁。\n\n```C++\nsize_t count_calls()\n{\n   static size_t ctr=0;\n   eturn ++ctr;\n}\n\nint main()\n{\n    for(size_t i=0; i!=10; i++)\n        cout<< count_calls() << endl;\n    return 0;\n}\n```\n\n在控制流第一次经过ctr的定义之前, ctr被创建且初始化为0; 每次调用ctr加1. 每次执行函数, 变量ctr的值已经存在并等于函数上一次退出的时候的值。\n\n## 函数声明\n\n函数只能定义一次，但可以声明多次。（有例外），如果一个函数永远不可能给我们用到，那他可以只有声明没有定义。\n\n函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息，函数声明也称作**函数原型**。\n\n**best practices:** 在头文件中进行函数声明，含有函数声明的头文件应该包含到定义函数的源文件中。\n\n\n## 分离式编译\n\n分离式编译，C++允许我们将程序分割到几个文件中去，每个文件独立编译。\n\n**简单的示例：**\n\n**目录树：**\n\n    source \n          facc.cpp\n          main.cpp\n    header\n          myHead.h\n\n```C++\n//facc.cpp\n#include <iostream>\n#include \"MyHead.h\"     //定义fac函数，肯定要包含其声明\nusing namespace std;\nint fac(int n){\n    if (n==1){\n        return 1;\n    }else {\n        return n*fac(n-1);\n    }\n}\n\n//main.cpp\n#include <iostream>\n#include \"MyHead.h\"     //使用fac，肯定也要包含其声明\nusing namespace std;\n\nint main()\n{\n    cout<<fac(5)<<endl;\n    return 0;\n}\n\n//myHead.h    //头文件中只有函数的声明\n#ifndef MYHEAD_H_INCLUDED\n#define MYHEAD_H_INCLUDED\nint fac(int n);     \n#endif // MYHEAD_H_INCLUDED\n```\n\n\n## const形参和实参\n\n实参初始化形参会忽略掉顶层const，也就是当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。\n\n我们可以使用非常量初始化底层const，但是反过来不行。\n\n\n# 数组形参\n\n**数组的两个特殊点：** \n- 不允许拷贝数组，所以不可以使用传值的方式使用数组参数(传值即为拷贝)。\n- 通常数组的传递使用的是指针形式，传递的是指针的首地址。\n\n尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式：\n\n```C++\n//尽管形式不同，但这三个print函数是等价的\n//每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);\nvoid print(const int[10]) //这里的维度表示我们期望数组含有多少元素，实际不一定\n```\n\n当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型：\n\n```C++\nint i = 2;\nint j[2] = {1,2};\nprint(&i);  //正确，&i的类型是int*\nprint(j);   //正确，j被转换成int*并指向j[0]\n```\n\n如果我们传给print函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。\n\n**由于数组实际上是以指针的形式传递给函数的，因此一开始函数并不知道数组的确切尺寸，调用者应该为此提供额外的一些信息。** \n\n管理指针形参有三种常用的技术：\n\n**1.使用标记指定数组长度**\n\n这种方法要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符就停止：\n\n```C++\nvoid print(const char *cp)\n{\n    if(cp){     //若cp不是空指针\n        while(*cp){     //只要指针所指字符不是空字符\n            cout<<*cp++;    //输出当前字符并将指针前移\n        }\n    }\n}\n```\n\n这个方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。\n\n**2.显示传递一个表示数组大小的形参**\n\n这种方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。\n\n```C++\n//const int ia[]等价于const int *ia\n//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问\nvoid print(const int ia[],size_t size)\n{\n    for(size_t i = 0; i != size; ++i){\n        cout<<ia[i]<<\" \";\n    }\n}\n```\n\n这种方法通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值：\n```C++\nint j[] = {1,2,3};\nprint(j,3);\n```\n\n**3.使用标准库函数begin和end**\n\nC++11标准引入两个名为begin和end的函数，begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一位置的指针，这两个函数定义在iterator头文件中。\n示例代码如下：\n```C++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int arr[] = {1,2,3,4,5,6,7,8,9,-1,5,3,4};\n\n    int *pbeg = begin(arr);     //指向arr首元素的指针\n    int *pend = end(arr);       //指向arr尾元素的指针\n\n    //寻找第一个负值元素，如果已经检查完全部元素则结束循环\n    while(pbeg != pend && *pbeg >= 0){\n        ++pbeg;\n    }\n    cout<<*pbeg<<endl;  //输出第一个负数的值\n}\n```\n对于本文的print函数，可以写成如下形式:\n\n```C++\nvoid print(const int *beg, const int *end)\n{\n    //输出beg到end之间（不含end）的所有元素\n    while(beg != end)\n        cout<<*beg++<<\" \";\n}\n```\n\n为了调用这两个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。使用方法如下：\n```C++\nint a[] = {1,2,3};\nprint(begin(j),end(j));\n```\n\n## 数组形参和const\n\n当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。\n\n## 数组引用形参\n\n形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上：\n\n```C++\nvoid print(int (&arr)[10]) {\n    for(auto elem : arr){\n        cout<<elem<<endl;\n    }\n}\n```\n\n**注意：**\n```C++\nf(int &arr[10])//错误,将arr声明为引用的数组\nf(int (&arr)[10])//正确, arr是有10个整形的数组引用\n```\n\n## 传递多维数组\n\n和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，**所以首元素本身就是一个数组，指针就是指向数组的指针，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分, 不能省略:**\n\n```C++\n//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowsize){...}\n//等价于\nvoid print(int matrix[][10], int rowsize){...}\n```\n\n我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。\n\n\n## main: 处理命令行选项\n\n\nC/C++语言中的main函数，经常带有参数argc，argv，如下：\n\n```C++\nint main(int argc, char** argv)\nint main(int argc, char* argv[])\n```\n\n第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。\n\n**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。**\n\n下面的程序演示argc和argv的使用：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc,char *argv[])\n{\n    int i;\n    for (i=0; i < argc; i++) {\n        cout<<\"Argument \"<<i<<\" is \"<<argv[i]<<endl;\n    }\n    return 0;\n}\n```\n\n假如上述代码编译为hello.exe，那么运行\nhello.exe a b c d e\n\n将得到\n\n    Argument 0 is hello.exe.\n    Argument 1 is a.\n    Argument 2 is b.\n    Argument 3 is c.\n    Argument 4 is d.\n    Argument 5 is e.\n    \n## 含有可变形参的参数（先知道有这么个东西，后面详细了解）\n\n\n## 返回函数指针\n\n# 函数重载（重点，待完善）\n\n**对于函数重载来说，形参数量或形参类型上有所不同。**\n\n**不允许两个函数除了返回类型外，其他所有的要素都相同。**\n\n# 特殊用途语言特性\n\n## 默认实参\n\n知识点1：函数反复调用的过程中重复出现的形参，这样的值被称为默认实参。该参数在使用过程中可以被用户指定，也可以使用默认数值\n\n知识点2：调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。\n\n知识点3：一旦某个形参被赋予了默认值，其后所有形参都必须有默认值。\n\n知识点4：顺序很重要！在设计函数时，将默认值的形参放在后面。\n\n知识点5：在给定的作用域中，一个形参只能被赋予一次默认实参，且局部变量不能作为默认实参。\n\n## 内联函数（inline）\n\n调用函数函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。\n\n**内联函数可以避免函数调用的开销。**\n\n将函数指定为“内联函数(inline)”，将它在每个调用点上“内联的展开”，该说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。一般来说，内联的机制用于优化规模较小、流程直接、频繁调用的函数，建议不大于75行。\n\n## constexpr函数\n\nconstexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。\n\n```C++\nconstexpr int new_sz(){ return 42;}\nconstexpr int foo = new_sz();     //正确：foo是一个常量表达式\n```\n\nconstexpr函数不一定返回常量表达式\n\n## 程序的调试帮助：assert和NDEBUG\n\n知识点1：预处理宏assert(expr)：包含一个表达式，expr为真时，assert什么也不做，为假时输出信息并终止程序。包含在cassert头文件中。通常用于检查不能发生的条件\n\n知识点2：assert依赖于一个NDEBUG的预处理变量的状态，如果定义了NDEBUG，assert什么也不做，默认状态下NDEBUG是未定义的。编译器也可以预先定义该变量。\n\n知识点3：也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef到#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略。\n\n```C++\nvoid pp()  \n{  \n    #ifndef NDEBUG  \n        cerr<<\"my name is:\"<<__func__<<endl;  \n    #endif  \n    //其他代码  \n} \n```\n\n一些C++编译器定义的调试有用的名字：\n\n_ _func_ _ :一个静态数组，存放函数的名字\n\n_ _FILE_ _ :存放文件名的字符串字面值\n\n_ _LINE_ _ :存放当前行号的整形字面值\n\n_ _TIME_ _ :存放文件编译时间的字符串字面值\n\n_ _DATE_ _ :存放文件编译日期的字符串字面值\n\n\n## 函数匹配\n\n1. 首先确定**候选函数**：候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。\n2. 接着选出**可行函数**：可行函数具备两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。\n\n如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。\n\n如果没有找到可行函数，编译器将报告无匹配函数的错误。\n\n3.寻找**最佳匹配**：它的基本思想是，**实参类型与形参类型越接近，他们匹配得越好**。\n\n编译器一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：\n\n- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。\n- 至少有一个实参的匹配优于其他可行函数提供的匹配。\n\n如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。\n\n\n# 函数指针\n\n函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：\n```C++\nbool lengthCompare(const string &,const string &);\n```\n\n该函数的类型是bool(const string&,const string&)。**要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可**。\n\n```\n//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型\nbool (*pf) const string& ,const string &);     //未初始化\n```\n\n从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。\n\n**注意：** *pf两端的括号必不可少。\n\n知识点2：当我们把函数名当作一个值使用时，函数自动的转换为指针，直接赋予或者取址皆可。可以直接使用只想该函数的指针调用该函数。\n\n知识点3：给指针赋予nullptr或者0时，指针不指向任何函数。\n\n知识点4：函数重载时，指针的类型必须与重载函数精确匹配，包括形参类型数量和返回值类型。\n\n知识点5：虽然不能返回一个函数，但是可以返回一个指向函数的指针。\n\n## 返回指向函数的指针\n\n```C++\nint (*f1(int)) (int *,int)\n```\n\n我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.\n\n出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。\n\n```C++\nauto f1(int)  -> int (*)(int *,int);\n```\n\n## 例子\n\n```C++\n#include <iostream>  \n#include<string>  \n#include<vector>  \nusing namespace std;  \n      \nint add(int a, int b)  \n{  \n    return a+b;  \n}  \nint subtract(int a, int b) { return a - b; }  \nint multiply(int a, int b) { return a * b; }  \nint divide(int a, int b) { return b != 0 ? a / b : 0; }//声明定义函数  \n      \nint main(int argc, char** argv)  \n{  \n    typedef int(*p)(int a, int b);  //声明函数指针，未初始化,p为指向函数的指针。使用typedef的声明语句定义的不再是变量而是类型别名  \n    //就是将变量转化为类型别名的一种方式，p原来是指向函数的指针变量，现在变成了指向函数的指针变量的类型别名  \n    vector<p> vec{add, subtract, multiply, divide};//vector初始化的C++11新特性  \n    for (auto f : vec)  \n        cout << f(2, 2) <<endl;  \n    return 0;  \n} \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"函数基础","published":1,"updated":"2018-01-16T13:11:28.527Z","layout":"post","photos":[],"link":"","_id":"cjcj3yigc0006jgc9gbvyvs9n","content":"<h1 id=\"函数基础\"><a href=\"#函数基础\" class=\"headerlink\" title=\"函数基础\"></a>函数基础</h1><p>一个典型的函数定义包括以下部分：<strong>返回类型、函数名、由0个或多个形参组成的列表以及函数体</strong>。<br><a id=\"more\"></a></p>\n<p>函数的调用完成两项工作：<strong>一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数</strong>。此时，主调函数的执行被暂时中断，被调函数开始执行。</p>\n<h2 id=\"形参和实参\"><a href=\"#形参和实参\" class=\"headerlink\" title=\"形参和实参\"></a>形参和实参</h2><p>函数有几个形参，我们就必须提供相同数量的实参。</p>\n<h2 id=\"局部对象\"><a href=\"#局部对象\" class=\"headerlink\" title=\"局部对象\"></a>局部对象</h2><p>形参和函数体内部定义的变量（含｛｝块域）统称为<strong>局部变量</strong>。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。</p>\n<h2 id=\"自动对象\"><a href=\"#自动对象\" class=\"headerlink\" title=\"自动对象\"></a>自动对象</h2><p>对于普通局部变量对应的对象来说, 当函数的控制路径经过变量定义语句时创建该对象, 当到达定义所在的块末尾时销毁它. <strong>我们把只存在于块执行期间的对象称为自动对象</strong>, 当块的执行结束后, 块中创建的自动对象的值就变成未定义的了.</p>\n<p>形参是一种自动对象, 函数开始时候为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以函数终止, 形参被销毁.</p>\n<p>对于局部变量对应的自动对象来说, 分两种情况：<br>如果变量定义本身含初始值, 就用这个初始值初始化;否则, 如果变量定义本身不含初始值, 执行默认初始化.意味着内置类型的未初始化局部变量将产生未定义的值.</p>\n<h2 id=\"局部静态对象\"><a href=\"#局部静态对象\" class=\"headerlink\" title=\"局部静态对象\"></a>局部静态对象</h2><p>当有些时候, <strong>有必要令局部变量的生命周期贯穿函数调用及之后的时间</strong>,可以将局部变量定义为<strong>static 类型</strong>, 局部静态变量在程序执行路径第一次经过对象定义语句时候初始化,并直到程序终止才被销毁。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> count_calls()</div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> ctr=<span class=\"number\">0</span>;</div><div class=\"line\">   eturn ++ctr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">0</span>; i!=<span class=\"number\">10</span>; i++)</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; count_calls() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在控制流第一次经过ctr的定义之前, ctr被创建且初始化为0; 每次调用ctr加1. 每次执行函数, 变量ctr的值已经存在并等于函数上一次退出的时候的值。</p>\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>函数只能定义一次，但可以声明多次。（有例外），如果一个函数永远不可能给我们用到，那他可以只有声明没有定义。</p>\n<p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息，函数声明也称作<strong>函数原型</strong>。</p>\n<p><strong>best practices:</strong> 在头文件中进行函数声明，含有函数声明的头文件应该包含到定义函数的源文件中。</p>\n<h2 id=\"分离式编译\"><a href=\"#分离式编译\" class=\"headerlink\" title=\"分离式编译\"></a>分离式编译</h2><p>分离式编译，C++允许我们将程序分割到几个文件中去，每个文件独立编译。</p>\n<p><strong>简单的示例：</strong></p>\n<p><strong>目录树：</strong></p>\n<pre><code>source \n      facc.cpp\n      main.cpp\nheader\n      myHead.h\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//facc.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyHead.h\"</span>     <span class=\"comment\">//定义fac函数，肯定要包含其声明</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fac</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> n*fac(n<span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyHead.h\"</span>     <span class=\"comment\">//使用fac，肯定也要包含其声明</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;fac(<span class=\"number\">5</span>)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//myHead.h    //头文件中只有函数的声明</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYHEAD_H_INCLUDED</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYHEAD_H_INCLUDED</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fac</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;     </div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// MYHEAD_H_INCLUDED</span></span></div></pre></td></tr></table></figure>\n<h2 id=\"const形参和实参\"><a href=\"#const形参和实参\" class=\"headerlink\" title=\"const形参和实参\"></a>const形参和实参</h2><p>实参初始化形参会忽略掉顶层const，也就是当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。</p>\n<p>我们可以使用非常量初始化底层const，但是反过来不行。</p>\n<h1 id=\"数组形参\"><a href=\"#数组形参\" class=\"headerlink\" title=\"数组形参\"></a>数组形参</h1><p><strong>数组的两个特殊点：</strong> </p>\n<ul>\n<li>不允许拷贝数组，所以不可以使用传值的方式使用数组参数(传值即为拷贝)。</li>\n<li>通常数组的传递使用的是指针形式，传递的是指针的首地址。</li>\n</ul>\n<p>尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//尽管形式不同，但这三个print函数是等价的</span></div><div class=\"line\"><span class=\"comment\">//每个函数都有一个const int*类型的形参</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>*)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>[])</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>])</span> <span class=\"comment\">//这里的维度表示我们期望数组含有多少元素，实际不一定</span></span></div></pre></td></tr></table></figure>\n<p>当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> j[<span class=\"number\">2</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</div><div class=\"line\">print(&amp;i);  <span class=\"comment\">//正确，&amp;i的类型是int*</span></div><div class=\"line\">print(j);   <span class=\"comment\">//正确，j被转换成int*并指向j[0]</span></div></pre></td></tr></table></figure>\n<p>如果我们传给print函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。</p>\n<p><strong>由于数组实际上是以指针的形式传递给函数的，因此一开始函数并不知道数组的确切尺寸，调用者应该为此提供额外的一些信息。</strong> </p>\n<p>管理指针形参有三种常用的技术：</p>\n<p><strong>1.使用标记指定数组长度</strong></p>\n<p>这种方法要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符就停止：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cp)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(cp)&#123;     <span class=\"comment\">//若cp不是空指针</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(*cp)&#123;     <span class=\"comment\">//只要指针所指字符不是空字符</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;*cp++;    <span class=\"comment\">//输出当前字符并将指针前移</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。</p>\n<p><strong>2.显示传递一个表示数组大小的形参</strong></p>\n<p>这种方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//const int ia[]等价于const int *ia</span></div><div class=\"line\"><span class=\"comment\">//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ia[],<span class=\"keyword\">size_t</span> size)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i != size; ++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ia[i]&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">print(j,<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p><strong>3.使用标准库函数begin和end</strong></p>\n<p>C++11标准引入两个名为begin和end的函数，begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一位置的指针，这两个函数定义在iterator头文件中。<br>示例代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">-1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> *pbeg = begin(arr);     <span class=\"comment\">//指向arr首元素的指针</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *pend = end(arr);       <span class=\"comment\">//指向arr尾元素的指针</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//寻找第一个负值元素，如果已经检查完全部元素则结束循环</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(pbeg != pend &amp;&amp; *pbeg &gt;= <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        ++pbeg;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*pbeg&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//输出第一个负数的值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>对于本文的print函数，可以写成如下形式:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *beg, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *end)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//输出beg到end之间（不含end）的所有元素</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(beg != end)</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;*beg++&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了调用这两个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。使用方法如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">print(begin(j),end(j));</div></pre></td></tr></table></figure></p>\n<h2 id=\"数组形参和const\"><a href=\"#数组形参和const\" class=\"headerlink\" title=\"数组形参和const\"></a>数组形参和const</h2><p>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。</p>\n<h2 id=\"数组引用形参\"><a href=\"#数组引用形参\" class=\"headerlink\" title=\"数组引用形参\"></a>数组引用形参</h2><p>形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void print(int (&amp;arr)[10]) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> elem : arr)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;elem&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">f(<span class=\"keyword\">int</span> &amp;arr[<span class=\"number\">10</span>])<span class=\"comment\">//错误,将arr声明为引用的数组</span></div><div class=\"line\">f(<span class=\"keyword\">int</span> (&amp;arr)[<span class=\"number\">10</span>])<span class=\"comment\">//正确, arr是有10个整形的数组引用</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"传递多维数组\"><a href=\"#传递多维数组\" class=\"headerlink\" title=\"传递多维数组\"></a>传递多维数组</h2><p>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，<strong>所以首元素本身就是一个数组，指针就是指向数组的指针，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分, 不能省略:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></div><div class=\"line\">void print(int (*matrix)[10], int rowsize)&#123;...&#125;</div><div class=\"line\"><span class=\"comment\">//等价于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> matrix[][<span class=\"number\">10</span>], <span class=\"keyword\">int</span> rowsize)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。</p>\n<h2 id=\"main-处理命令行选项\"><a href=\"#main-处理命令行选项\" class=\"headerlink\" title=\"main: 处理命令行选项\"></a>main: 处理命令行选项</h2><p>C/C++语言中的main函数，经常带有参数argc，argv，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></div></pre></td></tr></table></figure>\n<p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。</p>\n<p><strong>当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。</strong></p>\n<p>下面的程序演示argc和argv的使用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt; argc; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Argument \"</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\" is \"</span>&lt;&lt;argv[i]&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假如上述代码编译为hello.exe，那么运行<br>hello.exe a b c d e</p>\n<p>将得到</p>\n<pre><code>Argument 0 is hello.exe.\nArgument 1 is a.\nArgument 2 is b.\nArgument 3 is c.\nArgument 4 is d.\nArgument 5 is e.\n</code></pre><h2 id=\"含有可变形参的参数（先知道有这么个东西，后面详细了解）\"><a href=\"#含有可变形参的参数（先知道有这么个东西，后面详细了解）\" class=\"headerlink\" title=\"含有可变形参的参数（先知道有这么个东西，后面详细了解）\"></a>含有可变形参的参数（先知道有这么个东西，后面详细了解）</h2><h2 id=\"返回函数指针\"><a href=\"#返回函数指针\" class=\"headerlink\" title=\"返回函数指针\"></a>返回函数指针</h2><h1 id=\"函数重载（重点，待完善）\"><a href=\"#函数重载（重点，待完善）\" class=\"headerlink\" title=\"函数重载（重点，待完善）\"></a>函数重载（重点，待完善）</h1><p><strong>对于函数重载来说，形参数量或形参类型上有所不同。</strong></p>\n<p><strong>不允许两个函数除了返回类型外，其他所有的要素都相同。</strong></p>\n<h1 id=\"特殊用途语言特性\"><a href=\"#特殊用途语言特性\" class=\"headerlink\" title=\"特殊用途语言特性\"></a>特殊用途语言特性</h1><h2 id=\"默认实参\"><a href=\"#默认实参\" class=\"headerlink\" title=\"默认实参\"></a>默认实参</h2><p>知识点1：函数反复调用的过程中重复出现的形参，这样的值被称为默认实参。该参数在使用过程中可以被用户指定，也可以使用默认数值</p>\n<p>知识点2：调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p>\n<p>知识点3：一旦某个形参被赋予了默认值，其后所有形参都必须有默认值。</p>\n<p>知识点4：顺序很重要！在设计函数时，将默认值的形参放在后面。</p>\n<p>知识点5：在给定的作用域中，一个形参只能被赋予一次默认实参，且局部变量不能作为默认实参。</p>\n<h2 id=\"内联函数（inline）\"><a href=\"#内联函数（inline）\" class=\"headerlink\" title=\"内联函数（inline）\"></a>内联函数（inline）</h2><p>调用函数函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。</p>\n<p><strong>内联函数可以避免函数调用的开销。</strong></p>\n<p>将函数指定为“内联函数(inline)”，将它在每个调用点上“内联的展开”，该说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。一般来说，内联的机制用于优化规模较小、流程直接、频繁调用的函数，建议不大于75行。</p>\n<h2 id=\"constexpr函数\"><a href=\"#constexpr函数\" class=\"headerlink\" title=\"constexpr函数\"></a>constexpr函数</h2><p>constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> <span class=\"title\">new_sz</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">42</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> foo = new_sz();     <span class=\"comment\">//正确：foo是一个常量表达式</span></div></pre></td></tr></table></figure>\n<p>constexpr函数不一定返回常量表达式</p>\n<h2 id=\"程序的调试帮助：assert和NDEBUG\"><a href=\"#程序的调试帮助：assert和NDEBUG\" class=\"headerlink\" title=\"程序的调试帮助：assert和NDEBUG\"></a>程序的调试帮助：assert和NDEBUG</h2><p>知识点1：预处理宏assert(expr)：包含一个表达式，expr为真时，assert什么也不做，为假时输出信息并终止程序。包含在cassert头文件中。通常用于检查不能发生的条件</p>\n<p>知识点2：assert依赖于一个NDEBUG的预处理变量的状态，如果定义了NDEBUG，assert什么也不做，默认状态下NDEBUG是未定义的。编译器也可以预先定义该变量。</p>\n<p>知识点3：也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef到#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pp</span><span class=\"params\">()</span>  </span></div><div class=\"line\"><span class=\"function\"></span>&#123;  </div><div class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NDEBUG  </span></div><div class=\"line\">        <span class=\"built_in\">cerr</span>&lt;&lt;<span class=\"string\">\"my name is:\"</span>&lt;&lt;__func__&lt;&lt;<span class=\"built_in\">endl</span>;  </div><div class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></div><div class=\"line\">    <span class=\"comment\">//其他代码  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一些C++编译器定义的调试有用的名字：</p>\n<p>_ <em>func</em> _ :一个静态数组，存放函数的名字</p>\n<p>_ <em>FILE</em> _ :存放文件名的字符串字面值</p>\n<p>_ <em>LINE</em> _ :存放当前行号的整形字面值</p>\n<p>_ <em>TIME</em> _ :存放文件编译时间的字符串字面值</p>\n<p>_ <em>DATE</em> _ :存放文件编译日期的字符串字面值</p>\n<h2 id=\"函数匹配\"><a href=\"#函数匹配\" class=\"headerlink\" title=\"函数匹配\"></a>函数匹配</h2><ol>\n<li>首先确定<strong>候选函数</strong>：候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。</li>\n<li>接着选出<strong>可行函数</strong>：可行函数具备两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</li>\n</ol>\n<p>如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。</p>\n<p>如果没有找到可行函数，编译器将报告无匹配函数的错误。</p>\n<p>3.寻找<strong>最佳匹配</strong>：它的基本思想是，<strong>实参类型与形参类型越接近，他们匹配得越好</strong>。</p>\n<p>编译器一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：</p>\n<ul>\n<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>\n<li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>\n</ul>\n<p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。</p>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">lengthCompare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;,<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>该函数的类型是bool(const string&amp;,const string&amp;)。<strong>要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型</div><div class=\"line\">bool (*pf) const string&amp; ,const string &amp;);     //未初始化</div></pre></td></tr></table></figure>\n<p>从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。</p>\n<p><strong>注意：</strong> *pf两端的括号必不可少。</p>\n<p>知识点2：当我们把函数名当作一个值使用时，函数自动的转换为指针，直接赋予或者取址皆可。可以直接使用只想该函数的指针调用该函数。</p>\n<p>知识点3：给指针赋予nullptr或者0时，指针不指向任何函数。</p>\n<p>知识点4：函数重载时，指针的类型必须与重载函数精确匹配，包括形参类型数量和返回值类型。</p>\n<p>知识点5：虽然不能返回一个函数，但是可以返回一个指向函数的指针。</p>\n<h2 id=\"返回指向函数的指针\"><a href=\"#返回指向函数的指针\" class=\"headerlink\" title=\"返回指向函数的指针\"></a>返回指向函数的指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> (*f1(<span class=\"keyword\">int</span>)) (<span class=\"keyword\">int</span> *,<span class=\"keyword\">int</span>)</div></pre></td></tr></table></figure>\n<p>我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.</p>\n<p>出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto f1(int)  -&gt; int (*)(int *,int);</div></pre></td></tr></table></figure>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;  </span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;  </span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </div><div class=\"line\">      </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span>  </span></div><div class=\"line\"><span class=\"function\"></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> a+b;  </div><div class=\"line\">&#125;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subtract</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a - b; &#125;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a * b; &#125;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> b != <span class=\"number\">0</span> ? a / b : <span class=\"number\">0</span>; &#125;<span class=\"comment\">//声明定义函数  </span></div><div class=\"line\">      </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span>  </span></div><div class=\"line\"><span class=\"function\"></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span><span class=\"params\">(*p)</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;  <span class=\"comment\">//声明函数指针，未初始化,p为指向函数的指针。使用typedef的声明语句定义的不再是变量而是类型别名  </span></div><div class=\"line\">    <span class=\"comment\">//就是将变量转化为类型别名的一种方式，p原来是指向函数的指针变量，现在变成了指向函数的指针变量的类型别名  </span></div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;p&gt; vec&#123;add, subtract, multiply, divide&#125;;<span class=\"comment\">//vector初始化的C++11新特性  </span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> f : vec)  </div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; f(<span class=\"number\">2</span>, <span class=\"number\">2</span>) &lt;&lt;<span class=\"built_in\">endl</span>;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"函数基础\"><a href=\"#函数基础\" class=\"headerlink\" title=\"函数基础\"></a>函数基础</h1><p>一个典型的函数定义包括以下部分：<strong>返回类型、函数名、由0个或多个形参组成的列表以及函数体</strong>。<br>","more":"</p>\n<p>函数的调用完成两项工作：<strong>一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数</strong>。此时，主调函数的执行被暂时中断，被调函数开始执行。</p>\n<h2 id=\"形参和实参\"><a href=\"#形参和实参\" class=\"headerlink\" title=\"形参和实参\"></a>形参和实参</h2><p>函数有几个形参，我们就必须提供相同数量的实参。</p>\n<h2 id=\"局部对象\"><a href=\"#局部对象\" class=\"headerlink\" title=\"局部对象\"></a>局部对象</h2><p>形参和函数体内部定义的变量（含｛｝块域）统称为<strong>局部变量</strong>。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。</p>\n<h2 id=\"自动对象\"><a href=\"#自动对象\" class=\"headerlink\" title=\"自动对象\"></a>自动对象</h2><p>对于普通局部变量对应的对象来说, 当函数的控制路径经过变量定义语句时创建该对象, 当到达定义所在的块末尾时销毁它. <strong>我们把只存在于块执行期间的对象称为自动对象</strong>, 当块的执行结束后, 块中创建的自动对象的值就变成未定义的了.</p>\n<p>形参是一种自动对象, 函数开始时候为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以函数终止, 形参被销毁.</p>\n<p>对于局部变量对应的自动对象来说, 分两种情况：<br>如果变量定义本身含初始值, 就用这个初始值初始化;否则, 如果变量定义本身不含初始值, 执行默认初始化.意味着内置类型的未初始化局部变量将产生未定义的值.</p>\n<h2 id=\"局部静态对象\"><a href=\"#局部静态对象\" class=\"headerlink\" title=\"局部静态对象\"></a>局部静态对象</h2><p>当有些时候, <strong>有必要令局部变量的生命周期贯穿函数调用及之后的时间</strong>,可以将局部变量定义为<strong>static 类型</strong>, 局部静态变量在程序执行路径第一次经过对象定义语句时候初始化,并直到程序终止才被销毁。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> count_calls()</div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> ctr=<span class=\"number\">0</span>;</div><div class=\"line\">   eturn ++ctr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">0</span>; i!=<span class=\"number\">10</span>; i++)</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; count_calls() &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在控制流第一次经过ctr的定义之前, ctr被创建且初始化为0; 每次调用ctr加1. 每次执行函数, 变量ctr的值已经存在并等于函数上一次退出的时候的值。</p>\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>函数只能定义一次，但可以声明多次。（有例外），如果一个函数永远不可能给我们用到，那他可以只有声明没有定义。</p>\n<p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息，函数声明也称作<strong>函数原型</strong>。</p>\n<p><strong>best practices:</strong> 在头文件中进行函数声明，含有函数声明的头文件应该包含到定义函数的源文件中。</p>\n<h2 id=\"分离式编译\"><a href=\"#分离式编译\" class=\"headerlink\" title=\"分离式编译\"></a>分离式编译</h2><p>分离式编译，C++允许我们将程序分割到几个文件中去，每个文件独立编译。</p>\n<p><strong>简单的示例：</strong></p>\n<p><strong>目录树：</strong></p>\n<pre><code>source \n      facc.cpp\n      main.cpp\nheader\n      myHead.h\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//facc.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyHead.h\"</span>     <span class=\"comment\">//定义fac函数，肯定要包含其声明</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fac</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> n*fac(n<span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.cpp</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyHead.h\"</span>     <span class=\"comment\">//使用fac，肯定也要包含其声明</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;fac(<span class=\"number\">5</span>)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//myHead.h    //头文件中只有函数的声明</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYHEAD_H_INCLUDED</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYHEAD_H_INCLUDED</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fac</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;     </div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// MYHEAD_H_INCLUDED</span></span></div></pre></td></tr></table></figure>\n<h2 id=\"const形参和实参\"><a href=\"#const形参和实参\" class=\"headerlink\" title=\"const形参和实参\"></a>const形参和实参</h2><p>实参初始化形参会忽略掉顶层const，也就是当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。</p>\n<p>我们可以使用非常量初始化底层const，但是反过来不行。</p>\n<h1 id=\"数组形参\"><a href=\"#数组形参\" class=\"headerlink\" title=\"数组形参\"></a>数组形参</h1><p><strong>数组的两个特殊点：</strong> </p>\n<ul>\n<li>不允许拷贝数组，所以不可以使用传值的方式使用数组参数(传值即为拷贝)。</li>\n<li>通常数组的传递使用的是指针形式，传递的是指针的首地址。</li>\n</ul>\n<p>尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//尽管形式不同，但这三个print函数是等价的</span></div><div class=\"line\"><span class=\"comment\">//每个函数都有一个const int*类型的形参</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>*)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>[])</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>])</span> <span class=\"comment\">//这里的维度表示我们期望数组含有多少元素，实际不一定</span></span></div></pre></td></tr></table></figure>\n<p>当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> j[<span class=\"number\">2</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</div><div class=\"line\">print(&amp;i);  <span class=\"comment\">//正确，&amp;i的类型是int*</span></div><div class=\"line\">print(j);   <span class=\"comment\">//正确，j被转换成int*并指向j[0]</span></div></pre></td></tr></table></figure>\n<p>如果我们传给print函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。</p>\n<p><strong>由于数组实际上是以指针的形式传递给函数的，因此一开始函数并不知道数组的确切尺寸，调用者应该为此提供额外的一些信息。</strong> </p>\n<p>管理指针形参有三种常用的技术：</p>\n<p><strong>1.使用标记指定数组长度</strong></p>\n<p>这种方法要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符就停止：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cp)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(cp)&#123;     <span class=\"comment\">//若cp不是空指针</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(*cp)&#123;     <span class=\"comment\">//只要指针所指字符不是空字符</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;*cp++;    <span class=\"comment\">//输出当前字符并将指针前移</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。</p>\n<p><strong>2.显示传递一个表示数组大小的形参</strong></p>\n<p>这种方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//const int ia[]等价于const int *ia</span></div><div class=\"line\"><span class=\"comment\">//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ia[],<span class=\"keyword\">size_t</span> size)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i != size; ++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ia[i]&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> j[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">print(j,<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p><strong>3.使用标准库函数begin和end</strong></p>\n<p>C++11标准引入两个名为begin和end的函数，begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一位置的指针，这两个函数定义在iterator头文件中。<br>示例代码如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">-1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> *pbeg = begin(arr);     <span class=\"comment\">//指向arr首元素的指针</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *pend = end(arr);       <span class=\"comment\">//指向arr尾元素的指针</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//寻找第一个负值元素，如果已经检查完全部元素则结束循环</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(pbeg != pend &amp;&amp; *pbeg &gt;= <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        ++pbeg;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*pbeg&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//输出第一个负数的值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>对于本文的print函数，可以写成如下形式:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *beg, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *end)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//输出beg到end之间（不含end）的所有元素</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(beg != end)</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;*beg++&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了调用这两个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。使用方法如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">print(begin(j),end(j));</div></pre></td></tr></table></figure></p>\n<h2 id=\"数组形参和const\"><a href=\"#数组形参和const\" class=\"headerlink\" title=\"数组形参和const\"></a>数组形参和const</h2><p>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。</p>\n<h2 id=\"数组引用形参\"><a href=\"#数组引用形参\" class=\"headerlink\" title=\"数组引用形参\"></a>数组引用形参</h2><p>形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void print(int (&amp;arr)[10]) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> elem : arr)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;elem&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">f(<span class=\"keyword\">int</span> &amp;arr[<span class=\"number\">10</span>])<span class=\"comment\">//错误,将arr声明为引用的数组</span></div><div class=\"line\">f(<span class=\"keyword\">int</span> (&amp;arr)[<span class=\"number\">10</span>])<span class=\"comment\">//正确, arr是有10个整形的数组引用</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"传递多维数组\"><a href=\"#传递多维数组\" class=\"headerlink\" title=\"传递多维数组\"></a>传递多维数组</h2><p>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，<strong>所以首元素本身就是一个数组，指针就是指向数组的指针，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分, 不能省略:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></div><div class=\"line\">void print(int (*matrix)[10], int rowsize)&#123;...&#125;</div><div class=\"line\"><span class=\"comment\">//等价于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> matrix[][<span class=\"number\">10</span>], <span class=\"keyword\">int</span> rowsize)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。</p>\n<h2 id=\"main-处理命令行选项\"><a href=\"#main-处理命令行选项\" class=\"headerlink\" title=\"main: 处理命令行选项\"></a>main: 处理命令行选项</h2><p>C/C++语言中的main函数，经常带有参数argc，argv，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></div></pre></td></tr></table></figure>\n<p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。</p>\n<p><strong>当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。</strong></p>\n<p>下面的程序演示argc和argv的使用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt; argc; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Argument \"</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\" is \"</span>&lt;&lt;argv[i]&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假如上述代码编译为hello.exe，那么运行<br>hello.exe a b c d e</p>\n<p>将得到</p>\n<pre><code>Argument 0 is hello.exe.\nArgument 1 is a.\nArgument 2 is b.\nArgument 3 is c.\nArgument 4 is d.\nArgument 5 is e.\n</code></pre><h2 id=\"含有可变形参的参数（先知道有这么个东西，后面详细了解）\"><a href=\"#含有可变形参的参数（先知道有这么个东西，后面详细了解）\" class=\"headerlink\" title=\"含有可变形参的参数（先知道有这么个东西，后面详细了解）\"></a>含有可变形参的参数（先知道有这么个东西，后面详细了解）</h2><h2 id=\"返回函数指针\"><a href=\"#返回函数指针\" class=\"headerlink\" title=\"返回函数指针\"></a>返回函数指针</h2><h1 id=\"函数重载（重点，待完善）\"><a href=\"#函数重载（重点，待完善）\" class=\"headerlink\" title=\"函数重载（重点，待完善）\"></a>函数重载（重点，待完善）</h1><p><strong>对于函数重载来说，形参数量或形参类型上有所不同。</strong></p>\n<p><strong>不允许两个函数除了返回类型外，其他所有的要素都相同。</strong></p>\n<h1 id=\"特殊用途语言特性\"><a href=\"#特殊用途语言特性\" class=\"headerlink\" title=\"特殊用途语言特性\"></a>特殊用途语言特性</h1><h2 id=\"默认实参\"><a href=\"#默认实参\" class=\"headerlink\" title=\"默认实参\"></a>默认实参</h2><p>知识点1：函数反复调用的过程中重复出现的形参，这样的值被称为默认实参。该参数在使用过程中可以被用户指定，也可以使用默认数值</p>\n<p>知识点2：调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p>\n<p>知识点3：一旦某个形参被赋予了默认值，其后所有形参都必须有默认值。</p>\n<p>知识点4：顺序很重要！在设计函数时，将默认值的形参放在后面。</p>\n<p>知识点5：在给定的作用域中，一个形参只能被赋予一次默认实参，且局部变量不能作为默认实参。</p>\n<h2 id=\"内联函数（inline）\"><a href=\"#内联函数（inline）\" class=\"headerlink\" title=\"内联函数（inline）\"></a>内联函数（inline）</h2><p>调用函数函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。</p>\n<p><strong>内联函数可以避免函数调用的开销。</strong></p>\n<p>将函数指定为“内联函数(inline)”，将它在每个调用点上“内联的展开”，该说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。一般来说，内联的机制用于优化规模较小、流程直接、频繁调用的函数，建议不大于75行。</p>\n<h2 id=\"constexpr函数\"><a href=\"#constexpr函数\" class=\"headerlink\" title=\"constexpr函数\"></a>constexpr函数</h2><p>constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> <span class=\"title\">new_sz</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">42</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> foo = new_sz();     <span class=\"comment\">//正确：foo是一个常量表达式</span></div></pre></td></tr></table></figure>\n<p>constexpr函数不一定返回常量表达式</p>\n<h2 id=\"程序的调试帮助：assert和NDEBUG\"><a href=\"#程序的调试帮助：assert和NDEBUG\" class=\"headerlink\" title=\"程序的调试帮助：assert和NDEBUG\"></a>程序的调试帮助：assert和NDEBUG</h2><p>知识点1：预处理宏assert(expr)：包含一个表达式，expr为真时，assert什么也不做，为假时输出信息并终止程序。包含在cassert头文件中。通常用于检查不能发生的条件</p>\n<p>知识点2：assert依赖于一个NDEBUG的预处理变量的状态，如果定义了NDEBUG，assert什么也不做，默认状态下NDEBUG是未定义的。编译器也可以预先定义该变量。</p>\n<p>知识点3：也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef到#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pp</span><span class=\"params\">()</span>  </span></div><div class=\"line\"><span class=\"function\"></span>&#123;  </div><div class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NDEBUG  </span></div><div class=\"line\">        <span class=\"built_in\">cerr</span>&lt;&lt;<span class=\"string\">\"my name is:\"</span>&lt;&lt;__func__&lt;&lt;<span class=\"built_in\">endl</span>;  </div><div class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></div><div class=\"line\">    <span class=\"comment\">//其他代码  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一些C++编译器定义的调试有用的名字：</p>\n<p>_ <em>func</em> _ :一个静态数组，存放函数的名字</p>\n<p>_ <em>FILE</em> _ :存放文件名的字符串字面值</p>\n<p>_ <em>LINE</em> _ :存放当前行号的整形字面值</p>\n<p>_ <em>TIME</em> _ :存放文件编译时间的字符串字面值</p>\n<p>_ <em>DATE</em> _ :存放文件编译日期的字符串字面值</p>\n<h2 id=\"函数匹配\"><a href=\"#函数匹配\" class=\"headerlink\" title=\"函数匹配\"></a>函数匹配</h2><ol>\n<li>首先确定<strong>候选函数</strong>：候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。</li>\n<li>接着选出<strong>可行函数</strong>：可行函数具备两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</li>\n</ol>\n<p>如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。</p>\n<p>如果没有找到可行函数，编译器将报告无匹配函数的错误。</p>\n<p>3.寻找<strong>最佳匹配</strong>：它的基本思想是，<strong>实参类型与形参类型越接近，他们匹配得越好</strong>。</p>\n<p>编译器一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：</p>\n<ul>\n<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>\n<li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>\n</ul>\n<p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。</p>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">lengthCompare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;,<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>该函数的类型是bool(const string&amp;,const string&amp;)。<strong>要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型</div><div class=\"line\">bool (*pf) const string&amp; ,const string &amp;);     //未初始化</div></pre></td></tr></table></figure>\n<p>从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。</p>\n<p><strong>注意：</strong> *pf两端的括号必不可少。</p>\n<p>知识点2：当我们把函数名当作一个值使用时，函数自动的转换为指针，直接赋予或者取址皆可。可以直接使用只想该函数的指针调用该函数。</p>\n<p>知识点3：给指针赋予nullptr或者0时，指针不指向任何函数。</p>\n<p>知识点4：函数重载时，指针的类型必须与重载函数精确匹配，包括形参类型数量和返回值类型。</p>\n<p>知识点5：虽然不能返回一个函数，但是可以返回一个指向函数的指针。</p>\n<h2 id=\"返回指向函数的指针\"><a href=\"#返回指向函数的指针\" class=\"headerlink\" title=\"返回指向函数的指针\"></a>返回指向函数的指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> (*f1(<span class=\"keyword\">int</span>)) (<span class=\"keyword\">int</span> *,<span class=\"keyword\">int</span>)</div></pre></td></tr></table></figure>\n<p>我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int.</p>\n<p>出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto f1(int)  -&gt; int (*)(int *,int);</div></pre></td></tr></table></figure>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;  </span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;  </span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </div><div class=\"line\">      </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span>  </span></div><div class=\"line\"><span class=\"function\"></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> a+b;  </div><div class=\"line\">&#125;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subtract</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a - b; &#125;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a * b; &#125;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> b != <span class=\"number\">0</span> ? a / b : <span class=\"number\">0</span>; &#125;<span class=\"comment\">//声明定义函数  </span></div><div class=\"line\">      </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span>  </span></div><div class=\"line\"><span class=\"function\"></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span><span class=\"params\">(*p)</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;  <span class=\"comment\">//声明函数指针，未初始化,p为指向函数的指针。使用typedef的声明语句定义的不再是变量而是类型别名  </span></div><div class=\"line\">    <span class=\"comment\">//就是将变量转化为类型别名的一种方式，p原来是指向函数的指针变量，现在变成了指向函数的指针变量的类型别名  </span></div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;p&gt; vec&#123;add, subtract, multiply, divide&#125;;<span class=\"comment\">//vector初始化的C++11新特性  </span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> f : vec)  </div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; f(<span class=\"number\">2</span>, <span class=\"number\">2</span>) &lt;&lt;<span class=\"built_in\">endl</span>;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"牛客网-剑指offer","date":"2017-08-19T01:30:25.000Z","update":null,"comments":1,"_content":"\n# 前言\n牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：[点击查看](https://www.nowcoder.com/ta/coding-interviews)\n<!--more-->\n## 题目一：二维数组中的查找   （数组）\n\n**题目描述:**在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n**思路：**矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。\n\n**注：**时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。\n\n**代码：**\n\n```java\npublic class Solution {\n    public boolean Find(int target, int [][] array) {\n        if(array[0].length==0) { //[[]]的情况\n            return false;\n        }   //判断二维数组是否为空\n        for(int i=0;i<array.length;i++) {\n            // 找出target所在二维数组的行\n            if(target>=array[i][0]&&target<=array[i][array[i].length-1]) {\n                //找到所在行之后，因为该行是有序的，此时使用二分查找即可\n                int low = 0;\n                int high = array[i].length-1;\n                int mid;\n                while(low<=high) {\n                    mid = (high + low)/2;\n                    if(array[i][mid]>target) {\n                        high = mid - 1;\n                    }else if(array[i][mid]<target){\n                        low = mid + 1;\n                    }else {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n## 题目二：替换空格  （字符串）\n\n**题目描述:**请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n**思路：**\n\n**第一种：** 直接用StringBuffer提供的replace函数。(不可取，得自己搞)\n\n```java\nreplace(int start, int end, String str);\n```\n\nReplaces the characters in a substring of this sequence with characters in the specified String.\n\n**第二种：** 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，**从后向前**遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。\n\n**注：**从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。\n\n**代码：**\n\n```java\npublic class Solution {\n    public String replaceSpace(StringBuffer str) {\n        int oldlength = str.length()-1;\n        int newlength = oldlength;  //替换之后新数组的大小\n        for(int i=0;i<str.length();i++) {\n            if(str.charAt(i)==' '){\n                newlength += 2;   //由一个' '变为\"%20\",长度增加2\n            }\n        }\n        str.setLength(newlength+1);  //扩展str的长度,多余的位置是空字符\n        //此时oldlength和newlength都是数组的长度-1\n        for(;oldlength>=0&&oldlength<newlength;oldlength--){\n            if(str.charAt(oldlength)==' '){\n                str.setCharAt(newlength--, '0');\n                str.setCharAt(newlength--, '2');\n                str.setCharAt(newlength--, '%');\n            }else{\n                str.setCharAt(newlength--, str.charAt(oldlength));\n            }\n        }\n        return str.toString();\n    }\n}\n```\n## 题目三：从尾到头打印链表 （链表）\n\n**题目描述:**输入一个链表，从尾到头打印链表每个节点的值。\n\n**思路：**\n\n**第一种：** 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low)\n\n**第二种：** 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。\n\n**代码：**\n\n```java\n/**\n*    public class ListNode {\n*        int val;\n*        ListNode next = null;\n*\n*        ListNode(int val) {\n*            this.val = val;\n*        }\n*    }\n*\n*/\nimport java.util.ArrayList;\npublic class Solution {\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        ArrayList<Integer> vals = new ArrayList<>();\n        int count=0;\n        while(listNode != null) {\n            vals.add(listNode.val);\n            listNode = listNode.next;\n            count++;\n        }\n        for(int i=0;i<count/2;i++) {\n            int tem = vals.get(i);\n            vals.set(i, vals.get(count-i-1));\n            vals.set(count-i-1, tem);\n        }\n        return vals;  \n    }\n}\n```\n\n```java\npublic class linklist{\n    public static ArrayList<Integer> vals = new ArrayList<>();\n    public static void printListFromTailToHead(ListNode listNode) {\n        if(listNode != null) {\n            printListFromTailToHead(listNode.next);\n    \t    vals.add(listNode.val);\n        }\n    }\n    //return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。\n}\n```\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170819204904.png)\n\n## 题目四：重建二叉树 （树）\n\n## 题目五：用两个栈实现队列 （栈、队列）\n\n**题目描述:**用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n\n**思路：**\n \n入队push:将元素进栈A。\n\n出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。\n\n**注：** 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。\n\n**代码：**\n\n```java\npublic class Solution {\n    Stack<Integer> stack1 = new Stack<Integer>();\n    Stack<Integer> stack2 = new Stack<Integer>();\n     \n    public void push(int node) {\n        stack1.push(node);\n    }\n     \n    public int pop() {\n        while(stack1.empty()&&stack2.empty()){\n            System.out.println(\"队列为空!\");\n        }\n        if(stack2.empty()){\n            while(!stack1.empty()){\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n}\n```\n## 题目十一：二进制中1的个数 （位运算）\n**题目描述:**输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n\n**思路：**\n\n**方法一：** 通过n&n-1可以消除整数最右边的1。多次执行n=n&n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。\n\n**分析：**为啥n&n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。\n\n    n=12          1100 \n    n-1=11        1011\n    n=12&11       1000\n    n=8           1000\n    n-1=7         0111\n    n=8&7         0000\n\n**代码：**\n```java\npublic int NumberOf1(int n) {  \n    int count = 0;\n    while(n!=0){\n        n &= n-1;\n        count++;\n    }\n    return count;\n}\n```\n\n更多参考点击：[算法-求二进制数中1的个数](http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html)\n\n## 题目十二：数值的整数次方 （代码的完整性）\n**题目：**给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n\n**思路：**\n\n**方法一：**估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。\n\n**方法二：** **快速幂**，快速幂能将复杂度降至O(logb)，确实是快了不少。\n\n原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下：\n\na^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)\\*a^(2^1)\\*a^(2^3)\n\n通过使用&和>>位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。\n\n更多信息：[快速幂](http://www.cnblogs.com/CXCXCXC/p/4641812.html)\n\n**代码：**\n```java\npublic class Solution {\n    public double Power(double base, int exponent) {\n        double result = 1.0;\n        int e = exponent;\n        exponent = Math.abs(exponent);\n        if(exponent == 0){\n            return result;\n        }\n        while(exponent!=0){\n            if((exponent&1)==1){\n                result *= base;\n            }\n            base *= base;    //每移动一位，该为代表的乘数都翻倍\n            exponent = exponent >> 1;  //右移一位\n        }\n        return e>0?result:1/result;    \n    }\n}\n```\n\n\n## 题目十三：调整数组顺序使奇数位于偶数前面 （数组）\n**题目描述:**输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n**思路：**\n\n**方法一：** 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。\n\n**方法二：**重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。\n\n**代码：**\n```java\npublic class Solution {\n    public void reOrderArray(int [] array) {\n        for(int i=1;i<array.length;i++){\n    \t    if(array[i]%2==0){  //偶数的话，继续下一个数\n                continue;\n    \t    }else{   \n                int tem = array[i];  //保存待插入到偶数之前的奇数\n                int j;\n                for(j=i-1;j>=0&&(array[j]%2==0);j--){  //找到偶数之前插入的位置\n                    array[j+1] = array[j];  //偶数集体后移一位\n                }\n                array[j+1] = tem;  //将奇数插入到该位置上\n            }\n    \t}      \n    }\n}\n```\n\n## 题目十四：链表中倒数第k个结点\n**题目描述:**输入一个链表，输出该链表中倒数第k个结点。\n\n**思路：** 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count>=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。\n\n**代码：**\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n \n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode FindKthToTail(ListNode head,int k) {\n        int count = 0;\n        ListNode p = head;\n        ListNode node = null;  //head为空，返回null\n        if(k<=0) return node;  //k<=0无效，返回null\n        while(head!=null){\n            count++;\n            head = head.next;\n            if(count >= k) {  //相对第一个元素为k-1的间隔时,head和p同时往后走\n                node = p;\n                p = p.next;\n            }\n        }\n        return node;\n    }\n}\n```\n\n## 题目十五：反转链表\n**题目描述:**输入一个链表，反转链表后，输出链表的所有元素。\n\n**思路：** 依次遍历每个结点，同时通过头插法再重新创建新的链表\n\n**注：**可以利用之前的结点，而不需要重新创建新的结点，以后改进。\n\n**代码：**\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n \n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        ListNode p = null;\n        if(head == null) {\n            return p;\n        }else{\n            p = new ListNode(head.val);\n        }\n        ListNode q = head.next;\n        while(q!=null){\n            ListNode s = new ListNode(q.val);\n            s.next = p;\n            p = s;\n            q = q.next;\n        }\n        return p;\n    }\n}\n```\n\n\n## 题目十六：合并两个排序的链表\n**题目描述:**输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n\n**思路：** 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。\n\n**注：**可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。\n\n**代码：**\n\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n \n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode Merge(ListNode list1,ListNode list2) {\n        ListNode p = new ListNode(0);  //创建一个头结点,数据域初始化为0，不存储数据,指针域为null\n        ListNode head = p ;  //头指针,指向头结点\n        if(list1 == null && list2 == null) return null;\n        while(list1!=null && list2!=null){\n            if(list1.val < list2.val){\n                ListNode s = new ListNode(list1.val);\n                p.next = s;\n                p = s;\n                list1 = list1.next;\n                 \n            }else {\n                ListNode s = new ListNode(list2.val);\n                p.next = s;\n                p = s;\n                list2 = list2.next;\n            }\n        }\n        while(list1!=null){\n            ListNode s = new ListNode(list1.val);\n            p.next = s;\n            p = s;\n            list1 = list1.next;\n        }\n        while(list2!=null){\n            ListNode s = new ListNode(list2.val);\n            p.next = s;\n            p = s;\n            list2 = list2.next;\n        }\n        return head.next;  //头结点不存储元素,head.next指向第一个元素节点，返回 \n    }\n}\n```","source":"_posts/剑指offer.md","raw":"---\ntitle: 牛客网-剑指offer\ndate: 2017-08-19 9:30:25\nupdate:\ntags: [剑指offer,刷题,编程]\ncategories: 刷题\ncomments: true\n---\n\n# 前言\n牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：[点击查看](https://www.nowcoder.com/ta/coding-interviews)\n<!--more-->\n## 题目一：二维数组中的查找   （数组）\n\n**题目描述:**在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n**思路：**矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。\n\n**注：**时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。\n\n**代码：**\n\n```java\npublic class Solution {\n    public boolean Find(int target, int [][] array) {\n        if(array[0].length==0) { //[[]]的情况\n            return false;\n        }   //判断二维数组是否为空\n        for(int i=0;i<array.length;i++) {\n            // 找出target所在二维数组的行\n            if(target>=array[i][0]&&target<=array[i][array[i].length-1]) {\n                //找到所在行之后，因为该行是有序的，此时使用二分查找即可\n                int low = 0;\n                int high = array[i].length-1;\n                int mid;\n                while(low<=high) {\n                    mid = (high + low)/2;\n                    if(array[i][mid]>target) {\n                        high = mid - 1;\n                    }else if(array[i][mid]<target){\n                        low = mid + 1;\n                    }else {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n## 题目二：替换空格  （字符串）\n\n**题目描述:**请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n**思路：**\n\n**第一种：** 直接用StringBuffer提供的replace函数。(不可取，得自己搞)\n\n```java\nreplace(int start, int end, String str);\n```\n\nReplaces the characters in a substring of this sequence with characters in the specified String.\n\n**第二种：** 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，**从后向前**遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。\n\n**注：**从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。\n\n**代码：**\n\n```java\npublic class Solution {\n    public String replaceSpace(StringBuffer str) {\n        int oldlength = str.length()-1;\n        int newlength = oldlength;  //替换之后新数组的大小\n        for(int i=0;i<str.length();i++) {\n            if(str.charAt(i)==' '){\n                newlength += 2;   //由一个' '变为\"%20\",长度增加2\n            }\n        }\n        str.setLength(newlength+1);  //扩展str的长度,多余的位置是空字符\n        //此时oldlength和newlength都是数组的长度-1\n        for(;oldlength>=0&&oldlength<newlength;oldlength--){\n            if(str.charAt(oldlength)==' '){\n                str.setCharAt(newlength--, '0');\n                str.setCharAt(newlength--, '2');\n                str.setCharAt(newlength--, '%');\n            }else{\n                str.setCharAt(newlength--, str.charAt(oldlength));\n            }\n        }\n        return str.toString();\n    }\n}\n```\n## 题目三：从尾到头打印链表 （链表）\n\n**题目描述:**输入一个链表，从尾到头打印链表每个节点的值。\n\n**思路：**\n\n**第一种：** 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low)\n\n**第二种：** 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。\n\n**代码：**\n\n```java\n/**\n*    public class ListNode {\n*        int val;\n*        ListNode next = null;\n*\n*        ListNode(int val) {\n*            this.val = val;\n*        }\n*    }\n*\n*/\nimport java.util.ArrayList;\npublic class Solution {\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        ArrayList<Integer> vals = new ArrayList<>();\n        int count=0;\n        while(listNode != null) {\n            vals.add(listNode.val);\n            listNode = listNode.next;\n            count++;\n        }\n        for(int i=0;i<count/2;i++) {\n            int tem = vals.get(i);\n            vals.set(i, vals.get(count-i-1));\n            vals.set(count-i-1, tem);\n        }\n        return vals;  \n    }\n}\n```\n\n```java\npublic class linklist{\n    public static ArrayList<Integer> vals = new ArrayList<>();\n    public static void printListFromTailToHead(ListNode listNode) {\n        if(listNode != null) {\n            printListFromTailToHead(listNode.next);\n    \t    vals.add(listNode.val);\n        }\n    }\n    //return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。\n}\n```\n\n![](http://ou6yob3zd.bkt.clouddn.com/20170819204904.png)\n\n## 题目四：重建二叉树 （树）\n\n## 题目五：用两个栈实现队列 （栈、队列）\n\n**题目描述:**用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n\n**思路：**\n \n入队push:将元素进栈A。\n\n出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。\n\n**注：** 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。\n\n**代码：**\n\n```java\npublic class Solution {\n    Stack<Integer> stack1 = new Stack<Integer>();\n    Stack<Integer> stack2 = new Stack<Integer>();\n     \n    public void push(int node) {\n        stack1.push(node);\n    }\n     \n    public int pop() {\n        while(stack1.empty()&&stack2.empty()){\n            System.out.println(\"队列为空!\");\n        }\n        if(stack2.empty()){\n            while(!stack1.empty()){\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n}\n```\n## 题目十一：二进制中1的个数 （位运算）\n**题目描述:**输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n\n**思路：**\n\n**方法一：** 通过n&n-1可以消除整数最右边的1。多次执行n=n&n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。\n\n**分析：**为啥n&n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。\n\n    n=12          1100 \n    n-1=11        1011\n    n=12&11       1000\n    n=8           1000\n    n-1=7         0111\n    n=8&7         0000\n\n**代码：**\n```java\npublic int NumberOf1(int n) {  \n    int count = 0;\n    while(n!=0){\n        n &= n-1;\n        count++;\n    }\n    return count;\n}\n```\n\n更多参考点击：[算法-求二进制数中1的个数](http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html)\n\n## 题目十二：数值的整数次方 （代码的完整性）\n**题目：**给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n\n**思路：**\n\n**方法一：**估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。\n\n**方法二：** **快速幂**，快速幂能将复杂度降至O(logb)，确实是快了不少。\n\n原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下：\n\na^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)\\*a^(2^1)\\*a^(2^3)\n\n通过使用&和>>位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。\n\n更多信息：[快速幂](http://www.cnblogs.com/CXCXCXC/p/4641812.html)\n\n**代码：**\n```java\npublic class Solution {\n    public double Power(double base, int exponent) {\n        double result = 1.0;\n        int e = exponent;\n        exponent = Math.abs(exponent);\n        if(exponent == 0){\n            return result;\n        }\n        while(exponent!=0){\n            if((exponent&1)==1){\n                result *= base;\n            }\n            base *= base;    //每移动一位，该为代表的乘数都翻倍\n            exponent = exponent >> 1;  //右移一位\n        }\n        return e>0?result:1/result;    \n    }\n}\n```\n\n\n## 题目十三：调整数组顺序使奇数位于偶数前面 （数组）\n**题目描述:**输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n**思路：**\n\n**方法一：** 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。\n\n**方法二：**重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。\n\n**代码：**\n```java\npublic class Solution {\n    public void reOrderArray(int [] array) {\n        for(int i=1;i<array.length;i++){\n    \t    if(array[i]%2==0){  //偶数的话，继续下一个数\n                continue;\n    \t    }else{   \n                int tem = array[i];  //保存待插入到偶数之前的奇数\n                int j;\n                for(j=i-1;j>=0&&(array[j]%2==0);j--){  //找到偶数之前插入的位置\n                    array[j+1] = array[j];  //偶数集体后移一位\n                }\n                array[j+1] = tem;  //将奇数插入到该位置上\n            }\n    \t}      \n    }\n}\n```\n\n## 题目十四：链表中倒数第k个结点\n**题目描述:**输入一个链表，输出该链表中倒数第k个结点。\n\n**思路：** 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count>=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。\n\n**代码：**\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n \n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode FindKthToTail(ListNode head,int k) {\n        int count = 0;\n        ListNode p = head;\n        ListNode node = null;  //head为空，返回null\n        if(k<=0) return node;  //k<=0无效，返回null\n        while(head!=null){\n            count++;\n            head = head.next;\n            if(count >= k) {  //相对第一个元素为k-1的间隔时,head和p同时往后走\n                node = p;\n                p = p.next;\n            }\n        }\n        return node;\n    }\n}\n```\n\n## 题目十五：反转链表\n**题目描述:**输入一个链表，反转链表后，输出链表的所有元素。\n\n**思路：** 依次遍历每个结点，同时通过头插法再重新创建新的链表\n\n**注：**可以利用之前的结点，而不需要重新创建新的结点，以后改进。\n\n**代码：**\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n \n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        ListNode p = null;\n        if(head == null) {\n            return p;\n        }else{\n            p = new ListNode(head.val);\n        }\n        ListNode q = head.next;\n        while(q!=null){\n            ListNode s = new ListNode(q.val);\n            s.next = p;\n            p = s;\n            q = q.next;\n        }\n        return p;\n    }\n}\n```\n\n\n## 题目十六：合并两个排序的链表\n**题目描述:**输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n\n**思路：** 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。\n\n**注：**可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。\n\n**代码：**\n\n```java\n/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n \n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode Merge(ListNode list1,ListNode list2) {\n        ListNode p = new ListNode(0);  //创建一个头结点,数据域初始化为0，不存储数据,指针域为null\n        ListNode head = p ;  //头指针,指向头结点\n        if(list1 == null && list2 == null) return null;\n        while(list1!=null && list2!=null){\n            if(list1.val < list2.val){\n                ListNode s = new ListNode(list1.val);\n                p.next = s;\n                p = s;\n                list1 = list1.next;\n                 \n            }else {\n                ListNode s = new ListNode(list2.val);\n                p.next = s;\n                p = s;\n                list2 = list2.next;\n            }\n        }\n        while(list1!=null){\n            ListNode s = new ListNode(list1.val);\n            p.next = s;\n            p = s;\n            list1 = list1.next;\n        }\n        while(list2!=null){\n            ListNode s = new ListNode(list2.val);\n            p.next = s;\n            p = s;\n            list2 = list2.next;\n        }\n        return head.next;  //头结点不存储元素,head.next指向第一个元素节点，返回 \n    }\n}\n```","slug":"剑指offer","published":1,"updated":"2017-12-07T07:59:00.084Z","layout":"post","photos":[],"link":"","_id":"cjcj3yige0009jgc9ipd8dhvt","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：<a href=\"https://www.nowcoder.com/ta/coding-interviews\" target=\"_blank\" rel=\"external\">点击查看</a><br><a id=\"more\"></a></p>\n<h2 id=\"题目一：二维数组中的查找-（数组）\"><a href=\"#题目一：二维数组中的查找-（数组）\" class=\"headerlink\" title=\"题目一：二维数组中的查找   （数组）\"></a>题目一：二维数组中的查找   （数组）</h2><p><strong>题目描述:</strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<p><strong>思路：</strong>矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。</p>\n<p><strong>注：</strong>时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span> [][] array)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(array[<span class=\"number\">0</span>].length==<span class=\"number\">0</span>) &#123; <span class=\"comment\">//[[]]的情况</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;   <span class=\"comment\">//判断二维数组是否为空</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;array.length;i++) &#123;</div><div class=\"line\">            <span class=\"comment\">// 找出target所在二维数组的行</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(target&gt;=array[i][<span class=\"number\">0</span>]&amp;&amp;target&lt;=array[i][array[i].length-<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                <span class=\"comment\">//找到所在行之后，因为该行是有序的，此时使用二分查找即可</span></div><div class=\"line\">                <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">int</span> high = array[i].length-<span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">int</span> mid;</div><div class=\"line\">                <span class=\"keyword\">while</span>(low&lt;=high) &#123;</div><div class=\"line\">                    mid = (high + low)/<span class=\"number\">2</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span>(array[i][mid]&gt;target) &#123;</div><div class=\"line\">                        high = mid - <span class=\"number\">1</span>;</div><div class=\"line\">                    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(array[i][mid]&lt;target)&#123;</div><div class=\"line\">                        low = mid + <span class=\"number\">1</span>;</div><div class=\"line\">                    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"题目二：替换空格-（字符串）\"><a href=\"#题目二：替换空格-（字符串）\" class=\"headerlink\" title=\"题目二：替换空格  （字符串）\"></a>题目二：替换空格  （字符串）</h2><p><strong>题目描述:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n<p><strong>思路：</strong></p>\n<p><strong>第一种：</strong> 直接用StringBuffer提供的replace函数。(不可取，得自己搞)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">replace(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, String str);</div></pre></td></tr></table></figure>\n<p>Replaces the characters in a substring of this sequence with characters in the specified String.</p>\n<p><strong>第二种：</strong> 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，<strong>从后向前</strong>遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。</p>\n<p><strong>注：</strong>从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceSpace</span><span class=\"params\">(StringBuffer str)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldlength = str.length()-<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> newlength = oldlength;  <span class=\"comment\">//替换之后新数组的大小</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;str.length();i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(str.charAt(i)==<span class=\"string\">' '</span>)&#123;</div><div class=\"line\">                newlength += <span class=\"number\">2</span>;   <span class=\"comment\">//由一个' '变为\"%20\",长度增加2</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        str.setLength(newlength+<span class=\"number\">1</span>);  <span class=\"comment\">//扩展str的长度,多余的位置是空字符</span></div><div class=\"line\">        <span class=\"comment\">//此时oldlength和newlength都是数组的长度-1</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(;oldlength&gt;=<span class=\"number\">0</span>&amp;&amp;oldlength&lt;newlength;oldlength--)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(str.charAt(oldlength)==<span class=\"string\">' '</span>)&#123;</div><div class=\"line\">                str.setCharAt(newlength--, <span class=\"string\">'0'</span>);</div><div class=\"line\">                str.setCharAt(newlength--, <span class=\"string\">'2'</span>);</div><div class=\"line\">                str.setCharAt(newlength--, <span class=\"string\">'%'</span>);</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                str.setCharAt(newlength--, str.charAt(oldlength));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> str.toString();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"题目三：从尾到头打印链表-（链表）\"><a href=\"#题目三：从尾到头打印链表-（链表）\" class=\"headerlink\" title=\"题目三：从尾到头打印链表 （链表）\"></a>题目三：从尾到头打印链表 （链表）</h2><p><strong>题目描述:</strong>输入一个链表，从尾到头打印链表每个节点的值。</p>\n<p><strong>思路：</strong></p>\n<p><strong>第一种：</strong> 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low)</p>\n<p><strong>第二种：</strong> 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*    public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">*        int val;</span></div><div class=\"line\"><span class=\"comment\">*        ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">*        ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">*            this.val = val;</span></div><div class=\"line\"><span class=\"comment\">*        &#125;</span></div><div class=\"line\"><span class=\"comment\">*    &#125;</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">*/</span></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">printListFromTailToHead</span><span class=\"params\">(ListNode listNode)</span> </span>&#123;</div><div class=\"line\">        ArrayList&lt;Integer&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(listNode != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            vals.add(listNode.val);</div><div class=\"line\">            listNode = listNode.next;</div><div class=\"line\">            count++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;count/<span class=\"number\">2</span>;i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> tem = vals.get(i);</div><div class=\"line\">            vals.set(i, vals.get(count-i-<span class=\"number\">1</span>));</div><div class=\"line\">            vals.set(count-i-<span class=\"number\">1</span>, tem);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> vals;  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">linklist</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ArrayList&lt;Integer&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printListFromTailToHead</span><span class=\"params\">(ListNode listNode)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(listNode != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            printListFromTailToHead(listNode.next);</div><div class=\"line\">    \t    vals.add(listNode.val);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170819204904.png\" alt=\"\"></p>\n<h2 id=\"题目四：重建二叉树-（树）\"><a href=\"#题目四：重建二叉树-（树）\" class=\"headerlink\" title=\"题目四：重建二叉树 （树）\"></a>题目四：重建二叉树 （树）</h2><h2 id=\"题目五：用两个栈实现队列-（栈、队列）\"><a href=\"#题目五：用两个栈实现队列-（栈、队列）\" class=\"headerlink\" title=\"题目五：用两个栈实现队列 （栈、队列）\"></a>题目五：用两个栈实现队列 （栈、队列）</h2><p><strong>题目描述:</strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>\n<p><strong>思路：</strong></p>\n<p>入队push:将元素进栈A。</p>\n<p>出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。</p>\n<p><strong>注：</strong> 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    Stack&lt;Integer&gt; stack1 = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</div><div class=\"line\">    Stack&lt;Integer&gt; stack2 = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</div><div class=\"line\">        stack1.push(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">while</span>(stack1.empty()&amp;&amp;stack2.empty())&#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"队列为空!\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(stack2.empty())&#123;</div><div class=\"line\">            <span class=\"keyword\">while</span>(!stack1.empty())&#123;</div><div class=\"line\">                stack2.push(stack1.pop());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> stack2.pop();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"题目十一：二进制中1的个数-（位运算）\"><a href=\"#题目十一：二进制中1的个数-（位运算）\" class=\"headerlink\" title=\"题目十一：二进制中1的个数 （位运算）\"></a>题目十一：二进制中1的个数 （位运算）</h2><p><strong>题目描述:</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>\n<p><strong>思路：</strong></p>\n<p><strong>方法一：</strong> 通过n&amp;n-1可以消除整数最右边的1。多次执行n=n&amp;n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。</p>\n<p><strong>分析：</strong>为啥n&amp;n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>\n<pre><code>n=12          1100 \nn-1=11        1011\nn=12&amp;11       1000\nn=8           1000\nn-1=7         0111\nn=8&amp;7         0000\n</code></pre><p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">NumberOf1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n!=<span class=\"number\">0</span>)&#123;</div><div class=\"line\">        n &amp;= n-<span class=\"number\">1</span>;</div><div class=\"line\">        count++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>更多参考点击：<a href=\"http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html\" target=\"_blank\" rel=\"external\">算法-求二进制数中1的个数</a></p>\n<h2 id=\"题目十二：数值的整数次方-（代码的完整性）\"><a href=\"#题目十二：数值的整数次方-（代码的完整性）\" class=\"headerlink\" title=\"题目十二：数值的整数次方 （代码的完整性）\"></a>题目十二：数值的整数次方 （代码的完整性）</h2><p><strong>题目：</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>\n<p><strong>思路：</strong></p>\n<p><strong>方法一：</strong>估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。</p>\n<p><strong>方法二：</strong> <strong>快速幂</strong>，快速幂能将复杂度降至O(logb)，确实是快了不少。</p>\n<p>原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下：</p>\n<p>a^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)*a^(2^1)*a^(2^3)</p>\n<p>通过使用&amp;和&gt;&gt;位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。</p>\n<p>更多信息：<a href=\"http://www.cnblogs.com/CXCXCXC/p/4641812.html\" target=\"_blank\" rel=\"external\">快速幂</a></p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">Power</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">double</span> result = <span class=\"number\">1.0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> e = exponent;</div><div class=\"line\">        exponent = Math.abs(exponent);</div><div class=\"line\">        <span class=\"keyword\">if</span>(exponent == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(exponent!=<span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>((exponent&amp;<span class=\"number\">1</span>)==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">                result *= base;</div><div class=\"line\">            &#125;</div><div class=\"line\">            base *= base;    <span class=\"comment\">//每移动一位，该为代表的乘数都翻倍</span></div><div class=\"line\">            exponent = exponent &gt;&gt; <span class=\"number\">1</span>;  <span class=\"comment\">//右移一位</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> e&gt;<span class=\"number\">0</span>?result:<span class=\"number\">1</span>/result;    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十三：调整数组顺序使奇数位于偶数前面-（数组）\"><a href=\"#题目十三：调整数组顺序使奇数位于偶数前面-（数组）\" class=\"headerlink\" title=\"题目十三：调整数组顺序使奇数位于偶数前面 （数组）\"></a>题目十三：调整数组顺序使奇数位于偶数前面 （数组）</h2><p><strong>题目描述:</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>\n<p><strong>思路：</strong></p>\n<p><strong>方法一：</strong> 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。</p>\n<p><strong>方法二：</strong>重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。</p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reOrderArray</span><span class=\"params\">(<span class=\"keyword\">int</span> [] array)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;array.length;i++)&#123;</div><div class=\"line\">    \t    <span class=\"keyword\">if</span>(array[i]%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;  <span class=\"comment\">//偶数的话，继续下一个数</span></div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">    \t    &#125;<span class=\"keyword\">else</span>&#123;   </div><div class=\"line\">                <span class=\"keyword\">int</span> tem = array[i];  <span class=\"comment\">//保存待插入到偶数之前的奇数</span></div><div class=\"line\">                <span class=\"keyword\">int</span> j;</div><div class=\"line\">                <span class=\"keyword\">for</span>(j=i-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>&amp;&amp;(array[j]%<span class=\"number\">2</span>==<span class=\"number\">0</span>);j--)&#123;  <span class=\"comment\">//找到偶数之前插入的位置</span></div><div class=\"line\">                    array[j+<span class=\"number\">1</span>] = array[j];  <span class=\"comment\">//偶数集体后移一位</span></div><div class=\"line\">                &#125;</div><div class=\"line\">                array[j+<span class=\"number\">1</span>] = tem;  <span class=\"comment\">//将奇数插入到该位置上</span></div><div class=\"line\">            &#125;</div><div class=\"line\">    \t&#125;      </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十四：链表中倒数第k个结点\"><a href=\"#题目十四：链表中倒数第k个结点\" class=\"headerlink\" title=\"题目十四：链表中倒数第k个结点\"></a>题目十四：链表中倒数第k个结点</h2><p><strong>题目描述:</strong>输入一个链表，输出该链表中倒数第k个结点。</p>\n<p><strong>思路：</strong> 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count&gt;=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。</p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">    int val;</span></div><div class=\"line\"><span class=\"comment\">    ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\"> </span></div><div class=\"line\"><span class=\"comment\">    ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">        this.val = val;</span></div><div class=\"line\"><span class=\"comment\">    &#125;</span></div><div class=\"line\"><span class=\"comment\">&#125;*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">FindKthToTail</span><span class=\"params\">(ListNode head,<span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">        ListNode p = head;</div><div class=\"line\">        ListNode node = <span class=\"keyword\">null</span>;  <span class=\"comment\">//head为空，返回null</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(k&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> node;  <span class=\"comment\">//k&lt;=0无效，返回null</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(head!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            count++;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">            <span class=\"keyword\">if</span>(count &gt;= k) &#123;  <span class=\"comment\">//相对第一个元素为k-1的间隔时,head和p同时往后走</span></div><div class=\"line\">                node = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十五：反转链表\"><a href=\"#题目十五：反转链表\" class=\"headerlink\" title=\"题目十五：反转链表\"></a>题目十五：反转链表</h2><p><strong>题目描述:</strong>输入一个链表，反转链表后，输出链表的所有元素。</p>\n<p><strong>思路：</strong> 依次遍历每个结点，同时通过头插法再重新创建新的链表</p>\n<p><strong>注：</strong>可以利用之前的结点，而不需要重新创建新的结点，以后改进。</p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">    int val;</span></div><div class=\"line\"><span class=\"comment\">    ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\"> </span></div><div class=\"line\"><span class=\"comment\">    ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">        this.val = val;</span></div><div class=\"line\"><span class=\"comment\">    &#125;</span></div><div class=\"line\"><span class=\"comment\">&#125;*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">ReverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</div><div class=\"line\">        ListNode p = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> p;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            p = <span class=\"keyword\">new</span> ListNode(head.val);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ListNode q = head.next;</div><div class=\"line\">        <span class=\"keyword\">while</span>(q!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            ListNode s = <span class=\"keyword\">new</span> ListNode(q.val);</div><div class=\"line\">            s.next = p;</div><div class=\"line\">            p = s;</div><div class=\"line\">            q = q.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> p;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十六：合并两个排序的链表\"><a href=\"#题目十六：合并两个排序的链表\" class=\"headerlink\" title=\"题目十六：合并两个排序的链表\"></a>题目十六：合并两个排序的链表</h2><p><strong>题目描述:</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>\n<p><strong>思路：</strong> 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。</p>\n<p><strong>注：</strong>可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">    int val;</span></div><div class=\"line\"><span class=\"comment\">    ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\"> </span></div><div class=\"line\"><span class=\"comment\">    ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">        this.val = val;</span></div><div class=\"line\"><span class=\"comment\">    &#125;</span></div><div class=\"line\"><span class=\"comment\">&#125;*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">Merge</span><span class=\"params\">(ListNode list1,ListNode list2)</span> </span>&#123;</div><div class=\"line\">        ListNode p = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);  <span class=\"comment\">//创建一个头结点,数据域初始化为0，不存储数据,指针域为null</span></div><div class=\"line\">        ListNode head = p ;  <span class=\"comment\">//头指针,指向头结点</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(list1 == <span class=\"keyword\">null</span> &amp;&amp; list2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(list1!=<span class=\"keyword\">null</span> &amp;&amp; list2!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(list1.val &lt; list2.val)&#123;</div><div class=\"line\">                ListNode s = <span class=\"keyword\">new</span> ListNode(list1.val);</div><div class=\"line\">                p.next = s;</div><div class=\"line\">                p = s;</div><div class=\"line\">                list1 = list1.next;</div><div class=\"line\">                 </div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                ListNode s = <span class=\"keyword\">new</span> ListNode(list2.val);</div><div class=\"line\">                p.next = s;</div><div class=\"line\">                p = s;</div><div class=\"line\">                list2 = list2.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(list1!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            ListNode s = <span class=\"keyword\">new</span> ListNode(list1.val);</div><div class=\"line\">            p.next = s;</div><div class=\"line\">            p = s;</div><div class=\"line\">            list1 = list1.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(list2!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            ListNode s = <span class=\"keyword\">new</span> ListNode(list2.val);</div><div class=\"line\">            p.next = s;</div><div class=\"line\">            p = s;</div><div class=\"line\">            list2 = list2.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> head.next;  <span class=\"comment\">//头结点不存储元素,head.next指向第一个元素节点，返回 </span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：<a href=\"https://www.nowcoder.com/ta/coding-interviews\" target=\"_blank\" rel=\"external\">点击查看</a><br>","more":"</p>\n<h2 id=\"题目一：二维数组中的查找-（数组）\"><a href=\"#题目一：二维数组中的查找-（数组）\" class=\"headerlink\" title=\"题目一：二维数组中的查找   （数组）\"></a>题目一：二维数组中的查找   （数组）</h2><p><strong>题目描述:</strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<p><strong>思路：</strong>矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。</p>\n<p><strong>注：</strong>时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span> [][] array)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(array[<span class=\"number\">0</span>].length==<span class=\"number\">0</span>) &#123; <span class=\"comment\">//[[]]的情况</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;   <span class=\"comment\">//判断二维数组是否为空</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;array.length;i++) &#123;</div><div class=\"line\">            <span class=\"comment\">// 找出target所在二维数组的行</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(target&gt;=array[i][<span class=\"number\">0</span>]&amp;&amp;target&lt;=array[i][array[i].length-<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                <span class=\"comment\">//找到所在行之后，因为该行是有序的，此时使用二分查找即可</span></div><div class=\"line\">                <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</div><div class=\"line\">                <span class=\"keyword\">int</span> high = array[i].length-<span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">int</span> mid;</div><div class=\"line\">                <span class=\"keyword\">while</span>(low&lt;=high) &#123;</div><div class=\"line\">                    mid = (high + low)/<span class=\"number\">2</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span>(array[i][mid]&gt;target) &#123;</div><div class=\"line\">                        high = mid - <span class=\"number\">1</span>;</div><div class=\"line\">                    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(array[i][mid]&lt;target)&#123;</div><div class=\"line\">                        low = mid + <span class=\"number\">1</span>;</div><div class=\"line\">                    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"题目二：替换空格-（字符串）\"><a href=\"#题目二：替换空格-（字符串）\" class=\"headerlink\" title=\"题目二：替换空格  （字符串）\"></a>题目二：替换空格  （字符串）</h2><p><strong>题目描述:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n<p><strong>思路：</strong></p>\n<p><strong>第一种：</strong> 直接用StringBuffer提供的replace函数。(不可取，得自己搞)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">replace(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, String str);</div></pre></td></tr></table></figure>\n<p>Replaces the characters in a substring of this sequence with characters in the specified String.</p>\n<p><strong>第二种：</strong> 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，<strong>从后向前</strong>遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。</p>\n<p><strong>注：</strong>从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceSpace</span><span class=\"params\">(StringBuffer str)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldlength = str.length()-<span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> newlength = oldlength;  <span class=\"comment\">//替换之后新数组的大小</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;str.length();i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(str.charAt(i)==<span class=\"string\">' '</span>)&#123;</div><div class=\"line\">                newlength += <span class=\"number\">2</span>;   <span class=\"comment\">//由一个' '变为\"%20\",长度增加2</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        str.setLength(newlength+<span class=\"number\">1</span>);  <span class=\"comment\">//扩展str的长度,多余的位置是空字符</span></div><div class=\"line\">        <span class=\"comment\">//此时oldlength和newlength都是数组的长度-1</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(;oldlength&gt;=<span class=\"number\">0</span>&amp;&amp;oldlength&lt;newlength;oldlength--)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(str.charAt(oldlength)==<span class=\"string\">' '</span>)&#123;</div><div class=\"line\">                str.setCharAt(newlength--, <span class=\"string\">'0'</span>);</div><div class=\"line\">                str.setCharAt(newlength--, <span class=\"string\">'2'</span>);</div><div class=\"line\">                str.setCharAt(newlength--, <span class=\"string\">'%'</span>);</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                str.setCharAt(newlength--, str.charAt(oldlength));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> str.toString();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"题目三：从尾到头打印链表-（链表）\"><a href=\"#题目三：从尾到头打印链表-（链表）\" class=\"headerlink\" title=\"题目三：从尾到头打印链表 （链表）\"></a>题目三：从尾到头打印链表 （链表）</h2><p><strong>题目描述:</strong>输入一个链表，从尾到头打印链表每个节点的值。</p>\n<p><strong>思路：</strong></p>\n<p><strong>第一种：</strong> 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low)</p>\n<p><strong>第二种：</strong> 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*    public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">*        int val;</span></div><div class=\"line\"><span class=\"comment\">*        ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">*        ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">*            this.val = val;</span></div><div class=\"line\"><span class=\"comment\">*        &#125;</span></div><div class=\"line\"><span class=\"comment\">*    &#125;</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">*/</span></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">printListFromTailToHead</span><span class=\"params\">(ListNode listNode)</span> </span>&#123;</div><div class=\"line\">        ArrayList&lt;Integer&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(listNode != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            vals.add(listNode.val);</div><div class=\"line\">            listNode = listNode.next;</div><div class=\"line\">            count++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;count/<span class=\"number\">2</span>;i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> tem = vals.get(i);</div><div class=\"line\">            vals.set(i, vals.get(count-i-<span class=\"number\">1</span>));</div><div class=\"line\">            vals.set(count-i-<span class=\"number\">1</span>, tem);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> vals;  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">linklist</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ArrayList&lt;Integer&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printListFromTailToHead</span><span class=\"params\">(ListNode listNode)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(listNode != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            printListFromTailToHead(listNode.next);</div><div class=\"line\">    \t    vals.add(listNode.val);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/20170819204904.png\" alt=\"\"></p>\n<h2 id=\"题目四：重建二叉树-（树）\"><a href=\"#题目四：重建二叉树-（树）\" class=\"headerlink\" title=\"题目四：重建二叉树 （树）\"></a>题目四：重建二叉树 （树）</h2><h2 id=\"题目五：用两个栈实现队列-（栈、队列）\"><a href=\"#题目五：用两个栈实现队列-（栈、队列）\" class=\"headerlink\" title=\"题目五：用两个栈实现队列 （栈、队列）\"></a>题目五：用两个栈实现队列 （栈、队列）</h2><p><strong>题目描述:</strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>\n<p><strong>思路：</strong></p>\n<p>入队push:将元素进栈A。</p>\n<p>出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。</p>\n<p><strong>注：</strong> 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    Stack&lt;Integer&gt; stack1 = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</div><div class=\"line\">    Stack&lt;Integer&gt; stack2 = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</div><div class=\"line\">        stack1.push(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">while</span>(stack1.empty()&amp;&amp;stack2.empty())&#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"队列为空!\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(stack2.empty())&#123;</div><div class=\"line\">            <span class=\"keyword\">while</span>(!stack1.empty())&#123;</div><div class=\"line\">                stack2.push(stack1.pop());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> stack2.pop();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"题目十一：二进制中1的个数-（位运算）\"><a href=\"#题目十一：二进制中1的个数-（位运算）\" class=\"headerlink\" title=\"题目十一：二进制中1的个数 （位运算）\"></a>题目十一：二进制中1的个数 （位运算）</h2><p><strong>题目描述:</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>\n<p><strong>思路：</strong></p>\n<p><strong>方法一：</strong> 通过n&amp;n-1可以消除整数最右边的1。多次执行n=n&amp;n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。</p>\n<p><strong>分析：</strong>为啥n&amp;n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>\n<pre><code>n=12          1100 \nn-1=11        1011\nn=12&amp;11       1000\nn=8           1000\nn-1=7         0111\nn=8&amp;7         0000\n</code></pre><p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">NumberOf1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n!=<span class=\"number\">0</span>)&#123;</div><div class=\"line\">        n &amp;= n-<span class=\"number\">1</span>;</div><div class=\"line\">        count++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>更多参考点击：<a href=\"http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html\" target=\"_blank\" rel=\"external\">算法-求二进制数中1的个数</a></p>\n<h2 id=\"题目十二：数值的整数次方-（代码的完整性）\"><a href=\"#题目十二：数值的整数次方-（代码的完整性）\" class=\"headerlink\" title=\"题目十二：数值的整数次方 （代码的完整性）\"></a>题目十二：数值的整数次方 （代码的完整性）</h2><p><strong>题目：</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>\n<p><strong>思路：</strong></p>\n<p><strong>方法一：</strong>估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。</p>\n<p><strong>方法二：</strong> <strong>快速幂</strong>，快速幂能将复杂度降至O(logb)，确实是快了不少。</p>\n<p>原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下：</p>\n<p>a^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)*a^(2^1)*a^(2^3)</p>\n<p>通过使用&amp;和&gt;&gt;位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。</p>\n<p>更多信息：<a href=\"http://www.cnblogs.com/CXCXCXC/p/4641812.html\" target=\"_blank\" rel=\"external\">快速幂</a></p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">Power</span><span class=\"params\">(<span class=\"keyword\">double</span> base, <span class=\"keyword\">int</span> exponent)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">double</span> result = <span class=\"number\">1.0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> e = exponent;</div><div class=\"line\">        exponent = Math.abs(exponent);</div><div class=\"line\">        <span class=\"keyword\">if</span>(exponent == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(exponent!=<span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>((exponent&amp;<span class=\"number\">1</span>)==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">                result *= base;</div><div class=\"line\">            &#125;</div><div class=\"line\">            base *= base;    <span class=\"comment\">//每移动一位，该为代表的乘数都翻倍</span></div><div class=\"line\">            exponent = exponent &gt;&gt; <span class=\"number\">1</span>;  <span class=\"comment\">//右移一位</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> e&gt;<span class=\"number\">0</span>?result:<span class=\"number\">1</span>/result;    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十三：调整数组顺序使奇数位于偶数前面-（数组）\"><a href=\"#题目十三：调整数组顺序使奇数位于偶数前面-（数组）\" class=\"headerlink\" title=\"题目十三：调整数组顺序使奇数位于偶数前面 （数组）\"></a>题目十三：调整数组顺序使奇数位于偶数前面 （数组）</h2><p><strong>题目描述:</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>\n<p><strong>思路：</strong></p>\n<p><strong>方法一：</strong> 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。</p>\n<p><strong>方法二：</strong>重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。</p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reOrderArray</span><span class=\"params\">(<span class=\"keyword\">int</span> [] array)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;array.length;i++)&#123;</div><div class=\"line\">    \t    <span class=\"keyword\">if</span>(array[i]%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;  <span class=\"comment\">//偶数的话，继续下一个数</span></div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">    \t    &#125;<span class=\"keyword\">else</span>&#123;   </div><div class=\"line\">                <span class=\"keyword\">int</span> tem = array[i];  <span class=\"comment\">//保存待插入到偶数之前的奇数</span></div><div class=\"line\">                <span class=\"keyword\">int</span> j;</div><div class=\"line\">                <span class=\"keyword\">for</span>(j=i-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>&amp;&amp;(array[j]%<span class=\"number\">2</span>==<span class=\"number\">0</span>);j--)&#123;  <span class=\"comment\">//找到偶数之前插入的位置</span></div><div class=\"line\">                    array[j+<span class=\"number\">1</span>] = array[j];  <span class=\"comment\">//偶数集体后移一位</span></div><div class=\"line\">                &#125;</div><div class=\"line\">                array[j+<span class=\"number\">1</span>] = tem;  <span class=\"comment\">//将奇数插入到该位置上</span></div><div class=\"line\">            &#125;</div><div class=\"line\">    \t&#125;      </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十四：链表中倒数第k个结点\"><a href=\"#题目十四：链表中倒数第k个结点\" class=\"headerlink\" title=\"题目十四：链表中倒数第k个结点\"></a>题目十四：链表中倒数第k个结点</h2><p><strong>题目描述:</strong>输入一个链表，输出该链表中倒数第k个结点。</p>\n<p><strong>思路：</strong> 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count&gt;=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。</p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">    int val;</span></div><div class=\"line\"><span class=\"comment\">    ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\"> </span></div><div class=\"line\"><span class=\"comment\">    ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">        this.val = val;</span></div><div class=\"line\"><span class=\"comment\">    &#125;</span></div><div class=\"line\"><span class=\"comment\">&#125;*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">FindKthToTail</span><span class=\"params\">(ListNode head,<span class=\"keyword\">int</span> k)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">        ListNode p = head;</div><div class=\"line\">        ListNode node = <span class=\"keyword\">null</span>;  <span class=\"comment\">//head为空，返回null</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(k&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> node;  <span class=\"comment\">//k&lt;=0无效，返回null</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(head!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            count++;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">            <span class=\"keyword\">if</span>(count &gt;= k) &#123;  <span class=\"comment\">//相对第一个元素为k-1的间隔时,head和p同时往后走</span></div><div class=\"line\">                node = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> node;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十五：反转链表\"><a href=\"#题目十五：反转链表\" class=\"headerlink\" title=\"题目十五：反转链表\"></a>题目十五：反转链表</h2><p><strong>题目描述:</strong>输入一个链表，反转链表后，输出链表的所有元素。</p>\n<p><strong>思路：</strong> 依次遍历每个结点，同时通过头插法再重新创建新的链表</p>\n<p><strong>注：</strong>可以利用之前的结点，而不需要重新创建新的结点，以后改进。</p>\n<p><strong>代码：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">    int val;</span></div><div class=\"line\"><span class=\"comment\">    ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\"> </span></div><div class=\"line\"><span class=\"comment\">    ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">        this.val = val;</span></div><div class=\"line\"><span class=\"comment\">    &#125;</span></div><div class=\"line\"><span class=\"comment\">&#125;*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">ReverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</div><div class=\"line\">        ListNode p = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> p;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            p = <span class=\"keyword\">new</span> ListNode(head.val);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ListNode q = head.next;</div><div class=\"line\">        <span class=\"keyword\">while</span>(q!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            ListNode s = <span class=\"keyword\">new</span> ListNode(q.val);</div><div class=\"line\">            s.next = p;</div><div class=\"line\">            p = s;</div><div class=\"line\">            q = q.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> p;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目十六：合并两个排序的链表\"><a href=\"#题目十六：合并两个排序的链表\" class=\"headerlink\" title=\"题目十六：合并两个排序的链表\"></a>题目十六：合并两个排序的链表</h2><p><strong>题目描述:</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>\n<p><strong>思路：</strong> 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。</p>\n<p><strong>注：</strong>可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">public class ListNode &#123;</span></div><div class=\"line\"><span class=\"comment\">    int val;</span></div><div class=\"line\"><span class=\"comment\">    ListNode next = null;</span></div><div class=\"line\"><span class=\"comment\"> </span></div><div class=\"line\"><span class=\"comment\">    ListNode(int val) &#123;</span></div><div class=\"line\"><span class=\"comment\">        this.val = val;</span></div><div class=\"line\"><span class=\"comment\">    &#125;</span></div><div class=\"line\"><span class=\"comment\">&#125;*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">Merge</span><span class=\"params\">(ListNode list1,ListNode list2)</span> </span>&#123;</div><div class=\"line\">        ListNode p = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);  <span class=\"comment\">//创建一个头结点,数据域初始化为0，不存储数据,指针域为null</span></div><div class=\"line\">        ListNode head = p ;  <span class=\"comment\">//头指针,指向头结点</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(list1 == <span class=\"keyword\">null</span> &amp;&amp; list2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(list1!=<span class=\"keyword\">null</span> &amp;&amp; list2!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(list1.val &lt; list2.val)&#123;</div><div class=\"line\">                ListNode s = <span class=\"keyword\">new</span> ListNode(list1.val);</div><div class=\"line\">                p.next = s;</div><div class=\"line\">                p = s;</div><div class=\"line\">                list1 = list1.next;</div><div class=\"line\">                 </div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                ListNode s = <span class=\"keyword\">new</span> ListNode(list2.val);</div><div class=\"line\">                p.next = s;</div><div class=\"line\">                p = s;</div><div class=\"line\">                list2 = list2.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(list1!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            ListNode s = <span class=\"keyword\">new</span> ListNode(list1.val);</div><div class=\"line\">            p.next = s;</div><div class=\"line\">            p = s;</div><div class=\"line\">            list1 = list1.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(list2!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            ListNode s = <span class=\"keyword\">new</span> ListNode(list2.val);</div><div class=\"line\">            p.next = s;</div><div class=\"line\">            p = s;</div><div class=\"line\">            list2 = list2.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> head.next;  <span class=\"comment\">//头结点不存储元素,head.next指向第一个元素节点，返回 </span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"引用&指针&const","date":"2017-09-01T11:59:25.000Z","update":null,"comments":1,"_content":"　　本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。\n<!-- more -->\n\n# 引用\n\n一条声明语句由一个**基本数据类型**和紧随其后的一个**声明符**列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。\n\n```C++\nint a;\n基本数据类型   声明符（其实就是变量名）\n//更复杂的声明符 ----接下来的指针和引用\nint *b;   //指针可以不初始化，没语法错误\nint &b = a;     //引用必须初始化\n```\n\n**引用**（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&d的形式来定义引用类型，其中d是声明的变量名。\n\n```C++\nint ival = 1024;\nint &refVal = ival; //refVal指向ival(是ival的另一个名字)\nint &refVal2;   //报错，引用必须初始化\n```\n\n一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。**因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。**\n\n## 引用注意细节\n\n- 无法令引用重新绑定到另外一个对象，因此引用必须初始化。\n- 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。\n- 引用本身不是对象，所以不能定义引用的引用。\n- 引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（**两种例外，一种是对常量的引用 const int &**）\n\n```C++\nint &refVal4 = 10;  //错误，引用类型的初始值必须是一个对象\ndouble dval = 3.14;\nint &refVal5 = dval;  //错误：此处引用类型初始值必须是int型对象\n```\n\n## 代码示例\n\n```C++\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int a = 2;\n    int c = 4;\n    int &b = a;  //b是a的引用，即b是a的别名\n    //&b = c;  错误,无法令引用重新绑定到另外一个对象上\n    cout<<a<<\" \"<<b<<\" \"<<&a<<\" \"<<&b<<endl;\n    a = 5;\n    cout<<a<<\" \"<<b<<\" \"<<&a<<\" \"<<&b<<endl;\n    b = 6;\n    cout<<a<<\" \"<<b<<\" \"<<&a<<\" \"<<&b<<endl;\n    a = c;    //将a的值改变，b的值也相应改变，但&a和&b还是一样的\n    cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<&a<<\" \"<<&b<<\" \"<<&c<<endl;\n    b = c;   //同上\n    cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<&a<<\" \"<<&b<<\" \"<<&c<<endl;\n    return 0;\n}\n```\n\n    2  2  0x28fef8  0x28fef8\n    5  5  0x28fef8  0x28fef8\n    6  6  0x28fef8  0x28fef8\n    4  4  0x28fef8  0x28fef8 0x28fef4\n    4  4  0x28fef8  0x28fef8 0x28fef4\n    \n# 指针\n\n**指针**是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。\n\n**指针和引用的不同点**：\n\n- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。\n- 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n\n## 获取对象的地址\n\n指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&）.\n\n```C++\nint ival = 42;\nint *p = &ival;  //指针变量p存放变量ival的地址,也即p是指向变量ival的指针\n```\n\n## 注意细节\n\n- 引用不是对象，没有实际地址，所有不能定义指向引用的指针。\n- 指针的类型要和它指向的对象严格匹配(**两种例外，一种是指向常量的指针**)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。\n\n## 指针值\n\n指针的值（即地址）应属下列4种状态之一：\n1. 指向一个对象\n2. 指向紧邻对象所占空间的下一个位置   \n3. 空指针，意味着指针没有指向任何对象\n4. 无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值）\n\n**注意**：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。\n\n## 利用指针访问对象\n\n使用**解引用符**（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。\n\n## 空指针\n\n空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：\n\n```C++\nint *p1 = nullptr;    //等价于int *p1 = 0;\nint *p2 = 0;   //直接将p2初始化为字面常量0\nint *p3 = NULL;    //等价于int *p1 = 0;\n```\n\nC++程序最好使用nullptr,同时尽量避免使用NULL。\n\n- 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。\n\n```C++\nint zero = 0 ,*p;\npi = zero;       // 错误：不能把int变量直接赋给指针\n```\n\n**note**:**建立初始化所有指针**\n\n**原因**：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。\n\n因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。\n\n## void* 指针\n\n**void*** **是一种特殊的指针类型，可用于存放任意对象的地址**。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：\n\n```C++\ndouble obj = 3.14, *pd = &obj;  // 正确：void*能存放任意类型对象的地址\nvoid *pv = &obj;      // obj可以是任意类型的对象\npv = pd;             // pv可以存放任意类型的指针\n```\n\n利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n\n概括说来，**以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象**\n\n## 代码示例\n\n```C++\n#include <iostream>\nusing namespace std;\nint main()\n{\n    double obj = 3.14,*pd = &obj;\n    void *pv = &obj;\n    cout<<&obj<<\" \"<<obj<<endl;\n    cout<<&pd<<\" \"<<pd<<\" \"<<*pd<<endl;\n    cout<<&pv<<\" \"<<pv<<\" \"<<endl;  //不能直接操作void* 指针所指的对象，即*pv是不合法的\n    return 0;\n}\n```\n\n    0x28ff08   3.14\n    0x28ff04   0x28ff08   3.14\n    0x28ff00   0x28ff08 \n    \n\n## 理解复合类型的声明\n\n修饰符（*或&）和变量标识符写在一起，修饰符(*或者&)都是修饰变量的。\n\n```C++\nint *p1,*p2;   //p1和p2都是指向int的指针\n```\n\n## 指向指针的指针\n\n指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。\n\n通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指向指针的指针的指，依次类推：\n\n```C++\nint ival = 1024;\nint *pi = &ival;   //pi指向一个int型的数\nint **ppi = &pi;   //ppi指向一个int型的指针\n//解引用\ncout<<ival<<\" \"<<*pi<<\" \"<<**ppi<<endl;\n```\n\n## 指向指针的引用\n\n引用本身不是对象，因此**不能定义指向引用的指针**。但指针是对象，所以**存在对指针的引用**。\n\n```C++\nint i = 42;\nint *p;   //p是一个int型指针\nint *&r = p;   //r是一个对指针p的引用,  此时r和p指针同名\nr = &i;   //r引用了一个指针，因此给r赋值&i就是令指向i\n*r = 0;   //解引用r得到i，也就是p指向的对象，将i的值改为0\n```\n\n要理解r的类型到底是什么，最简单的方法就是**从右向左阅读r的定义**。**离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响**，因此r是一个引用。**声明符的其余部分用以确定r引用的类型是什么**，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。\n\n# const限定符\n\n## const定义\n\n有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字**const**对变量的类型加以限制：\n\n```C++\nconst int bufSize = 512;     //输入缓冲区大小\n```\n\n这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。\n\n**因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。**\n\n```C++\nconst int i = get_size();    //正确：运行时初始化\nconst int j = 42;            //正确：编译时初始化\nconst int k;                 //错误：k是一个未经初始化的常量\n```\n\n**const类型能参与的操作**：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。\n\n## 默认状态下，const对象仅在文件内有效\n\n当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：\n\n```C++\nconst int bufSize = 512;     //输入缓冲区大小\n```\n\n编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。\n\n**默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。**\n\n某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，**只在一个文件中定义const，而在多个文件中声明并使用它。**\n\n**解决办法：**  对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了：\n\n```C++\n//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问\nextern const int bufferSize = function();\n//file1.h头文件\nextern const int bufferSize; //与file1.cpp中定义的是同一个\n```\n\n**note**：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。\n\n\n## const引用\n\n\n可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为**对常量的引用**（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。\n\n```C++\nconst int ci = 1024;\nconst int &r1 = ci;    //正确：引用及其对应的对象都是常量\nr1 = 42;               //错误：r1时对常量的引用\nint &r2 = ci;          //错误：试图让一个非常量引用指向一个常量对象\n```\n\n因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。\n\n## 初始化和对const的引用 \n\n引用的类型必须与其所引用对象的类型一致，但是有两个例外。**第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。** 尤其，**允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式**：\n\n```C++\nint i = 42;    \nconst int &r1 = i;       //允许将const int &绑定到一个普通int对象上\nconst int &r2 = 42;      //正确：r1是一个常量引用\nconst int &r3 = r1*2;    //正确：r3是一个常量引用\nint &r4 = r1*2;          //错误：r4是一个普通的非常量y\n```\n\n如果int &r4 = r1*2合法，那么就可以通过r4改变r1的值，而r1是常量引用。\n\n常量引用被绑定到另外一种类型上时到底发生了什么：\n\n```C++\ndouble dval = 3.14;\nconst int &ri = dval;\n//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：\nconst int temp = dval;  //由双精度浮点数生成一个临时的整形常量\nconst int &ri = temp;   //让ri绑定这个临时量\n```\n\n**总结**：常量引用（const &）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。\n\n## 对const的引用可能引用一个并非const的对象\n\n必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：\n\n```C++\nint i = 42;\nint &r1 = i;                 // 引用r1绑定对象i\nconst int &r2 = i； // r2也绑定对象i，但是不允许通过r2修改i的值\nr1 = 0;    // r1并非常量引用，i的值修改为0\nr2 = 0;    // 错误：r2是一个常量引用\n```\n\nr2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。\n\n## 指针和const(指向常量的指针 const double *cptr)\n\n**指向常量的指针（pointer to const）不能用于改变其所指对象的值**。要想存放常量对象的地址，只能使用指向常量的指针。\n\n```C++\nconst double pi = 3.14;   //pi是一个常量，它的值不能改变\ndouble *ptr = &pi;        //错误，ptr是一个普通指针\nconst double *cptr = &pi; //正确：cptr可以指向一个双精度常量\n*cptr = 42;               //错误：不能给*cptr赋值\ndouble dval = 3.2;\ncptr = &dval;            //对的\n```\n\n**注意：**之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象：\n\n```C++\ndouble dval = 3.14;\nconst double *ptr = &dval;\n```\n\n和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。**所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变**。\n\n## const指针（常量指针 int *const curErr）\n\n指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。**常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了**。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值：\n\n```C++\nint errNumb = 0;\nint *const curErr = &errNumb;  //curErr将一直指向errNumb\nconst double pi = 3.14159;\nconst double *const pip = &pi;  //pip是一个指向常量对象的常量指针\n```\n\n**从右向左阅读**\n\n此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。\n\n指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值：\n\n```C++\n*pip = 2.72; // 错误：pip是一个指向常量的指针\n//如果curErr所指的对象（也就是errNumb）的值不为0\nif(*curErr)\n{\n    errorHandler();\n    *curErr = 0;  //正确，把curErr所值得对象的值重置\n}\n```\n\n## 总结\n\n指向常量的指针（const doubel *cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int *const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。\n\n```C++\nconst double pi = 3.14\nconst double *const pip = &pi;\n```\n\n则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/引用&指针&const.md","raw":"---\ntitle: 引用&指针&const\ndate: 2017-09-1 19:59:25\nupdate:\ntags: [C++ Primers,C++基础知识]\ncategories: C++\ncomments: true\n---\n　　本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。\n<!-- more -->\n\n# 引用\n\n一条声明语句由一个**基本数据类型**和紧随其后的一个**声明符**列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。\n\n```C++\nint a;\n基本数据类型   声明符（其实就是变量名）\n//更复杂的声明符 ----接下来的指针和引用\nint *b;   //指针可以不初始化，没语法错误\nint &b = a;     //引用必须初始化\n```\n\n**引用**（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&d的形式来定义引用类型，其中d是声明的变量名。\n\n```C++\nint ival = 1024;\nint &refVal = ival; //refVal指向ival(是ival的另一个名字)\nint &refVal2;   //报错，引用必须初始化\n```\n\n一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。**因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。**\n\n## 引用注意细节\n\n- 无法令引用重新绑定到另外一个对象，因此引用必须初始化。\n- 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。\n- 引用本身不是对象，所以不能定义引用的引用。\n- 引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（**两种例外，一种是对常量的引用 const int &**）\n\n```C++\nint &refVal4 = 10;  //错误，引用类型的初始值必须是一个对象\ndouble dval = 3.14;\nint &refVal5 = dval;  //错误：此处引用类型初始值必须是int型对象\n```\n\n## 代码示例\n\n```C++\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int a = 2;\n    int c = 4;\n    int &b = a;  //b是a的引用，即b是a的别名\n    //&b = c;  错误,无法令引用重新绑定到另外一个对象上\n    cout<<a<<\" \"<<b<<\" \"<<&a<<\" \"<<&b<<endl;\n    a = 5;\n    cout<<a<<\" \"<<b<<\" \"<<&a<<\" \"<<&b<<endl;\n    b = 6;\n    cout<<a<<\" \"<<b<<\" \"<<&a<<\" \"<<&b<<endl;\n    a = c;    //将a的值改变，b的值也相应改变，但&a和&b还是一样的\n    cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<&a<<\" \"<<&b<<\" \"<<&c<<endl;\n    b = c;   //同上\n    cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<&a<<\" \"<<&b<<\" \"<<&c<<endl;\n    return 0;\n}\n```\n\n    2  2  0x28fef8  0x28fef8\n    5  5  0x28fef8  0x28fef8\n    6  6  0x28fef8  0x28fef8\n    4  4  0x28fef8  0x28fef8 0x28fef4\n    4  4  0x28fef8  0x28fef8 0x28fef4\n    \n# 指针\n\n**指针**是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。\n\n**指针和引用的不同点**：\n\n- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。\n- 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n\n## 获取对象的地址\n\n指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&）.\n\n```C++\nint ival = 42;\nint *p = &ival;  //指针变量p存放变量ival的地址,也即p是指向变量ival的指针\n```\n\n## 注意细节\n\n- 引用不是对象，没有实际地址，所有不能定义指向引用的指针。\n- 指针的类型要和它指向的对象严格匹配(**两种例外，一种是指向常量的指针**)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。\n\n## 指针值\n\n指针的值（即地址）应属下列4种状态之一：\n1. 指向一个对象\n2. 指向紧邻对象所占空间的下一个位置   \n3. 空指针，意味着指针没有指向任何对象\n4. 无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值）\n\n**注意**：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。\n\n## 利用指针访问对象\n\n使用**解引用符**（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。\n\n## 空指针\n\n空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：\n\n```C++\nint *p1 = nullptr;    //等价于int *p1 = 0;\nint *p2 = 0;   //直接将p2初始化为字面常量0\nint *p3 = NULL;    //等价于int *p1 = 0;\n```\n\nC++程序最好使用nullptr,同时尽量避免使用NULL。\n\n- 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。\n\n```C++\nint zero = 0 ,*p;\npi = zero;       // 错误：不能把int变量直接赋给指针\n```\n\n**note**:**建立初始化所有指针**\n\n**原因**：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。\n\n因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。\n\n## void* 指针\n\n**void*** **是一种特殊的指针类型，可用于存放任意对象的地址**。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：\n\n```C++\ndouble obj = 3.14, *pd = &obj;  // 正确：void*能存放任意类型对象的地址\nvoid *pv = &obj;      // obj可以是任意类型的对象\npv = pd;             // pv可以存放任意类型的指针\n```\n\n利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n\n概括说来，**以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象**\n\n## 代码示例\n\n```C++\n#include <iostream>\nusing namespace std;\nint main()\n{\n    double obj = 3.14,*pd = &obj;\n    void *pv = &obj;\n    cout<<&obj<<\" \"<<obj<<endl;\n    cout<<&pd<<\" \"<<pd<<\" \"<<*pd<<endl;\n    cout<<&pv<<\" \"<<pv<<\" \"<<endl;  //不能直接操作void* 指针所指的对象，即*pv是不合法的\n    return 0;\n}\n```\n\n    0x28ff08   3.14\n    0x28ff04   0x28ff08   3.14\n    0x28ff00   0x28ff08 \n    \n\n## 理解复合类型的声明\n\n修饰符（*或&）和变量标识符写在一起，修饰符(*或者&)都是修饰变量的。\n\n```C++\nint *p1,*p2;   //p1和p2都是指向int的指针\n```\n\n## 指向指针的指针\n\n指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。\n\n通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指向指针的指针的指，依次类推：\n\n```C++\nint ival = 1024;\nint *pi = &ival;   //pi指向一个int型的数\nint **ppi = &pi;   //ppi指向一个int型的指针\n//解引用\ncout<<ival<<\" \"<<*pi<<\" \"<<**ppi<<endl;\n```\n\n## 指向指针的引用\n\n引用本身不是对象，因此**不能定义指向引用的指针**。但指针是对象，所以**存在对指针的引用**。\n\n```C++\nint i = 42;\nint *p;   //p是一个int型指针\nint *&r = p;   //r是一个对指针p的引用,  此时r和p指针同名\nr = &i;   //r引用了一个指针，因此给r赋值&i就是令指向i\n*r = 0;   //解引用r得到i，也就是p指向的对象，将i的值改为0\n```\n\n要理解r的类型到底是什么，最简单的方法就是**从右向左阅读r的定义**。**离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响**，因此r是一个引用。**声明符的其余部分用以确定r引用的类型是什么**，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。\n\n# const限定符\n\n## const定义\n\n有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字**const**对变量的类型加以限制：\n\n```C++\nconst int bufSize = 512;     //输入缓冲区大小\n```\n\n这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。\n\n**因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。**\n\n```C++\nconst int i = get_size();    //正确：运行时初始化\nconst int j = 42;            //正确：编译时初始化\nconst int k;                 //错误：k是一个未经初始化的常量\n```\n\n**const类型能参与的操作**：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。\n\n## 默认状态下，const对象仅在文件内有效\n\n当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：\n\n```C++\nconst int bufSize = 512;     //输入缓冲区大小\n```\n\n编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。\n\n**默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。**\n\n某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，**只在一个文件中定义const，而在多个文件中声明并使用它。**\n\n**解决办法：**  对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了：\n\n```C++\n//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问\nextern const int bufferSize = function();\n//file1.h头文件\nextern const int bufferSize; //与file1.cpp中定义的是同一个\n```\n\n**note**：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。\n\n\n## const引用\n\n\n可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为**对常量的引用**（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。\n\n```C++\nconst int ci = 1024;\nconst int &r1 = ci;    //正确：引用及其对应的对象都是常量\nr1 = 42;               //错误：r1时对常量的引用\nint &r2 = ci;          //错误：试图让一个非常量引用指向一个常量对象\n```\n\n因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。\n\n## 初始化和对const的引用 \n\n引用的类型必须与其所引用对象的类型一致，但是有两个例外。**第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。** 尤其，**允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式**：\n\n```C++\nint i = 42;    \nconst int &r1 = i;       //允许将const int &绑定到一个普通int对象上\nconst int &r2 = 42;      //正确：r1是一个常量引用\nconst int &r3 = r1*2;    //正确：r3是一个常量引用\nint &r4 = r1*2;          //错误：r4是一个普通的非常量y\n```\n\n如果int &r4 = r1*2合法，那么就可以通过r4改变r1的值，而r1是常量引用。\n\n常量引用被绑定到另外一种类型上时到底发生了什么：\n\n```C++\ndouble dval = 3.14;\nconst int &ri = dval;\n//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：\nconst int temp = dval;  //由双精度浮点数生成一个临时的整形常量\nconst int &ri = temp;   //让ri绑定这个临时量\n```\n\n**总结**：常量引用（const &）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。\n\n## 对const的引用可能引用一个并非const的对象\n\n必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：\n\n```C++\nint i = 42;\nint &r1 = i;                 // 引用r1绑定对象i\nconst int &r2 = i； // r2也绑定对象i，但是不允许通过r2修改i的值\nr1 = 0;    // r1并非常量引用，i的值修改为0\nr2 = 0;    // 错误：r2是一个常量引用\n```\n\nr2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。\n\n## 指针和const(指向常量的指针 const double *cptr)\n\n**指向常量的指针（pointer to const）不能用于改变其所指对象的值**。要想存放常量对象的地址，只能使用指向常量的指针。\n\n```C++\nconst double pi = 3.14;   //pi是一个常量，它的值不能改变\ndouble *ptr = &pi;        //错误，ptr是一个普通指针\nconst double *cptr = &pi; //正确：cptr可以指向一个双精度常量\n*cptr = 42;               //错误：不能给*cptr赋值\ndouble dval = 3.2;\ncptr = &dval;            //对的\n```\n\n**注意：**之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象：\n\n```C++\ndouble dval = 3.14;\nconst double *ptr = &dval;\n```\n\n和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。**所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变**。\n\n## const指针（常量指针 int *const curErr）\n\n指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。**常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了**。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值：\n\n```C++\nint errNumb = 0;\nint *const curErr = &errNumb;  //curErr将一直指向errNumb\nconst double pi = 3.14159;\nconst double *const pip = &pi;  //pip是一个指向常量对象的常量指针\n```\n\n**从右向左阅读**\n\n此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。\n\n指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值：\n\n```C++\n*pip = 2.72; // 错误：pip是一个指向常量的指针\n//如果curErr所指的对象（也就是errNumb）的值不为0\nif(*curErr)\n{\n    errorHandler();\n    *curErr = 0;  //正确，把curErr所值得对象的值重置\n}\n```\n\n## 总结\n\n指向常量的指针（const doubel *cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int *const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。\n\n```C++\nconst double pi = 3.14\nconst double *const pip = &pi;\n```\n\n则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"引用&指针&const","published":1,"updated":"2018-01-16T06:30:25.588Z","layout":"post","photos":[],"link":"","_id":"cjcj3yigh000bjgc9jgmv1jid","content":"<p>　　本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。<br><a id=\"more\"></a></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><p>一条声明语句由一个<strong>基本数据类型</strong>和紧随其后的一个<strong>声明符</strong>列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a;</div><div class=\"line\">基本数据类型   声明符（其实就是变量名）</div><div class=\"line\"><span class=\"comment\">//更复杂的声明符 ----接下来的指针和引用</span></div><div class=\"line\"><span class=\"keyword\">int</span> *b;   <span class=\"comment\">//指针可以不初始化，没语法错误</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;b = a;     <span class=\"comment\">//引用必须初始化</span></div></pre></td></tr></table></figure>\n<p><strong>引用</strong>（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">1024</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal = ival; <span class=\"comment\">//refVal指向ival(是ival的另一个名字)</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal2;   <span class=\"comment\">//报错，引用必须初始化</span></div></pre></td></tr></table></figure>\n<p>一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。<strong>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</strong></p>\n<h2 id=\"引用注意细节\"><a href=\"#引用注意细节\" class=\"headerlink\" title=\"引用注意细节\"></a>引用注意细节</h2><ul>\n<li>无法令引用重新绑定到另外一个对象，因此引用必须初始化。</li>\n<li>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。</li>\n<li>引用本身不是对象，所以不能定义引用的引用。</li>\n<li>引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（<strong>两种例外，一种是对常量的引用 const int &amp;</strong>）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal4 = <span class=\"number\">10</span>;  <span class=\"comment\">//错误，引用类型的初始值必须是一个对象</span></div><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal5 = dval;  <span class=\"comment\">//错误：此处引用类型初始值必须是int型对象</span></div></pre></td></tr></table></figure>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">4</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> &amp;b = a;  <span class=\"comment\">//b是a的引用，即b是a的别名</span></div><div class=\"line\">    <span class=\"comment\">//&amp;b = c;  错误,无法令引用重新绑定到另外一个对象上</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a = <span class=\"number\">5</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    b = <span class=\"number\">6</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a = c;    <span class=\"comment\">//将a的值改变，b的值也相应改变，但&amp;a和&amp;b还是一样的</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;c&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;c&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    b = c;   <span class=\"comment\">//同上</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;c&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;c&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>2  2  0x28fef8  0x28fef8\n5  5  0x28fef8  0x28fef8\n6  6  0x28fef8  0x28fef8\n4  4  0x28fef8  0x28fef8 0x28fef4\n4  4  0x28fef8  0x28fef8 0x28fef4\n</code></pre><h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><p><strong>指针</strong>是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p>\n<p><strong>指针和引用的不同点</strong>：</p>\n<ul>\n<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li>\n<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>\n</ul>\n<h2 id=\"获取对象的地址\"><a href=\"#获取对象的地址\" class=\"headerlink\" title=\"获取对象的地址\"></a>获取对象的地址</h2><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&amp;）.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *p = &amp;ival;  <span class=\"comment\">//指针变量p存放变量ival的地址,也即p是指向变量ival的指针</span></div></pre></td></tr></table></figure>\n<h2 id=\"注意细节\"><a href=\"#注意细节\" class=\"headerlink\" title=\"注意细节\"></a>注意细节</h2><ul>\n<li>引用不是对象，没有实际地址，所有不能定义指向引用的指针。</li>\n<li>指针的类型要和它指向的对象严格匹配(<strong>两种例外，一种是指向常量的指针</strong>)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</li>\n</ul>\n<h2 id=\"指针值\"><a href=\"#指针值\" class=\"headerlink\" title=\"指针值\"></a>指针值</h2><p>指针的值（即地址）应属下列4种状态之一：</p>\n<ol>\n<li>指向一个对象</li>\n<li>指向紧邻对象所占空间的下一个位置   </li>\n<li>空指针，意味着指针没有指向任何对象</li>\n<li>无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值）</li>\n</ol>\n<p><strong>注意</strong>：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。</p>\n<h2 id=\"利用指针访问对象\"><a href=\"#利用指针访问对象\" class=\"headerlink\" title=\"利用指针访问对象\"></a>利用指针访问对象</h2><p>使用<strong>解引用符</strong>（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。</p>\n<h2 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h2><p>空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *p1 = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">//等价于int *p1 = 0;</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p2 = <span class=\"number\">0</span>;   <span class=\"comment\">//直接将p2初始化为字面常量0</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p3 = <span class=\"literal\">NULL</span>;    <span class=\"comment\">//等价于int *p1 = 0;</span></div></pre></td></tr></table></figure>\n<p>C++程序最好使用nullptr,同时尽量避免使用NULL。</p>\n<ul>\n<li>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> zero = <span class=\"number\">0</span> ,*p;</div><div class=\"line\">pi = zero;       <span class=\"comment\">// 错误：不能把int变量直接赋给指针</span></div></pre></td></tr></table></figure>\n<p><strong>note</strong>:<strong>建立初始化所有指针</strong></p>\n<p><strong>原因</strong>：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</p>\n<p>因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。</p>\n<h2 id=\"void-指针\"><a href=\"#void-指针\" class=\"headerlink\" title=\"void* 指针\"></a>void* 指针</h2><p><strong>void*</strong> <strong>是一种特殊的指针类型，可用于存放任意对象的地址</strong>。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> obj = <span class=\"number\">3.14</span>, *pd = &amp;obj;  <span class=\"comment\">// 正确：void*能存放任意类型对象的地址</span></div><div class=\"line\"><span class=\"keyword\">void</span> *pv = &amp;obj;      <span class=\"comment\">// obj可以是任意类型的对象</span></div><div class=\"line\">pv = pd;             <span class=\"comment\">// pv可以存放任意类型的指针</span></div></pre></td></tr></table></figure>\n<p>利用void<em>指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void</em>指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p>\n<p>概括说来，<strong>以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象</strong></p>\n<h2 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> obj = <span class=\"number\">3.14</span>,*pd = &amp;obj;</div><div class=\"line\">    <span class=\"keyword\">void</span> *pv = &amp;obj;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;&amp;obj&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;obj&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;&amp;pd&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;pd&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;*pd&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;&amp;pv&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;pv&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//不能直接操作void* 指针所指的对象，即*pv是不合法的</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>0x28ff08   3.14\n0x28ff04   0x28ff08   3.14\n0x28ff00   0x28ff08 \n</code></pre><h2 id=\"理解复合类型的声明\"><a href=\"#理解复合类型的声明\" class=\"headerlink\" title=\"理解复合类型的声明\"></a>理解复合类型的声明</h2><p>修饰符（<em>或&amp;）和变量标识符写在一起，修饰符(</em>或者&amp;)都是修饰变量的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *p1,*p2;   <span class=\"comment\">//p1和p2都是指向int的指针</span></div></pre></td></tr></table></figure>\n<h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><p>指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。</p>\n<p>通过<em>的个数可以区分指针的级别。也就是说，<strong>表示指向指针的指针，</strong></em>表示指向指针的指针的指，依次类推：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">1024</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *pi = &amp;ival;   <span class=\"comment\">//pi指向一个int型的数</span></div><div class=\"line\"><span class=\"keyword\">int</span> **ppi = &amp;pi;   <span class=\"comment\">//ppi指向一个int型的指针</span></div><div class=\"line\"><span class=\"comment\">//解引用</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;ival&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;*pi&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;**ppi&lt;&lt;<span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"指向指针的引用\"><a href=\"#指向指针的引用\" class=\"headerlink\" title=\"指向指针的引用\"></a>指向指针的引用</h2><p>引用本身不是对象，因此<strong>不能定义指向引用的指针</strong>。但指针是对象，所以<strong>存在对指针的引用</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *p;   <span class=\"comment\">//p是一个int型指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> *&amp;r = p;   <span class=\"comment\">//r是一个对指针p的引用,  此时r和p指针同名</span></div><div class=\"line\">r = &amp;i;   <span class=\"comment\">//r引用了一个指针，因此给r赋值&amp;i就是令指向i</span></div><div class=\"line\">*r = <span class=\"number\">0</span>;   <span class=\"comment\">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></div></pre></td></tr></table></figure>\n<p>要理解r的类型到底是什么，最简单的方法就是<strong>从右向左阅读r的定义</strong>。<strong>离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响</strong>，因此r是一个引用。<strong>声明符的其余部分用以确定r引用的类型是什么</strong>，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。</p>\n<h1 id=\"const限定符\"><a href=\"#const限定符\" class=\"headerlink\" title=\"const限定符\"></a>const限定符</h1><h2 id=\"const定义\"><a href=\"#const定义\" class=\"headerlink\" title=\"const定义\"></a>const定义</h2><p>有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字<strong>const</strong>对变量的类型加以限制：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufSize = <span class=\"number\">512</span>;     <span class=\"comment\">//输入缓冲区大小</span></div></pre></td></tr></table></figure>\n<p>这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。</p>\n<p><strong>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i = get_size();    <span class=\"comment\">//正确：运行时初始化</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> j = <span class=\"number\">42</span>;            <span class=\"comment\">//正确：编译时初始化</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k;                 <span class=\"comment\">//错误：k是一个未经初始化的常量</span></div></pre></td></tr></table></figure>\n<p><strong>const类型能参与的操作</strong>：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。</p>\n<h2 id=\"默认状态下，const对象仅在文件内有效\"><a href=\"#默认状态下，const对象仅在文件内有效\" class=\"headerlink\" title=\"默认状态下，const对象仅在文件内有效\"></a>默认状态下，const对象仅在文件内有效</h2><p>当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufSize = <span class=\"number\">512</span>;     <span class=\"comment\">//输入缓冲区大小</span></div></pre></td></tr></table></figure>\n<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。</p>\n<p><strong>默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。</strong></p>\n<p>某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，<strong>只在一个文件中定义const，而在多个文件中声明并使用它。</strong></p>\n<p><strong>解决办法：</strong>  对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufferSize = function();</div><div class=\"line\"><span class=\"comment\">//file1.h头文件</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufferSize; <span class=\"comment\">//与file1.cpp中定义的是同一个</span></div></pre></td></tr></table></figure>\n<p><strong>note</strong>：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>\n<h2 id=\"const引用\"><a href=\"#const引用\" class=\"headerlink\" title=\"const引用\"></a>const引用</h2><p>可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为<strong>对常量的引用</strong>（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = <span class=\"number\">1024</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r1 = ci;    <span class=\"comment\">//正确：引用及其对应的对象都是常量</span></div><div class=\"line\">r1 = <span class=\"number\">42</span>;               <span class=\"comment\">//错误：r1时对常量的引用</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r2 = ci;          <span class=\"comment\">//错误：试图让一个非常量引用指向一个常量对象</span></div></pre></td></tr></table></figure>\n<p>因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。</p>\n<h2 id=\"初始化和对const的引用\"><a href=\"#初始化和对const的引用\" class=\"headerlink\" title=\"初始化和对const的引用\"></a>初始化和对const的引用</h2><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。<strong>第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。</strong> 尤其，<strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;    </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r1 = i;       <span class=\"comment\">//允许将const int &amp;绑定到一个普通int对象上</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r2 = <span class=\"number\">42</span>;      <span class=\"comment\">//正确：r1是一个常量引用</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r3 = r1*<span class=\"number\">2</span>;    <span class=\"comment\">//正确：r3是一个常量引用</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r4 = r1*<span class=\"number\">2</span>;          <span class=\"comment\">//错误：r4是一个普通的非常量y</span></div></pre></td></tr></table></figure>\n<p>如果int &amp;r4 = r1*2合法，那么就可以通过r4改变r1的值，而r1是常量引用。</p>\n<p>常量引用被绑定到另外一种类型上时到底发生了什么：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</div><div class=\"line\"><span class=\"comment\">//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> temp = dval;  <span class=\"comment\">//由双精度浮点数生成一个临时的整形常量</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = temp;   <span class=\"comment\">//让ri绑定这个临时量</span></div></pre></td></tr></table></figure>\n<p><strong>总结</strong>：常量引用（const &amp;）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。</p>\n<h2 id=\"对const的引用可能引用一个并非const的对象\"><a href=\"#对const的引用可能引用一个并非const的对象\" class=\"headerlink\" title=\"对const的引用可能引用一个并非const的对象\"></a>对const的引用可能引用一个并非const的对象</h2><p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r1 = i;                 <span class=\"comment\">// 引用r1绑定对象i</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r2 = i； <span class=\"comment\">// r2也绑定对象i，但是不允许通过r2修改i的值</span></div><div class=\"line\">r1 = <span class=\"number\">0</span>;    <span class=\"comment\">// r1并非常量引用，i的值修改为0</span></div><div class=\"line\">r2 = <span class=\"number\">0</span>;    <span class=\"comment\">// 错误：r2是一个常量引用</span></div></pre></td></tr></table></figure>\n<p>r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。</p>\n<h2 id=\"指针和const-指向常量的指针-const-double-cptr\"><a href=\"#指针和const-指向常量的指针-const-double-cptr\" class=\"headerlink\" title=\"指针和const(指向常量的指针 const double *cptr)\"></a>指针和const(指向常量的指针 const double *cptr)</h2><p><strong>指向常量的指针（pointer to const）不能用于改变其所指对象的值</strong>。要想存放常量对象的地址，只能使用指向常量的指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;   <span class=\"comment\">//pi是一个常量，它的值不能改变</span></div><div class=\"line\"><span class=\"keyword\">double</span> *ptr = &amp;pi;        <span class=\"comment\">//错误，ptr是一个普通指针</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *cptr = &amp;pi; <span class=\"comment\">//正确：cptr可以指向一个双精度常量</span></div><div class=\"line\">*cptr = <span class=\"number\">42</span>;               <span class=\"comment\">//错误：不能给*cptr赋值</span></div><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.2</span>;</div><div class=\"line\">cptr = &amp;dval;            <span class=\"comment\">//对的</span></div></pre></td></tr></table></figure>\n<p><strong>注意：</strong>之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *ptr = &amp;dval;</div></pre></td></tr></table></figure>\n<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。<strong>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变</strong>。</p>\n<h2 id=\"const指针（常量指针-int-const-curErr）\"><a href=\"#const指针（常量指针-int-const-curErr）\" class=\"headerlink\" title=\"const指针（常量指针 int *const curErr）\"></a>const指针（常量指针 int *const curErr）</h2><p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。<strong>常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了</strong>。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> errNumb = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> curErr = &amp;errNumb;  <span class=\"comment\">//curErr将一直指向errNumb</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14159</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *<span class=\"keyword\">const</span> pip = &amp;pi;  <span class=\"comment\">//pip是一个指向常量对象的常量指针</span></div></pre></td></tr></table></figure>\n<p><strong>从右向左阅读</strong></p>\n<p>此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。</p>\n<p>指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">*pip = <span class=\"number\">2.72</span>; <span class=\"comment\">// 错误：pip是一个指向常量的指针</span></div><div class=\"line\"><span class=\"comment\">//如果curErr所指的对象（也就是errNumb）的值不为0</span></div><div class=\"line\"><span class=\"keyword\">if</span>(*curErr)</div><div class=\"line\">&#123;</div><div class=\"line\">    errorHandler();</div><div class=\"line\">    *curErr = <span class=\"number\">0</span>;  <span class=\"comment\">//正确，把curErr所值得对象的值重置</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>指向常量的指针（const doubel <em>cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int </em>const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *<span class=\"keyword\">const</span> pip = &amp;pi;</div></pre></td></tr></table></figure>\n<p>则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。</p>\n","site":{"data":{}},"excerpt":"<p>　　本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。<br>","more":"</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><p>一条声明语句由一个<strong>基本数据类型</strong>和紧随其后的一个<strong>声明符</strong>列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a;</div><div class=\"line\">基本数据类型   声明符（其实就是变量名）</div><div class=\"line\"><span class=\"comment\">//更复杂的声明符 ----接下来的指针和引用</span></div><div class=\"line\"><span class=\"keyword\">int</span> *b;   <span class=\"comment\">//指针可以不初始化，没语法错误</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;b = a;     <span class=\"comment\">//引用必须初始化</span></div></pre></td></tr></table></figure>\n<p><strong>引用</strong>（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">1024</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal = ival; <span class=\"comment\">//refVal指向ival(是ival的另一个名字)</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal2;   <span class=\"comment\">//报错，引用必须初始化</span></div></pre></td></tr></table></figure>\n<p>一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。<strong>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</strong></p>\n<h2 id=\"引用注意细节\"><a href=\"#引用注意细节\" class=\"headerlink\" title=\"引用注意细节\"></a>引用注意细节</h2><ul>\n<li>无法令引用重新绑定到另外一个对象，因此引用必须初始化。</li>\n<li>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。</li>\n<li>引用本身不是对象，所以不能定义引用的引用。</li>\n<li>引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（<strong>两种例外，一种是对常量的引用 const int &amp;</strong>）</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal4 = <span class=\"number\">10</span>;  <span class=\"comment\">//错误，引用类型的初始值必须是一个对象</span></div><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refVal5 = dval;  <span class=\"comment\">//错误：此处引用类型初始值必须是int型对象</span></div></pre></td></tr></table></figure>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">4</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> &amp;b = a;  <span class=\"comment\">//b是a的引用，即b是a的别名</span></div><div class=\"line\">    <span class=\"comment\">//&amp;b = c;  错误,无法令引用重新绑定到另外一个对象上</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a = <span class=\"number\">5</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    b = <span class=\"number\">6</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a = c;    <span class=\"comment\">//将a的值改变，b的值也相应改变，但&amp;a和&amp;b还是一样的</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;c&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;c&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    b = c;   <span class=\"comment\">//同上</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;c&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;a&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;b&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;&amp;c&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>2  2  0x28fef8  0x28fef8\n5  5  0x28fef8  0x28fef8\n6  6  0x28fef8  0x28fef8\n4  4  0x28fef8  0x28fef8 0x28fef4\n4  4  0x28fef8  0x28fef8 0x28fef4\n</code></pre><h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><p><strong>指针</strong>是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p>\n<p><strong>指针和引用的不同点</strong>：</p>\n<ul>\n<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li>\n<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>\n</ul>\n<h2 id=\"获取对象的地址\"><a href=\"#获取对象的地址\" class=\"headerlink\" title=\"获取对象的地址\"></a>获取对象的地址</h2><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&amp;）.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *p = &amp;ival;  <span class=\"comment\">//指针变量p存放变量ival的地址,也即p是指向变量ival的指针</span></div></pre></td></tr></table></figure>\n<h2 id=\"注意细节\"><a href=\"#注意细节\" class=\"headerlink\" title=\"注意细节\"></a>注意细节</h2><ul>\n<li>引用不是对象，没有实际地址，所有不能定义指向引用的指针。</li>\n<li>指针的类型要和它指向的对象严格匹配(<strong>两种例外，一种是指向常量的指针</strong>)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</li>\n</ul>\n<h2 id=\"指针值\"><a href=\"#指针值\" class=\"headerlink\" title=\"指针值\"></a>指针值</h2><p>指针的值（即地址）应属下列4种状态之一：</p>\n<ol>\n<li>指向一个对象</li>\n<li>指向紧邻对象所占空间的下一个位置   </li>\n<li>空指针，意味着指针没有指向任何对象</li>\n<li>无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值）</li>\n</ol>\n<p><strong>注意</strong>：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。</p>\n<h2 id=\"利用指针访问对象\"><a href=\"#利用指针访问对象\" class=\"headerlink\" title=\"利用指针访问对象\"></a>利用指针访问对象</h2><p>使用<strong>解引用符</strong>（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。</p>\n<h2 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h2><p>空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *p1 = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">//等价于int *p1 = 0;</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p2 = <span class=\"number\">0</span>;   <span class=\"comment\">//直接将p2初始化为字面常量0</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p3 = <span class=\"literal\">NULL</span>;    <span class=\"comment\">//等价于int *p1 = 0;</span></div></pre></td></tr></table></figure>\n<p>C++程序最好使用nullptr,同时尽量避免使用NULL。</p>\n<ul>\n<li>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> zero = <span class=\"number\">0</span> ,*p;</div><div class=\"line\">pi = zero;       <span class=\"comment\">// 错误：不能把int变量直接赋给指针</span></div></pre></td></tr></table></figure>\n<p><strong>note</strong>:<strong>建立初始化所有指针</strong></p>\n<p><strong>原因</strong>：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</p>\n<p>因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。</p>\n<h2 id=\"void-指针\"><a href=\"#void-指针\" class=\"headerlink\" title=\"void* 指针\"></a>void* 指针</h2><p><strong>void*</strong> <strong>是一种特殊的指针类型，可用于存放任意对象的地址</strong>。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> obj = <span class=\"number\">3.14</span>, *pd = &amp;obj;  <span class=\"comment\">// 正确：void*能存放任意类型对象的地址</span></div><div class=\"line\"><span class=\"keyword\">void</span> *pv = &amp;obj;      <span class=\"comment\">// obj可以是任意类型的对象</span></div><div class=\"line\">pv = pd;             <span class=\"comment\">// pv可以存放任意类型的指针</span></div></pre></td></tr></table></figure>\n<p>利用void<em>指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void</em>指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p>\n<p>概括说来，<strong>以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象</strong></p>\n<h2 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> obj = <span class=\"number\">3.14</span>,*pd = &amp;obj;</div><div class=\"line\">    <span class=\"keyword\">void</span> *pv = &amp;obj;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;&amp;obj&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;obj&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;&amp;pd&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;pd&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;*pd&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;&amp;pv&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;pv&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//不能直接操作void* 指针所指的对象，即*pv是不合法的</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>0x28ff08   3.14\n0x28ff04   0x28ff08   3.14\n0x28ff00   0x28ff08 \n</code></pre><h2 id=\"理解复合类型的声明\"><a href=\"#理解复合类型的声明\" class=\"headerlink\" title=\"理解复合类型的声明\"></a>理解复合类型的声明</h2><p>修饰符（<em>或&amp;）和变量标识符写在一起，修饰符(</em>或者&amp;)都是修饰变量的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *p1,*p2;   <span class=\"comment\">//p1和p2都是指向int的指针</span></div></pre></td></tr></table></figure>\n<h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><p>指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。</p>\n<p>通过<em>的个数可以区分指针的级别。也就是说，<strong>表示指向指针的指针，</strong></em>表示指向指针的指针的指，依次类推：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">1024</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *pi = &amp;ival;   <span class=\"comment\">//pi指向一个int型的数</span></div><div class=\"line\"><span class=\"keyword\">int</span> **ppi = &amp;pi;   <span class=\"comment\">//ppi指向一个int型的指针</span></div><div class=\"line\"><span class=\"comment\">//解引用</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;ival&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;*pi&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;**ppi&lt;&lt;<span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure>\n<h2 id=\"指向指针的引用\"><a href=\"#指向指针的引用\" class=\"headerlink\" title=\"指向指针的引用\"></a>指向指针的引用</h2><p>引用本身不是对象，因此<strong>不能定义指向引用的指针</strong>。但指针是对象，所以<strong>存在对指针的引用</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *p;   <span class=\"comment\">//p是一个int型指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> *&amp;r = p;   <span class=\"comment\">//r是一个对指针p的引用,  此时r和p指针同名</span></div><div class=\"line\">r = &amp;i;   <span class=\"comment\">//r引用了一个指针，因此给r赋值&amp;i就是令指向i</span></div><div class=\"line\">*r = <span class=\"number\">0</span>;   <span class=\"comment\">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></div></pre></td></tr></table></figure>\n<p>要理解r的类型到底是什么，最简单的方法就是<strong>从右向左阅读r的定义</strong>。<strong>离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响</strong>，因此r是一个引用。<strong>声明符的其余部分用以确定r引用的类型是什么</strong>，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。</p>\n<h1 id=\"const限定符\"><a href=\"#const限定符\" class=\"headerlink\" title=\"const限定符\"></a>const限定符</h1><h2 id=\"const定义\"><a href=\"#const定义\" class=\"headerlink\" title=\"const定义\"></a>const定义</h2><p>有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字<strong>const</strong>对变量的类型加以限制：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufSize = <span class=\"number\">512</span>;     <span class=\"comment\">//输入缓冲区大小</span></div></pre></td></tr></table></figure>\n<p>这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。</p>\n<p><strong>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i = get_size();    <span class=\"comment\">//正确：运行时初始化</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> j = <span class=\"number\">42</span>;            <span class=\"comment\">//正确：编译时初始化</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k;                 <span class=\"comment\">//错误：k是一个未经初始化的常量</span></div></pre></td></tr></table></figure>\n<p><strong>const类型能参与的操作</strong>：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。</p>\n<h2 id=\"默认状态下，const对象仅在文件内有效\"><a href=\"#默认状态下，const对象仅在文件内有效\" class=\"headerlink\" title=\"默认状态下，const对象仅在文件内有效\"></a>默认状态下，const对象仅在文件内有效</h2><p>当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufSize = <span class=\"number\">512</span>;     <span class=\"comment\">//输入缓冲区大小</span></div></pre></td></tr></table></figure>\n<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。</p>\n<p><strong>默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。</strong></p>\n<p>某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，<strong>只在一个文件中定义const，而在多个文件中声明并使用它。</strong></p>\n<p><strong>解决办法：</strong>  对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufferSize = function();</div><div class=\"line\"><span class=\"comment\">//file1.h头文件</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> bufferSize; <span class=\"comment\">//与file1.cpp中定义的是同一个</span></div></pre></td></tr></table></figure>\n<p><strong>note</strong>：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>\n<h2 id=\"const引用\"><a href=\"#const引用\" class=\"headerlink\" title=\"const引用\"></a>const引用</h2><p>可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为<strong>对常量的引用</strong>（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = <span class=\"number\">1024</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r1 = ci;    <span class=\"comment\">//正确：引用及其对应的对象都是常量</span></div><div class=\"line\">r1 = <span class=\"number\">42</span>;               <span class=\"comment\">//错误：r1时对常量的引用</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r2 = ci;          <span class=\"comment\">//错误：试图让一个非常量引用指向一个常量对象</span></div></pre></td></tr></table></figure>\n<p>因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。</p>\n<h2 id=\"初始化和对const的引用\"><a href=\"#初始化和对const的引用\" class=\"headerlink\" title=\"初始化和对const的引用\"></a>初始化和对const的引用</h2><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。<strong>第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。</strong> 尤其，<strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;    </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r1 = i;       <span class=\"comment\">//允许将const int &amp;绑定到一个普通int对象上</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r2 = <span class=\"number\">42</span>;      <span class=\"comment\">//正确：r1是一个常量引用</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r3 = r1*<span class=\"number\">2</span>;    <span class=\"comment\">//正确：r3是一个常量引用</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r4 = r1*<span class=\"number\">2</span>;          <span class=\"comment\">//错误：r4是一个普通的非常量y</span></div></pre></td></tr></table></figure>\n<p>如果int &amp;r4 = r1*2合法，那么就可以通过r4改变r1的值，而r1是常量引用。</p>\n<p>常量引用被绑定到另外一种类型上时到底发生了什么：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</div><div class=\"line\"><span class=\"comment\">//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> temp = dval;  <span class=\"comment\">//由双精度浮点数生成一个临时的整形常量</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = temp;   <span class=\"comment\">//让ri绑定这个临时量</span></div></pre></td></tr></table></figure>\n<p><strong>总结</strong>：常量引用（const &amp;）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。</p>\n<h2 id=\"对const的引用可能引用一个并非const的对象\"><a href=\"#对const的引用可能引用一个并非const的对象\" class=\"headerlink\" title=\"对const的引用可能引用一个并非const的对象\"></a>对const的引用可能引用一个并非const的对象</h2><p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r1 = i;                 <span class=\"comment\">// 引用r1绑定对象i</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r2 = i； <span class=\"comment\">// r2也绑定对象i，但是不允许通过r2修改i的值</span></div><div class=\"line\">r1 = <span class=\"number\">0</span>;    <span class=\"comment\">// r1并非常量引用，i的值修改为0</span></div><div class=\"line\">r2 = <span class=\"number\">0</span>;    <span class=\"comment\">// 错误：r2是一个常量引用</span></div></pre></td></tr></table></figure>\n<p>r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。</p>\n<h2 id=\"指针和const-指向常量的指针-const-double-cptr\"><a href=\"#指针和const-指向常量的指针-const-double-cptr\" class=\"headerlink\" title=\"指针和const(指向常量的指针 const double *cptr)\"></a>指针和const(指向常量的指针 const double *cptr)</h2><p><strong>指向常量的指针（pointer to const）不能用于改变其所指对象的值</strong>。要想存放常量对象的地址，只能使用指向常量的指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;   <span class=\"comment\">//pi是一个常量，它的值不能改变</span></div><div class=\"line\"><span class=\"keyword\">double</span> *ptr = &amp;pi;        <span class=\"comment\">//错误，ptr是一个普通指针</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *cptr = &amp;pi; <span class=\"comment\">//正确：cptr可以指向一个双精度常量</span></div><div class=\"line\">*cptr = <span class=\"number\">42</span>;               <span class=\"comment\">//错误：不能给*cptr赋值</span></div><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.2</span>;</div><div class=\"line\">cptr = &amp;dval;            <span class=\"comment\">//对的</span></div></pre></td></tr></table></figure>\n<p><strong>注意：</strong>之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *ptr = &amp;dval;</div></pre></td></tr></table></figure>\n<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。<strong>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变</strong>。</p>\n<h2 id=\"const指针（常量指针-int-const-curErr）\"><a href=\"#const指针（常量指针-int-const-curErr）\" class=\"headerlink\" title=\"const指针（常量指针 int *const curErr）\"></a>const指针（常量指针 int *const curErr）</h2><p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。<strong>常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了</strong>。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> errNumb = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> curErr = &amp;errNumb;  <span class=\"comment\">//curErr将一直指向errNumb</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14159</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *<span class=\"keyword\">const</span> pip = &amp;pi;  <span class=\"comment\">//pip是一个指向常量对象的常量指针</span></div></pre></td></tr></table></figure>\n<p><strong>从右向左阅读</strong></p>\n<p>此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。</p>\n<p>指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">*pip = <span class=\"number\">2.72</span>; <span class=\"comment\">// 错误：pip是一个指向常量的指针</span></div><div class=\"line\"><span class=\"comment\">//如果curErr所指的对象（也就是errNumb）的值不为0</span></div><div class=\"line\"><span class=\"keyword\">if</span>(*curErr)</div><div class=\"line\">&#123;</div><div class=\"line\">    errorHandler();</div><div class=\"line\">    *curErr = <span class=\"number\">0</span>;  <span class=\"comment\">//正确，把curErr所值得对象的值重置</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>指向常量的指针（const doubel <em>cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int </em>const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *<span class=\"keyword\">const</span> pip = &amp;pi;</div></pre></td></tr></table></figure>\n<p>则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。</p>"},{"title":"类的基本概念","date":"2017-10-22T13:59:00.000Z","update":null,"comments":1,"_content":"# 一、前言\n介绍一些类的基本概念，包括类的基本思想，函数成员和数据成员，static成员，友元等。\n<!--more-->\n\n# 类\n\n类的基本思想是**数据抽象和封装**。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。\n\n封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。\n\n## 定义成员函数\n\n尽管所有成员函数都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。\n\nSales_data的一个成员函数\n\n```C++\nstring isbn() const { return bookNo;}\n```\n## 引入this指针\n\n```C++\nSales_data total;\ntotal.isbn();\n```\n在这里，使用点运算符来访问total对象的isbn成员，然后再调用它。\n\n当我们调用成员函数时，实际上是在替某个对象调用它。它隐式地指向调用该函数的对象的成员。实际上隐式地返回 total.bookNo。\n\n成员函数通过一个名为**this**的额外参数来访问调用它的那个对象。**当我们调用一个成员函数时，用请求该函数的对象地址初始化this。**\n\n```C++\ntotal.isbn()\n```\n\n相当于：\n\n```C++\n//伪代码，用于说明调用成员函数的实际执行过程\nSales_data::isbn(&total)\n```\n其中调用Sales_data的isbn成员时传入了total地址。\n\nthis是一个常量指针，我们不允许改变。\n\n\n## 引入const成员函数\n\n默认情况下，this的类型是指向类类型非常量版本的常量指针。意味着（在默认情况下）我们不能把this绑定到一个常量对象上。**这一情况也就使我们不能在一个常量对象上调用普通的成员函数。**\n\n**C++允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针**（const Sales_data *const this）。**像这样使用const的成员函数被称作常量成员函数**。\n\n因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内存。\n\n**常量对象、以及常量对象的引用或指针都只能调用常量成员函数。** ，非常量对象可以调用常量成员函数。\n\n\n## 类作用域和成员函数\n\n编译器分两步处理类：**首先编译成员的声明，然后才轮到成员函数体。** 因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。\n\n**类外部定义的成员的名字必须包含它所属的类名。**\n\n## 定义类相关的非成员函数\n\n一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。\n\n## 点运算符和箭头运算符（.  ->)\n\n```C++\nPerson p1 ,*p2;\np1.getname();   //针对于对象来使用的\np2->getname();   //针对于指针来使用的，等价于*p2.getname();\n```\n\n## 构造函数\n\n类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。\n\n**构造函数不能被声明成const。** 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。\n\n只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。\n\n知识点1：构造函数—特殊的成员函数，用来控制对象的初始化过程。无返回类型，可重载，不能被声明为const.\n\n知识点2：若无，则有默认的构造函数，是编译器自己隐式的定义的。又称合成的默认构造函数。\n\n知识点3：某些类是不能使用默认的构造函数的，以下三个原因：\n\n1：在未声明任何构造函数的前提下，类内对象的初始化将不受控制\n\n2：合成的默认构造函数可能会造成不必要的错误，如若没有类内初始值来初始化成员，可能这些成员将是未定义的。\n\n3：如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该对象。\n\n所以，在撰写类的时候，最好定义一个自己的构造函数。\n\n## 代码示例\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person;  //前向声明Person类\nistream& read(istream& is,Person& person);  //声明read函数\n\nclass Person{\npublic:\n    Person() = default;     //默认构造函数  等价于Person(){};\n    Person(string name,string address);   //重载构造函数\n    Person(istream &is){   //重载构造函数，通过调用非成员函数read对其进行赋值\n        read(is,*this);\n    }\n    void show();\n    const string& getname(){\n         return this->name;\n    }\n    const string& getaddress(){\n         return this->address;\n    }\n    void setname(string name){\n        this->name = name;\n    }\n    void setaddress(string address){\n        this->address = address;\n    }\n    Person& combine(const Person &person);\nprivate:\n    string name;\n    string address;\n};\nvoid Person::show(){\n    cout<<\"name:\"<<this->name<<\" address:\"<<this->address<<endl;\n}\nPerson::Person(string name,string address):name(name),address(address){\n}\nPerson& Person::combine(const Person &person){\n    name += person.name;\n    return *this;\n}\n\nistream& read(istream& is,Person& person){   //非成员函数\n    string name ,address;\n    is>>name>>address;\n    person.setname(name);\n    person.setaddress(address);\n    return is;\n}\n\nint main()\n{\n    Person p1(\"wangxinri\",\"cqu\");\n    p1.show();\n    Person p2(\"ri\",\"cqu\");\n    p1.combine(p2);\n    p1.show();\n    cout<<p2.getname()<<endl;\n    cout<<p2.getaddress()<<endl;\n    Person p3(cin);\n    p3.show();\n    return 0;\n}\n```\n\n## 拷贝、赋值和析构\n\n如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。\n\n对于某些类来说合成的版本无法正常工作，管理动态内存的类通常不能依赖于上述操作的合成版本。\n\n使用vector或者string的类能避免分配和释放内存带来的复杂性。如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。\n\n# 类的静态成员\n\n**有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联**。例如，一个银行账号类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。\n\n## 声明静态成员\n\n我们通过在成员的声明之前加上关键字static使得其与类关联在一起，和其他成员一样，静态成员可以使public得或private的。静态数据成员的类型可以使常量、引用、指针、类类型等。\n\n举个例子，我们定义一个类，用它表示银行的账户记录：\n\n```C++\nclass Account{\npublic:\n    void calculate() {amount+=amount*interestRate;}\n    static double rate() {return interestRate;}\n    static void rate(double);\nprivate:\n    std::string owner;\n    double amount;\n    static double interestRate;\n    static double initRate();\n};\n```\n\n**类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。** 因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。\n\n**类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的（const是用来修饰this指针类型的），而且我们也不能在static函数体内使用this指针，这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。静态成员函数不可以同时声明为 virtual、const、volatile函数。**\n\n```C++\nclass base{   \n    virtual static void func1();//错误   \n    static void func2() const;//错误   \n    static void func3() volatile;//错误   \n};\n```\n\n## 使用类的静态成员\n\n我们使用作用域运算符直接访问静态成员：\n```C++\ndouble r;\nr=Account::rate();   //使用作用域运算符访问静态成员\n```\n虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针类访问静态成员：\n```C++\nAccount ac1;\nAccount *ac2=&ac1;\n//调用静态成员函数rate的等价形式\nr=ac1.rate();   //通过Account的对象或引用\nr=ac2->rate();   //通过指向Account对象的指针\n```\n\n成员函数不用通过作用域运算符就能直接使用静态成员。\n\n```C++\nclass Account{\npublic:\n　　void calculate() {amount+=amount*interestRate;}\nprivate:\n　　static double interestRate;\n};\n```\n\n## 定义静态成员\n\n和其他的成员函数一样，**我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句**：\n```C++\nvoid Account::rate(double newRate)\n{\n　　interestRate=newRate;\n}\n```\n\n**和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。**\n\n因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。**而且一般来说，我们不能在类的内部初始化静态数据成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。**\n\n类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在于程序的整个生命周期中。\n\n我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：\n\n```C++\n//定义并初始化一个静态成员\ndouble Account::interestRate=initRate();\n```\n\n这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用initRate函数。注意，虽然initRate是私有的，我们也能使用它初始化interestRate。和其他成员的定义一样，interestRate的定义也可以访问类的私有成员。\n\n**要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一文件中**。\n\n## 静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\n\n通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适用于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员执行数组成员的维度：\n\n```C++\nclass Account{\npublic:\n    static double rate() { return interestRate;}\n    static void rate(double);\nprivate:\n    static constexpr int period=30;\n    double daily_tbl[period]; //period是常量表达式\n};\n```\n\n**如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了**：\n\n```C++\n//一个不带初始值的静态成员的定义\nconstexpr int Account::period;  //初始值在类的定义内提供\n```\n\n<font color=red>**即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员**。 </font>\n\n## 静态成员能用于某些场景，而普遍成员不能\n\n如我们所见，静态成员独立于任何对象。因为，在某些非静态数据成员可能非法的场合，静态 成员却可以正常地使用。举个例子，**静态数据成员可以是不完全类型。特别地，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。**\n\n```C++\nclass Bar{\npublic:\n    //......\nprivate:\n    static Bar mem1;  //正确：静态成员可以是不完全类型\n    Bar *mem2;         //正确：指针成员可以使不完全类型\n    Bar mem3;         //错误：数据成员必须是完全类型\n};\n```\n\n**静态成员和普通成员的另一个区别是我们可以使用静态成员作为默认实参**：\n\n```C++\nclass Screen{\npublic:\n    //bkground 不是一个在类中稍后定义的静态成员\n    Screen &clear(char =bkground);\nprivate:\n    static const char bkground;\n};\n```\n\n非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以从中获取成员的值，最终引发错误。\n\n## 简单代码示例\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Account{\npublic:\n    static double rate() { return interestRate; }\n    static void rate(double Rate);\nprivate:\n    string owner;\n    static double interestRate ;\n    static const int aa = 0;  //正确\n    static constexpr int bb = 0;  //正确，constexpr类型可以类内初始化\n    //static double cc = 0;  //错误\n};\n//外层定义static成员不需要加上static\ndouble Account::interestRate = 1.0;   //定义并初始化一个成员\nvoid Account::rate(double Rate){\n    interestRate = Rate;\n}\n\nint main()\n{\n    Account a1,a2;\n    cout<<a1.rate()<<\" \"<<a2.rate()<<endl;\n    a1.rate(2.0);\n    cout<<a1.rate()<<\" \"<<a2.rate()<<endl;\n    return 0;\n}\n```\n\n# 友元（friend）\n\n友元：类允许其他类或者函数访问其非公有成员，方法是令其他类或者函数成为它的**友元（friend)**。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。\n\n友元函数只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员函数也不受它所在区域访问控制级别的约束。\n\n一般来说，最好在类定义开始或者结束前的位置集中声明友元。\n\n## 友元的声明\n\n友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。\n\n\n## 友元再探\n\n类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数时隐式内联的。\n\n## 类之间的友元关系\n\n```C++\nclass Screen{\n    //Window_megr的成员可以访问Screen类的私有部分。\n    friend class Window_megr;  把Window_megr指定成Screen的友元\n    //Screen类的剩余部分\n}\n```\n\n如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。\n\n必须注意的是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。\n\n## 令成员函数作为友元\n\n除了令整个Window_mgr作为友元之外，Screen还可以只为Window_mgr成员函数clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：\n\n```C++\nclass Screen{\n    //Window_mgr::clear必须在Screen类之前被声明\n    friend void Window_mgr::clear(ScreenIndex);\n    //Screen类的剩余部分\n};\n```\n\n要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：\n\n- 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。\n- 接下来定义Screen，包括对于clear的友元声明\n- 最后定义clear，此时它才可以使用Screen的成员。\n\n \n\n## 函数重载和友元\n\n尽管重载函数的名字相同，但他们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：\n\n```C++\n//重载的storeOn函数\nextern ostream& storeOn(ostream＆ ,Screen &);\nextern BitMap &storeOn(BitMap& ,Screen &);\nclass Screen{\n    //StoreOnde ostream版本能访问Screen对象的私有部分\n    friend ostream::ostream& storeOn(ostream& ,Screen);\n};\n```\n\nScreen类把接受ostream&的storeOn函数声明成它的友元，但是接受BitMap&作为参数的版本仍然不能访问Screen。\n\n## 友元声明和作用域\n\n类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。\n\n甚至**就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。** 换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：\n\n```C++\nstruct X{\n    friend void f() { /*友元函数可以定义在类的内部*/}\n    X() {f();}  //错误：f还没有被声明\n    void g();\n    void h();\n};\nvoid X::g(){return f();}  //错误：f还没有被声明\nvoid f();   //声明那个定义在X中的函数\nvoid X::h() {return f();}  //正确：现在f的声明在作用域中了\n```\n关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。\n\n\n## 简单友元类示例\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass student{\nfriend class teacher;\npublic:\n    void show_info(){\n        cout<<\"name:\"<<name<<\" address\"<<endl;\n    }\nprivate:\n    string name = \"xin\";\n    string address = \"cqu\";\n};\nclass teacher{\npublic:\n    void show_info(){\n        cout<<\"name:\"<<name<<\" address\"<<endl;\n    }\n    void showStudent(student &STD);\nprivate:\n    string name;\n    string address;\n};\n\nvoid teacher::showStudent(student &STD){\n    cout<<STD.name<<\" \"<<STD.address<<endl;\n}\nint main()\n{\n    student STD;\n    STD.show_info();\n    teacher TEA;\n    TEA.showStudent(STD);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/类的基本概念.md","raw":"---\ntitle: 类的基本概念\ndate: 2017-10-22 21:59:00\nupdate: \ntags: [static成员,C++,类定义]\ncategories: C++\ncomments: true\n---\n# 一、前言\n介绍一些类的基本概念，包括类的基本思想，函数成员和数据成员，static成员，友元等。\n<!--more-->\n\n# 类\n\n类的基本思想是**数据抽象和封装**。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。\n\n封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。\n\n## 定义成员函数\n\n尽管所有成员函数都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。\n\nSales_data的一个成员函数\n\n```C++\nstring isbn() const { return bookNo;}\n```\n## 引入this指针\n\n```C++\nSales_data total;\ntotal.isbn();\n```\n在这里，使用点运算符来访问total对象的isbn成员，然后再调用它。\n\n当我们调用成员函数时，实际上是在替某个对象调用它。它隐式地指向调用该函数的对象的成员。实际上隐式地返回 total.bookNo。\n\n成员函数通过一个名为**this**的额外参数来访问调用它的那个对象。**当我们调用一个成员函数时，用请求该函数的对象地址初始化this。**\n\n```C++\ntotal.isbn()\n```\n\n相当于：\n\n```C++\n//伪代码，用于说明调用成员函数的实际执行过程\nSales_data::isbn(&total)\n```\n其中调用Sales_data的isbn成员时传入了total地址。\n\nthis是一个常量指针，我们不允许改变。\n\n\n## 引入const成员函数\n\n默认情况下，this的类型是指向类类型非常量版本的常量指针。意味着（在默认情况下）我们不能把this绑定到一个常量对象上。**这一情况也就使我们不能在一个常量对象上调用普通的成员函数。**\n\n**C++允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针**（const Sales_data *const this）。**像这样使用const的成员函数被称作常量成员函数**。\n\n因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内存。\n\n**常量对象、以及常量对象的引用或指针都只能调用常量成员函数。** ，非常量对象可以调用常量成员函数。\n\n\n## 类作用域和成员函数\n\n编译器分两步处理类：**首先编译成员的声明，然后才轮到成员函数体。** 因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。\n\n**类外部定义的成员的名字必须包含它所属的类名。**\n\n## 定义类相关的非成员函数\n\n一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。\n\n## 点运算符和箭头运算符（.  ->)\n\n```C++\nPerson p1 ,*p2;\np1.getname();   //针对于对象来使用的\np2->getname();   //针对于指针来使用的，等价于*p2.getname();\n```\n\n## 构造函数\n\n类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。\n\n**构造函数不能被声明成const。** 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。\n\n只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。\n\n知识点1：构造函数—特殊的成员函数，用来控制对象的初始化过程。无返回类型，可重载，不能被声明为const.\n\n知识点2：若无，则有默认的构造函数，是编译器自己隐式的定义的。又称合成的默认构造函数。\n\n知识点3：某些类是不能使用默认的构造函数的，以下三个原因：\n\n1：在未声明任何构造函数的前提下，类内对象的初始化将不受控制\n\n2：合成的默认构造函数可能会造成不必要的错误，如若没有类内初始值来初始化成员，可能这些成员将是未定义的。\n\n3：如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该对象。\n\n所以，在撰写类的时候，最好定义一个自己的构造函数。\n\n## 代码示例\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person;  //前向声明Person类\nistream& read(istream& is,Person& person);  //声明read函数\n\nclass Person{\npublic:\n    Person() = default;     //默认构造函数  等价于Person(){};\n    Person(string name,string address);   //重载构造函数\n    Person(istream &is){   //重载构造函数，通过调用非成员函数read对其进行赋值\n        read(is,*this);\n    }\n    void show();\n    const string& getname(){\n         return this->name;\n    }\n    const string& getaddress(){\n         return this->address;\n    }\n    void setname(string name){\n        this->name = name;\n    }\n    void setaddress(string address){\n        this->address = address;\n    }\n    Person& combine(const Person &person);\nprivate:\n    string name;\n    string address;\n};\nvoid Person::show(){\n    cout<<\"name:\"<<this->name<<\" address:\"<<this->address<<endl;\n}\nPerson::Person(string name,string address):name(name),address(address){\n}\nPerson& Person::combine(const Person &person){\n    name += person.name;\n    return *this;\n}\n\nistream& read(istream& is,Person& person){   //非成员函数\n    string name ,address;\n    is>>name>>address;\n    person.setname(name);\n    person.setaddress(address);\n    return is;\n}\n\nint main()\n{\n    Person p1(\"wangxinri\",\"cqu\");\n    p1.show();\n    Person p2(\"ri\",\"cqu\");\n    p1.combine(p2);\n    p1.show();\n    cout<<p2.getname()<<endl;\n    cout<<p2.getaddress()<<endl;\n    Person p3(cin);\n    p3.show();\n    return 0;\n}\n```\n\n## 拷贝、赋值和析构\n\n如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。\n\n对于某些类来说合成的版本无法正常工作，管理动态内存的类通常不能依赖于上述操作的合成版本。\n\n使用vector或者string的类能避免分配和释放内存带来的复杂性。如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。\n\n# 类的静态成员\n\n**有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联**。例如，一个银行账号类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。\n\n## 声明静态成员\n\n我们通过在成员的声明之前加上关键字static使得其与类关联在一起，和其他成员一样，静态成员可以使public得或private的。静态数据成员的类型可以使常量、引用、指针、类类型等。\n\n举个例子，我们定义一个类，用它表示银行的账户记录：\n\n```C++\nclass Account{\npublic:\n    void calculate() {amount+=amount*interestRate;}\n    static double rate() {return interestRate;}\n    static void rate(double);\nprivate:\n    std::string owner;\n    double amount;\n    static double interestRate;\n    static double initRate();\n};\n```\n\n**类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。** 因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。\n\n**类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的（const是用来修饰this指针类型的），而且我们也不能在static函数体内使用this指针，这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。静态成员函数不可以同时声明为 virtual、const、volatile函数。**\n\n```C++\nclass base{   \n    virtual static void func1();//错误   \n    static void func2() const;//错误   \n    static void func3() volatile;//错误   \n};\n```\n\n## 使用类的静态成员\n\n我们使用作用域运算符直接访问静态成员：\n```C++\ndouble r;\nr=Account::rate();   //使用作用域运算符访问静态成员\n```\n虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针类访问静态成员：\n```C++\nAccount ac1;\nAccount *ac2=&ac1;\n//调用静态成员函数rate的等价形式\nr=ac1.rate();   //通过Account的对象或引用\nr=ac2->rate();   //通过指向Account对象的指针\n```\n\n成员函数不用通过作用域运算符就能直接使用静态成员。\n\n```C++\nclass Account{\npublic:\n　　void calculate() {amount+=amount*interestRate;}\nprivate:\n　　static double interestRate;\n};\n```\n\n## 定义静态成员\n\n和其他的成员函数一样，**我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句**：\n```C++\nvoid Account::rate(double newRate)\n{\n　　interestRate=newRate;\n}\n```\n\n**和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。**\n\n因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。**而且一般来说，我们不能在类的内部初始化静态数据成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。**\n\n类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在于程序的整个生命周期中。\n\n我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：\n\n```C++\n//定义并初始化一个静态成员\ndouble Account::interestRate=initRate();\n```\n\n这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用initRate函数。注意，虽然initRate是私有的，我们也能使用它初始化interestRate。和其他成员的定义一样，interestRate的定义也可以访问类的私有成员。\n\n**要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一文件中**。\n\n## 静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\n\n通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适用于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员执行数组成员的维度：\n\n```C++\nclass Account{\npublic:\n    static double rate() { return interestRate;}\n    static void rate(double);\nprivate:\n    static constexpr int period=30;\n    double daily_tbl[period]; //period是常量表达式\n};\n```\n\n**如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了**：\n\n```C++\n//一个不带初始值的静态成员的定义\nconstexpr int Account::period;  //初始值在类的定义内提供\n```\n\n<font color=red>**即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员**。 </font>\n\n## 静态成员能用于某些场景，而普遍成员不能\n\n如我们所见，静态成员独立于任何对象。因为，在某些非静态数据成员可能非法的场合，静态 成员却可以正常地使用。举个例子，**静态数据成员可以是不完全类型。特别地，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。**\n\n```C++\nclass Bar{\npublic:\n    //......\nprivate:\n    static Bar mem1;  //正确：静态成员可以是不完全类型\n    Bar *mem2;         //正确：指针成员可以使不完全类型\n    Bar mem3;         //错误：数据成员必须是完全类型\n};\n```\n\n**静态成员和普通成员的另一个区别是我们可以使用静态成员作为默认实参**：\n\n```C++\nclass Screen{\npublic:\n    //bkground 不是一个在类中稍后定义的静态成员\n    Screen &clear(char =bkground);\nprivate:\n    static const char bkground;\n};\n```\n\n非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以从中获取成员的值，最终引发错误。\n\n## 简单代码示例\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Account{\npublic:\n    static double rate() { return interestRate; }\n    static void rate(double Rate);\nprivate:\n    string owner;\n    static double interestRate ;\n    static const int aa = 0;  //正确\n    static constexpr int bb = 0;  //正确，constexpr类型可以类内初始化\n    //static double cc = 0;  //错误\n};\n//外层定义static成员不需要加上static\ndouble Account::interestRate = 1.0;   //定义并初始化一个成员\nvoid Account::rate(double Rate){\n    interestRate = Rate;\n}\n\nint main()\n{\n    Account a1,a2;\n    cout<<a1.rate()<<\" \"<<a2.rate()<<endl;\n    a1.rate(2.0);\n    cout<<a1.rate()<<\" \"<<a2.rate()<<endl;\n    return 0;\n}\n```\n\n# 友元（friend）\n\n友元：类允许其他类或者函数访问其非公有成员，方法是令其他类或者函数成为它的**友元（friend)**。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。\n\n友元函数只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员函数也不受它所在区域访问控制级别的约束。\n\n一般来说，最好在类定义开始或者结束前的位置集中声明友元。\n\n## 友元的声明\n\n友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。\n\n\n## 友元再探\n\n类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数时隐式内联的。\n\n## 类之间的友元关系\n\n```C++\nclass Screen{\n    //Window_megr的成员可以访问Screen类的私有部分。\n    friend class Window_megr;  把Window_megr指定成Screen的友元\n    //Screen类的剩余部分\n}\n```\n\n如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。\n\n必须注意的是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。\n\n## 令成员函数作为友元\n\n除了令整个Window_mgr作为友元之外，Screen还可以只为Window_mgr成员函数clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：\n\n```C++\nclass Screen{\n    //Window_mgr::clear必须在Screen类之前被声明\n    friend void Window_mgr::clear(ScreenIndex);\n    //Screen类的剩余部分\n};\n```\n\n要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：\n\n- 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。\n- 接下来定义Screen，包括对于clear的友元声明\n- 最后定义clear，此时它才可以使用Screen的成员。\n\n \n\n## 函数重载和友元\n\n尽管重载函数的名字相同，但他们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：\n\n```C++\n//重载的storeOn函数\nextern ostream& storeOn(ostream＆ ,Screen &);\nextern BitMap &storeOn(BitMap& ,Screen &);\nclass Screen{\n    //StoreOnde ostream版本能访问Screen对象的私有部分\n    friend ostream::ostream& storeOn(ostream& ,Screen);\n};\n```\n\nScreen类把接受ostream&的storeOn函数声明成它的友元，但是接受BitMap&作为参数的版本仍然不能访问Screen。\n\n## 友元声明和作用域\n\n类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。\n\n甚至**就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。** 换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：\n\n```C++\nstruct X{\n    friend void f() { /*友元函数可以定义在类的内部*/}\n    X() {f();}  //错误：f还没有被声明\n    void g();\n    void h();\n};\nvoid X::g(){return f();}  //错误：f还没有被声明\nvoid f();   //声明那个定义在X中的函数\nvoid X::h() {return f();}  //正确：现在f的声明在作用域中了\n```\n关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。\n\n\n## 简单友元类示例\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass student{\nfriend class teacher;\npublic:\n    void show_info(){\n        cout<<\"name:\"<<name<<\" address\"<<endl;\n    }\nprivate:\n    string name = \"xin\";\n    string address = \"cqu\";\n};\nclass teacher{\npublic:\n    void show_info(){\n        cout<<\"name:\"<<name<<\" address\"<<endl;\n    }\n    void showStudent(student &STD);\nprivate:\n    string name;\n    string address;\n};\n\nvoid teacher::showStudent(student &STD){\n    cout<<STD.name<<\" \"<<STD.address<<endl;\n}\nint main()\n{\n    student STD;\n    STD.show_info();\n    teacher TEA;\n    TEA.showStudent(STD);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"类的基本概念","published":1,"updated":"2018-01-17T12:39:40.280Z","layout":"post","photos":[],"link":"","_id":"cjcj3yiox001bjgc9pv7zphoe","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍一些类的基本概念，包括类的基本思想，函数成员和数据成员，static成员，友元等。<br><a id=\"more\"></a></p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>类的基本思想是<strong>数据抽象和封装</strong>。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>\n<p>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。</p>\n<h2 id=\"定义成员函数\"><a href=\"#定义成员函数\" class=\"headerlink\" title=\"定义成员函数\"></a>定义成员函数</h2><p>尽管所有成员函数都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。</p>\n<p>Sales_data的一个成员函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">isbn</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> bookNo;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"引入this指针\"><a href=\"#引入this指针\" class=\"headerlink\" title=\"引入this指针\"></a>引入this指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Sales_data total;</div><div class=\"line\">total.isbn();</div></pre></td></tr></table></figure>\n<p>在这里，使用点运算符来访问total对象的isbn成员，然后再调用它。</p>\n<p>当我们调用成员函数时，实际上是在替某个对象调用它。它隐式地指向调用该函数的对象的成员。实际上隐式地返回 total.bookNo。</p>\n<p>成员函数通过一个名为<strong>this</strong>的额外参数来访问调用它的那个对象。<strong>当我们调用一个成员函数时，用请求该函数的对象地址初始化this。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">total.isbn()</div></pre></td></tr></table></figure>\n<p>相当于：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//伪代码，用于说明调用成员函数的实际执行过程</span></div><div class=\"line\">Sales_data::isbn(&amp;total)</div></pre></td></tr></table></figure>\n<p>其中调用Sales_data的isbn成员时传入了total地址。</p>\n<p>this是一个常量指针，我们不允许改变。</p>\n<h2 id=\"引入const成员函数\"><a href=\"#引入const成员函数\" class=\"headerlink\" title=\"引入const成员函数\"></a>引入const成员函数</h2><p>默认情况下，this的类型是指向类类型非常量版本的常量指针。意味着（在默认情况下）我们不能把this绑定到一个常量对象上。<strong>这一情况也就使我们不能在一个常量对象上调用普通的成员函数。</strong></p>\n<p><strong>C++允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针</strong>（const Sales_data <em>const this）。<em>*像这样使用const的成员函数被称作常量成员函数</em></em>。</p>\n<p>因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内存。</p>\n<p><strong>常量对象、以及常量对象的引用或指针都只能调用常量成员函数。</strong> ，非常量对象可以调用常量成员函数。</p>\n<h2 id=\"类作用域和成员函数\"><a href=\"#类作用域和成员函数\" class=\"headerlink\" title=\"类作用域和成员函数\"></a>类作用域和成员函数</h2><p>编译器分两步处理类：<strong>首先编译成员的声明，然后才轮到成员函数体。</strong> 因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>\n<p><strong>类外部定义的成员的名字必须包含它所属的类名。</strong></p>\n<h2 id=\"定义类相关的非成员函数\"><a href=\"#定义类相关的非成员函数\" class=\"headerlink\" title=\"定义类相关的非成员函数\"></a>定义类相关的非成员函数</h2><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p>\n<h2 id=\"点运算符和箭头运算符（-gt\"><a href=\"#点运算符和箭头运算符（-gt\" class=\"headerlink\" title=\"点运算符和箭头运算符（.  -&gt;)\"></a>点运算符和箭头运算符（.  -&gt;)</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person p1 ,*p2;</div><div class=\"line\">p1.getname();   <span class=\"comment\">//针对于对象来使用的</span></div><div class=\"line\">p2-&gt;getname();   <span class=\"comment\">//针对于指针来使用的，等价于*p2.getname();</span></div></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>。</p>\n<p><strong>构造函数不能被声明成const。</strong> 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。</p>\n<p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p>\n<p>知识点1：构造函数—特殊的成员函数，用来控制对象的初始化过程。无返回类型，可重载，不能被声明为const.</p>\n<p>知识点2：若无，则有默认的构造函数，是编译器自己隐式的定义的。又称合成的默认构造函数。</p>\n<p>知识点3：某些类是不能使用默认的构造函数的，以下三个原因：</p>\n<p>1：在未声明任何构造函数的前提下，类内对象的初始化将不受控制</p>\n<p>2：合成的默认构造函数可能会造成不必要的错误，如若没有类内初始值来初始化成员，可能这些成员将是未定义的。</p>\n<p>3：如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该对象。</p>\n<p>所以，在撰写类的时候，最好定义一个自己的构造函数。</p>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span>  <span class=\"comment\">//前向声明Person类</span></div><div class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">read</span><span class=\"params\">(istream&amp; is,Person&amp; person)</span></span>;  <span class=\"comment\">//声明read函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Person() = <span class=\"keyword\">default</span>;     <span class=\"comment\">//默认构造函数  等价于Person()&#123;&#125;;</span></div><div class=\"line\">    Person(<span class=\"built_in\">string</span> name,<span class=\"built_in\">string</span> address);   <span class=\"comment\">//重载构造函数</span></div><div class=\"line\">    Person(istream &amp;is)&#123;   <span class=\"comment\">//重载构造函数，通过调用非成员函数read对其进行赋值</span></div><div class=\"line\">        read(is,*<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">getname</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">getaddress</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;address;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setname</span><span class=\"params\">(<span class=\"built_in\">string</span> name)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setaddress</span><span class=\"params\">(<span class=\"built_in\">string</span> address)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;address = address;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\">Person&amp; <span class=\"title\">combine</span><span class=\"params\">(<span class=\"keyword\">const</span> Person &amp;person)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">string</span> address;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">void</span> Person::show()&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"name:\"</span>&lt;&lt;<span class=\"keyword\">this</span>-&gt;name&lt;&lt;<span class=\"string\">\" address:\"</span>&lt;&lt;<span class=\"keyword\">this</span>-&gt;address&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Person::Person(<span class=\"built_in\">string</span> name,<span class=\"built_in\">string</span> address):name(name),address(address)&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Person&amp; Person::combine(<span class=\"keyword\">const</span> Person &amp;person)&#123;</div><div class=\"line\">    name += person.name;</div><div class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">read</span><span class=\"params\">(istream&amp; is,Person&amp; person)</span></span>&#123;   <span class=\"comment\">//非成员函数</span></div><div class=\"line\">    <span class=\"built_in\">string</span> name ,address;</div><div class=\"line\">    is&gt;&gt;name&gt;&gt;address;</div><div class=\"line\">    person.setname(name);</div><div class=\"line\">    person.setaddress(address);</div><div class=\"line\">    <span class=\"keyword\">return</span> is;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"string\">\"wangxinri\"</span>,<span class=\"string\">\"cqu\"</span>)</span></span>;</div><div class=\"line\">    p1.show();</div><div class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"string\">\"ri\"</span>,<span class=\"string\">\"cqu\"</span>)</span></span>;</div><div class=\"line\">    p1.combine(p2);</div><div class=\"line\">    p1.show();</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;p2.getname()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;p2.getaddress()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"function\">Person <span class=\"title\">p3</span><span class=\"params\">(<span class=\"built_in\">cin</span>)</span></span>;</div><div class=\"line\">    p3.show();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"拷贝、赋值和析构\"><a href=\"#拷贝、赋值和析构\" class=\"headerlink\" title=\"拷贝、赋值和析构\"></a>拷贝、赋值和析构</h2><p>如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。</p>\n<p>对于某些类来说合成的版本无法正常工作，管理动态内存的类通常不能依赖于上述操作的合成版本。</p>\n<p>使用vector或者string的类能避免分配和释放内存带来的复杂性。如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。</p>\n<h1 id=\"类的静态成员\"><a href=\"#类的静态成员\" class=\"headerlink\" title=\"类的静态成员\"></a>类的静态成员</h1><p><strong>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联</strong>。例如，一个银行账号类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。</p>\n<h2 id=\"声明静态成员\"><a href=\"#声明静态成员\" class=\"headerlink\" title=\"声明静态成员\"></a>声明静态成员</h2><p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起，和其他成员一样，静态成员可以使public得或private的。静态数据成员的类型可以使常量、引用、指针、类类型等。</p>\n<p>举个例子，我们定义一个类，用它表示银行的账户记录：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">calculate</span><span class=\"params\">()</span> </span>&#123;amount+=amount*interestRate;&#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> interestRate;&#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> owner;</div><div class=\"line\">    <span class=\"keyword\">double</span> amount;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> interestRate;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">initRate</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</strong> 因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。</p>\n<p><strong>类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的（const是用来修饰this指针类型的），而且我们也不能在static函数体内使用this指针，这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。静态成员函数不可以同时声明为 virtual、const、volatile函数。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base</span>&#123;</span>   </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;<span class=\"comment\">//错误   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//错误   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func3</span><span class=\"params\">()</span> <span class=\"keyword\">volatile</span></span>;<span class=\"comment\">//错误   </span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"使用类的静态成员\"><a href=\"#使用类的静态成员\" class=\"headerlink\" title=\"使用类的静态成员\"></a>使用类的静态成员</h2><p>我们使用作用域运算符直接访问静态成员：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> r;</div><div class=\"line\">r=Account::rate();   <span class=\"comment\">//使用作用域运算符访问静态成员</span></div></pre></td></tr></table></figure></p>\n<p>虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针类访问静态成员：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Account ac1;</div><div class=\"line\">Account *ac2=&amp;ac1;</div><div class=\"line\"><span class=\"comment\">//调用静态成员函数rate的等价形式</span></div><div class=\"line\">r=ac1.rate();   <span class=\"comment\">//通过Account的对象或引用</span></div><div class=\"line\">r=ac2-&gt;rate();   <span class=\"comment\">//通过指向Account对象的指针</span></div></pre></td></tr></table></figure></p>\n<p>成员函数不用通过作用域运算符就能直接使用静态成员。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">　　<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">calculate</span><span class=\"params\">()</span> </span>&#123;amount+=amount*interestRate;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">　　<span class=\"keyword\">static</span> <span class=\"keyword\">double</span> interestRate;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"定义静态成员\"><a href=\"#定义静态成员\" class=\"headerlink\" title=\"定义静态成员\"></a>定义静态成员</h2><p>和其他的成员函数一样，<strong>我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句</strong>：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> Account::rate(<span class=\"keyword\">double</span> newRate)</div><div class=\"line\">&#123;</div><div class=\"line\">　　interestRate=newRate;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。</strong></p>\n<p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。<strong>而且一般来说，我们不能在类的内部初始化静态数据成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。</strong></p>\n<p>类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在于程序的整个生命周期中。</p>\n<p>我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义并初始化一个静态成员</span></div><div class=\"line\"><span class=\"keyword\">double</span> Account::interestRate=initRate();</div></pre></td></tr></table></figure>\n<p>这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用initRate函数。注意，虽然initRate是私有的，我们也能使用它初始化interestRate。和其他成员的定义一样，interestRate的定义也可以访问类的私有成员。</p>\n<p><strong>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一文件中</strong>。</p>\n<h2 id=\"静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\"><a href=\"#静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\" class=\"headerlink\" title=\"静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\"></a>静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）</h2><p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适用于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员执行数组成员的维度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> interestRate;&#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> period=<span class=\"number\">30</span>;</div><div class=\"line\">    <span class=\"keyword\">double</span> daily_tbl[period]; <span class=\"comment\">//period是常量表达式</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个不带初始值的静态成员的定义</span></div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> Account::period;  <span class=\"comment\">//初始值在类的定义内提供</span></div></pre></td></tr></table></figure>\n<font color=\"red\"><strong>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员</strong>。 </font>\n\n<h2 id=\"静态成员能用于某些场景，而普遍成员不能\"><a href=\"#静态成员能用于某些场景，而普遍成员不能\" class=\"headerlink\" title=\"静态成员能用于某些场景，而普遍成员不能\"></a>静态成员能用于某些场景，而普遍成员不能</h2><p>如我们所见，静态成员独立于任何对象。因为，在某些非静态数据成员可能非法的场合，静态 成员却可以正常地使用。举个例子，<strong>静态数据成员可以是不完全类型。特别地，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//......</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> Bar mem1;  <span class=\"comment\">//正确：静态成员可以是不完全类型</span></div><div class=\"line\">    Bar *mem2;         <span class=\"comment\">//正确：指针成员可以使不完全类型</span></div><div class=\"line\">    Bar mem3;         <span class=\"comment\">//错误：数据成员必须是完全类型</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>静态成员和普通成员的另一个区别是我们可以使用静态成员作为默认实参</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//bkground 不是一个在类中稍后定义的静态成员</span></div><div class=\"line\">    <span class=\"function\">Screen &amp;<span class=\"title\">clear</span><span class=\"params\">(<span class=\"keyword\">char</span> =bkground)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> bkground;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以从中获取成员的值，最终引发错误。</p>\n<h2 id=\"简单代码示例\"><a href=\"#简单代码示例\" class=\"headerlink\" title=\"简单代码示例\"></a>简单代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> interestRate; &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"keyword\">double</span> Rate)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> owner;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> interestRate ;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> aa = <span class=\"number\">0</span>;  <span class=\"comment\">//正确</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> bb = <span class=\"number\">0</span>;  <span class=\"comment\">//正确，constexpr类型可以类内初始化</span></div><div class=\"line\">    <span class=\"comment\">//static double cc = 0;  //错误</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//外层定义static成员不需要加上static</span></div><div class=\"line\"><span class=\"keyword\">double</span> Account::interestRate = <span class=\"number\">1.0</span>;   <span class=\"comment\">//定义并初始化一个成员</span></div><div class=\"line\"><span class=\"keyword\">void</span> Account::rate(<span class=\"keyword\">double</span> Rate)&#123;</div><div class=\"line\">    interestRate = Rate;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    Account a1,a2;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a1.rate()&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;a2.rate()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a1.rate(<span class=\"number\">2.0</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a1.rate()&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;a2.rate()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"友元（friend）\"><a href=\"#友元（friend）\" class=\"headerlink\" title=\"友元（friend）\"></a>友元（friend）</h1><p>友元：类允许其他类或者函数访问其非公有成员，方法是令其他类或者函数成为它的<strong>友元（friend)</strong>。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。</p>\n<p>友元函数只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员函数也不受它所在区域访问控制级别的约束。</p>\n<p>一般来说，最好在类定义开始或者结束前的位置集中声明友元。</p>\n<h2 id=\"友元的声明\"><a href=\"#友元的声明\" class=\"headerlink\" title=\"友元的声明\"></a>友元的声明</h2><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>\n<h2 id=\"友元再探\"><a href=\"#友元再探\" class=\"headerlink\" title=\"友元再探\"></a>友元再探</h2><p>类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数时隐式内联的。</p>\n<h2 id=\"类之间的友元关系\"><a href=\"#类之间的友元关系\" class=\"headerlink\" title=\"类之间的友元关系\"></a>类之间的友元关系</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\">    <span class=\"comment\">//Window_megr的成员可以访问Screen类的私有部分。</span></div><div class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window_megr</span>;</span>  把Window_megr指定成Screen的友元</div><div class=\"line\">    <span class=\"comment\">//Screen类的剩余部分</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p>\n<p>必须注意的是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。</p>\n<h2 id=\"令成员函数作为友元\"><a href=\"#令成员函数作为友元\" class=\"headerlink\" title=\"令成员函数作为友元\"></a>令成员函数作为友元</h2><p>除了令整个Window_mgr作为友元之外，Screen还可以只为Window_mgr成员函数clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\">    <span class=\"comment\">//Window_mgr::clear必须在Screen类之前被声明</span></div><div class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> Window_mgr::clear(ScreenIndex);</div><div class=\"line\">    <span class=\"comment\">//Screen类的剩余部分</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：</p>\n<ul>\n<li>首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。</li>\n<li>接下来定义Screen，包括对于clear的友元声明</li>\n<li>最后定义clear，此时它才可以使用Screen的成员。</li>\n</ul>\n<h2 id=\"函数重载和友元\"><a href=\"#函数重载和友元\" class=\"headerlink\" title=\"函数重载和友元\"></a>函数重载和友元</h2><p>尽管重载函数的名字相同，但他们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//重载的storeOn函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> ostream&amp; <span class=\"title\">storeOn</span><span class=\"params\">(ostream＆ ,Screen &amp;)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> BitMap &amp;<span class=\"title\">storeOn</span><span class=\"params\">(BitMap&amp; ,Screen &amp;)</span></span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\">    <span class=\"comment\">//StoreOnde ostream版本能访问Screen对象的私有部分</span></div><div class=\"line\">    <span class=\"keyword\">friend</span> ostream::<span class=\"function\">ostream&amp; <span class=\"title\">storeOn</span><span class=\"params\">(ostream&amp; ,Screen)</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Screen类把接受ostream&amp;的storeOn函数声明成它的友元，但是接受BitMap&amp;作为参数的版本仍然不能访问Screen。</p>\n<h2 id=\"友元声明和作用域\"><a href=\"#友元声明和作用域\" class=\"headerlink\" title=\"友元声明和作用域\"></a>友元声明和作用域</h2><p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。</p>\n<p>甚至<strong>就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。</strong> 换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span>&#123;</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/*友元函数可以定义在类的内部*/</span>&#125;</div><div class=\"line\">    X() &#123;f();&#125;  <span class=\"comment\">//错误：f还没有被声明</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">h</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">void</span> X::g()&#123;<span class=\"keyword\">return</span> f();&#125;  <span class=\"comment\">//错误：f还没有被声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;   <span class=\"comment\">//声明那个定义在X中的函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> X::h() &#123;<span class=\"keyword\">return</span> f();&#125;  <span class=\"comment\">//正确：现在f的声明在作用域中了</span></div></pre></td></tr></table></figure>\n<p>关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。</p>\n<h2 id=\"简单友元类示例\"><a href=\"#简单友元类示例\" class=\"headerlink\" title=\"简单友元类示例\"></a>简单友元类示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">student</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">teacher</span>;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_info</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"name:\"</span>&lt;&lt;name&lt;&lt;<span class=\"string\">\" address\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> name = <span class=\"string\">\"xin\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> address = <span class=\"string\">\"cqu\"</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">teacher</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_info</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"name:\"</span>&lt;&lt;name&lt;&lt;<span class=\"string\">\" address\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showStudent</span><span class=\"params\">(student &amp;STD)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">string</span> address;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> teacher::showStudent(student &amp;STD)&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;STD.name&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;STD.address&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    student STD;</div><div class=\"line\">    STD.show_info();</div><div class=\"line\">    teacher TEA;</div><div class=\"line\">    TEA.showStudent(STD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍一些类的基本概念，包括类的基本思想，函数成员和数据成员，static成员，友元等。<br>","more":"</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>类的基本思想是<strong>数据抽象和封装</strong>。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>\n<p>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。</p>\n<h2 id=\"定义成员函数\"><a href=\"#定义成员函数\" class=\"headerlink\" title=\"定义成员函数\"></a>定义成员函数</h2><p>尽管所有成员函数都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。</p>\n<p>Sales_data的一个成员函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">isbn</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> bookNo;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"引入this指针\"><a href=\"#引入this指针\" class=\"headerlink\" title=\"引入this指针\"></a>引入this指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Sales_data total;</div><div class=\"line\">total.isbn();</div></pre></td></tr></table></figure>\n<p>在这里，使用点运算符来访问total对象的isbn成员，然后再调用它。</p>\n<p>当我们调用成员函数时，实际上是在替某个对象调用它。它隐式地指向调用该函数的对象的成员。实际上隐式地返回 total.bookNo。</p>\n<p>成员函数通过一个名为<strong>this</strong>的额外参数来访问调用它的那个对象。<strong>当我们调用一个成员函数时，用请求该函数的对象地址初始化this。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">total.isbn()</div></pre></td></tr></table></figure>\n<p>相当于：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//伪代码，用于说明调用成员函数的实际执行过程</span></div><div class=\"line\">Sales_data::isbn(&amp;total)</div></pre></td></tr></table></figure>\n<p>其中调用Sales_data的isbn成员时传入了total地址。</p>\n<p>this是一个常量指针，我们不允许改变。</p>\n<h2 id=\"引入const成员函数\"><a href=\"#引入const成员函数\" class=\"headerlink\" title=\"引入const成员函数\"></a>引入const成员函数</h2><p>默认情况下，this的类型是指向类类型非常量版本的常量指针。意味着（在默认情况下）我们不能把this绑定到一个常量对象上。<strong>这一情况也就使我们不能在一个常量对象上调用普通的成员函数。</strong></p>\n<p><strong>C++允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针</strong>（const Sales_data <em>const this）。<em>*像这样使用const的成员函数被称作常量成员函数</em></em>。</p>\n<p>因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内存。</p>\n<p><strong>常量对象、以及常量对象的引用或指针都只能调用常量成员函数。</strong> ，非常量对象可以调用常量成员函数。</p>\n<h2 id=\"类作用域和成员函数\"><a href=\"#类作用域和成员函数\" class=\"headerlink\" title=\"类作用域和成员函数\"></a>类作用域和成员函数</h2><p>编译器分两步处理类：<strong>首先编译成员的声明，然后才轮到成员函数体。</strong> 因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>\n<p><strong>类外部定义的成员的名字必须包含它所属的类名。</strong></p>\n<h2 id=\"定义类相关的非成员函数\"><a href=\"#定义类相关的非成员函数\" class=\"headerlink\" title=\"定义类相关的非成员函数\"></a>定义类相关的非成员函数</h2><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p>\n<h2 id=\"点运算符和箭头运算符（-gt\"><a href=\"#点运算符和箭头运算符（-gt\" class=\"headerlink\" title=\"点运算符和箭头运算符（.  -&gt;)\"></a>点运算符和箭头运算符（.  -&gt;)</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person p1 ,*p2;</div><div class=\"line\">p1.getname();   <span class=\"comment\">//针对于对象来使用的</span></div><div class=\"line\">p2-&gt;getname();   <span class=\"comment\">//针对于指针来使用的，等价于*p2.getname();</span></div></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>。</p>\n<p><strong>构造函数不能被声明成const。</strong> 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。</p>\n<p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p>\n<p>知识点1：构造函数—特殊的成员函数，用来控制对象的初始化过程。无返回类型，可重载，不能被声明为const.</p>\n<p>知识点2：若无，则有默认的构造函数，是编译器自己隐式的定义的。又称合成的默认构造函数。</p>\n<p>知识点3：某些类是不能使用默认的构造函数的，以下三个原因：</p>\n<p>1：在未声明任何构造函数的前提下，类内对象的初始化将不受控制</p>\n<p>2：合成的默认构造函数可能会造成不必要的错误，如若没有类内初始值来初始化成员，可能这些成员将是未定义的。</p>\n<p>3：如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该对象。</p>\n<p>所以，在撰写类的时候，最好定义一个自己的构造函数。</p>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>;</span>  <span class=\"comment\">//前向声明Person类</span></div><div class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">read</span><span class=\"params\">(istream&amp; is,Person&amp; person)</span></span>;  <span class=\"comment\">//声明read函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Person() = <span class=\"keyword\">default</span>;     <span class=\"comment\">//默认构造函数  等价于Person()&#123;&#125;;</span></div><div class=\"line\">    Person(<span class=\"built_in\">string</span> name,<span class=\"built_in\">string</span> address);   <span class=\"comment\">//重载构造函数</span></div><div class=\"line\">    Person(istream &amp;is)&#123;   <span class=\"comment\">//重载构造函数，通过调用非成员函数read对其进行赋值</span></div><div class=\"line\">        read(is,*<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">getname</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"title\">getaddress</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;address;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setname</span><span class=\"params\">(<span class=\"built_in\">string</span> name)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setaddress</span><span class=\"params\">(<span class=\"built_in\">string</span> address)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>-&gt;address = address;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\">Person&amp; <span class=\"title\">combine</span><span class=\"params\">(<span class=\"keyword\">const</span> Person &amp;person)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">string</span> address;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">void</span> Person::show()&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"name:\"</span>&lt;&lt;<span class=\"keyword\">this</span>-&gt;name&lt;&lt;<span class=\"string\">\" address:\"</span>&lt;&lt;<span class=\"keyword\">this</span>-&gt;address&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Person::Person(<span class=\"built_in\">string</span> name,<span class=\"built_in\">string</span> address):name(name),address(address)&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Person&amp; Person::combine(<span class=\"keyword\">const</span> Person &amp;person)&#123;</div><div class=\"line\">    name += person.name;</div><div class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">read</span><span class=\"params\">(istream&amp; is,Person&amp; person)</span></span>&#123;   <span class=\"comment\">//非成员函数</span></div><div class=\"line\">    <span class=\"built_in\">string</span> name ,address;</div><div class=\"line\">    is&gt;&gt;name&gt;&gt;address;</div><div class=\"line\">    person.setname(name);</div><div class=\"line\">    person.setaddress(address);</div><div class=\"line\">    <span class=\"keyword\">return</span> is;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"string\">\"wangxinri\"</span>,<span class=\"string\">\"cqu\"</span>)</span></span>;</div><div class=\"line\">    p1.show();</div><div class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"string\">\"ri\"</span>,<span class=\"string\">\"cqu\"</span>)</span></span>;</div><div class=\"line\">    p1.combine(p2);</div><div class=\"line\">    p1.show();</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;p2.getname()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;p2.getaddress()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"function\">Person <span class=\"title\">p3</span><span class=\"params\">(<span class=\"built_in\">cin</span>)</span></span>;</div><div class=\"line\">    p3.show();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"拷贝、赋值和析构\"><a href=\"#拷贝、赋值和析构\" class=\"headerlink\" title=\"拷贝、赋值和析构\"></a>拷贝、赋值和析构</h2><p>如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。</p>\n<p>对于某些类来说合成的版本无法正常工作，管理动态内存的类通常不能依赖于上述操作的合成版本。</p>\n<p>使用vector或者string的类能避免分配和释放内存带来的复杂性。如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。</p>\n<h1 id=\"类的静态成员\"><a href=\"#类的静态成员\" class=\"headerlink\" title=\"类的静态成员\"></a>类的静态成员</h1><p><strong>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联</strong>。例如，一个银行账号类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。</p>\n<h2 id=\"声明静态成员\"><a href=\"#声明静态成员\" class=\"headerlink\" title=\"声明静态成员\"></a>声明静态成员</h2><p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起，和其他成员一样，静态成员可以使public得或private的。静态数据成员的类型可以使常量、引用、指针、类类型等。</p>\n<p>举个例子，我们定义一个类，用它表示银行的账户记录：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">calculate</span><span class=\"params\">()</span> </span>&#123;amount+=amount*interestRate;&#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> interestRate;&#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> owner;</div><div class=\"line\">    <span class=\"keyword\">double</span> amount;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> interestRate;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">initRate</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</strong> 因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。</p>\n<p><strong>类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的（const是用来修饰this指针类型的），而且我们也不能在static函数体内使用this指针，这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。静态成员函数不可以同时声明为 virtual、const、volatile函数。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base</span>&#123;</span>   </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;<span class=\"comment\">//错误   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//错误   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func3</span><span class=\"params\">()</span> <span class=\"keyword\">volatile</span></span>;<span class=\"comment\">//错误   </span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"使用类的静态成员\"><a href=\"#使用类的静态成员\" class=\"headerlink\" title=\"使用类的静态成员\"></a>使用类的静态成员</h2><p>我们使用作用域运算符直接访问静态成员：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> r;</div><div class=\"line\">r=Account::rate();   <span class=\"comment\">//使用作用域运算符访问静态成员</span></div></pre></td></tr></table></figure></p>\n<p>虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针类访问静态成员：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Account ac1;</div><div class=\"line\">Account *ac2=&amp;ac1;</div><div class=\"line\"><span class=\"comment\">//调用静态成员函数rate的等价形式</span></div><div class=\"line\">r=ac1.rate();   <span class=\"comment\">//通过Account的对象或引用</span></div><div class=\"line\">r=ac2-&gt;rate();   <span class=\"comment\">//通过指向Account对象的指针</span></div></pre></td></tr></table></figure></p>\n<p>成员函数不用通过作用域运算符就能直接使用静态成员。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">　　<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">calculate</span><span class=\"params\">()</span> </span>&#123;amount+=amount*interestRate;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">　　<span class=\"keyword\">static</span> <span class=\"keyword\">double</span> interestRate;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"定义静态成员\"><a href=\"#定义静态成员\" class=\"headerlink\" title=\"定义静态成员\"></a>定义静态成员</h2><p>和其他的成员函数一样，<strong>我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句</strong>：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> Account::rate(<span class=\"keyword\">double</span> newRate)</div><div class=\"line\">&#123;</div><div class=\"line\">　　interestRate=newRate;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。</strong></p>\n<p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。<strong>而且一般来说，我们不能在类的内部初始化静态数据成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。</strong></p>\n<p>类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在于程序的整个生命周期中。</p>\n<p>我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义并初始化一个静态成员</span></div><div class=\"line\"><span class=\"keyword\">double</span> Account::interestRate=initRate();</div></pre></td></tr></table></figure>\n<p>这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用initRate函数。注意，虽然initRate是私有的，我们也能使用它初始化interestRate。和其他成员的定义一样，interestRate的定义也可以访问类的私有成员。</p>\n<p><strong>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一文件中</strong>。</p>\n<h2 id=\"静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\"><a href=\"#静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\" class=\"headerlink\" title=\"静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）\"></a>静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）</h2><p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适用于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员执行数组成员的维度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> interestRate;&#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> period=<span class=\"number\">30</span>;</div><div class=\"line\">    <span class=\"keyword\">double</span> daily_tbl[period]; <span class=\"comment\">//period是常量表达式</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个不带初始值的静态成员的定义</span></div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> Account::period;  <span class=\"comment\">//初始值在类的定义内提供</span></div></pre></td></tr></table></figure>\n<font color=\"red\"><strong>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员</strong>。 </font>\n\n<h2 id=\"静态成员能用于某些场景，而普遍成员不能\"><a href=\"#静态成员能用于某些场景，而普遍成员不能\" class=\"headerlink\" title=\"静态成员能用于某些场景，而普遍成员不能\"></a>静态成员能用于某些场景，而普遍成员不能</h2><p>如我们所见，静态成员独立于任何对象。因为，在某些非静态数据成员可能非法的场合，静态 成员却可以正常地使用。举个例子，<strong>静态数据成员可以是不完全类型。特别地，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//......</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> Bar mem1;  <span class=\"comment\">//正确：静态成员可以是不完全类型</span></div><div class=\"line\">    Bar *mem2;         <span class=\"comment\">//正确：指针成员可以使不完全类型</span></div><div class=\"line\">    Bar mem3;         <span class=\"comment\">//错误：数据成员必须是完全类型</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>静态成员和普通成员的另一个区别是我们可以使用静态成员作为默认实参</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//bkground 不是一个在类中稍后定义的静态成员</span></div><div class=\"line\">    <span class=\"function\">Screen &amp;<span class=\"title\">clear</span><span class=\"params\">(<span class=\"keyword\">char</span> =bkground)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> bkground;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以从中获取成员的值，最终引发错误。</p>\n<h2 id=\"简单代码示例\"><a href=\"#简单代码示例\" class=\"headerlink\" title=\"简单代码示例\"></a>简单代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> interestRate; &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"keyword\">double</span> Rate)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> owner;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> interestRate ;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> aa = <span class=\"number\">0</span>;  <span class=\"comment\">//正确</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> bb = <span class=\"number\">0</span>;  <span class=\"comment\">//正确，constexpr类型可以类内初始化</span></div><div class=\"line\">    <span class=\"comment\">//static double cc = 0;  //错误</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//外层定义static成员不需要加上static</span></div><div class=\"line\"><span class=\"keyword\">double</span> Account::interestRate = <span class=\"number\">1.0</span>;   <span class=\"comment\">//定义并初始化一个成员</span></div><div class=\"line\"><span class=\"keyword\">void</span> Account::rate(<span class=\"keyword\">double</span> Rate)&#123;</div><div class=\"line\">    interestRate = Rate;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    Account a1,a2;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a1.rate()&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;a2.rate()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a1.rate(<span class=\"number\">2.0</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a1.rate()&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;a2.rate()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"友元（friend）\"><a href=\"#友元（friend）\" class=\"headerlink\" title=\"友元（friend）\"></a>友元（friend）</h1><p>友元：类允许其他类或者函数访问其非公有成员，方法是令其他类或者函数成为它的<strong>友元（friend)</strong>。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。</p>\n<p>友元函数只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员函数也不受它所在区域访问控制级别的约束。</p>\n<p>一般来说，最好在类定义开始或者结束前的位置集中声明友元。</p>\n<h2 id=\"友元的声明\"><a href=\"#友元的声明\" class=\"headerlink\" title=\"友元的声明\"></a>友元的声明</h2><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>\n<h2 id=\"友元再探\"><a href=\"#友元再探\" class=\"headerlink\" title=\"友元再探\"></a>友元再探</h2><p>类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数时隐式内联的。</p>\n<h2 id=\"类之间的友元关系\"><a href=\"#类之间的友元关系\" class=\"headerlink\" title=\"类之间的友元关系\"></a>类之间的友元关系</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\">    <span class=\"comment\">//Window_megr的成员可以访问Screen类的私有部分。</span></div><div class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window_megr</span>;</span>  把Window_megr指定成Screen的友元</div><div class=\"line\">    <span class=\"comment\">//Screen类的剩余部分</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p>\n<p>必须注意的是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。</p>\n<h2 id=\"令成员函数作为友元\"><a href=\"#令成员函数作为友元\" class=\"headerlink\" title=\"令成员函数作为友元\"></a>令成员函数作为友元</h2><p>除了令整个Window_mgr作为友元之外，Screen还可以只为Window_mgr成员函数clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\">    <span class=\"comment\">//Window_mgr::clear必须在Screen类之前被声明</span></div><div class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> Window_mgr::clear(ScreenIndex);</div><div class=\"line\">    <span class=\"comment\">//Screen类的剩余部分</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：</p>\n<ul>\n<li>首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。</li>\n<li>接下来定义Screen，包括对于clear的友元声明</li>\n<li>最后定义clear，此时它才可以使用Screen的成员。</li>\n</ul>\n<h2 id=\"函数重载和友元\"><a href=\"#函数重载和友元\" class=\"headerlink\" title=\"函数重载和友元\"></a>函数重载和友元</h2><p>尽管重载函数的名字相同，但他们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//重载的storeOn函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> ostream&amp; <span class=\"title\">storeOn</span><span class=\"params\">(ostream＆ ,Screen &amp;)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> BitMap &amp;<span class=\"title\">storeOn</span><span class=\"params\">(BitMap&amp; ,Screen &amp;)</span></span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen</span>&#123;</span></div><div class=\"line\">    <span class=\"comment\">//StoreOnde ostream版本能访问Screen对象的私有部分</span></div><div class=\"line\">    <span class=\"keyword\">friend</span> ostream::<span class=\"function\">ostream&amp; <span class=\"title\">storeOn</span><span class=\"params\">(ostream&amp; ,Screen)</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Screen类把接受ostream&amp;的storeOn函数声明成它的友元，但是接受BitMap&amp;作为参数的版本仍然不能访问Screen。</p>\n<h2 id=\"友元声明和作用域\"><a href=\"#友元声明和作用域\" class=\"headerlink\" title=\"友元声明和作用域\"></a>友元声明和作用域</h2><p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。</p>\n<p>甚至<strong>就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。</strong> 换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span>&#123;</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/*友元函数可以定义在类的内部*/</span>&#125;</div><div class=\"line\">    X() &#123;f();&#125;  <span class=\"comment\">//错误：f还没有被声明</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">h</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">void</span> X::g()&#123;<span class=\"keyword\">return</span> f();&#125;  <span class=\"comment\">//错误：f还没有被声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;   <span class=\"comment\">//声明那个定义在X中的函数</span></div><div class=\"line\"><span class=\"keyword\">void</span> X::h() &#123;<span class=\"keyword\">return</span> f();&#125;  <span class=\"comment\">//正确：现在f的声明在作用域中了</span></div></pre></td></tr></table></figure>\n<p>关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。</p>\n<h2 id=\"简单友元类示例\"><a href=\"#简单友元类示例\" class=\"headerlink\" title=\"简单友元类示例\"></a>简单友元类示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">student</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">teacher</span>;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_info</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"name:\"</span>&lt;&lt;name&lt;&lt;<span class=\"string\">\" address\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> name = <span class=\"string\">\"xin\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> address = <span class=\"string\">\"cqu\"</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">teacher</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_info</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"name:\"</span>&lt;&lt;name&lt;&lt;<span class=\"string\">\" address\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showStudent</span><span class=\"params\">(student &amp;STD)</span></span>;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> name;</div><div class=\"line\">    <span class=\"built_in\">string</span> address;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> teacher::showStudent(student &amp;STD)&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;STD.name&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;STD.address&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    student STD;</div><div class=\"line\">    STD.show_info();</div><div class=\"line\">    teacher TEA;</div><div class=\"line\">    TEA.showStudent(STD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"顺序容器概述","date":"2017-10-26T13:59:00.000Z","update":null,"comments":1,"_content":"# 一、前言\n\n介绍顺序容器的种类及基本操作。\n<!--more-->\n\n# 顺序容器\n\n一个容器就是一些特定类型对象的集合。**顺序容器**（sequential container）为程序员提供了控制元素存储和访问顺序的能力。**这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应**。与之相对的是11章的**有序和无序关联容器**，它们根据关键字的值来存储元素。\n\n所有顺序容器都提供了快速访问元素的能力，但是，这些容器在以下方面都有不同的性能折中。\n- 向容器添加或从容器中删除元素的代价。\n- 非顺序访问容器中的元素。\n\n顺序容器类型：\n\n```C++\nvector 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。\ndeque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。\nlist 双向链表。只支持双向顺序访问。在list中任何位置插入/删除都很快\nforward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快。\narray 固定大小数组。支持快速随机访问。不能添加或删除元素。\nstring 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。\n```\n\n- 除了array外，其他容器都提供高效、灵活的内存管理。\n- string和vector将元素保存在连续的内存空间中。因为连续，所以下标访问非常快。但在中间插入、删除较慢（O(n)）。有时添加一个元素还可能需要分配的额外空间，这种情况所有元素必须移动到新的存储空间中\n- forward_list和array是新C++标准增加的类型。array比内置数组更安全。forward_list没有size()操作。新标准库的容器比旧版本的快得多。\n\n\n## 确定使用哪种顺序容器\n\n**通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。**\n\n- 一般用vector。\n- 如果程序有很多小元素，且空间的额外开销很重要，则不要用list或forward_list。\n- 要随机访问元素用vector或deque。\n- 如果要在中间插入或删除元素，应用list或forward_list。\n- 如果要在头尾插入或删除元素。但不会在中间插入或删除元素，用deque。\n- 如果程序只有在读取输入的时候才需要在容器中间位置插入元素，随后需要随机访问元素。如果确实需要，则考虑在输入阶段用list，一旦输入完成，将list中的元素拷贝到一个vector中。\n\n\n如果程序既需要随机访问元素，又需要在容器中间插入元素，该怎么办？\n\n一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。\n\n\n# 容器库概述\n\n容器类型上的操作形成了一种层次：\n\n- 某些操作是所有容器类型都提供的。\n- 另外一些操作仅针对顺序容器、关联容器或无序容器。\n- 还有一些操作只适用于一小部分容器。\n\n## 对容器可以保存的元素类型的限制\n \n顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另外一个容器。\n\n```C++\nvector<vector<string>> lines;     //lines是一个vector，其元类型是string的vector\n```\n\n某些类没有默认的构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：\n\n```C++\n//假定noDefault是一个没有默认构造函数的类型\nvector<noDefault> v1(10,init);      //正确：提供了元素初始化器\nvector<noDefault> v2(10);           //错误：必须提供一个元素初始化器\n```\n\n<font color=red> **容器操作：(待补充)** </font>\n\n## 迭代器\n\n\n### 标准库array具有固定大小\n\n与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：\n\n```C++\narray<int,42>        //类型为：保存42个int的数组\narray<string,10>     //类型为：保存10个string的数组\n```\n\n为了使用array类型，我们必须同时指定元素类型和大小：\n```C++\narray<int,10>::size_type i;     //数组类型包括元素类型和大小\narray<int>::size_type j;        //错误：array<int>不是一个类型\n```\n\n初始化array：\n\n```C++\narray<int,10> ia1;       //10个默认初始化的int\narray<int,10> ia2 = {0,1,2,3,4,5,6,7,8,9};    //列表初始化\narray<int,10> ia3 = {42};      //ia3[0]为42，剩余元素为0\n```\n\n值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并无此限制。\n```C++\nint digs[10] = {0,1,2,3,4,5,6,7,8,9};\nint cpy[10] = digs;            //错误，内置数组不支持拷贝或赋值\narray<int,10> digits = {0,1,2,3,4,5,6,7,8,9};\narray<int,10> copy = digits;   //正确，只要数组类型匹配即合法\n```\n\n## 赋值和swap\n\n赋值相关的运算符可用于所有的容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。\n\n```C++\nc1 = c2;       //将c1的内容替换为c2中元素的拷贝\nc1 = {a,b,c};  //赋值后，c1大小为3\n```\n\n如果两个容器原来的大小不同，赋值运算后两者的大小都与右边容器的原大小相同。\n\n与内置数组不同，**标准库array类型允许赋值**。赋值号左右两边的运算对象必须具有相同的类型。也就是array进行赋值，**左右两边数组大小必须相等**。\n\n**1.assign(仅顺序容器)**\n\n**允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值**。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，我们可以用assign实现将一个vector中的一段char *值赋予一个list中的string：\n\n```C++\nlist<string> names;\nvector<const char *> oldstyle;\nname = oldstyle;   //错误，容器类型不匹配，赋值，类型必须完全一样\n//正确：可以将const char * 转化为string\nnames.assign(oldstyle.cbegin(),oldstyle.cend());\n```\n\nassign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素：\n\n```C++\n//等价于slist1.clear();\n//后跟slist1.insert(slist1.begin(),10,\"Hiya!\");\nlist<string> slist1(1);      //1个元素，为空string\nslist1.assign(10,\"Hiya!\");\n```\n\n**2.使用swap**\n\nswap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。\n\n```C++\nvector<string> svec1(10);       //10个元素的vector\nvector<string> svec2(24);       //24个元素的vector\nswap(svec1,svec2);\n```\n\n**除array外，swap不对任何元素进行拷贝、删除或插入操作。因此可以保证在常数时间内完成**。\n\n在新标准中，容器既提供成员版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。**统一使用非成员版本的swap是一个好习惯。**\n\n## 关系运算符\n\n每个容器类型都支持相等运算符（== 和 ！=）；除了无序关联容器外的所有容器都支持关系运算符（>、>=、<、<=）。**关系运算符左右两边的运算对象必须是相同类型的容器。且必须保存相同类型的元素。**\n\n- 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。\n- 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。\n- 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。 \n\n**容器的关系运算符使用元素的关系运算符完成比较**：\n容器的相等运算符实际上是使用元素的==运算符 来实现比较的，而其他关系运算符 是使用元素的<运算符 。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算符。\n\n```C++\nvector<Sale_data> storeA, storeB;\nif(storeA < storeB)                 // 错误：Sales_data没有<运算符\n```\n\n注意： **只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。**\n\n# 顺序容器的操作\n\n顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。上一节介绍了所有容器都支持的操作。本章剩余部分将介绍顺序容器所特有的操作。\n\n## 向顺序容器添加元素\n\n除了array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。\n\n```C++\n向顺序容器添加元素的操作：\n操作会改变容器的大小；array不支持这些操作。\n\nforward_list有自己专有版本的insert和emplace；\nforward_list不支持push_back和emplace_back\nvector和string不支持push_front和emplace_front\nc.push_back(t)　　　　　　　　在c的尾部创建一个值为t或由args创建的元素，返回void\nc.emplace_back(args)\nc.push_front(t)　　　　　　　　在c的头部创建一个值为t或由args创建的元素，返回void\nc.emplace_front(args)\nc.insert(p,t)　　　　　　　　　  在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器\nc.emplace(p,args)\nc.insert(p,n,t)　 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p\nc.insert(p,b,e)　 将迭代器b和e指向的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回p\nc.insert(p,il)　　il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器：若列表为空，则返回p\n```\n \n**向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。**\n\n当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque的首位之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。\n\n## 使用push_back\n\n**我们看到push_back将一个元素追加到一个vector的尾部。除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。**\n\n例如，下面的循环每次读取一个string到word中，然后追加到容器尾部：\n\n```C++\n//从标准输入读取数据，将每个单词放到容器末尾\nstring word;\nwhile(cin>>word)\n　　container.push_back(word);\n```\n\n对push_back的调用在container尾部创建了一个新的元素，将container的size增大了1。该元素的值为word的一个拷贝，container的类型可以是list、vector或deque。\n\n**关键概念**：当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。\n\n \n\n## 使用push_front\n\n**除了push_back, list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部：**\n\n```C++\nlist<int> ilist;\n//将元素添加到Ilist开头\nfor(size_t ix=0;ix!=4;++ix)\n　　ilist.push_front(ix);\n```\n\n此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的新的开始位置。即，当我们插入1时，它会被放置在0之前，2被放置在1之前，依次类推。因此，在循环中以这种方式将元素添加到容器中，最终会形成逆序。\n\n**注意：** deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首部进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置插入元素会很耗时。\n\n \n\n## 在容器中的特定位置添加元素（insert）\n\n**push_back和push_front操作提供了一种方便地在顺序容器尾部或头部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。**\n\n每个insert函数都接受一个迭代器作为其一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，<font color=red > **所有insert函数将元素插入到迭代器所指定的位置之前** </font>。例如，下面的语句\n\n```C++\nslist.insert(iter,\"Hello!\");  //将hello添加到iter之前的位置\n```\n\n虽然某些容器不支持push_front操作，但他们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front:\n\n```C++\nvector<string> svec;\nlist<string> slist;\n//等价于调用slist.push_front(\"Hello!\");\nslist.insert(slist.begin(),\"Hello!\");\n//vector不支持push_front，但我们可以插入到begin()之前\n//警告：插入到vector末尾之外的任何位置都可能很慢\nsvec.insert(svec.begin(),\"Hello!\");\n```\n\n**将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时**。\n\n \n\n## 插入范围内元素\n\n除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函数类似。其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素够按给定值初始化：\n\n```C++\nsvec.insert(svec.end(),10,\"Anna\");\n```\n\n这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string“Anna”。\n\n接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前：\n\n```C++\nvector<string> v={\"quasi\",\"simba\",\"frollo\",\"scar\"};\n//将v的最后两个元素添加到slist的开始位置\nslist.insert(slist.begin(),v.end()-2,v.end());\nslist.insert(slist.end(),{\"these\",\"words\",\"will\",\"go\",\"at\",\"the\",\"end\"});\nslist.insert(slist.begin(),slist.begin(),slist.end()); //运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器\n```\n\n**如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。**\n\n## 使用insert的返回值\n\n通过使用insert的返回值，可以在容器中一个特定的位置反复插入元素：\n\n```C++\nlist<string> lst;\nauto iter=lst.begin();\nwhile(cin>>word)\n　　iter=lst.insert(iter,word);  //等价于调用push_front\n```\n\n在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，读取下一个单词。\n\n## 使用emplace操作\n\n使用emplace操作\n\n**新标准引入了三个成员——emplace_front、emplace和emplace_back，这些操作（构造而不是拷贝元素）。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定的位置之前或容器尾部。**\n\n当调用push或insert成员函数时，我们将元素类型对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，**则是将参数传递给元素类型的构造函数**。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：\n\n```C++\n//在c的末尾构造一个Sales_data对象\n//使用三个参数的Sales_data的构造函数\nc.emplace_back(\"978-0590353403\",25,15.99);\nc.push_back(\"978-0590353403\",25,15.99);     //错误：没有接受三个参数的push_back版本\n//正确：创建一个临时的Sales_data对象传递给push_back\nc.push_back(Sales_data((\"978-0590353403\",25,15.99));\n```\n\n**其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。**\n\n<font color=red> **emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配** </font> ：\n\n```C++\n//iter指向c中一个元素，其中保存了Sales_data元素\nc.emplace_back();//使用Sales_data的默认构造函数\nc.emplace(iter,\"999-999999999\"); //使用Sales_data(string)\n//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数\nc.emplace_front(\"978-0590353403\",25,15.99);\n```\n\n**emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。**\n\n\n## 访问元素 （访问成员函数返回的是引用）\n\n下表列出了我们可以用来在顺序容器值访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。\n\n包括array在内的每个顺序容器都有一个front成员函数，而除了forward_list之外的所以顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用：\n\n```C++\n//在解引用一个迭代器或调用front或back之前检查是否有元素\nif(!c.empty()){\n　　//val和val2是c中第一个元素值的拷贝\n　　auto val=*c.begin(),val2=c.front();\n　　//val3和val4是c中最后一个元素值的拷贝\n　　auto last=c.end();\n　　auto val3=*(--last);  //不能递减forward_list迭代器\n　　auto val4=c.back();  //forward_list不支持\n```\n\n**此程序用两种不同方式来获取c中的首元素和尾元素的引用。** 直接的方式是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获取尾元素的引用。\n\n<font color=red>  **在顺序容器中访问元素的操作** </font>\n\n```C++\nat和下标操作只适用于string、vector、deque和array。\nback不适用于forward_list。\nc.back() 　　　　　　　　　　返回c中尾元素的引用。若c为空，函数行为未定义\nc.front()　　　　　　　　　　 返回c中首元素的引用。若c为空，函数行为未定义\nc[n]　　　　　　　　　　　　 返回c中下标为n的元素的引用，n是一个无符号整数。若n>c.size(),则函数的行为未定义\nc.at[n]　　　　　　　　　　  返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常\n```\n\n**对一个空容器调用front和back，就像使用一个越界的下标一样。是一种严重的程序设计错误。**\n\n## 访问成员函数返回的是引用\n\n在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：\n\n```C++\nif(!c.empty()){\n    c.front() = 42;   //将42赋予c中的第一个元素\n    auto &v = c.back();     //获得指向最后一个元素的引用\n    v = 1024;          //改变c中的元素\n    auto v2 = c.back();    //v2不是一个引用，它是c.back()的一个拷贝\n    v2 = 0;\n}\n```\n\n**与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。**\n\n## 下标操作和安全的随机访问\n\n提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们已经看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。\n\n**我们希望确保下标是合法的，可以使用at成员函数**。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常：\n\n```C++\nvector<string> svec;  //空vector\ncout<<svec[0];   //运行时错误：svec中没有元素\ncout<<svec.at[0];   //抛出一个out_of_range异常\n```\n\n## 删除元素\n\n与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下表所示：\n\n<font color=red> **顺序容器的删除操作** </font>\n\n```C++\n这些操作会改变容器的大小，所以不适用于array\nforward_list有特殊版本的erase\nforward_list不支持pop_back；vector和string不支持pop_front\nc.pop_back() 　　　　　　删除c中尾元素，若c为空，则函数行为未定义，函数返回void\nc.pop_front()　　　　　　删除c中首元素，若c为空，则函数行为未定义，函数返回void\nc.erase(p)　　　　　　　 删除迭代器p所指的元素，返回以指向被删除元素之后的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数的行为未定义\nc.erase(b,e)　　　　　　 删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器\nc.clear()　　　　　　　　 删除c中的所以元素，返回void\n```\n\n**删除deque中除首位元素之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。**\n\n## pop_front和pop_back成员函数\n\npop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似的，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。\n\n这些操作返回void，如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它：\n\n```C++\nwhile(!ilist.empty()){\n　　process(ilist.front());  //对ilist的首元素进行一些处理\n　　ilist.pop_front();　　//完成处理后删除首元素\n}\n```\n \n\n## 从容器内部删除一个元素\n\n成员函数erase从容器中指定位置删除元素，我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。**两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。**\n\n例如，下面的循环删除一个list中的所有奇数元素：\n\n```C++\nlist<int> lst=(0,1,2,3,4,5,6,7,8,9};\nauto it=lst.begin();\nwhile(it!=lst.end())\n　　if(*it%2)\n　　　　it=lst.erase(it);  //删除此元素\n　　else\n　　　　++it;\n```\n\n每个循环步中，首先检查当前元素是否是奇数，如果是，就删除该元素，并将it设置为我们所删除的元素之后的元素。如果*it为偶数，我们将it递增，从而在下一步循环检查下一个元素。\n\n## 删除多个元素\n\n接受一对迭代器的erase版本允许我们删除一个范围内的元素：\n\n```C++\n//删除两个迭代器表示的范围内的元素\n//返回指向最后一个被删除元素之后位置的迭代器\nelem1=slist.erase(elem1,elem2);  //调用后，elem1==elem2\n```\n\n**迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置**。\n\n为了删除一个容器中的所有元素，我们既可以调用clear，也可以用begin和end获得的迭代器作为参数调用erase：\n\n```C++\nslist.clear() ;//删除容器中的所有元素\nslist.erase(slist.begin(),slist.end());   //等价调用\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/顺序容器概述.md","raw":"---\ntitle: 顺序容器概述\ndate: 2017-10-26 21:59:00\nupdate: \ntags: [顺序容器]\ncategories: C++\ncomments: true\n---\n# 一、前言\n\n介绍顺序容器的种类及基本操作。\n<!--more-->\n\n# 顺序容器\n\n一个容器就是一些特定类型对象的集合。**顺序容器**（sequential container）为程序员提供了控制元素存储和访问顺序的能力。**这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应**。与之相对的是11章的**有序和无序关联容器**，它们根据关键字的值来存储元素。\n\n所有顺序容器都提供了快速访问元素的能力，但是，这些容器在以下方面都有不同的性能折中。\n- 向容器添加或从容器中删除元素的代价。\n- 非顺序访问容器中的元素。\n\n顺序容器类型：\n\n```C++\nvector 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。\ndeque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。\nlist 双向链表。只支持双向顺序访问。在list中任何位置插入/删除都很快\nforward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快。\narray 固定大小数组。支持快速随机访问。不能添加或删除元素。\nstring 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。\n```\n\n- 除了array外，其他容器都提供高效、灵活的内存管理。\n- string和vector将元素保存在连续的内存空间中。因为连续，所以下标访问非常快。但在中间插入、删除较慢（O(n)）。有时添加一个元素还可能需要分配的额外空间，这种情况所有元素必须移动到新的存储空间中\n- forward_list和array是新C++标准增加的类型。array比内置数组更安全。forward_list没有size()操作。新标准库的容器比旧版本的快得多。\n\n\n## 确定使用哪种顺序容器\n\n**通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。**\n\n- 一般用vector。\n- 如果程序有很多小元素，且空间的额外开销很重要，则不要用list或forward_list。\n- 要随机访问元素用vector或deque。\n- 如果要在中间插入或删除元素，应用list或forward_list。\n- 如果要在头尾插入或删除元素。但不会在中间插入或删除元素，用deque。\n- 如果程序只有在读取输入的时候才需要在容器中间位置插入元素，随后需要随机访问元素。如果确实需要，则考虑在输入阶段用list，一旦输入完成，将list中的元素拷贝到一个vector中。\n\n\n如果程序既需要随机访问元素，又需要在容器中间插入元素，该怎么办？\n\n一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。\n\n\n# 容器库概述\n\n容器类型上的操作形成了一种层次：\n\n- 某些操作是所有容器类型都提供的。\n- 另外一些操作仅针对顺序容器、关联容器或无序容器。\n- 还有一些操作只适用于一小部分容器。\n\n## 对容器可以保存的元素类型的限制\n \n顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另外一个容器。\n\n```C++\nvector<vector<string>> lines;     //lines是一个vector，其元类型是string的vector\n```\n\n某些类没有默认的构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：\n\n```C++\n//假定noDefault是一个没有默认构造函数的类型\nvector<noDefault> v1(10,init);      //正确：提供了元素初始化器\nvector<noDefault> v2(10);           //错误：必须提供一个元素初始化器\n```\n\n<font color=red> **容器操作：(待补充)** </font>\n\n## 迭代器\n\n\n### 标准库array具有固定大小\n\n与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：\n\n```C++\narray<int,42>        //类型为：保存42个int的数组\narray<string,10>     //类型为：保存10个string的数组\n```\n\n为了使用array类型，我们必须同时指定元素类型和大小：\n```C++\narray<int,10>::size_type i;     //数组类型包括元素类型和大小\narray<int>::size_type j;        //错误：array<int>不是一个类型\n```\n\n初始化array：\n\n```C++\narray<int,10> ia1;       //10个默认初始化的int\narray<int,10> ia2 = {0,1,2,3,4,5,6,7,8,9};    //列表初始化\narray<int,10> ia3 = {42};      //ia3[0]为42，剩余元素为0\n```\n\n值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并无此限制。\n```C++\nint digs[10] = {0,1,2,3,4,5,6,7,8,9};\nint cpy[10] = digs;            //错误，内置数组不支持拷贝或赋值\narray<int,10> digits = {0,1,2,3,4,5,6,7,8,9};\narray<int,10> copy = digits;   //正确，只要数组类型匹配即合法\n```\n\n## 赋值和swap\n\n赋值相关的运算符可用于所有的容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。\n\n```C++\nc1 = c2;       //将c1的内容替换为c2中元素的拷贝\nc1 = {a,b,c};  //赋值后，c1大小为3\n```\n\n如果两个容器原来的大小不同，赋值运算后两者的大小都与右边容器的原大小相同。\n\n与内置数组不同，**标准库array类型允许赋值**。赋值号左右两边的运算对象必须具有相同的类型。也就是array进行赋值，**左右两边数组大小必须相等**。\n\n**1.assign(仅顺序容器)**\n\n**允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值**。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，我们可以用assign实现将一个vector中的一段char *值赋予一个list中的string：\n\n```C++\nlist<string> names;\nvector<const char *> oldstyle;\nname = oldstyle;   //错误，容器类型不匹配，赋值，类型必须完全一样\n//正确：可以将const char * 转化为string\nnames.assign(oldstyle.cbegin(),oldstyle.cend());\n```\n\nassign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素：\n\n```C++\n//等价于slist1.clear();\n//后跟slist1.insert(slist1.begin(),10,\"Hiya!\");\nlist<string> slist1(1);      //1个元素，为空string\nslist1.assign(10,\"Hiya!\");\n```\n\n**2.使用swap**\n\nswap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。\n\n```C++\nvector<string> svec1(10);       //10个元素的vector\nvector<string> svec2(24);       //24个元素的vector\nswap(svec1,svec2);\n```\n\n**除array外，swap不对任何元素进行拷贝、删除或插入操作。因此可以保证在常数时间内完成**。\n\n在新标准中，容器既提供成员版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。**统一使用非成员版本的swap是一个好习惯。**\n\n## 关系运算符\n\n每个容器类型都支持相等运算符（== 和 ！=）；除了无序关联容器外的所有容器都支持关系运算符（>、>=、<、<=）。**关系运算符左右两边的运算对象必须是相同类型的容器。且必须保存相同类型的元素。**\n\n- 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。\n- 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。\n- 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。 \n\n**容器的关系运算符使用元素的关系运算符完成比较**：\n容器的相等运算符实际上是使用元素的==运算符 来实现比较的，而其他关系运算符 是使用元素的<运算符 。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算符。\n\n```C++\nvector<Sale_data> storeA, storeB;\nif(storeA < storeB)                 // 错误：Sales_data没有<运算符\n```\n\n注意： **只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。**\n\n# 顺序容器的操作\n\n顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。上一节介绍了所有容器都支持的操作。本章剩余部分将介绍顺序容器所特有的操作。\n\n## 向顺序容器添加元素\n\n除了array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。\n\n```C++\n向顺序容器添加元素的操作：\n操作会改变容器的大小；array不支持这些操作。\n\nforward_list有自己专有版本的insert和emplace；\nforward_list不支持push_back和emplace_back\nvector和string不支持push_front和emplace_front\nc.push_back(t)　　　　　　　　在c的尾部创建一个值为t或由args创建的元素，返回void\nc.emplace_back(args)\nc.push_front(t)　　　　　　　　在c的头部创建一个值为t或由args创建的元素，返回void\nc.emplace_front(args)\nc.insert(p,t)　　　　　　　　　  在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器\nc.emplace(p,args)\nc.insert(p,n,t)　 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p\nc.insert(p,b,e)　 将迭代器b和e指向的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回p\nc.insert(p,il)　　il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器：若列表为空，则返回p\n```\n \n**向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。**\n\n当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque的首位之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。\n\n## 使用push_back\n\n**我们看到push_back将一个元素追加到一个vector的尾部。除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。**\n\n例如，下面的循环每次读取一个string到word中，然后追加到容器尾部：\n\n```C++\n//从标准输入读取数据，将每个单词放到容器末尾\nstring word;\nwhile(cin>>word)\n　　container.push_back(word);\n```\n\n对push_back的调用在container尾部创建了一个新的元素，将container的size增大了1。该元素的值为word的一个拷贝，container的类型可以是list、vector或deque。\n\n**关键概念**：当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。\n\n \n\n## 使用push_front\n\n**除了push_back, list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部：**\n\n```C++\nlist<int> ilist;\n//将元素添加到Ilist开头\nfor(size_t ix=0;ix!=4;++ix)\n　　ilist.push_front(ix);\n```\n\n此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的新的开始位置。即，当我们插入1时，它会被放置在0之前，2被放置在1之前，依次类推。因此，在循环中以这种方式将元素添加到容器中，最终会形成逆序。\n\n**注意：** deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首部进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置插入元素会很耗时。\n\n \n\n## 在容器中的特定位置添加元素（insert）\n\n**push_back和push_front操作提供了一种方便地在顺序容器尾部或头部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。**\n\n每个insert函数都接受一个迭代器作为其一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，<font color=red > **所有insert函数将元素插入到迭代器所指定的位置之前** </font>。例如，下面的语句\n\n```C++\nslist.insert(iter,\"Hello!\");  //将hello添加到iter之前的位置\n```\n\n虽然某些容器不支持push_front操作，但他们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front:\n\n```C++\nvector<string> svec;\nlist<string> slist;\n//等价于调用slist.push_front(\"Hello!\");\nslist.insert(slist.begin(),\"Hello!\");\n//vector不支持push_front，但我们可以插入到begin()之前\n//警告：插入到vector末尾之外的任何位置都可能很慢\nsvec.insert(svec.begin(),\"Hello!\");\n```\n\n**将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时**。\n\n \n\n## 插入范围内元素\n\n除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函数类似。其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素够按给定值初始化：\n\n```C++\nsvec.insert(svec.end(),10,\"Anna\");\n```\n\n这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string“Anna”。\n\n接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前：\n\n```C++\nvector<string> v={\"quasi\",\"simba\",\"frollo\",\"scar\"};\n//将v的最后两个元素添加到slist的开始位置\nslist.insert(slist.begin(),v.end()-2,v.end());\nslist.insert(slist.end(),{\"these\",\"words\",\"will\",\"go\",\"at\",\"the\",\"end\"});\nslist.insert(slist.begin(),slist.begin(),slist.end()); //运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器\n```\n\n**如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。**\n\n## 使用insert的返回值\n\n通过使用insert的返回值，可以在容器中一个特定的位置反复插入元素：\n\n```C++\nlist<string> lst;\nauto iter=lst.begin();\nwhile(cin>>word)\n　　iter=lst.insert(iter,word);  //等价于调用push_front\n```\n\n在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，读取下一个单词。\n\n## 使用emplace操作\n\n使用emplace操作\n\n**新标准引入了三个成员——emplace_front、emplace和emplace_back，这些操作（构造而不是拷贝元素）。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定的位置之前或容器尾部。**\n\n当调用push或insert成员函数时，我们将元素类型对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，**则是将参数传递给元素类型的构造函数**。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：\n\n```C++\n//在c的末尾构造一个Sales_data对象\n//使用三个参数的Sales_data的构造函数\nc.emplace_back(\"978-0590353403\",25,15.99);\nc.push_back(\"978-0590353403\",25,15.99);     //错误：没有接受三个参数的push_back版本\n//正确：创建一个临时的Sales_data对象传递给push_back\nc.push_back(Sales_data((\"978-0590353403\",25,15.99));\n```\n\n**其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。**\n\n<font color=red> **emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配** </font> ：\n\n```C++\n//iter指向c中一个元素，其中保存了Sales_data元素\nc.emplace_back();//使用Sales_data的默认构造函数\nc.emplace(iter,\"999-999999999\"); //使用Sales_data(string)\n//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数\nc.emplace_front(\"978-0590353403\",25,15.99);\n```\n\n**emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。**\n\n\n## 访问元素 （访问成员函数返回的是引用）\n\n下表列出了我们可以用来在顺序容器值访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。\n\n包括array在内的每个顺序容器都有一个front成员函数，而除了forward_list之外的所以顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用：\n\n```C++\n//在解引用一个迭代器或调用front或back之前检查是否有元素\nif(!c.empty()){\n　　//val和val2是c中第一个元素值的拷贝\n　　auto val=*c.begin(),val2=c.front();\n　　//val3和val4是c中最后一个元素值的拷贝\n　　auto last=c.end();\n　　auto val3=*(--last);  //不能递减forward_list迭代器\n　　auto val4=c.back();  //forward_list不支持\n```\n\n**此程序用两种不同方式来获取c中的首元素和尾元素的引用。** 直接的方式是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获取尾元素的引用。\n\n<font color=red>  **在顺序容器中访问元素的操作** </font>\n\n```C++\nat和下标操作只适用于string、vector、deque和array。\nback不适用于forward_list。\nc.back() 　　　　　　　　　　返回c中尾元素的引用。若c为空，函数行为未定义\nc.front()　　　　　　　　　　 返回c中首元素的引用。若c为空，函数行为未定义\nc[n]　　　　　　　　　　　　 返回c中下标为n的元素的引用，n是一个无符号整数。若n>c.size(),则函数的行为未定义\nc.at[n]　　　　　　　　　　  返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常\n```\n\n**对一个空容器调用front和back，就像使用一个越界的下标一样。是一种严重的程序设计错误。**\n\n## 访问成员函数返回的是引用\n\n在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：\n\n```C++\nif(!c.empty()){\n    c.front() = 42;   //将42赋予c中的第一个元素\n    auto &v = c.back();     //获得指向最后一个元素的引用\n    v = 1024;          //改变c中的元素\n    auto v2 = c.back();    //v2不是一个引用，它是c.back()的一个拷贝\n    v2 = 0;\n}\n```\n\n**与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。**\n\n## 下标操作和安全的随机访问\n\n提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们已经看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。\n\n**我们希望确保下标是合法的，可以使用at成员函数**。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常：\n\n```C++\nvector<string> svec;  //空vector\ncout<<svec[0];   //运行时错误：svec中没有元素\ncout<<svec.at[0];   //抛出一个out_of_range异常\n```\n\n## 删除元素\n\n与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下表所示：\n\n<font color=red> **顺序容器的删除操作** </font>\n\n```C++\n这些操作会改变容器的大小，所以不适用于array\nforward_list有特殊版本的erase\nforward_list不支持pop_back；vector和string不支持pop_front\nc.pop_back() 　　　　　　删除c中尾元素，若c为空，则函数行为未定义，函数返回void\nc.pop_front()　　　　　　删除c中首元素，若c为空，则函数行为未定义，函数返回void\nc.erase(p)　　　　　　　 删除迭代器p所指的元素，返回以指向被删除元素之后的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数的行为未定义\nc.erase(b,e)　　　　　　 删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器\nc.clear()　　　　　　　　 删除c中的所以元素，返回void\n```\n\n**删除deque中除首位元素之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。**\n\n## pop_front和pop_back成员函数\n\npop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似的，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。\n\n这些操作返回void，如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它：\n\n```C++\nwhile(!ilist.empty()){\n　　process(ilist.front());  //对ilist的首元素进行一些处理\n　　ilist.pop_front();　　//完成处理后删除首元素\n}\n```\n \n\n## 从容器内部删除一个元素\n\n成员函数erase从容器中指定位置删除元素，我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。**两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。**\n\n例如，下面的循环删除一个list中的所有奇数元素：\n\n```C++\nlist<int> lst=(0,1,2,3,4,5,6,7,8,9};\nauto it=lst.begin();\nwhile(it!=lst.end())\n　　if(*it%2)\n　　　　it=lst.erase(it);  //删除此元素\n　　else\n　　　　++it;\n```\n\n每个循环步中，首先检查当前元素是否是奇数，如果是，就删除该元素，并将it设置为我们所删除的元素之后的元素。如果*it为偶数，我们将it递增，从而在下一步循环检查下一个元素。\n\n## 删除多个元素\n\n接受一对迭代器的erase版本允许我们删除一个范围内的元素：\n\n```C++\n//删除两个迭代器表示的范围内的元素\n//返回指向最后一个被删除元素之后位置的迭代器\nelem1=slist.erase(elem1,elem2);  //调用后，elem1==elem2\n```\n\n**迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置**。\n\n为了删除一个容器中的所有元素，我们既可以调用clear，也可以用begin和end获得的迭代器作为参数调用erase：\n\n```C++\nslist.clear() ;//删除容器中的所有元素\nslist.erase(slist.begin(),slist.end());   //等价调用\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"顺序容器概述","published":1,"updated":"2018-01-17T12:43:10.734Z","layout":"post","photos":[],"link":"","_id":"cjcj3yip0001djgc9no0t1u7n","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍顺序容器的种类及基本操作。<br><a id=\"more\"></a></p>\n<h1 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h1><p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>（sequential container）为程序员提供了控制元素存储和访问顺序的能力。<strong>这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应</strong>。与之相对的是11章的<strong>有序和无序关联容器</strong>，它们根据关键字的值来存储元素。</p>\n<p>所有顺序容器都提供了快速访问元素的能力，但是，这些容器在以下方面都有不同的性能折中。</p>\n<ul>\n<li>向容器添加或从容器中删除元素的代价。</li>\n<li>非顺序访问容器中的元素。</li>\n</ul>\n<p>顺序容器类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span> 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。</div><div class=\"line\"><span class=\"built_in\">deque</span> 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。</div><div class=\"line\"><span class=\"built_in\">list</span> 双向链表。只支持双向顺序访问。在<span class=\"built_in\">list</span>中任何位置插入/删除都很快</div><div class=\"line\">forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快。</div><div class=\"line\"><span class=\"built_in\">array</span> 固定大小数组。支持快速随机访问。不能添加或删除元素。</div><div class=\"line\"><span class=\"built_in\">string</span> 与<span class=\"built_in\">vector</span>相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。</div></pre></td></tr></table></figure>\n<ul>\n<li>除了array外，其他容器都提供高效、灵活的内存管理。</li>\n<li>string和vector将元素保存在连续的内存空间中。因为连续，所以下标访问非常快。但在中间插入、删除较慢（O(n)）。有时添加一个元素还可能需要分配的额外空间，这种情况所有元素必须移动到新的存储空间中</li>\n<li>forward_list和array是新C++标准增加的类型。array比内置数组更安全。forward_list没有size()操作。新标准库的容器比旧版本的快得多。</li>\n</ul>\n<h2 id=\"确定使用哪种顺序容器\"><a href=\"#确定使用哪种顺序容器\" class=\"headerlink\" title=\"确定使用哪种顺序容器\"></a>确定使用哪种顺序容器</h2><p><strong>通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。</strong></p>\n<ul>\n<li>一般用vector。</li>\n<li>如果程序有很多小元素，且空间的额外开销很重要，则不要用list或forward_list。</li>\n<li>要随机访问元素用vector或deque。</li>\n<li>如果要在中间插入或删除元素，应用list或forward_list。</li>\n<li>如果要在头尾插入或删除元素。但不会在中间插入或删除元素，用deque。</li>\n<li>如果程序只有在读取输入的时候才需要在容器中间位置插入元素，随后需要随机访问元素。如果确实需要，则考虑在输入阶段用list，一旦输入完成，将list中的元素拷贝到一个vector中。</li>\n</ul>\n<p>如果程序既需要随机访问元素，又需要在容器中间插入元素，该怎么办？</p>\n<p>一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。</p>\n<h1 id=\"容器库概述\"><a href=\"#容器库概述\" class=\"headerlink\" title=\"容器库概述\"></a>容器库概述</h1><p>容器类型上的操作形成了一种层次：</p>\n<ul>\n<li>某些操作是所有容器类型都提供的。</li>\n<li>另外一些操作仅针对顺序容器、关联容器或无序容器。</li>\n<li>还有一些操作只适用于一小部分容器。</li>\n</ul>\n<h2 id=\"对容器可以保存的元素类型的限制\"><a href=\"#对容器可以保存的元素类型的限制\" class=\"headerlink\" title=\"对容器可以保存的元素类型的限制\"></a>对容器可以保存的元素类型的限制</h2><p>顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另外一个容器。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; lines;     <span class=\"comment\">//lines是一个vector，其元类型是string的vector</span></div></pre></td></tr></table></figure>\n<p>某些类没有默认的构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//假定noDefault是一个没有默认构造函数的类型</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;noDefault&gt; v1(<span class=\"number\">10</span>,init);      <span class=\"comment\">//正确：提供了元素初始化器</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;noDefault&gt; v2(<span class=\"number\">10</span>);           <span class=\"comment\">//错误：必须提供一个元素初始化器</span></div></pre></td></tr></table></figure>\n<font color=\"red\"> <strong>容器操作：(待补充)</strong> </font>\n\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><h3 id=\"标准库array具有固定大小\"><a href=\"#标准库array具有固定大小\" class=\"headerlink\" title=\"标准库array具有固定大小\"></a>标准库array具有固定大小</h3><p>与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,42&gt;        <span class=\"comment\">//类型为：保存42个int的数组</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"built_in\">string</span>,10&gt;     <span class=\"comment\">//类型为：保存10个string的数组</span></div></pre></td></tr></table></figure>\n<p>为了使用array类型，我们必须同时指定元素类型和大小：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt;::size_type i;     <span class=\"comment\">//数组类型包括元素类型和大小</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type j;        <span class=\"comment\">//错误：array&lt;int&gt;不是一个类型</span></div></pre></td></tr></table></figure></p>\n<p>初始化array：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; ia1;       <span class=\"comment\">//10个默认初始化的int</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; ia2 = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;    <span class=\"comment\">//列表初始化</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; ia3 = &#123;<span class=\"number\">42</span>&#125;;      <span class=\"comment\">//ia3[0]为42，剩余元素为0</span></div></pre></td></tr></table></figure>\n<p>值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并无此限制。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> digs[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> cpy[<span class=\"number\">10</span>] = digs;            <span class=\"comment\">//错误，内置数组不支持拷贝或赋值</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; digits = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; copy = digits;   <span class=\"comment\">//正确，只要数组类型匹配即合法</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"赋值和swap\"><a href=\"#赋值和swap\" class=\"headerlink\" title=\"赋值和swap\"></a>赋值和swap</h2><p>赋值相关的运算符可用于所有的容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">c1 = c2;       <span class=\"comment\">//将c1的内容替换为c2中元素的拷贝</span></div><div class=\"line\">c1 = &#123;a,b,c&#125;;  <span class=\"comment\">//赋值后，c1大小为3</span></div></pre></td></tr></table></figure>\n<p>如果两个容器原来的大小不同，赋值运算后两者的大小都与右边容器的原大小相同。</p>\n<p>与内置数组不同，<strong>标准库array类型允许赋值</strong>。赋值号左右两边的运算对象必须具有相同的类型。也就是array进行赋值，<strong>左右两边数组大小必须相等</strong>。</p>\n<p><strong>1.assign(仅顺序容器)</strong></p>\n<p><strong>允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值</strong>。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，我们可以用assign实现将一个vector中的一段char *值赋予一个list中的string：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; names;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *&gt; oldstyle;</div><div class=\"line\">name = oldstyle;   <span class=\"comment\">//错误，容器类型不匹配，赋值，类型必须完全一样</span></div><div class=\"line\"><span class=\"comment\">//正确：可以将const char * 转化为string</span></div><div class=\"line\">names.assign(oldstyle.cbegin(),oldstyle.cend());</div></pre></td></tr></table></figure>\n<p>assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//等价于slist1.clear();</span></div><div class=\"line\"><span class=\"comment\">//后跟slist1.insert(slist1.begin(),10,\"Hiya!\");</span></div><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; slist1(<span class=\"number\">1</span>);      <span class=\"comment\">//1个元素，为空string</span></div><div class=\"line\">slist1.assign(<span class=\"number\">10</span>,<span class=\"string\">\"Hiya!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>2.使用swap</strong></p>\n<p>swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec1(<span class=\"number\">10</span>);       <span class=\"comment\">//10个元素的vector</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec2(<span class=\"number\">24</span>);       <span class=\"comment\">//24个元素的vector</span></div><div class=\"line\">swap(svec1,svec2);</div></pre></td></tr></table></figure>\n<p><strong>除array外，swap不对任何元素进行拷贝、删除或插入操作。因此可以保证在常数时间内完成</strong>。</p>\n<p>在新标准中，容器既提供成员版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。<strong>统一使用非成员版本的swap是一个好习惯。</strong></p>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>每个容器类型都支持相等运算符（== 和 ！=）；除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。<strong>关系运算符左右两边的运算对象必须是相同类型的容器。且必须保存相同类型的元素。</strong></p>\n<ul>\n<li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。</li>\n<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>\n<li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。 </li>\n</ul>\n<p><strong>容器的关系运算符使用元素的关系运算符完成比较</strong>：<br>容器的相等运算符实际上是使用元素的==运算符 来实现比较的，而其他关系运算符 是使用元素的&lt;运算符 。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算符。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Sale_data&gt; storeA, storeB;</div><div class=\"line\"><span class=\"keyword\">if</span>(storeA &lt; storeB)                 <span class=\"comment\">// 错误：Sales_data没有&lt;运算符</span></div></pre></td></tr></table></figure>\n<p>注意： <strong>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</strong></p>\n<h1 id=\"顺序容器的操作\"><a href=\"#顺序容器的操作\" class=\"headerlink\" title=\"顺序容器的操作\"></a>顺序容器的操作</h1><p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。上一节介绍了所有容器都支持的操作。本章剩余部分将介绍顺序容器所特有的操作。</p>\n<h2 id=\"向顺序容器添加元素\"><a href=\"#向顺序容器添加元素\" class=\"headerlink\" title=\"向顺序容器添加元素\"></a>向顺序容器添加元素</h2><p>除了array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">向顺序容器添加元素的操作：</div><div class=\"line\">操作会改变容器的大小；<span class=\"built_in\">array</span>不支持这些操作。</div><div class=\"line\"></div><div class=\"line\">forward_list有自己专有版本的insert和emplace；</div><div class=\"line\">forward_list不支持push_back和emplace_back</div><div class=\"line\"><span class=\"built_in\">vector</span>和<span class=\"built_in\">string</span>不支持push_front和emplace_front</div><div class=\"line\">c.push_back(t)　　　　　　　　在c的尾部创建一个值为t或由args创建的元素，返回<span class=\"keyword\">void</span></div><div class=\"line\">c.emplace_back(args)</div><div class=\"line\">c.push_front(t)　　　　　　　　在c的头部创建一个值为t或由args创建的元素，返回<span class=\"keyword\">void</span></div><div class=\"line\">c.emplace_front(args)</div><div class=\"line\">c.insert(p,t)　　　　　　　　　  在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器</div><div class=\"line\">c.emplace(p,args)</div><div class=\"line\">c.insert(p,n,t)　 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为<span class=\"number\">0</span>，则返回p</div><div class=\"line\">c.insert(p,b,e)　 将迭代器b和e指向的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回p</div><div class=\"line\">c.insert(p,il)　　il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器：若列表为空，则返回p</div></pre></td></tr></table></figure>\n<p><strong>向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。</strong></p>\n<p>当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque的首位之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。</p>\n<h2 id=\"使用push-back\"><a href=\"#使用push-back\" class=\"headerlink\" title=\"使用push_back\"></a>使用push_back</h2><p><strong>我们看到push_back将一个元素追加到一个vector的尾部。除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。</strong></p>\n<p>例如，下面的循环每次读取一个string到word中，然后追加到容器尾部：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//从标准输入读取数据，将每个单词放到容器末尾</span></div><div class=\"line\"><span class=\"built_in\">string</span> word;</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;word)</div><div class=\"line\">　　container.push_back(word);</div></pre></td></tr></table></figure>\n<p>对push_back的调用在container尾部创建了一个新的元素，将container的size增大了1。该元素的值为word的一个拷贝，container的类型可以是list、vector或deque。</p>\n<p><strong>关键概念</strong>：当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p>\n<h2 id=\"使用push-front\"><a href=\"#使用push-front\" class=\"headerlink\" title=\"使用push_front\"></a>使用push_front</h2><p><strong>除了push_back, list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; ilist;</div><div class=\"line\"><span class=\"comment\">//将元素添加到Ilist开头</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> ix=<span class=\"number\">0</span>;ix!=<span class=\"number\">4</span>;++ix)</div><div class=\"line\">　　ilist.push_front(ix);</div></pre></td></tr></table></figure>\n<p>此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的新的开始位置。即，当我们插入1时，它会被放置在0之前，2被放置在1之前，依次类推。因此，在循环中以这种方式将元素添加到容器中，最终会形成逆序。</p>\n<p><strong>注意：</strong> deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首部进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置插入元素会很耗时。</p>\n<h2 id=\"在容器中的特定位置添加元素（insert）\"><a href=\"#在容器中的特定位置添加元素（insert）\" class=\"headerlink\" title=\"在容器中的特定位置添加元素（insert）\"></a>在容器中的特定位置添加元素（insert）</h2><p><strong>push_back和push_front操作提供了一种方便地在顺序容器尾部或头部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。</strong></p>\n<p>每个insert函数都接受一个迭代器作为其一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，<font color=\"red\"> <strong>所有insert函数将元素插入到迭代器所指定的位置之前</strong> </font>。例如，下面的语句</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">slist.insert(iter,<span class=\"string\">\"Hello!\"</span>);  <span class=\"comment\">//将hello添加到iter之前的位置</span></div></pre></td></tr></table></figure>\n<p>虽然某些容器不支持push_front操作，但他们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec;</div><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; slist;</div><div class=\"line\"><span class=\"comment\">//等价于调用slist.push_front(\"Hello!\");</span></div><div class=\"line\">slist.insert(slist.begin(),<span class=\"string\">\"Hello!\"</span>);</div><div class=\"line\"><span class=\"comment\">//vector不支持push_front，但我们可以插入到begin()之前</span></div><div class=\"line\"><span class=\"comment\">//警告：插入到vector末尾之外的任何位置都可能很慢</span></div><div class=\"line\">svec.insert(svec.begin(),<span class=\"string\">\"Hello!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时</strong>。</p>\n<h2 id=\"插入范围内元素\"><a href=\"#插入范围内元素\" class=\"headerlink\" title=\"插入范围内元素\"></a>插入范围内元素</h2><p>除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函数类似。其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素够按给定值初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">svec.insert(svec.end(),<span class=\"number\">10</span>,<span class=\"string\">\"Anna\"</span>);</div></pre></td></tr></table></figure>\n<p>这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string“Anna”。</p>\n<p>接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v=&#123;<span class=\"string\">\"quasi\"</span>,<span class=\"string\">\"simba\"</span>,<span class=\"string\">\"frollo\"</span>,<span class=\"string\">\"scar\"</span>&#125;;</div><div class=\"line\"><span class=\"comment\">//将v的最后两个元素添加到slist的开始位置</span></div><div class=\"line\">slist.insert(slist.begin(),v.end()<span class=\"number\">-2</span>,v.end());</div><div class=\"line\">slist.insert(slist.end(),&#123;<span class=\"string\">\"these\"</span>,<span class=\"string\">\"words\"</span>,<span class=\"string\">\"will\"</span>,<span class=\"string\">\"go\"</span>,<span class=\"string\">\"at\"</span>,<span class=\"string\">\"the\"</span>,<span class=\"string\">\"end\"</span>&#125;);</div><div class=\"line\">slist.insert(slist.begin(),slist.begin(),slist.end()); <span class=\"comment\">//运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器</span></div></pre></td></tr></table></figure>\n<p><strong>如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。</strong></p>\n<h2 id=\"使用insert的返回值\"><a href=\"#使用insert的返回值\" class=\"headerlink\" title=\"使用insert的返回值\"></a>使用insert的返回值</h2><p>通过使用insert的返回值，可以在容器中一个特定的位置反复插入元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; lst;</div><div class=\"line\"><span class=\"keyword\">auto</span> iter=lst.begin();</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;word)</div><div class=\"line\">　　iter=lst.insert(iter,word);  <span class=\"comment\">//等价于调用push_front</span></div></pre></td></tr></table></figure>\n<p>在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，读取下一个单词。</p>\n<h2 id=\"使用emplace操作\"><a href=\"#使用emplace操作\" class=\"headerlink\" title=\"使用emplace操作\"></a>使用emplace操作</h2><p>使用emplace操作</p>\n<p><strong>新标准引入了三个成员——emplace_front、emplace和emplace_back，这些操作（构造而不是拷贝元素）。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定的位置之前或容器尾部。</strong></p>\n<p>当调用push或insert成员函数时，我们将元素类型对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，<strong>则是将参数传递给元素类型的构造函数</strong>。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在c的末尾构造一个Sales_data对象</span></div><div class=\"line\"><span class=\"comment\">//使用三个参数的Sales_data的构造函数</span></div><div class=\"line\">c.emplace_back(<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>);</div><div class=\"line\">c.push_back(<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>);     <span class=\"comment\">//错误：没有接受三个参数的push_back版本</span></div><div class=\"line\"><span class=\"comment\">//正确：创建一个临时的Sales_data对象传递给push_back</span></div><div class=\"line\">c.push_back(Sales_data((<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>));</div></pre></td></tr></table></figure>\n<p><strong>其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。</strong></p>\n<font color=\"red\"> <strong>emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</strong> </font> ：<br><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//iter指向c中一个元素，其中保存了Sales_data元素</span></div><div class=\"line\">c.emplace_back();<span class=\"comment\">//使用Sales_data的默认构造函数</span></div><div class=\"line\">c.emplace(iter,<span class=\"string\">\"999-999999999\"</span>); <span class=\"comment\">//使用Sales_data(string)</span></div><div class=\"line\"><span class=\"comment\">//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数</span></div><div class=\"line\">c.emplace_front(<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>);</div></pre></td></tr></table></figure><br><br><strong>emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。</strong><br><br><br>## 访问元素 （访问成员函数返回的是引用）<br><br>下表列出了我们可以用来在顺序容器值访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。<br><br>包括array在内的每个顺序容器都有一个front成员函数，而除了forward_list之外的所以顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用：<br><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在解引用一个迭代器或调用front或back之前检查是否有元素</span></div><div class=\"line\"><span class=\"keyword\">if</span>(!c.empty())&#123;</div><div class=\"line\">　　<span class=\"comment\">//val和val2是c中第一个元素值的拷贝</span></div><div class=\"line\">　　<span class=\"keyword\">auto</span> val=*c.begin(),val2=c.front();</div><div class=\"line\">　　<span class=\"comment\">//val3和val4是c中最后一个元素值的拷贝</span></div><div class=\"line\">　　<span class=\"keyword\">auto</span> last=c.end();</div><div class=\"line\">　　<span class=\"keyword\">auto</span> val3=*(--last);  <span class=\"comment\">//不能递减forward_list迭代器</span></div><div class=\"line\">　　<span class=\"keyword\">auto</span> val4=c.back();  <span class=\"comment\">//forward_list不支持</span></div></pre></td></tr></table></figure><br><br><strong>此程序用两种不同方式来获取c中的首元素和尾元素的引用。</strong> 直接的方式是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获取尾元素的引用。<br><br><font color=\"red\">  <strong>在顺序容器中访问元素的操作</strong> </font>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">at和下标操作只适用于<span class=\"built_in\">string</span>、<span class=\"built_in\">vector</span>、<span class=\"built_in\">deque</span>和<span class=\"built_in\">array</span>。</div><div class=\"line\">back不适用于forward_list。</div><div class=\"line\">c.back() 　　　　　　　　　　返回c中尾元素的引用。若c为空，函数行为未定义</div><div class=\"line\">c.front()　　　　　　　　　　 返回c中首元素的引用。若c为空，函数行为未定义</div><div class=\"line\">c[n]　　　　　　　　　　　　 返回c中下标为n的元素的引用，n是一个无符号整数。若n&gt;c.size(),则函数的行为未定义</div><div class=\"line\">c.at[n]　　　　　　　　　　  返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常</div></pre></td></tr></table></figure>\n<p><strong>对一个空容器调用front和back，就像使用一个越界的下标一样。是一种严重的程序设计错误。</strong></p>\n<h2 id=\"访问成员函数返回的是引用\"><a href=\"#访问成员函数返回的是引用\" class=\"headerlink\" title=\"访问成员函数返回的是引用\"></a>访问成员函数返回的是引用</h2><p>在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!c.empty())&#123;</div><div class=\"line\">    c.front() = <span class=\"number\">42</span>;   <span class=\"comment\">//将42赋予c中的第一个元素</span></div><div class=\"line\">    <span class=\"keyword\">auto</span> &amp;v = c.back();     <span class=\"comment\">//获得指向最后一个元素的引用</span></div><div class=\"line\">    v = <span class=\"number\">1024</span>;          <span class=\"comment\">//改变c中的元素</span></div><div class=\"line\">    <span class=\"keyword\">auto</span> v2 = c.back();    <span class=\"comment\">//v2不是一个引用，它是c.back()的一个拷贝</span></div><div class=\"line\">    v2 = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。</strong></p>\n<h2 id=\"下标操作和安全的随机访问\"><a href=\"#下标操作和安全的随机访问\" class=\"headerlink\" title=\"下标操作和安全的随机访问\"></a>下标操作和安全的随机访问</h2><p>提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们已经看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。</p>\n<p><strong>我们希望确保下标是合法的，可以使用at成员函数</strong>。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec;  <span class=\"comment\">//空vector</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;svec[<span class=\"number\">0</span>];   <span class=\"comment\">//运行时错误：svec中没有元素</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;svec.at[<span class=\"number\">0</span>];   <span class=\"comment\">//抛出一个out_of_range异常</span></div></pre></td></tr></table></figure>\n<h2 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h2><p>与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下表所示：</p>\n<font color=\"red\"> <strong>顺序容器的删除操作</strong> </font>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">这些操作会改变容器的大小，所以不适用于<span class=\"built_in\">array</span></div><div class=\"line\">forward_list有特殊版本的erase</div><div class=\"line\">forward_list不支持pop_back；<span class=\"built_in\">vector</span>和<span class=\"built_in\">string</span>不支持pop_front</div><div class=\"line\">c.pop_back() 　　　　　　删除c中尾元素，若c为空，则函数行为未定义，函数返回<span class=\"keyword\">void</span></div><div class=\"line\">c.pop_front()　　　　　　删除c中首元素，若c为空，则函数行为未定义，函数返回<span class=\"keyword\">void</span></div><div class=\"line\">c.erase(p)　　　　　　　 删除迭代器p所指的元素，返回以指向被删除元素之后的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数的行为未定义</div><div class=\"line\">c.erase(b,e)　　　　　　 删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器</div><div class=\"line\">c.clear()　　　　　　　　 删除c中的所以元素，返回<span class=\"keyword\">void</span></div></pre></td></tr></table></figure>\n<p><strong>删除deque中除首位元素之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。</strong></p>\n<h2 id=\"pop-front和pop-back成员函数\"><a href=\"#pop-front和pop-back成员函数\" class=\"headerlink\" title=\"pop_front和pop_back成员函数\"></a>pop_front和pop_back成员函数</h2><p>pop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似的，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。</p>\n<p>这些操作返回void，如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(!ilist.empty())&#123;</div><div class=\"line\">　　process(ilist.front());  <span class=\"comment\">//对ilist的首元素进行一些处理</span></div><div class=\"line\">　　ilist.pop_front();　　<span class=\"comment\">//完成处理后删除首元素</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"从容器内部删除一个元素\"><a href=\"#从容器内部删除一个元素\" class=\"headerlink\" title=\"从容器内部删除一个元素\"></a>从容器内部删除一个元素</h2><p>成员函数erase从容器中指定位置删除元素，我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。<strong>两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。</strong></p>\n<p>例如，下面的循环删除一个list中的所有奇数元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; lst=(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">auto</span> it=lst.begin();</div><div class=\"line\"><span class=\"keyword\">while</span>(it!=lst.end())</div><div class=\"line\">　　<span class=\"keyword\">if</span>(*it%<span class=\"number\">2</span>)</div><div class=\"line\">　　　　it=lst.erase(it);  <span class=\"comment\">//删除此元素</span></div><div class=\"line\">　　<span class=\"keyword\">else</span></div><div class=\"line\">　　　　++it;</div></pre></td></tr></table></figure>\n<p>每个循环步中，首先检查当前元素是否是奇数，如果是，就删除该元素，并将it设置为我们所删除的元素之后的元素。如果*it为偶数，我们将it递增，从而在下一步循环检查下一个元素。</p>\n<h2 id=\"删除多个元素\"><a href=\"#删除多个元素\" class=\"headerlink\" title=\"删除多个元素\"></a>删除多个元素</h2><p>接受一对迭代器的erase版本允许我们删除一个范围内的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//删除两个迭代器表示的范围内的元素</span></div><div class=\"line\"><span class=\"comment\">//返回指向最后一个被删除元素之后位置的迭代器</span></div><div class=\"line\">elem1=slist.erase(elem1,elem2);  <span class=\"comment\">//调用后，elem1==elem2</span></div></pre></td></tr></table></figure>\n<p><strong>迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置</strong>。</p>\n<p>为了删除一个容器中的所有元素，我们既可以调用clear，也可以用begin和end获得的迭代器作为参数调用erase：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">slist.clear() ;<span class=\"comment\">//删除容器中的所有元素</span></div><div class=\"line\">slist.erase(slist.begin(),slist.end());   <span class=\"comment\">//等价调用</span></div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍顺序容器的种类及基本操作。<br>","more":"</p>\n<h1 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h1><p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>（sequential container）为程序员提供了控制元素存储和访问顺序的能力。<strong>这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应</strong>。与之相对的是11章的<strong>有序和无序关联容器</strong>，它们根据关键字的值来存储元素。</p>\n<p>所有顺序容器都提供了快速访问元素的能力，但是，这些容器在以下方面都有不同的性能折中。</p>\n<ul>\n<li>向容器添加或从容器中删除元素的代价。</li>\n<li>非顺序访问容器中的元素。</li>\n</ul>\n<p>顺序容器类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span> 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。</div><div class=\"line\"><span class=\"built_in\">deque</span> 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。</div><div class=\"line\"><span class=\"built_in\">list</span> 双向链表。只支持双向顺序访问。在<span class=\"built_in\">list</span>中任何位置插入/删除都很快</div><div class=\"line\">forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快。</div><div class=\"line\"><span class=\"built_in\">array</span> 固定大小数组。支持快速随机访问。不能添加或删除元素。</div><div class=\"line\"><span class=\"built_in\">string</span> 与<span class=\"built_in\">vector</span>相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。</div></pre></td></tr></table></figure>\n<ul>\n<li>除了array外，其他容器都提供高效、灵活的内存管理。</li>\n<li>string和vector将元素保存在连续的内存空间中。因为连续，所以下标访问非常快。但在中间插入、删除较慢（O(n)）。有时添加一个元素还可能需要分配的额外空间，这种情况所有元素必须移动到新的存储空间中</li>\n<li>forward_list和array是新C++标准增加的类型。array比内置数组更安全。forward_list没有size()操作。新标准库的容器比旧版本的快得多。</li>\n</ul>\n<h2 id=\"确定使用哪种顺序容器\"><a href=\"#确定使用哪种顺序容器\" class=\"headerlink\" title=\"确定使用哪种顺序容器\"></a>确定使用哪种顺序容器</h2><p><strong>通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。</strong></p>\n<ul>\n<li>一般用vector。</li>\n<li>如果程序有很多小元素，且空间的额外开销很重要，则不要用list或forward_list。</li>\n<li>要随机访问元素用vector或deque。</li>\n<li>如果要在中间插入或删除元素，应用list或forward_list。</li>\n<li>如果要在头尾插入或删除元素。但不会在中间插入或删除元素，用deque。</li>\n<li>如果程序只有在读取输入的时候才需要在容器中间位置插入元素，随后需要随机访问元素。如果确实需要，则考虑在输入阶段用list，一旦输入完成，将list中的元素拷贝到一个vector中。</li>\n</ul>\n<p>如果程序既需要随机访问元素，又需要在容器中间插入元素，该怎么办？</p>\n<p>一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。</p>\n<h1 id=\"容器库概述\"><a href=\"#容器库概述\" class=\"headerlink\" title=\"容器库概述\"></a>容器库概述</h1><p>容器类型上的操作形成了一种层次：</p>\n<ul>\n<li>某些操作是所有容器类型都提供的。</li>\n<li>另外一些操作仅针对顺序容器、关联容器或无序容器。</li>\n<li>还有一些操作只适用于一小部分容器。</li>\n</ul>\n<h2 id=\"对容器可以保存的元素类型的限制\"><a href=\"#对容器可以保存的元素类型的限制\" class=\"headerlink\" title=\"对容器可以保存的元素类型的限制\"></a>对容器可以保存的元素类型的限制</h2><p>顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另外一个容器。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; lines;     <span class=\"comment\">//lines是一个vector，其元类型是string的vector</span></div></pre></td></tr></table></figure>\n<p>某些类没有默认的构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//假定noDefault是一个没有默认构造函数的类型</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;noDefault&gt; v1(<span class=\"number\">10</span>,init);      <span class=\"comment\">//正确：提供了元素初始化器</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;noDefault&gt; v2(<span class=\"number\">10</span>);           <span class=\"comment\">//错误：必须提供一个元素初始化器</span></div></pre></td></tr></table></figure>\n<font color=\"red\"> <strong>容器操作：(待补充)</strong> </font>\n\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><h3 id=\"标准库array具有固定大小\"><a href=\"#标准库array具有固定大小\" class=\"headerlink\" title=\"标准库array具有固定大小\"></a>标准库array具有固定大小</h3><p>与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,42&gt;        <span class=\"comment\">//类型为：保存42个int的数组</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"built_in\">string</span>,10&gt;     <span class=\"comment\">//类型为：保存10个string的数组</span></div></pre></td></tr></table></figure>\n<p>为了使用array类型，我们必须同时指定元素类型和大小：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt;::size_type i;     <span class=\"comment\">//数组类型包括元素类型和大小</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>&gt;::size_type j;        <span class=\"comment\">//错误：array&lt;int&gt;不是一个类型</span></div></pre></td></tr></table></figure></p>\n<p>初始化array：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; ia1;       <span class=\"comment\">//10个默认初始化的int</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; ia2 = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;    <span class=\"comment\">//列表初始化</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; ia3 = &#123;<span class=\"number\">42</span>&#125;;      <span class=\"comment\">//ia3[0]为42，剩余元素为0</span></div></pre></td></tr></table></figure>\n<p>值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并无此限制。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> digs[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> cpy[<span class=\"number\">10</span>] = digs;            <span class=\"comment\">//错误，内置数组不支持拷贝或赋值</span></div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; digits = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>,10&gt; copy = digits;   <span class=\"comment\">//正确，只要数组类型匹配即合法</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"赋值和swap\"><a href=\"#赋值和swap\" class=\"headerlink\" title=\"赋值和swap\"></a>赋值和swap</h2><p>赋值相关的运算符可用于所有的容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">c1 = c2;       <span class=\"comment\">//将c1的内容替换为c2中元素的拷贝</span></div><div class=\"line\">c1 = &#123;a,b,c&#125;;  <span class=\"comment\">//赋值后，c1大小为3</span></div></pre></td></tr></table></figure>\n<p>如果两个容器原来的大小不同，赋值运算后两者的大小都与右边容器的原大小相同。</p>\n<p>与内置数组不同，<strong>标准库array类型允许赋值</strong>。赋值号左右两边的运算对象必须具有相同的类型。也就是array进行赋值，<strong>左右两边数组大小必须相等</strong>。</p>\n<p><strong>1.assign(仅顺序容器)</strong></p>\n<p><strong>允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值</strong>。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，我们可以用assign实现将一个vector中的一段char *值赋予一个list中的string：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; names;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *&gt; oldstyle;</div><div class=\"line\">name = oldstyle;   <span class=\"comment\">//错误，容器类型不匹配，赋值，类型必须完全一样</span></div><div class=\"line\"><span class=\"comment\">//正确：可以将const char * 转化为string</span></div><div class=\"line\">names.assign(oldstyle.cbegin(),oldstyle.cend());</div></pre></td></tr></table></figure>\n<p>assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//等价于slist1.clear();</span></div><div class=\"line\"><span class=\"comment\">//后跟slist1.insert(slist1.begin(),10,\"Hiya!\");</span></div><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; slist1(<span class=\"number\">1</span>);      <span class=\"comment\">//1个元素，为空string</span></div><div class=\"line\">slist1.assign(<span class=\"number\">10</span>,<span class=\"string\">\"Hiya!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>2.使用swap</strong></p>\n<p>swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec1(<span class=\"number\">10</span>);       <span class=\"comment\">//10个元素的vector</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec2(<span class=\"number\">24</span>);       <span class=\"comment\">//24个元素的vector</span></div><div class=\"line\">swap(svec1,svec2);</div></pre></td></tr></table></figure>\n<p><strong>除array外，swap不对任何元素进行拷贝、删除或插入操作。因此可以保证在常数时间内完成</strong>。</p>\n<p>在新标准中，容器既提供成员版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。<strong>统一使用非成员版本的swap是一个好习惯。</strong></p>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>每个容器类型都支持相等运算符（== 和 ！=）；除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。<strong>关系运算符左右两边的运算对象必须是相同类型的容器。且必须保存相同类型的元素。</strong></p>\n<ul>\n<li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。</li>\n<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>\n<li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。 </li>\n</ul>\n<p><strong>容器的关系运算符使用元素的关系运算符完成比较</strong>：<br>容器的相等运算符实际上是使用元素的==运算符 来实现比较的，而其他关系运算符 是使用元素的&lt;运算符 。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算符。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;Sale_data&gt; storeA, storeB;</div><div class=\"line\"><span class=\"keyword\">if</span>(storeA &lt; storeB)                 <span class=\"comment\">// 错误：Sales_data没有&lt;运算符</span></div></pre></td></tr></table></figure>\n<p>注意： <strong>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</strong></p>\n<h1 id=\"顺序容器的操作\"><a href=\"#顺序容器的操作\" class=\"headerlink\" title=\"顺序容器的操作\"></a>顺序容器的操作</h1><p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。上一节介绍了所有容器都支持的操作。本章剩余部分将介绍顺序容器所特有的操作。</p>\n<h2 id=\"向顺序容器添加元素\"><a href=\"#向顺序容器添加元素\" class=\"headerlink\" title=\"向顺序容器添加元素\"></a>向顺序容器添加元素</h2><p>除了array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">向顺序容器添加元素的操作：</div><div class=\"line\">操作会改变容器的大小；<span class=\"built_in\">array</span>不支持这些操作。</div><div class=\"line\"></div><div class=\"line\">forward_list有自己专有版本的insert和emplace；</div><div class=\"line\">forward_list不支持push_back和emplace_back</div><div class=\"line\"><span class=\"built_in\">vector</span>和<span class=\"built_in\">string</span>不支持push_front和emplace_front</div><div class=\"line\">c.push_back(t)　　　　　　　　在c的尾部创建一个值为t或由args创建的元素，返回<span class=\"keyword\">void</span></div><div class=\"line\">c.emplace_back(args)</div><div class=\"line\">c.push_front(t)　　　　　　　　在c的头部创建一个值为t或由args创建的元素，返回<span class=\"keyword\">void</span></div><div class=\"line\">c.emplace_front(args)</div><div class=\"line\">c.insert(p,t)　　　　　　　　　  在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器</div><div class=\"line\">c.emplace(p,args)</div><div class=\"line\">c.insert(p,n,t)　 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为<span class=\"number\">0</span>，则返回p</div><div class=\"line\">c.insert(p,b,e)　 将迭代器b和e指向的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回p</div><div class=\"line\">c.insert(p,il)　　il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器：若列表为空，则返回p</div></pre></td></tr></table></figure>\n<p><strong>向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。</strong></p>\n<p>当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque的首位之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。</p>\n<h2 id=\"使用push-back\"><a href=\"#使用push-back\" class=\"headerlink\" title=\"使用push_back\"></a>使用push_back</h2><p><strong>我们看到push_back将一个元素追加到一个vector的尾部。除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。</strong></p>\n<p>例如，下面的循环每次读取一个string到word中，然后追加到容器尾部：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//从标准输入读取数据，将每个单词放到容器末尾</span></div><div class=\"line\"><span class=\"built_in\">string</span> word;</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;word)</div><div class=\"line\">　　container.push_back(word);</div></pre></td></tr></table></figure>\n<p>对push_back的调用在container尾部创建了一个新的元素，将container的size增大了1。该元素的值为word的一个拷贝，container的类型可以是list、vector或deque。</p>\n<p><strong>关键概念</strong>：当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p>\n<h2 id=\"使用push-front\"><a href=\"#使用push-front\" class=\"headerlink\" title=\"使用push_front\"></a>使用push_front</h2><p><strong>除了push_back, list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; ilist;</div><div class=\"line\"><span class=\"comment\">//将元素添加到Ilist开头</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> ix=<span class=\"number\">0</span>;ix!=<span class=\"number\">4</span>;++ix)</div><div class=\"line\">　　ilist.push_front(ix);</div></pre></td></tr></table></figure>\n<p>此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的新的开始位置。即，当我们插入1时，它会被放置在0之前，2被放置在1之前，依次类推。因此，在循环中以这种方式将元素添加到容器中，最终会形成逆序。</p>\n<p><strong>注意：</strong> deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首部进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置插入元素会很耗时。</p>\n<h2 id=\"在容器中的特定位置添加元素（insert）\"><a href=\"#在容器中的特定位置添加元素（insert）\" class=\"headerlink\" title=\"在容器中的特定位置添加元素（insert）\"></a>在容器中的特定位置添加元素（insert）</h2><p><strong>push_back和push_front操作提供了一种方便地在顺序容器尾部或头部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。</strong></p>\n<p>每个insert函数都接受一个迭代器作为其一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，<font color=\"red\"> <strong>所有insert函数将元素插入到迭代器所指定的位置之前</strong> </font>。例如，下面的语句</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">slist.insert(iter,<span class=\"string\">\"Hello!\"</span>);  <span class=\"comment\">//将hello添加到iter之前的位置</span></div></pre></td></tr></table></figure>\n<p>虽然某些容器不支持push_front操作，但他们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec;</div><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; slist;</div><div class=\"line\"><span class=\"comment\">//等价于调用slist.push_front(\"Hello!\");</span></div><div class=\"line\">slist.insert(slist.begin(),<span class=\"string\">\"Hello!\"</span>);</div><div class=\"line\"><span class=\"comment\">//vector不支持push_front，但我们可以插入到begin()之前</span></div><div class=\"line\"><span class=\"comment\">//警告：插入到vector末尾之外的任何位置都可能很慢</span></div><div class=\"line\">svec.insert(svec.begin(),<span class=\"string\">\"Hello!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时</strong>。</p>\n<h2 id=\"插入范围内元素\"><a href=\"#插入范围内元素\" class=\"headerlink\" title=\"插入范围内元素\"></a>插入范围内元素</h2><p>除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函数类似。其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素够按给定值初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">svec.insert(svec.end(),<span class=\"number\">10</span>,<span class=\"string\">\"Anna\"</span>);</div></pre></td></tr></table></figure>\n<p>这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string“Anna”。</p>\n<p>接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v=&#123;<span class=\"string\">\"quasi\"</span>,<span class=\"string\">\"simba\"</span>,<span class=\"string\">\"frollo\"</span>,<span class=\"string\">\"scar\"</span>&#125;;</div><div class=\"line\"><span class=\"comment\">//将v的最后两个元素添加到slist的开始位置</span></div><div class=\"line\">slist.insert(slist.begin(),v.end()<span class=\"number\">-2</span>,v.end());</div><div class=\"line\">slist.insert(slist.end(),&#123;<span class=\"string\">\"these\"</span>,<span class=\"string\">\"words\"</span>,<span class=\"string\">\"will\"</span>,<span class=\"string\">\"go\"</span>,<span class=\"string\">\"at\"</span>,<span class=\"string\">\"the\"</span>,<span class=\"string\">\"end\"</span>&#125;);</div><div class=\"line\">slist.insert(slist.begin(),slist.begin(),slist.end()); <span class=\"comment\">//运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器</span></div></pre></td></tr></table></figure>\n<p><strong>如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。</strong></p>\n<h2 id=\"使用insert的返回值\"><a href=\"#使用insert的返回值\" class=\"headerlink\" title=\"使用insert的返回值\"></a>使用insert的返回值</h2><p>通过使用insert的返回值，可以在容器中一个特定的位置反复插入元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; lst;</div><div class=\"line\"><span class=\"keyword\">auto</span> iter=lst.begin();</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;word)</div><div class=\"line\">　　iter=lst.insert(iter,word);  <span class=\"comment\">//等价于调用push_front</span></div></pre></td></tr></table></figure>\n<p>在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，读取下一个单词。</p>\n<h2 id=\"使用emplace操作\"><a href=\"#使用emplace操作\" class=\"headerlink\" title=\"使用emplace操作\"></a>使用emplace操作</h2><p>使用emplace操作</p>\n<p><strong>新标准引入了三个成员——emplace_front、emplace和emplace_back，这些操作（构造而不是拷贝元素）。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定的位置之前或容器尾部。</strong></p>\n<p>当调用push或insert成员函数时，我们将元素类型对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，<strong>则是将参数传递给元素类型的构造函数</strong>。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在c的末尾构造一个Sales_data对象</span></div><div class=\"line\"><span class=\"comment\">//使用三个参数的Sales_data的构造函数</span></div><div class=\"line\">c.emplace_back(<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>);</div><div class=\"line\">c.push_back(<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>);     <span class=\"comment\">//错误：没有接受三个参数的push_back版本</span></div><div class=\"line\"><span class=\"comment\">//正确：创建一个临时的Sales_data对象传递给push_back</span></div><div class=\"line\">c.push_back(Sales_data((<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>));</div></pre></td></tr></table></figure>\n<p><strong>其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。</strong></p>\n<font color=\"red\"> <strong>emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</strong> </font> ：<br><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//iter指向c中一个元素，其中保存了Sales_data元素</span></div><div class=\"line\">c.emplace_back();<span class=\"comment\">//使用Sales_data的默认构造函数</span></div><div class=\"line\">c.emplace(iter,<span class=\"string\">\"999-999999999\"</span>); <span class=\"comment\">//使用Sales_data(string)</span></div><div class=\"line\"><span class=\"comment\">//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数</span></div><div class=\"line\">c.emplace_front(<span class=\"string\">\"978-0590353403\"</span>,<span class=\"number\">25</span>,<span class=\"number\">15.99</span>);</div></pre></td></tr></table></figure><br><br><strong>emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。</strong><br><br><br>## 访问元素 （访问成员函数返回的是引用）<br><br>下表列出了我们可以用来在顺序容器值访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。<br><br>包括array在内的每个顺序容器都有一个front成员函数，而除了forward_list之外的所以顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用：<br><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在解引用一个迭代器或调用front或back之前检查是否有元素</span></div><div class=\"line\"><span class=\"keyword\">if</span>(!c.empty())&#123;</div><div class=\"line\">　　<span class=\"comment\">//val和val2是c中第一个元素值的拷贝</span></div><div class=\"line\">　　<span class=\"keyword\">auto</span> val=*c.begin(),val2=c.front();</div><div class=\"line\">　　<span class=\"comment\">//val3和val4是c中最后一个元素值的拷贝</span></div><div class=\"line\">　　<span class=\"keyword\">auto</span> last=c.end();</div><div class=\"line\">　　<span class=\"keyword\">auto</span> val3=*(--last);  <span class=\"comment\">//不能递减forward_list迭代器</span></div><div class=\"line\">　　<span class=\"keyword\">auto</span> val4=c.back();  <span class=\"comment\">//forward_list不支持</span></div></pre></td></tr></table></figure><br><br><strong>此程序用两种不同方式来获取c中的首元素和尾元素的引用。</strong> 直接的方式是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获取尾元素的引用。<br><br><font color=\"red\">  <strong>在顺序容器中访问元素的操作</strong> </font>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">at和下标操作只适用于<span class=\"built_in\">string</span>、<span class=\"built_in\">vector</span>、<span class=\"built_in\">deque</span>和<span class=\"built_in\">array</span>。</div><div class=\"line\">back不适用于forward_list。</div><div class=\"line\">c.back() 　　　　　　　　　　返回c中尾元素的引用。若c为空，函数行为未定义</div><div class=\"line\">c.front()　　　　　　　　　　 返回c中首元素的引用。若c为空，函数行为未定义</div><div class=\"line\">c[n]　　　　　　　　　　　　 返回c中下标为n的元素的引用，n是一个无符号整数。若n&gt;c.size(),则函数的行为未定义</div><div class=\"line\">c.at[n]　　　　　　　　　　  返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常</div></pre></td></tr></table></figure>\n<p><strong>对一个空容器调用front和back，就像使用一个越界的下标一样。是一种严重的程序设计错误。</strong></p>\n<h2 id=\"访问成员函数返回的是引用\"><a href=\"#访问成员函数返回的是引用\" class=\"headerlink\" title=\"访问成员函数返回的是引用\"></a>访问成员函数返回的是引用</h2><p>在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!c.empty())&#123;</div><div class=\"line\">    c.front() = <span class=\"number\">42</span>;   <span class=\"comment\">//将42赋予c中的第一个元素</span></div><div class=\"line\">    <span class=\"keyword\">auto</span> &amp;v = c.back();     <span class=\"comment\">//获得指向最后一个元素的引用</span></div><div class=\"line\">    v = <span class=\"number\">1024</span>;          <span class=\"comment\">//改变c中的元素</span></div><div class=\"line\">    <span class=\"keyword\">auto</span> v2 = c.back();    <span class=\"comment\">//v2不是一个引用，它是c.back()的一个拷贝</span></div><div class=\"line\">    v2 = <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。</strong></p>\n<h2 id=\"下标操作和安全的随机访问\"><a href=\"#下标操作和安全的随机访问\" class=\"headerlink\" title=\"下标操作和安全的随机访问\"></a>下标操作和安全的随机访问</h2><p>提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们已经看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。</p>\n<p><strong>我们希望确保下标是合法的，可以使用at成员函数</strong>。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; svec;  <span class=\"comment\">//空vector</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;svec[<span class=\"number\">0</span>];   <span class=\"comment\">//运行时错误：svec中没有元素</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;svec.at[<span class=\"number\">0</span>];   <span class=\"comment\">//抛出一个out_of_range异常</span></div></pre></td></tr></table></figure>\n<h2 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h2><p>与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下表所示：</p>\n<font color=\"red\"> <strong>顺序容器的删除操作</strong> </font>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">这些操作会改变容器的大小，所以不适用于<span class=\"built_in\">array</span></div><div class=\"line\">forward_list有特殊版本的erase</div><div class=\"line\">forward_list不支持pop_back；<span class=\"built_in\">vector</span>和<span class=\"built_in\">string</span>不支持pop_front</div><div class=\"line\">c.pop_back() 　　　　　　删除c中尾元素，若c为空，则函数行为未定义，函数返回<span class=\"keyword\">void</span></div><div class=\"line\">c.pop_front()　　　　　　删除c中首元素，若c为空，则函数行为未定义，函数返回<span class=\"keyword\">void</span></div><div class=\"line\">c.erase(p)　　　　　　　 删除迭代器p所指的元素，返回以指向被删除元素之后的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数的行为未定义</div><div class=\"line\">c.erase(b,e)　　　　　　 删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器</div><div class=\"line\">c.clear()　　　　　　　　 删除c中的所以元素，返回<span class=\"keyword\">void</span></div></pre></td></tr></table></figure>\n<p><strong>删除deque中除首位元素之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。</strong></p>\n<h2 id=\"pop-front和pop-back成员函数\"><a href=\"#pop-front和pop-back成员函数\" class=\"headerlink\" title=\"pop_front和pop_back成员函数\"></a>pop_front和pop_back成员函数</h2><p>pop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似的，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。</p>\n<p>这些操作返回void，如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(!ilist.empty())&#123;</div><div class=\"line\">　　process(ilist.front());  <span class=\"comment\">//对ilist的首元素进行一些处理</span></div><div class=\"line\">　　ilist.pop_front();　　<span class=\"comment\">//完成处理后删除首元素</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"从容器内部删除一个元素\"><a href=\"#从容器内部删除一个元素\" class=\"headerlink\" title=\"从容器内部删除一个元素\"></a>从容器内部删除一个元素</h2><p>成员函数erase从容器中指定位置删除元素，我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。<strong>两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。</strong></p>\n<p>例如，下面的循环删除一个list中的所有奇数元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; lst=(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">auto</span> it=lst.begin();</div><div class=\"line\"><span class=\"keyword\">while</span>(it!=lst.end())</div><div class=\"line\">　　<span class=\"keyword\">if</span>(*it%<span class=\"number\">2</span>)</div><div class=\"line\">　　　　it=lst.erase(it);  <span class=\"comment\">//删除此元素</span></div><div class=\"line\">　　<span class=\"keyword\">else</span></div><div class=\"line\">　　　　++it;</div></pre></td></tr></table></figure>\n<p>每个循环步中，首先检查当前元素是否是奇数，如果是，就删除该元素，并将it设置为我们所删除的元素之后的元素。如果*it为偶数，我们将it递增，从而在下一步循环检查下一个元素。</p>\n<h2 id=\"删除多个元素\"><a href=\"#删除多个元素\" class=\"headerlink\" title=\"删除多个元素\"></a>删除多个元素</h2><p>接受一对迭代器的erase版本允许我们删除一个范围内的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//删除两个迭代器表示的范围内的元素</span></div><div class=\"line\"><span class=\"comment\">//返回指向最后一个被删除元素之后位置的迭代器</span></div><div class=\"line\">elem1=slist.erase(elem1,elem2);  <span class=\"comment\">//调用后，elem1==elem2</span></div></pre></td></tr></table></figure>\n<p><strong>迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置</strong>。</p>\n<p>为了删除一个容器中的所有元素，我们既可以调用clear，也可以用begin和end获得的迭代器作为参数调用erase：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">slist.clear() ;<span class=\"comment\">//删除容器中的所有元素</span></div><div class=\"line\">slist.erase(slist.begin(),slist.end());   <span class=\"comment\">//等价调用</span></div></pre></td></tr></table></figure>"},{"title":"样先","date":"2017-08-12T11:59:25.000Z","update":null,"comments":1,"_content":"　　仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）\n<!-- more -->\n新日左右：\n\n　　余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。\n\n　　予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。\n\n　　大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。\n\n　　新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！\n\n　　样先\n\n <p align=\"right\">2015.2.18</p> \n\n　　真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！\n\n<div id=\"music163player\">\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=68450&auto=0&height=66\"></iframe>\n</div>                                                                                       ","source":"_posts/样先.md","raw":"---\ntitle: 样先\ndate: 2017-08-12 19:59:25\nupdate:\ntags: [兄弟,朋友]\ncategories: 兄弟\ncomments: true\n---\n　　仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）\n<!-- more -->\n新日左右：\n\n　　余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。\n\n　　予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。\n\n　　大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。\n\n　　新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！\n\n　　样先\n\n <p align=\"right\">2015.2.18</p> \n\n　　真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！\n\n<div id=\"music163player\">\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=68450&auto=0&height=66\"></iframe>\n</div>                                                                                       ","slug":"样先","published":1,"updated":"2017-12-07T07:59:00.086Z","layout":"post","photos":[],"link":"","_id":"cjcj3yip5001gjgc9dfbhd5jg","content":"<p>　　仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）<br><a id=\"more\"></a><br>新日左右：</p>\n<p>　　余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。</p>\n<p>　　予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。</p>\n<p>　　大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。</p>\n<p>　　新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！</p>\n<p>　　样先</p>\n <p align=\"right\">2015.2.18</p> \n\n<p>　　真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！</p>\n<div id=\"music163player\"><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=68450&auto=0&height=66\"></iframe><br></div>                                                                                       ","site":{"data":{}},"excerpt":"<p>　　仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）<br>","more":"<br>新日左右：</p>\n<p>　　余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。</p>\n<p>　　予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。</p>\n<p>　　大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。</p>\n<p>　　新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！</p>\n<p>　　样先</p>\n <p align=\"right\">2015.2.18</p> \n\n<p>　　真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！</p>\n<div id=\"music163player\"><br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=68450&auto=0&height=66\"></iframe><br></div>"},{"title":"数组&指针&string","date":"2017-10-14T04:59:25.000Z","update":null,"comments":1,"_content":"# 一、前言\n\n介绍使用数组的基本方法，同时介绍C++中string的初始化和一些常用函数。\n\n<!--more-->\n\n# 数组\n\n数组与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是相对地也损失了一些灵活性。\n\n**note：** 如果不清楚元素的确切个数，请使用vector。\n\n## 定义和初始化内置数组\n\n数组是一种复合类型，数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，**维度必须是一个常量表达式**。\n\n```C++\nunsigned cnt = 42;        //不是常量表达式\nconstexpr unsigned sz = 42;       //常量表达式\nint arr[10];           //含有10个整型的数组\nint *parr[sz];          //含有42个整型指针的数组\nstring bad[cnt];         //错误：cnt不是常量表达式\nstring strs[get_size()];     //当gett_size是constexpr时正确；否则错误\n```\n默认情况下，数组的元素被默认初始化。另外数组的元素应为对象，因此不存在引用的数组。\n\n## 显式初始化数组元素\n\n可以对数组的元素进行列表初始化，此时允许忽略数组的纬度。\n\n```C++\nconst unsigned sz = 3;\nint ial[sz] = {0,1,2};      //含有三个元素的数组，元素值分别是０１２\nint a2[] = {0 ,1 , 2};      //维度是３的数组\nint a3[5] = {0,1,2};        // 等价于{0,1,2,0,0}\nstring a4[3] = {“hi” , “bye”};  //{“hi”,”bye” ,”“}\nint a5[2] = {0,1,2}         //错误，　初始值太多\n```\n\n## 字符数组的特殊性（用字符串字面值对数组进行初始化）\n\n字符数组可以用字符串字面值初始化，但是特殊的是结束符（'\\0'）也会被拷贝进去\n```C++\nchar a1[] = {‘C’,’+’ ,’+’};       //列表初始化没有空字符\nchar a2[] = {‘C’,’+’,‘+’,’\\0’};    //列表初始化，含有显示的空字符\nchar a3[] = “C++”;                 //自动添加表示字符串结束的空字符\nconst char a4[6] =”Daniel”;      //错了，没有空间可以存放空字符\n```\na4数组的大小必须至少是7。\n\n## 数组不允许拷贝和赋值\n\n不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：\n\n```C++\nint a[] = {0,1,2};\nint a2[] = a;         //错误：不允许使用一个数组初始化另一个数组\na2 = a;               //错误：不能把一个数组直接赋值给另一个数组\n```\n\n## 理解复杂的数组声明\n\n可以定义一个存放指针的数组。又因为数组本身是对象，所以允许定义数组的指针（指向数组的指针）及数组的引用（对数组的引用）。\n\n```C++\n//[]的优先级比*高\nint *ptrs[10];                  //ptrs是含有10个整型指针的数组\nint (*Parray)[10] = &arr;       //Parray指向一个含有10个整数的数组\nint (&arrRef)[10] = arr;        //arrRef引用一个含有10个整数的数组\n```\n\n**默认情况下，类型修饰符从右向左一次绑定，** 对于ptrs来说，首先知道我们定义了一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。\n\n**要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。**\n\nParray的含义：首先*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。最终，Parray是一个指针，它指向一个int数组，数组中包含10个元素。\n\n当然，对修饰符的数量并没有特殊限制：\n\n```C++\nint *(&array)[10] = ptrs;     //array是数组的引用，该数组含有10个指针\n```\n\n## 访问数组元素\n\n数组的元素也能使用范围for语句或下标运算符来访问。\n\n当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。\n\n```C++\nfor(auto i : scores) {\n    cout<<i<<\" \";\n}\n```\n\n##  指针和数组\n\n在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。\n\n```C++\nstring nums[] = {\"one\",\"two\",\"three\"};          //数组的元素是string对象\nstring *p = &nums[0];                           //p指向nums的第一个元素\n```\n\n数组的一个特性：**在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。**\n\n```C++\nstring *p = nums;       //等价于p2=&nums[0];\n```\n\n## auto 和 decltype\n\n```C++\nint ia[] = {0,1,2,3,4,5};\nauto ia2(ia);       //ia2是一个整型指针，指向ia的第一个元素\n\ndecltype(ia) ia3 = {3,4,5,6,7,8};     //ia3类型是由10个整数构成的数组，并对该数组进行赋值\n```\n\n## 指针也是迭代器\n\n```C++\nint arr[] = {0,1,2,3,4,5,6,7,8,9};\nint *p = arr;            //p指向arr的第一个元素\n++p;\n```\n\n遍历数组元素，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：\n\n```C++\nint *e = &arr[10];       //指向尾元素的下一位置的指针\nfor(int *b = arr; b!=e; ++b){\n    cout<<*b<<end;       //输出arr的元素\n}\n```\n\n**note:** 尽管能计算得到尾后指针，但是这种用法极易出错，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似。\n\n\n**begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针**，这两个函数定义在**iterator**头文件中。\n\n正确的使用形式：\n```C++\nint ia[] = {1,2,3,4,5};\nint *beg = begin(ia);    //指向ia首元素的指针\nint *last = end(ia);     //指向arr尾元素的下一位置的指针\nfor(beg;beg!=last;++beg){\n    cout<<*beg<<\" \";\n}\n```\n\n**note:** 一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end()函数返回的与迭代器类似的功能。特别要注意，**尾后指针不能执行解引用和递增操作**。\n\n\n### 下标和指针\n\n```C++\nint ia[] = {0,2,4,6,8};    //含有5个整数的数组\nint i = ia[2];        //ia[2]得到(ia+2)所指的元素，即*(ia+2)\nint *p = ia;\ni = *(p+2);         //等价于i = ia[2];\n只要指针指向的是数组中的元素(或者数组中尾元素的下一位置，此时下标需要为负值)，都可以执行下标运算。\nint *p = &ia[2];      //p指向索引为2的元素\nint j = p[1];         //j = ia[3]\nint k = p[-2];        //k = ia[0]\n```\n\n**注意：** 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。\n\n\n## C风格字符串\n\nC风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以**空字符结束**（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（'\\0'）。\n\n**C风格字符字符串函数**\n\n```C++\n\\\\p,p1,p2都是字符数组的形式，在string.h头文件中\nstrlen(p)         返回p的长度，空字符不计算在内\nstrcmp(p1,p2)     比较p1和p2的相等。如果p1==p2，返回0；如果p1>p2,返回一个正值；如果p1<p2，返回一个负值\nstrcat(p1,p2)     将p2附加到p1之后，返回p1\nstrcpy(p1,p2)     将p2拷贝给p1,返回p1\n```\n\n对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。\n\n\n## 与旧代码的接口\n\n现代的C++ 程序不得不与那些充满了数组或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。\n\n## 混用string对象和C风格字符串\n\n允许使用字符串字面值来初始化对象：\n\n```C++\nstring s(\"Hello world\");      //s的内容是Hello world\n```\n\n更一般的情况，**任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代**：\n\n- 允许使用空字符结束的字符数组来初始化string对象或为string对象赋值。\n- 在string对象的加法运算过程中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中匀速使用以空字符串结束的字符数组作为右侧的运算对象。\n\n\n上述性质反过来就不成立，比如不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为**c_str的成员函数**。\n\n```C++\nstring s = \"wangxinri\";\nchar *p = s ;      //错误，不能用string对象直接初始化指向字符的指针\nconst char *str = s.c_str();      //正确\n```\n\n我们无法保证c_str()返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效果。因此使用最好将c_str()返回的数组拷贝一份。\n\n## 使用数组初始化vector对象\n\n不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象\n\n```C++\nint int_arr[] = {0,1,2,3,4,5};\nvector<int> ivec(begin(int_arr),end(int_arr));\n\n//拷贝三个元素：int_arr[1],int_arr[2],int_arr[3]\nvector<int> subVec(int_arr+1,int_arr4);\n```\n\n**注意：** 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。\n\n\n## 多维数组（待补充）\n\n# string\n\nstring表示可变长的字符序列，使用string类型必须首先包含string头文件。\n\n## 初始化string对象的方式\n\n```C++\nstring s1             默认初始化，s1是一个空串\nstring s2(s1)         s2是s1的副本\nstring s2 = s1        等价于s2(s1)，s2是s1的副本\nstring s3(\"value\")    s3是字面值\"value\"的副本，除了字面值最后的那个空字符外\nstring s3 = \"value\"   等价于s3(\"value\")，s3是字面值\"value\"的副本\nstring s4(n, 'c')     把s4初始化为由连续n个字符c组成的串\n```\n## string对象上的操作\n\n```C++\nos<<s \t将s写到输出流os当中，返回os\nis>>s \t从is中读取字符串赋给s，字符串以空白分隔，返回is\ngetline(is, s) \t从is中读取一行赋给s，返回is\ns.empty() \ts为空赋返回true，否则返回false\ns.size() \t返回s中的字符的个数\ns[n] \t返回s中第n个字符的引用，位置n从0计起\ns1+s2 \t返回s1和s2连接后的结果\ns1=s2 \t用s2的副本代替s1中原来的字符\ns1==s2 \t如果s1和s2中所含的字符完全一样，则它们相等，返回true\ns1!=s2 \t如果s1和s2中所含的字符不一样，返回true\n<, <=, >, >= \t利用字符在字典中的顺序进行比较，且对字母的大小写敏感\n```\n## 代码示例\n\n```C++\n#include<iostream>\nusing namespace std;\nint main() {\n    string str;\n    while(cin>>str){   \n        cout<<str<<endl;\n    }\n    return 0;\n}\n\n#include<iostream>\nusing namespace std;\nint main() {\n    string line;\n    while(getline(cin,line)){   \n        cout<<line<<endl;\n    }\n    return 0;\n}\n```\n\n## 处理string对象中的字符\n\n对字符处理的一些方法，在**cctype**头文件中定义了一组标准库函数处理这部分工作\n```C++\nisalnmu(c) \t当c是字母或数字为真\nisalpha(c) \t当c是字母为真\niscntrl(c) \t当c是控字符时为真\nisdigit(c) \t当c是数字为真\nisgraph(c) \t当c不是空格但可打印为真\nislower(c) \t当c是小写字母为真\nisprint(c) \t当c是可打印字符为真(即c是空格或c具有可视形式)\nispunct(c) \t当c是标点符号为真(即c不是控字符、数字、字母、可打印空白中的一种)\nisspace(c) \t当c是空白为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进制符中一种)\nissupper(c) \t当c是大写字母为真\nisxdigit(c) \t当c是十六进制数字为真\ntolower(c) \t若c是大写字母，输出对应小写字母；否则原样输出c\ntoupper(c) \t若c是小写字母，输出对应大写字母；否则原样输出c\n```\n\n## 处理string每个字符，使用基于范围的for语句\n\n```C++\n// 用范围for语句和ispunct函数统计string对象中标点符号的个数（使用范围for语句遍历给定序列的每个元素）\n#include <iostream>\n#include <string>\nusing namespace std;\nint main()\n{\nstring s(\"Hello World!!!\");\ndecltype(s.size()) punct_cnt = 0;            //punct_cnt的类型同s.size()，即为string :: size_type\nfor (auto c : s)            // 对于s中的每个字符\n      if (ispunct(c))       // 如果该字符是标点符号\n           ++ispunct_cnt;  // 计数\ncout << punct_cnt << \" punctuation characters in \" << s << endl;\nreturn 0;\n}\n\n// 用范围for语句将字符串改写为大写字母的形式（使用范围for语句改变字符串中的字符）\n#include <iostream>\n#include <string>\nusing namespace std;\nint main()\n{\nstring s (\"Hello World!!!\")\n// 转换成大写形式\nfor (auto &c : s)          // 对于s中的每个字符(c是引用)\n      c = toupper(c);     // c是一个引用，赋值语句改变了c绑定的字符的值，标准库函数toupper将小写的参数c改为大写\ncout << s << endl;\nreturn 0;\n} \n\n```\n\n## 只处理string一部分字符\n\n要想访问string对象总的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。\n\n**注意：检查下标的合法性**\n\n一种简便易行的方法是：总是设下标的类型为**string::size_type**，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。\n\n```C++\nconst string s = \"keep out\";\nfor(auto &c :s){    //C的类型是常量引用，不能通过C修改其绑定的对象\n    cout<<c<<endl;\n}\n```\n\n\n\n\n","source":"_posts/数组&指针&string.md","raw":"---\ntitle: 数组&指针&string\ndate: 2017-10-14 12:59:25\nupdate:\ntags: [数组,指针]\ncategories: C++\ncomments: true\n---\n# 一、前言\n\n介绍使用数组的基本方法，同时介绍C++中string的初始化和一些常用函数。\n\n<!--more-->\n\n# 数组\n\n数组与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是相对地也损失了一些灵活性。\n\n**note：** 如果不清楚元素的确切个数，请使用vector。\n\n## 定义和初始化内置数组\n\n数组是一种复合类型，数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，**维度必须是一个常量表达式**。\n\n```C++\nunsigned cnt = 42;        //不是常量表达式\nconstexpr unsigned sz = 42;       //常量表达式\nint arr[10];           //含有10个整型的数组\nint *parr[sz];          //含有42个整型指针的数组\nstring bad[cnt];         //错误：cnt不是常量表达式\nstring strs[get_size()];     //当gett_size是constexpr时正确；否则错误\n```\n默认情况下，数组的元素被默认初始化。另外数组的元素应为对象，因此不存在引用的数组。\n\n## 显式初始化数组元素\n\n可以对数组的元素进行列表初始化，此时允许忽略数组的纬度。\n\n```C++\nconst unsigned sz = 3;\nint ial[sz] = {0,1,2};      //含有三个元素的数组，元素值分别是０１２\nint a2[] = {0 ,1 , 2};      //维度是３的数组\nint a3[5] = {0,1,2};        // 等价于{0,1,2,0,0}\nstring a4[3] = {“hi” , “bye”};  //{“hi”,”bye” ,”“}\nint a5[2] = {0,1,2}         //错误，　初始值太多\n```\n\n## 字符数组的特殊性（用字符串字面值对数组进行初始化）\n\n字符数组可以用字符串字面值初始化，但是特殊的是结束符（'\\0'）也会被拷贝进去\n```C++\nchar a1[] = {‘C’,’+’ ,’+’};       //列表初始化没有空字符\nchar a2[] = {‘C’,’+’,‘+’,’\\0’};    //列表初始化，含有显示的空字符\nchar a3[] = “C++”;                 //自动添加表示字符串结束的空字符\nconst char a4[6] =”Daniel”;      //错了，没有空间可以存放空字符\n```\na4数组的大小必须至少是7。\n\n## 数组不允许拷贝和赋值\n\n不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：\n\n```C++\nint a[] = {0,1,2};\nint a2[] = a;         //错误：不允许使用一个数组初始化另一个数组\na2 = a;               //错误：不能把一个数组直接赋值给另一个数组\n```\n\n## 理解复杂的数组声明\n\n可以定义一个存放指针的数组。又因为数组本身是对象，所以允许定义数组的指针（指向数组的指针）及数组的引用（对数组的引用）。\n\n```C++\n//[]的优先级比*高\nint *ptrs[10];                  //ptrs是含有10个整型指针的数组\nint (*Parray)[10] = &arr;       //Parray指向一个含有10个整数的数组\nint (&arrRef)[10] = arr;        //arrRef引用一个含有10个整数的数组\n```\n\n**默认情况下，类型修饰符从右向左一次绑定，** 对于ptrs来说，首先知道我们定义了一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。\n\n**要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。**\n\nParray的含义：首先*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。最终，Parray是一个指针，它指向一个int数组，数组中包含10个元素。\n\n当然，对修饰符的数量并没有特殊限制：\n\n```C++\nint *(&array)[10] = ptrs;     //array是数组的引用，该数组含有10个指针\n```\n\n## 访问数组元素\n\n数组的元素也能使用范围for语句或下标运算符来访问。\n\n当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。\n\n```C++\nfor(auto i : scores) {\n    cout<<i<<\" \";\n}\n```\n\n##  指针和数组\n\n在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。\n\n```C++\nstring nums[] = {\"one\",\"two\",\"three\"};          //数组的元素是string对象\nstring *p = &nums[0];                           //p指向nums的第一个元素\n```\n\n数组的一个特性：**在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。**\n\n```C++\nstring *p = nums;       //等价于p2=&nums[0];\n```\n\n## auto 和 decltype\n\n```C++\nint ia[] = {0,1,2,3,4,5};\nauto ia2(ia);       //ia2是一个整型指针，指向ia的第一个元素\n\ndecltype(ia) ia3 = {3,4,5,6,7,8};     //ia3类型是由10个整数构成的数组，并对该数组进行赋值\n```\n\n## 指针也是迭代器\n\n```C++\nint arr[] = {0,1,2,3,4,5,6,7,8,9};\nint *p = arr;            //p指向arr的第一个元素\n++p;\n```\n\n遍历数组元素，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：\n\n```C++\nint *e = &arr[10];       //指向尾元素的下一位置的指针\nfor(int *b = arr; b!=e; ++b){\n    cout<<*b<<end;       //输出arr的元素\n}\n```\n\n**note:** 尽管能计算得到尾后指针，但是这种用法极易出错，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似。\n\n\n**begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针**，这两个函数定义在**iterator**头文件中。\n\n正确的使用形式：\n```C++\nint ia[] = {1,2,3,4,5};\nint *beg = begin(ia);    //指向ia首元素的指针\nint *last = end(ia);     //指向arr尾元素的下一位置的指针\nfor(beg;beg!=last;++beg){\n    cout<<*beg<<\" \";\n}\n```\n\n**note:** 一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end()函数返回的与迭代器类似的功能。特别要注意，**尾后指针不能执行解引用和递增操作**。\n\n\n### 下标和指针\n\n```C++\nint ia[] = {0,2,4,6,8};    //含有5个整数的数组\nint i = ia[2];        //ia[2]得到(ia+2)所指的元素，即*(ia+2)\nint *p = ia;\ni = *(p+2);         //等价于i = ia[2];\n只要指针指向的是数组中的元素(或者数组中尾元素的下一位置，此时下标需要为负值)，都可以执行下标运算。\nint *p = &ia[2];      //p指向索引为2的元素\nint j = p[1];         //j = ia[3]\nint k = p[-2];        //k = ia[0]\n```\n\n**注意：** 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。\n\n\n## C风格字符串\n\nC风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以**空字符结束**（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（'\\0'）。\n\n**C风格字符字符串函数**\n\n```C++\n\\\\p,p1,p2都是字符数组的形式，在string.h头文件中\nstrlen(p)         返回p的长度，空字符不计算在内\nstrcmp(p1,p2)     比较p1和p2的相等。如果p1==p2，返回0；如果p1>p2,返回一个正值；如果p1<p2，返回一个负值\nstrcat(p1,p2)     将p2附加到p1之后，返回p1\nstrcpy(p1,p2)     将p2拷贝给p1,返回p1\n```\n\n对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。\n\n\n## 与旧代码的接口\n\n现代的C++ 程序不得不与那些充满了数组或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。\n\n## 混用string对象和C风格字符串\n\n允许使用字符串字面值来初始化对象：\n\n```C++\nstring s(\"Hello world\");      //s的内容是Hello world\n```\n\n更一般的情况，**任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代**：\n\n- 允许使用空字符结束的字符数组来初始化string对象或为string对象赋值。\n- 在string对象的加法运算过程中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中匀速使用以空字符串结束的字符数组作为右侧的运算对象。\n\n\n上述性质反过来就不成立，比如不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为**c_str的成员函数**。\n\n```C++\nstring s = \"wangxinri\";\nchar *p = s ;      //错误，不能用string对象直接初始化指向字符的指针\nconst char *str = s.c_str();      //正确\n```\n\n我们无法保证c_str()返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效果。因此使用最好将c_str()返回的数组拷贝一份。\n\n## 使用数组初始化vector对象\n\n不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象\n\n```C++\nint int_arr[] = {0,1,2,3,4,5};\nvector<int> ivec(begin(int_arr),end(int_arr));\n\n//拷贝三个元素：int_arr[1],int_arr[2],int_arr[3]\nvector<int> subVec(int_arr+1,int_arr4);\n```\n\n**注意：** 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。\n\n\n## 多维数组（待补充）\n\n# string\n\nstring表示可变长的字符序列，使用string类型必须首先包含string头文件。\n\n## 初始化string对象的方式\n\n```C++\nstring s1             默认初始化，s1是一个空串\nstring s2(s1)         s2是s1的副本\nstring s2 = s1        等价于s2(s1)，s2是s1的副本\nstring s3(\"value\")    s3是字面值\"value\"的副本，除了字面值最后的那个空字符外\nstring s3 = \"value\"   等价于s3(\"value\")，s3是字面值\"value\"的副本\nstring s4(n, 'c')     把s4初始化为由连续n个字符c组成的串\n```\n## string对象上的操作\n\n```C++\nos<<s \t将s写到输出流os当中，返回os\nis>>s \t从is中读取字符串赋给s，字符串以空白分隔，返回is\ngetline(is, s) \t从is中读取一行赋给s，返回is\ns.empty() \ts为空赋返回true，否则返回false\ns.size() \t返回s中的字符的个数\ns[n] \t返回s中第n个字符的引用，位置n从0计起\ns1+s2 \t返回s1和s2连接后的结果\ns1=s2 \t用s2的副本代替s1中原来的字符\ns1==s2 \t如果s1和s2中所含的字符完全一样，则它们相等，返回true\ns1!=s2 \t如果s1和s2中所含的字符不一样，返回true\n<, <=, >, >= \t利用字符在字典中的顺序进行比较，且对字母的大小写敏感\n```\n## 代码示例\n\n```C++\n#include<iostream>\nusing namespace std;\nint main() {\n    string str;\n    while(cin>>str){   \n        cout<<str<<endl;\n    }\n    return 0;\n}\n\n#include<iostream>\nusing namespace std;\nint main() {\n    string line;\n    while(getline(cin,line)){   \n        cout<<line<<endl;\n    }\n    return 0;\n}\n```\n\n## 处理string对象中的字符\n\n对字符处理的一些方法，在**cctype**头文件中定义了一组标准库函数处理这部分工作\n```C++\nisalnmu(c) \t当c是字母或数字为真\nisalpha(c) \t当c是字母为真\niscntrl(c) \t当c是控字符时为真\nisdigit(c) \t当c是数字为真\nisgraph(c) \t当c不是空格但可打印为真\nislower(c) \t当c是小写字母为真\nisprint(c) \t当c是可打印字符为真(即c是空格或c具有可视形式)\nispunct(c) \t当c是标点符号为真(即c不是控字符、数字、字母、可打印空白中的一种)\nisspace(c) \t当c是空白为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进制符中一种)\nissupper(c) \t当c是大写字母为真\nisxdigit(c) \t当c是十六进制数字为真\ntolower(c) \t若c是大写字母，输出对应小写字母；否则原样输出c\ntoupper(c) \t若c是小写字母，输出对应大写字母；否则原样输出c\n```\n\n## 处理string每个字符，使用基于范围的for语句\n\n```C++\n// 用范围for语句和ispunct函数统计string对象中标点符号的个数（使用范围for语句遍历给定序列的每个元素）\n#include <iostream>\n#include <string>\nusing namespace std;\nint main()\n{\nstring s(\"Hello World!!!\");\ndecltype(s.size()) punct_cnt = 0;            //punct_cnt的类型同s.size()，即为string :: size_type\nfor (auto c : s)            // 对于s中的每个字符\n      if (ispunct(c))       // 如果该字符是标点符号\n           ++ispunct_cnt;  // 计数\ncout << punct_cnt << \" punctuation characters in \" << s << endl;\nreturn 0;\n}\n\n// 用范围for语句将字符串改写为大写字母的形式（使用范围for语句改变字符串中的字符）\n#include <iostream>\n#include <string>\nusing namespace std;\nint main()\n{\nstring s (\"Hello World!!!\")\n// 转换成大写形式\nfor (auto &c : s)          // 对于s中的每个字符(c是引用)\n      c = toupper(c);     // c是一个引用，赋值语句改变了c绑定的字符的值，标准库函数toupper将小写的参数c改为大写\ncout << s << endl;\nreturn 0;\n} \n\n```\n\n## 只处理string一部分字符\n\n要想访问string对象总的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。\n\n**注意：检查下标的合法性**\n\n一种简便易行的方法是：总是设下标的类型为**string::size_type**，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。\n\n```C++\nconst string s = \"keep out\";\nfor(auto &c :s){    //C的类型是常量引用，不能通过C修改其绑定的对象\n    cout<<c<<endl;\n}\n```\n\n\n\n\n","slug":"数组&指针&string","published":1,"updated":"2018-01-16T12:43:02.720Z","layout":"post","photos":[],"link":"","_id":"cjcj3yip8001jjgc9zx3kj0ut","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍使用数组的基本方法，同时介绍C++中string的初始化和一些常用函数。</p>\n<a id=\"more\"></a>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>数组与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是相对地也损失了一些灵活性。</p>\n<p><strong>note：</strong> 如果不清楚元素的确切个数，请使用vector。</p>\n<h2 id=\"定义和初始化内置数组\"><a href=\"#定义和初始化内置数组\" class=\"headerlink\" title=\"定义和初始化内置数组\"></a>定义和初始化内置数组</h2><p>数组是一种复合类型，数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，<strong>维度必须是一个常量表达式</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">unsigned</span> cnt = <span class=\"number\">42</span>;        <span class=\"comment\">//不是常量表达式</span></div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">unsigned</span> sz = <span class=\"number\">42</span>;       <span class=\"comment\">//常量表达式</span></div><div class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];           <span class=\"comment\">//含有10个整型的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> *parr[sz];          <span class=\"comment\">//含有42个整型指针的数组</span></div><div class=\"line\"><span class=\"built_in\">string</span> bad[cnt];         <span class=\"comment\">//错误：cnt不是常量表达式</span></div><div class=\"line\"><span class=\"built_in\">string</span> strs[get_size()];     <span class=\"comment\">//当gett_size是constexpr时正确；否则错误</span></div></pre></td></tr></table></figure>\n<p>默认情况下，数组的元素被默认初始化。另外数组的元素应为对象，因此不存在引用的数组。</p>\n<h2 id=\"显式初始化数组元素\"><a href=\"#显式初始化数组元素\" class=\"headerlink\" title=\"显式初始化数组元素\"></a>显式初始化数组元素</h2><p>可以对数组的元素进行列表初始化，此时允许忽略数组的纬度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> sz = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> ial[sz] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;      <span class=\"comment\">//含有三个元素的数组，元素值分别是０１２</span></div><div class=\"line\"><span class=\"keyword\">int</span> a2[] = &#123;<span class=\"number\">0</span> ,<span class=\"number\">1</span> , <span class=\"number\">2</span>&#125;;      <span class=\"comment\">//维度是３的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> a3[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;        <span class=\"comment\">// 等价于&#123;0,1,2,0,0&#125;</span></div><div class=\"line\"><span class=\"built_in\">string</span> a4[<span class=\"number\">3</span>] = &#123;“hi” , “bye”&#125;;  <span class=\"comment\">//&#123;“hi”,”bye” ,”“&#125;</span></div><div class=\"line\"><span class=\"keyword\">int</span> a5[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;         <span class=\"comment\">//错误，　初始值太多</span></div></pre></td></tr></table></figure>\n<h2 id=\"字符数组的特殊性（用字符串字面值对数组进行初始化）\"><a href=\"#字符数组的特殊性（用字符串字面值对数组进行初始化）\" class=\"headerlink\" title=\"字符数组的特殊性（用字符串字面值对数组进行初始化）\"></a>字符数组的特殊性（用字符串字面值对数组进行初始化）</h2><p>字符数组可以用字符串字面值初始化，但是特殊的是结束符（’\\0’）也会被拷贝进去<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> a1[] = &#123;‘C’,’+’ ,’+’&#125;;       <span class=\"comment\">//列表初始化没有空字符</span></div><div class=\"line\"><span class=\"keyword\">char</span> a2[] = &#123;‘C’,’+’,‘+’,’\\<span class=\"number\">0</span>’&#125;;    <span class=\"comment\">//列表初始化，含有显示的空字符</span></div><div class=\"line\"><span class=\"keyword\">char</span> a3[] = “C++”;                 <span class=\"comment\">//自动添加表示字符串结束的空字符</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> a4[<span class=\"number\">6</span>] =”Daniel”;      <span class=\"comment\">//错了，没有空间可以存放空字符</span></div></pre></td></tr></table></figure></p>\n<p>a4数组的大小必须至少是7。</p>\n<h2 id=\"数组不允许拷贝和赋值\"><a href=\"#数组不允许拷贝和赋值\" class=\"headerlink\" title=\"数组不允许拷贝和赋值\"></a>数组不允许拷贝和赋值</h2><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> a2[] = a;         <span class=\"comment\">//错误：不允许使用一个数组初始化另一个数组</span></div><div class=\"line\">a2 = a;               <span class=\"comment\">//错误：不能把一个数组直接赋值给另一个数组</span></div></pre></td></tr></table></figure>\n<h2 id=\"理解复杂的数组声明\"><a href=\"#理解复杂的数组声明\" class=\"headerlink\" title=\"理解复杂的数组声明\"></a>理解复杂的数组声明</h2><p>可以定义一个存放指针的数组。又因为数组本身是对象，所以允许定义数组的指针（指向数组的指针）及数组的引用（对数组的引用）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//[]的优先级比*高</span></div><div class=\"line\"><span class=\"keyword\">int</span> *ptrs[<span class=\"number\">10</span>];                  <span class=\"comment\">//ptrs是含有10个整型指针的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> (*Parray)[<span class=\"number\">10</span>] = &amp;arr;       <span class=\"comment\">//Parray指向一个含有10个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> (&amp;arrRef)[<span class=\"number\">10</span>] = arr;        <span class=\"comment\">//arrRef引用一个含有10个整数的数组</span></div></pre></td></tr></table></figure>\n<p><strong>默认情况下，类型修饰符从右向左一次绑定，</strong> 对于ptrs来说，首先知道我们定义了一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。</p>\n<p><strong>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</strong></p>\n<p>Parray的含义：首先*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。最终，Parray是一个指针，它指向一个int数组，数组中包含10个元素。</p>\n<p>当然，对修饰符的数量并没有特殊限制：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *(&amp;<span class=\"built_in\">array</span>)[<span class=\"number\">10</span>] = ptrs;     <span class=\"comment\">//array是数组的引用，该数组含有10个指针</span></div></pre></td></tr></table></figure>\n<h2 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h2><p>数组的元素也能使用范围for语句或下标运算符来访问。</p>\n<p>当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i : scores) &#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h2><p>在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> nums[] = &#123;<span class=\"string\">\"one\"</span>,<span class=\"string\">\"two\"</span>,<span class=\"string\">\"three\"</span>&#125;;          <span class=\"comment\">//数组的元素是string对象</span></div><div class=\"line\"><span class=\"built_in\">string</span> *p = &amp;nums[<span class=\"number\">0</span>];                           <span class=\"comment\">//p指向nums的第一个元素</span></div></pre></td></tr></table></figure>\n<p>数组的一个特性：<strong>在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> *p = nums;       <span class=\"comment\">//等价于p2=&amp;nums[0];</span></div></pre></td></tr></table></figure>\n<h2 id=\"auto-和-decltype\"><a href=\"#auto-和-decltype\" class=\"headerlink\" title=\"auto 和 decltype\"></a>auto 和 decltype</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">ia2</span><span class=\"params\">(ia)</span></span>;       <span class=\"comment\">//ia2是一个整型指针，指向ia的第一个元素</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">decltype</span>(ia) ia3 = &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;;     <span class=\"comment\">//ia3类型是由10个整数构成的数组，并对该数组进行赋值</span></div></pre></td></tr></table></figure>\n<h2 id=\"指针也是迭代器\"><a href=\"#指针也是迭代器\" class=\"headerlink\" title=\"指针也是迭代器\"></a>指针也是迭代器</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> *p = arr;            <span class=\"comment\">//p指向arr的第一个元素</span></div><div class=\"line\">++p;</div></pre></td></tr></table></figure>\n<p>遍历数组元素，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *e = &amp;arr[<span class=\"number\">10</span>];       <span class=\"comment\">//指向尾元素的下一位置的指针</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> *b = arr; b!=e; ++b)&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*b&lt;&lt;end;       <span class=\"comment\">//输出arr的元素</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>note:</strong> 尽管能计算得到尾后指针，但是这种用法极易出错，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似。</p>\n<p><strong>begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针</strong>，这两个函数定义在<strong>iterator</strong>头文件中。</p>\n<p>正确的使用形式：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> *beg = begin(ia);    <span class=\"comment\">//指向ia首元素的指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> *last = end(ia);     <span class=\"comment\">//指向arr尾元素的下一位置的指针</span></div><div class=\"line\"><span class=\"keyword\">for</span>(beg;beg!=last;++beg)&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*beg&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>note:</strong> 一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end()函数返回的与迭代器类似的功能。特别要注意，<strong>尾后指针不能执行解引用和递增操作</strong>。</p>\n<h3 id=\"下标和指针\"><a href=\"#下标和指针\" class=\"headerlink\" title=\"下标和指针\"></a>下标和指针</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>&#125;;    <span class=\"comment\">//含有5个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> i = ia[<span class=\"number\">2</span>];        <span class=\"comment\">//ia[2]得到(ia+2)所指的元素，即*(ia+2)</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p = ia;</div><div class=\"line\">i = *(p+<span class=\"number\">2</span>);         <span class=\"comment\">//等价于i = ia[2];</span></div><div class=\"line\">只要指针指向的是数组中的元素(或者数组中尾元素的下一位置，此时下标需要为负值)，都可以执行下标运算。</div><div class=\"line\"><span class=\"keyword\">int</span> *p = &amp;ia[<span class=\"number\">2</span>];      <span class=\"comment\">//p指向索引为2的元素</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = p[<span class=\"number\">1</span>];         <span class=\"comment\">//j = ia[3]</span></div><div class=\"line\"><span class=\"keyword\">int</span> k = p[<span class=\"number\">-2</span>];        <span class=\"comment\">//k = ia[0]</span></div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p>\n<h2 id=\"C风格字符串\"><a href=\"#C风格字符串\" class=\"headerlink\" title=\"C风格字符串\"></a>C风格字符串</h2><p>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以<strong>空字符结束</strong>（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\\0’）。</p>\n<p><strong>C风格字符字符串函数</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\\\p,p1,p2都是字符数组的形式，在<span class=\"built_in\">string</span>.h头文件中</div><div class=\"line\"><span class=\"built_in\">strlen</span>(p)         返回p的长度，空字符不计算在内</div><div class=\"line\"><span class=\"built_in\">strcmp</span>(p1,p2)     比较p1和p2的相等。如果p1==p2，返回<span class=\"number\">0</span>；如果p1&gt;p2,返回一个正值；如果p1&lt;p2，返回一个负值</div><div class=\"line\"><span class=\"built_in\">strcat</span>(p1,p2)     将p2附加到p1之后，返回p1</div><div class=\"line\"><span class=\"built_in\">strcpy</span>(p1,p2)     将p2拷贝给p1,返回p1</div></pre></td></tr></table></figure>\n<p>对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。</p>\n<h2 id=\"与旧代码的接口\"><a href=\"#与旧代码的接口\" class=\"headerlink\" title=\"与旧代码的接口\"></a>与旧代码的接口</h2><p>现代的C++ 程序不得不与那些充满了数组或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。</p>\n<h2 id=\"混用string对象和C风格字符串\"><a href=\"#混用string对象和C风格字符串\" class=\"headerlink\" title=\"混用string对象和C风格字符串\"></a>混用string对象和C风格字符串</h2><p>允许使用字符串字面值来初始化对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"Hello world\"</span>)</span></span>;      <span class=\"comment\">//s的内容是Hello world</span></div></pre></td></tr></table></figure>\n<p>更一般的情况，<strong>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代</strong>：</p>\n<ul>\n<li>允许使用空字符结束的字符数组来初始化string对象或为string对象赋值。</li>\n<li>在string对象的加法运算过程中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中匀速使用以空字符串结束的字符数组作为右侧的运算对象。</li>\n</ul>\n<p>上述性质反过来就不成立，比如不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为<strong>c_str的成员函数</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s = <span class=\"string\">\"wangxinri\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> *p = s ;      <span class=\"comment\">//错误，不能用string对象直接初始化指向字符的指针</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = s.c_str();      <span class=\"comment\">//正确</span></div></pre></td></tr></table></figure>\n<p>我们无法保证c_str()返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效果。因此使用最好将c_str()返回的数组拷贝一份。</p>\n<h2 id=\"使用数组初始化vector对象\"><a href=\"#使用数组初始化vector对象\" class=\"headerlink\" title=\"使用数组初始化vector对象\"></a>使用数组初始化vector对象</h2><p>不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> int_arr[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec(begin(int_arr),end(int_arr));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//拷贝三个元素：int_arr[1],int_arr[2],int_arr[3]</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVec(int_arr+<span class=\"number\">1</span>,int_arr4);</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</p>\n<h2 id=\"多维数组（待补充）\"><a href=\"#多维数组（待补充）\" class=\"headerlink\" title=\"多维数组（待补充）\"></a>多维数组（待补充）</h2><h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>string表示可变长的字符序列，使用string类型必须首先包含string头文件。</p>\n<h2 id=\"初始化string对象的方式\"><a href=\"#初始化string对象的方式\" class=\"headerlink\" title=\"初始化string对象的方式\"></a>初始化string对象的方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s1             默认初始化，s1是一个空串</div><div class=\"line\">string s2(s1)         s2是s1的副本</div><div class=\"line\"><span class=\"built_in\">string</span> s2 = s1        等价于s2(s1)，s2是s1的副本</div><div class=\"line\"><span class=\"built_in\">string</span> s3(<span class=\"string\">\"value\"</span>)    s3是字面值<span class=\"string\">\"value\"</span>的副本，除了字面值最后的那个空字符外</div><div class=\"line\"><span class=\"built_in\">string</span> s3 = <span class=\"string\">\"value\"</span>   等价于s3(<span class=\"string\">\"value\"</span>)，s3是字面值<span class=\"string\">\"value\"</span>的副本</div><div class=\"line\"><span class=\"built_in\">string</span> s4(n, <span class=\"string\">'c'</span>)     把s4初始化为由连续n个字符c组成的串</div></pre></td></tr></table></figure>\n<h2 id=\"string对象上的操作\"><a href=\"#string对象上的操作\" class=\"headerlink\" title=\"string对象上的操作\"></a>string对象上的操作</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">os&lt;&lt;s \t将s写到输出流os当中，返回os</div><div class=\"line\">is&gt;&gt;s \t从is中读取字符串赋给s，字符串以空白分隔，返回is</div><div class=\"line\">getline(is, s) \t从is中读取一行赋给s，返回is</div><div class=\"line\">s.empty() \ts为空赋返回<span class=\"literal\">true</span>，否则返回<span class=\"literal\">false</span></div><div class=\"line\">s.size() \t返回s中的字符的个数</div><div class=\"line\">s[n] \t返回s中第n个字符的引用，位置n从<span class=\"number\">0</span>计起</div><div class=\"line\">s1+s2 \t返回s1和s2连接后的结果</div><div class=\"line\">s1=s2 \t用s2的副本代替s1中原来的字符</div><div class=\"line\">s1==s2 \t如果s1和s2中所含的字符完全一样，则它们相等，返回<span class=\"literal\">true</span></div><div class=\"line\">s1!=s2 \t如果s1和s2中所含的字符不一样，返回<span class=\"literal\">true</span></div><div class=\"line\">&lt;, &lt;=, &gt;, &gt;= \t利用字符在字典中的顺序进行比较，且对字母的大小写敏感</div></pre></td></tr></table></figure>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> str;</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;str)&#123;   </div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;str&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> line;</div><div class=\"line\">    <span class=\"keyword\">while</span>(getline(<span class=\"built_in\">cin</span>,line))&#123;   </div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;line&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"处理string对象中的字符\"><a href=\"#处理string对象中的字符\" class=\"headerlink\" title=\"处理string对象中的字符\"></a>处理string对象中的字符</h2><p>对字符处理的一些方法，在<strong>cctype</strong>头文件中定义了一组标准库函数处理这部分工作<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">isalnmu(c) \t当c是字母或数字为真</div><div class=\"line\"><span class=\"built_in\">isalpha</span>(c) \t当c是字母为真</div><div class=\"line\"><span class=\"built_in\">iscntrl</span>(c) \t当c是控字符时为真</div><div class=\"line\"><span class=\"built_in\">isdigit</span>(c) \t当c是数字为真</div><div class=\"line\"><span class=\"built_in\">isgraph</span>(c) \t当c不是空格但可打印为真</div><div class=\"line\"><span class=\"built_in\">islower</span>(c) \t当c是小写字母为真</div><div class=\"line\"><span class=\"built_in\">isprint</span>(c) \t当c是可打印字符为真(即c是空格或c具有可视形式)</div><div class=\"line\"><span class=\"built_in\">ispunct</span>(c) \t当c是标点符号为真(即c不是控字符、数字、字母、可打印空白中的一种)</div><div class=\"line\"><span class=\"built_in\">isspace</span>(c) \t当c是空白为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进制符中一种)</div><div class=\"line\">issupper(c) \t当c是大写字母为真</div><div class=\"line\"><span class=\"built_in\">isxdigit</span>(c) \t当c是十六进制数字为真</div><div class=\"line\"><span class=\"built_in\">tolower</span>(c) \t若c是大写字母，输出对应小写字母；否则原样输出c</div><div class=\"line\"><span class=\"built_in\">toupper</span>(c) \t若c是小写字母，输出对应大写字母；否则原样输出c</div></pre></td></tr></table></figure></p>\n<h2 id=\"处理string每个字符，使用基于范围的for语句\"><a href=\"#处理string每个字符，使用基于范围的for语句\" class=\"headerlink\" title=\"处理string每个字符，使用基于范围的for语句\"></a>处理string每个字符，使用基于范围的for语句</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 用范围for语句和ispunct函数统计string对象中标点符号的个数（使用范围for语句遍历给定序列的每个元素）</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"Hello World!!!\"</span>)</span></span>;</div><div class=\"line\"><span class=\"keyword\">decltype</span>(s.size()) punct_cnt = <span class=\"number\">0</span>;            <span class=\"comment\">//punct_cnt的类型同s.size()，即为string :: size_type</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c : s)            <span class=\"comment\">// 对于s中的每个字符</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">ispunct</span>(c))       <span class=\"comment\">// 如果该字符是标点符号</span></div><div class=\"line\">           ++ispunct_cnt;  <span class=\"comment\">// 计数</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; punct_cnt &lt;&lt; <span class=\"string\">\" punctuation characters in \"</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用范围for语句将字符串改写为大写字母的形式（使用范围for语句改变字符串中的字符）</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s</span> <span class=\"params\">(<span class=\"string\">\"Hello World!!!\"</span>)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"comment\">// 转换成大写形式</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">for</span> <span class=\"params\">(<span class=\"keyword\">auto</span> &amp;c : s)</span>          <span class=\"comment\">// 对于s中的每个字符(c是引用)</span></span></div><div class=\"line\"><span class=\"function\">      c </span>= <span class=\"built_in\">toupper</span>(c);     <span class=\"comment\">// c是一个引用，赋值语句改变了c绑定的字符的值，标准库函数toupper将小写的参数c改为大写</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"只处理string一部分字符\"><a href=\"#只处理string一部分字符\" class=\"headerlink\" title=\"只处理string一部分字符\"></a>只处理string一部分字符</h2><p>要想访问string对象总的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。</p>\n<p><strong>注意：检查下标的合法性</strong></p>\n<p>一种简便易行的方法是：总是设下标的类型为<strong>string::size_type</strong>，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> s = <span class=\"string\">\"keep out\"</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c :s)&#123;    <span class=\"comment\">//C的类型是常量引用，不能通过C修改其绑定的对象</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍使用数组的基本方法，同时介绍C++中string的初始化和一些常用函数。</p>","more":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>数组与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是相对地也损失了一些灵活性。</p>\n<p><strong>note：</strong> 如果不清楚元素的确切个数，请使用vector。</p>\n<h2 id=\"定义和初始化内置数组\"><a href=\"#定义和初始化内置数组\" class=\"headerlink\" title=\"定义和初始化内置数组\"></a>定义和初始化内置数组</h2><p>数组是一种复合类型，数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，<strong>维度必须是一个常量表达式</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">unsigned</span> cnt = <span class=\"number\">42</span>;        <span class=\"comment\">//不是常量表达式</span></div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">unsigned</span> sz = <span class=\"number\">42</span>;       <span class=\"comment\">//常量表达式</span></div><div class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];           <span class=\"comment\">//含有10个整型的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> *parr[sz];          <span class=\"comment\">//含有42个整型指针的数组</span></div><div class=\"line\"><span class=\"built_in\">string</span> bad[cnt];         <span class=\"comment\">//错误：cnt不是常量表达式</span></div><div class=\"line\"><span class=\"built_in\">string</span> strs[get_size()];     <span class=\"comment\">//当gett_size是constexpr时正确；否则错误</span></div></pre></td></tr></table></figure>\n<p>默认情况下，数组的元素被默认初始化。另外数组的元素应为对象，因此不存在引用的数组。</p>\n<h2 id=\"显式初始化数组元素\"><a href=\"#显式初始化数组元素\" class=\"headerlink\" title=\"显式初始化数组元素\"></a>显式初始化数组元素</h2><p>可以对数组的元素进行列表初始化，此时允许忽略数组的纬度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> sz = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> ial[sz] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;      <span class=\"comment\">//含有三个元素的数组，元素值分别是０１２</span></div><div class=\"line\"><span class=\"keyword\">int</span> a2[] = &#123;<span class=\"number\">0</span> ,<span class=\"number\">1</span> , <span class=\"number\">2</span>&#125;;      <span class=\"comment\">//维度是３的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> a3[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;        <span class=\"comment\">// 等价于&#123;0,1,2,0,0&#125;</span></div><div class=\"line\"><span class=\"built_in\">string</span> a4[<span class=\"number\">3</span>] = &#123;“hi” , “bye”&#125;;  <span class=\"comment\">//&#123;“hi”,”bye” ,”“&#125;</span></div><div class=\"line\"><span class=\"keyword\">int</span> a5[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;         <span class=\"comment\">//错误，　初始值太多</span></div></pre></td></tr></table></figure>\n<h2 id=\"字符数组的特殊性（用字符串字面值对数组进行初始化）\"><a href=\"#字符数组的特殊性（用字符串字面值对数组进行初始化）\" class=\"headerlink\" title=\"字符数组的特殊性（用字符串字面值对数组进行初始化）\"></a>字符数组的特殊性（用字符串字面值对数组进行初始化）</h2><p>字符数组可以用字符串字面值初始化，但是特殊的是结束符（’\\0’）也会被拷贝进去<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> a1[] = &#123;‘C’,’+’ ,’+’&#125;;       <span class=\"comment\">//列表初始化没有空字符</span></div><div class=\"line\"><span class=\"keyword\">char</span> a2[] = &#123;‘C’,’+’,‘+’,’\\<span class=\"number\">0</span>’&#125;;    <span class=\"comment\">//列表初始化，含有显示的空字符</span></div><div class=\"line\"><span class=\"keyword\">char</span> a3[] = “C++”;                 <span class=\"comment\">//自动添加表示字符串结束的空字符</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> a4[<span class=\"number\">6</span>] =”Daniel”;      <span class=\"comment\">//错了，没有空间可以存放空字符</span></div></pre></td></tr></table></figure></p>\n<p>a4数组的大小必须至少是7。</p>\n<h2 id=\"数组不允许拷贝和赋值\"><a href=\"#数组不允许拷贝和赋值\" class=\"headerlink\" title=\"数组不允许拷贝和赋值\"></a>数组不允许拷贝和赋值</h2><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> a2[] = a;         <span class=\"comment\">//错误：不允许使用一个数组初始化另一个数组</span></div><div class=\"line\">a2 = a;               <span class=\"comment\">//错误：不能把一个数组直接赋值给另一个数组</span></div></pre></td></tr></table></figure>\n<h2 id=\"理解复杂的数组声明\"><a href=\"#理解复杂的数组声明\" class=\"headerlink\" title=\"理解复杂的数组声明\"></a>理解复杂的数组声明</h2><p>可以定义一个存放指针的数组。又因为数组本身是对象，所以允许定义数组的指针（指向数组的指针）及数组的引用（对数组的引用）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//[]的优先级比*高</span></div><div class=\"line\"><span class=\"keyword\">int</span> *ptrs[<span class=\"number\">10</span>];                  <span class=\"comment\">//ptrs是含有10个整型指针的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> (*Parray)[<span class=\"number\">10</span>] = &amp;arr;       <span class=\"comment\">//Parray指向一个含有10个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> (&amp;arrRef)[<span class=\"number\">10</span>] = arr;        <span class=\"comment\">//arrRef引用一个含有10个整数的数组</span></div></pre></td></tr></table></figure>\n<p><strong>默认情况下，类型修饰符从右向左一次绑定，</strong> 对于ptrs来说，首先知道我们定义了一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。</p>\n<p><strong>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</strong></p>\n<p>Parray的含义：首先*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。最终，Parray是一个指针，它指向一个int数组，数组中包含10个元素。</p>\n<p>当然，对修饰符的数量并没有特殊限制：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *(&amp;<span class=\"built_in\">array</span>)[<span class=\"number\">10</span>] = ptrs;     <span class=\"comment\">//array是数组的引用，该数组含有10个指针</span></div></pre></td></tr></table></figure>\n<h2 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h2><p>数组的元素也能使用范围for语句或下标运算符来访问。</p>\n<p>当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i : scores) &#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h2><p>在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> nums[] = &#123;<span class=\"string\">\"one\"</span>,<span class=\"string\">\"two\"</span>,<span class=\"string\">\"three\"</span>&#125;;          <span class=\"comment\">//数组的元素是string对象</span></div><div class=\"line\"><span class=\"built_in\">string</span> *p = &amp;nums[<span class=\"number\">0</span>];                           <span class=\"comment\">//p指向nums的第一个元素</span></div></pre></td></tr></table></figure>\n<p>数组的一个特性：<strong>在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> *p = nums;       <span class=\"comment\">//等价于p2=&amp;nums[0];</span></div></pre></td></tr></table></figure>\n<h2 id=\"auto-和-decltype\"><a href=\"#auto-和-decltype\" class=\"headerlink\" title=\"auto 和 decltype\"></a>auto 和 decltype</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">ia2</span><span class=\"params\">(ia)</span></span>;       <span class=\"comment\">//ia2是一个整型指针，指向ia的第一个元素</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">decltype</span>(ia) ia3 = &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;;     <span class=\"comment\">//ia3类型是由10个整数构成的数组，并对该数组进行赋值</span></div></pre></td></tr></table></figure>\n<h2 id=\"指针也是迭代器\"><a href=\"#指针也是迭代器\" class=\"headerlink\" title=\"指针也是迭代器\"></a>指针也是迭代器</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> *p = arr;            <span class=\"comment\">//p指向arr的第一个元素</span></div><div class=\"line\">++p;</div></pre></td></tr></table></figure>\n<p>遍历数组元素，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *e = &amp;arr[<span class=\"number\">10</span>];       <span class=\"comment\">//指向尾元素的下一位置的指针</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> *b = arr; b!=e; ++b)&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*b&lt;&lt;end;       <span class=\"comment\">//输出arr的元素</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>note:</strong> 尽管能计算得到尾后指针，但是这种用法极易出错，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似。</p>\n<p><strong>begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针</strong>，这两个函数定义在<strong>iterator</strong>头文件中。</p>\n<p>正确的使用形式：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> *beg = begin(ia);    <span class=\"comment\">//指向ia首元素的指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> *last = end(ia);     <span class=\"comment\">//指向arr尾元素的下一位置的指针</span></div><div class=\"line\"><span class=\"keyword\">for</span>(beg;beg!=last;++beg)&#123;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*beg&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>note:</strong> 一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end()函数返回的与迭代器类似的功能。特别要注意，<strong>尾后指针不能执行解引用和递增操作</strong>。</p>\n<h3 id=\"下标和指针\"><a href=\"#下标和指针\" class=\"headerlink\" title=\"下标和指针\"></a>下标和指针</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>&#125;;    <span class=\"comment\">//含有5个整数的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> i = ia[<span class=\"number\">2</span>];        <span class=\"comment\">//ia[2]得到(ia+2)所指的元素，即*(ia+2)</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p = ia;</div><div class=\"line\">i = *(p+<span class=\"number\">2</span>);         <span class=\"comment\">//等价于i = ia[2];</span></div><div class=\"line\">只要指针指向的是数组中的元素(或者数组中尾元素的下一位置，此时下标需要为负值)，都可以执行下标运算。</div><div class=\"line\"><span class=\"keyword\">int</span> *p = &amp;ia[<span class=\"number\">2</span>];      <span class=\"comment\">//p指向索引为2的元素</span></div><div class=\"line\"><span class=\"keyword\">int</span> j = p[<span class=\"number\">1</span>];         <span class=\"comment\">//j = ia[3]</span></div><div class=\"line\"><span class=\"keyword\">int</span> k = p[<span class=\"number\">-2</span>];        <span class=\"comment\">//k = ia[0]</span></div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p>\n<h2 id=\"C风格字符串\"><a href=\"#C风格字符串\" class=\"headerlink\" title=\"C风格字符串\"></a>C风格字符串</h2><p>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以<strong>空字符结束</strong>（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\\0’）。</p>\n<p><strong>C风格字符字符串函数</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\\\p,p1,p2都是字符数组的形式，在<span class=\"built_in\">string</span>.h头文件中</div><div class=\"line\"><span class=\"built_in\">strlen</span>(p)         返回p的长度，空字符不计算在内</div><div class=\"line\"><span class=\"built_in\">strcmp</span>(p1,p2)     比较p1和p2的相等。如果p1==p2，返回<span class=\"number\">0</span>；如果p1&gt;p2,返回一个正值；如果p1&lt;p2，返回一个负值</div><div class=\"line\"><span class=\"built_in\">strcat</span>(p1,p2)     将p2附加到p1之后，返回p1</div><div class=\"line\"><span class=\"built_in\">strcpy</span>(p1,p2)     将p2拷贝给p1,返回p1</div></pre></td></tr></table></figure>\n<p>对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。</p>\n<h2 id=\"与旧代码的接口\"><a href=\"#与旧代码的接口\" class=\"headerlink\" title=\"与旧代码的接口\"></a>与旧代码的接口</h2><p>现代的C++ 程序不得不与那些充满了数组或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。</p>\n<h2 id=\"混用string对象和C风格字符串\"><a href=\"#混用string对象和C风格字符串\" class=\"headerlink\" title=\"混用string对象和C风格字符串\"></a>混用string对象和C风格字符串</h2><p>允许使用字符串字面值来初始化对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"Hello world\"</span>)</span></span>;      <span class=\"comment\">//s的内容是Hello world</span></div></pre></td></tr></table></figure>\n<p>更一般的情况，<strong>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代</strong>：</p>\n<ul>\n<li>允许使用空字符结束的字符数组来初始化string对象或为string对象赋值。</li>\n<li>在string对象的加法运算过程中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中匀速使用以空字符串结束的字符数组作为右侧的运算对象。</li>\n</ul>\n<p>上述性质反过来就不成立，比如不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为<strong>c_str的成员函数</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s = <span class=\"string\">\"wangxinri\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> *p = s ;      <span class=\"comment\">//错误，不能用string对象直接初始化指向字符的指针</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = s.c_str();      <span class=\"comment\">//正确</span></div></pre></td></tr></table></figure>\n<p>我们无法保证c_str()返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效果。因此使用最好将c_str()返回的数组拷贝一份。</p>\n<h2 id=\"使用数组初始化vector对象\"><a href=\"#使用数组初始化vector对象\" class=\"headerlink\" title=\"使用数组初始化vector对象\"></a>使用数组初始化vector对象</h2><p>不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> int_arr[] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec(begin(int_arr),end(int_arr));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//拷贝三个元素：int_arr[1],int_arr[2],int_arr[3]</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVec(int_arr+<span class=\"number\">1</span>,int_arr4);</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</p>\n<h2 id=\"多维数组（待补充）\"><a href=\"#多维数组（待补充）\" class=\"headerlink\" title=\"多维数组（待补充）\"></a>多维数组（待补充）</h2><h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>string表示可变长的字符序列，使用string类型必须首先包含string头文件。</p>\n<h2 id=\"初始化string对象的方式\"><a href=\"#初始化string对象的方式\" class=\"headerlink\" title=\"初始化string对象的方式\"></a>初始化string对象的方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s1             默认初始化，s1是一个空串</div><div class=\"line\">string s2(s1)         s2是s1的副本</div><div class=\"line\"><span class=\"built_in\">string</span> s2 = s1        等价于s2(s1)，s2是s1的副本</div><div class=\"line\"><span class=\"built_in\">string</span> s3(<span class=\"string\">\"value\"</span>)    s3是字面值<span class=\"string\">\"value\"</span>的副本，除了字面值最后的那个空字符外</div><div class=\"line\"><span class=\"built_in\">string</span> s3 = <span class=\"string\">\"value\"</span>   等价于s3(<span class=\"string\">\"value\"</span>)，s3是字面值<span class=\"string\">\"value\"</span>的副本</div><div class=\"line\"><span class=\"built_in\">string</span> s4(n, <span class=\"string\">'c'</span>)     把s4初始化为由连续n个字符c组成的串</div></pre></td></tr></table></figure>\n<h2 id=\"string对象上的操作\"><a href=\"#string对象上的操作\" class=\"headerlink\" title=\"string对象上的操作\"></a>string对象上的操作</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">os&lt;&lt;s \t将s写到输出流os当中，返回os</div><div class=\"line\">is&gt;&gt;s \t从is中读取字符串赋给s，字符串以空白分隔，返回is</div><div class=\"line\">getline(is, s) \t从is中读取一行赋给s，返回is</div><div class=\"line\">s.empty() \ts为空赋返回<span class=\"literal\">true</span>，否则返回<span class=\"literal\">false</span></div><div class=\"line\">s.size() \t返回s中的字符的个数</div><div class=\"line\">s[n] \t返回s中第n个字符的引用，位置n从<span class=\"number\">0</span>计起</div><div class=\"line\">s1+s2 \t返回s1和s2连接后的结果</div><div class=\"line\">s1=s2 \t用s2的副本代替s1中原来的字符</div><div class=\"line\">s1==s2 \t如果s1和s2中所含的字符完全一样，则它们相等，返回<span class=\"literal\">true</span></div><div class=\"line\">s1!=s2 \t如果s1和s2中所含的字符不一样，返回<span class=\"literal\">true</span></div><div class=\"line\">&lt;, &lt;=, &gt;, &gt;= \t利用字符在字典中的顺序进行比较，且对字母的大小写敏感</div></pre></td></tr></table></figure>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> str;</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;str)&#123;   </div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;str&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> line;</div><div class=\"line\">    <span class=\"keyword\">while</span>(getline(<span class=\"built_in\">cin</span>,line))&#123;   </div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;line&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"处理string对象中的字符\"><a href=\"#处理string对象中的字符\" class=\"headerlink\" title=\"处理string对象中的字符\"></a>处理string对象中的字符</h2><p>对字符处理的一些方法，在<strong>cctype</strong>头文件中定义了一组标准库函数处理这部分工作<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">isalnmu(c) \t当c是字母或数字为真</div><div class=\"line\"><span class=\"built_in\">isalpha</span>(c) \t当c是字母为真</div><div class=\"line\"><span class=\"built_in\">iscntrl</span>(c) \t当c是控字符时为真</div><div class=\"line\"><span class=\"built_in\">isdigit</span>(c) \t当c是数字为真</div><div class=\"line\"><span class=\"built_in\">isgraph</span>(c) \t当c不是空格但可打印为真</div><div class=\"line\"><span class=\"built_in\">islower</span>(c) \t当c是小写字母为真</div><div class=\"line\"><span class=\"built_in\">isprint</span>(c) \t当c是可打印字符为真(即c是空格或c具有可视形式)</div><div class=\"line\"><span class=\"built_in\">ispunct</span>(c) \t当c是标点符号为真(即c不是控字符、数字、字母、可打印空白中的一种)</div><div class=\"line\"><span class=\"built_in\">isspace</span>(c) \t当c是空白为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进制符中一种)</div><div class=\"line\">issupper(c) \t当c是大写字母为真</div><div class=\"line\"><span class=\"built_in\">isxdigit</span>(c) \t当c是十六进制数字为真</div><div class=\"line\"><span class=\"built_in\">tolower</span>(c) \t若c是大写字母，输出对应小写字母；否则原样输出c</div><div class=\"line\"><span class=\"built_in\">toupper</span>(c) \t若c是小写字母，输出对应大写字母；否则原样输出c</div></pre></td></tr></table></figure></p>\n<h2 id=\"处理string每个字符，使用基于范围的for语句\"><a href=\"#处理string每个字符，使用基于范围的for语句\" class=\"headerlink\" title=\"处理string每个字符，使用基于范围的for语句\"></a>处理string每个字符，使用基于范围的for语句</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 用范围for语句和ispunct函数统计string对象中标点符号的个数（使用范围for语句遍历给定序列的每个元素）</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"Hello World!!!\"</span>)</span></span>;</div><div class=\"line\"><span class=\"keyword\">decltype</span>(s.size()) punct_cnt = <span class=\"number\">0</span>;            <span class=\"comment\">//punct_cnt的类型同s.size()，即为string :: size_type</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c : s)            <span class=\"comment\">// 对于s中的每个字符</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">ispunct</span>(c))       <span class=\"comment\">// 如果该字符是标点符号</span></div><div class=\"line\">           ++ispunct_cnt;  <span class=\"comment\">// 计数</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; punct_cnt &lt;&lt; <span class=\"string\">\" punctuation characters in \"</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用范围for语句将字符串改写为大写字母的形式（使用范围for语句改变字符串中的字符）</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s</span> <span class=\"params\">(<span class=\"string\">\"Hello World!!!\"</span>)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"comment\">// 转换成大写形式</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">for</span> <span class=\"params\">(<span class=\"keyword\">auto</span> &amp;c : s)</span>          <span class=\"comment\">// 对于s中的每个字符(c是引用)</span></span></div><div class=\"line\"><span class=\"function\">      c </span>= <span class=\"built_in\">toupper</span>(c);     <span class=\"comment\">// c是一个引用，赋值语句改变了c绑定的字符的值，标准库函数toupper将小写的参数c改为大写</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"只处理string一部分字符\"><a href=\"#只处理string一部分字符\" class=\"headerlink\" title=\"只处理string一部分字符\"></a>只处理string一部分字符</h2><p>要想访问string对象总的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。</p>\n<p><strong>注意：检查下标的合法性</strong></p>\n<p>一种简便易行的方法是：总是设下标的类型为<strong>string::size_type</strong>，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> s = <span class=\"string\">\"keep out\"</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c :s)&#123;    <span class=\"comment\">//C的类型是常量引用，不能通过C修改其绑定的对象</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"try语句块和异常处理","date":"2017-10-15T02:59:00.000Z","update":null,"comments":1,"_content":"# 一、前言\n\n简单介绍try语句块和异常处理。\n\n<!--more-->\n\n# 异常\n异常处理机制为程序中异常检测和异常处理这两部分的协作提供了支持。在C++语言中，异常处理包括：\n\n- **throw表达式**（throw expression），异常检测部分使用throw表达式来表示它遇到的了无法处理的问题，我们说throw引发了异常。\n- **try语句块**（try block）,异常处理部分使用try语句处理异常。try语句块以关键字try开始，并以一个或多个catch字句结束。try语句块中代码抛出的异常通常会被某个catch字句处理。因为**catch字句”处理“异常，所以它们也被称作异常处理代码**。\n- **一套异常类**（exception class），用于在throw表达式和相关的catch字句之间传递异常具体信息。\n\n## throw表达式\n\n程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。\n\n## try语句块\n\n```C++\ntry{\n    program-staments\n}catch(exception-declaration){\n    handler-staments\n}catch(exception-declaration){\n    handler-staments\n} ...\n```\n\n**代码示例**\n```++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>   //标准异常库\nusing namespace std;\nint main()\n{\n    int a,b;\n    cout<<\"请输入相除的两个整数：\";\n    while(cin>>a>>b)\n    {\n        try\n        {\n            if (b == 0) throw std::runtime_error(\"被除数不能为0\");//runtime_error异常类:只有在运行时才能检测出的问题\n            cout<<static_cast<double>(a)/b<<endl;//考虑到不可以整除产生小数的情况,先将a强制转化为double类型\n        }\n        catch (runtime_error err)//err是runtime_error类的一个实例\n        {\n            cout << err.what() ;\n            //实例的成员函数，返回内容由编译其决定\n            cout << \"\\n是否需要重新输入? Enter y or n:\" << endl;\n            char c;\n            cin >> c;\n            if (!cin || c == 'n')\n                break;//break只能用在开关体或者循环体中\n        }//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理\n        //如果没有catch部分，仅有try，仍然会报错\n        cout<<\"请输入相除的两个整数：\";\n    }\n    return 0 ;\n}\n```\n输出结果：\n\n    请输入相除的两个整数：2 4\n    0.5\n    请输入相除的两个整数：2 0\n    被除数不能为0\n    是否需要重新输入?\n    n\n\n\n简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理，如果没有catch部分，仅有try，仍然会报错。","source":"_posts/try语句块和异常处理.md","raw":"---\ntitle: try语句块和异常处理\ndate: 2017-10-15 10:59:00\nupdate: \ntags: [异常处理]\ncategories: C++\ncomments: true\n---\n# 一、前言\n\n简单介绍try语句块和异常处理。\n\n<!--more-->\n\n# 异常\n异常处理机制为程序中异常检测和异常处理这两部分的协作提供了支持。在C++语言中，异常处理包括：\n\n- **throw表达式**（throw expression），异常检测部分使用throw表达式来表示它遇到的了无法处理的问题，我们说throw引发了异常。\n- **try语句块**（try block）,异常处理部分使用try语句处理异常。try语句块以关键字try开始，并以一个或多个catch字句结束。try语句块中代码抛出的异常通常会被某个catch字句处理。因为**catch字句”处理“异常，所以它们也被称作异常处理代码**。\n- **一套异常类**（exception class），用于在throw表达式和相关的catch字句之间传递异常具体信息。\n\n## throw表达式\n\n程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。\n\n## try语句块\n\n```C++\ntry{\n    program-staments\n}catch(exception-declaration){\n    handler-staments\n}catch(exception-declaration){\n    handler-staments\n} ...\n```\n\n**代码示例**\n```++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>   //标准异常库\nusing namespace std;\nint main()\n{\n    int a,b;\n    cout<<\"请输入相除的两个整数：\";\n    while(cin>>a>>b)\n    {\n        try\n        {\n            if (b == 0) throw std::runtime_error(\"被除数不能为0\");//runtime_error异常类:只有在运行时才能检测出的问题\n            cout<<static_cast<double>(a)/b<<endl;//考虑到不可以整除产生小数的情况,先将a强制转化为double类型\n        }\n        catch (runtime_error err)//err是runtime_error类的一个实例\n        {\n            cout << err.what() ;\n            //实例的成员函数，返回内容由编译其决定\n            cout << \"\\n是否需要重新输入? Enter y or n:\" << endl;\n            char c;\n            cin >> c;\n            if (!cin || c == 'n')\n                break;//break只能用在开关体或者循环体中\n        }//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理\n        //如果没有catch部分，仅有try，仍然会报错\n        cout<<\"请输入相除的两个整数：\";\n    }\n    return 0 ;\n}\n```\n输出结果：\n\n    请输入相除的两个整数：2 4\n    0.5\n    请输入相除的两个整数：2 0\n    被除数不能为0\n    是否需要重新输入?\n    n\n\n\n简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理，如果没有catch部分，仅有try，仍然会报错。","slug":"try语句块和异常处理","published":1,"updated":"2018-01-16T12:52:54.455Z","layout":"post","photos":[],"link":"","_id":"cjcj3yipf001njgc9tpl4cwbl","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>简单介绍try语句块和异常处理。</p>\n<a id=\"more\"></a>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供了支持。在C++语言中，异常处理包括：</p>\n<ul>\n<li><strong>throw表达式</strong>（throw expression），异常检测部分使用throw表达式来表示它遇到的了无法处理的问题，我们说throw引发了异常。</li>\n<li><strong>try语句块</strong>（try block）,异常处理部分使用try语句处理异常。try语句块以关键字try开始，并以一个或多个catch字句结束。try语句块中代码抛出的异常通常会被某个catch字句处理。因为<strong>catch字句”处理“异常，所以它们也被称作异常处理代码</strong>。</li>\n<li><strong>一套异常类</strong>（exception class），用于在throw表达式和相关的catch字句之间传递异常具体信息。</li>\n</ul>\n<h2 id=\"throw表达式\"><a href=\"#throw表达式\" class=\"headerlink\" title=\"throw表达式\"></a>throw表达式</h2><p>程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。</p>\n<h2 id=\"try语句块\"><a href=\"#try语句块\" class=\"headerlink\" title=\"try语句块\"></a>try语句块</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    program-staments</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(exception-declaration)&#123;</div><div class=\"line\">    handler-staments</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(exception-declaration)&#123;</div><div class=\"line\">    handler-staments</div><div class=\"line\">&#125; ...</div></pre></td></tr></table></figure>\n<p><strong>代码示例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;stdexcept&gt;   //标准异常库</div><div class=\"line\">using namespace std;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int a,b;</div><div class=\"line\">    cout&lt;&lt;&quot;请输入相除的两个整数：&quot;;</div><div class=\"line\">    while(cin&gt;&gt;a&gt;&gt;b)</div><div class=\"line\">    &#123;</div><div class=\"line\">        try</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (b == 0) throw std::runtime_error(&quot;被除数不能为0&quot;);//runtime_error异常类:只有在运行时才能检测出的问题</div><div class=\"line\">            cout&lt;&lt;static_cast&lt;double&gt;(a)/b&lt;&lt;endl;//考虑到不可以整除产生小数的情况,先将a强制转化为double类型</div><div class=\"line\">        &#125;</div><div class=\"line\">        catch (runtime_error err)//err是runtime_error类的一个实例</div><div class=\"line\">        &#123;</div><div class=\"line\">            cout &lt;&lt; err.what() ;</div><div class=\"line\">            //实例的成员函数，返回内容由编译其决定</div><div class=\"line\">            cout &lt;&lt; &quot;\\n是否需要重新输入? Enter y or n:&quot; &lt;&lt; endl;</div><div class=\"line\">            char c;</div><div class=\"line\">            cin &gt;&gt; c;</div><div class=\"line\">            if (!cin || c == &apos;n&apos;)</div><div class=\"line\">                break;//break只能用在开关体或者循环体中</div><div class=\"line\">        &#125;//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理</div><div class=\"line\">        //如果没有catch部分，仅有try，仍然会报错</div><div class=\"line\">        cout&lt;&lt;&quot;请输入相除的两个整数：&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0 ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出结果：</p>\n<pre><code>请输入相除的两个整数：2 4\n0.5\n请输入相除的两个整数：2 0\n被除数不能为0\n是否需要重新输入?\nn\n</code></pre><p>简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理，如果没有catch部分，仅有try，仍然会报错。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>简单介绍try语句块和异常处理。</p>","more":"<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供了支持。在C++语言中，异常处理包括：</p>\n<ul>\n<li><strong>throw表达式</strong>（throw expression），异常检测部分使用throw表达式来表示它遇到的了无法处理的问题，我们说throw引发了异常。</li>\n<li><strong>try语句块</strong>（try block）,异常处理部分使用try语句处理异常。try语句块以关键字try开始，并以一个或多个catch字句结束。try语句块中代码抛出的异常通常会被某个catch字句处理。因为<strong>catch字句”处理“异常，所以它们也被称作异常处理代码</strong>。</li>\n<li><strong>一套异常类</strong>（exception class），用于在throw表达式和相关的catch字句之间传递异常具体信息。</li>\n</ul>\n<h2 id=\"throw表达式\"><a href=\"#throw表达式\" class=\"headerlink\" title=\"throw表达式\"></a>throw表达式</h2><p>程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。</p>\n<h2 id=\"try语句块\"><a href=\"#try语句块\" class=\"headerlink\" title=\"try语句块\"></a>try语句块</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    program-staments</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(exception-declaration)&#123;</div><div class=\"line\">    handler-staments</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(exception-declaration)&#123;</div><div class=\"line\">    handler-staments</div><div class=\"line\">&#125; ...</div></pre></td></tr></table></figure>\n<p><strong>代码示例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;stdexcept&gt;   //标准异常库</div><div class=\"line\">using namespace std;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int a,b;</div><div class=\"line\">    cout&lt;&lt;&quot;请输入相除的两个整数：&quot;;</div><div class=\"line\">    while(cin&gt;&gt;a&gt;&gt;b)</div><div class=\"line\">    &#123;</div><div class=\"line\">        try</div><div class=\"line\">        &#123;</div><div class=\"line\">            if (b == 0) throw std::runtime_error(&quot;被除数不能为0&quot;);//runtime_error异常类:只有在运行时才能检测出的问题</div><div class=\"line\">            cout&lt;&lt;static_cast&lt;double&gt;(a)/b&lt;&lt;endl;//考虑到不可以整除产生小数的情况,先将a强制转化为double类型</div><div class=\"line\">        &#125;</div><div class=\"line\">        catch (runtime_error err)//err是runtime_error类的一个实例</div><div class=\"line\">        &#123;</div><div class=\"line\">            cout &lt;&lt; err.what() ;</div><div class=\"line\">            //实例的成员函数，返回内容由编译其决定</div><div class=\"line\">            cout &lt;&lt; &quot;\\n是否需要重新输入? Enter y or n:&quot; &lt;&lt; endl;</div><div class=\"line\">            char c;</div><div class=\"line\">            cin &gt;&gt; c;</div><div class=\"line\">            if (!cin || c == &apos;n&apos;)</div><div class=\"line\">                break;//break只能用在开关体或者循环体中</div><div class=\"line\">        &#125;//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理</div><div class=\"line\">        //如果没有catch部分，仅有try，仍然会报错</div><div class=\"line\">        cout&lt;&lt;&quot;请输入相除的两个整数：&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0 ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出结果：</p>\n<pre><code>请输入相除的两个整数：2 4\n0.5\n请输入相除的两个整数：2 0\n被除数不能为0\n是否需要重新输入?\nn\n</code></pre><p>简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理，如果没有catch部分，仅有try，仍然会报错。</p>"},{"title":"表达式基础","date":"2017-10-14T14:00:00.000Z","update":null,"comments":1,"_content":"# 一、前言\n\n介绍C++中常见的表达式。\n\n<!--more-->\n\n## 基础概念\n\n### 组合运算符和运算对象\n\n对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解**运算符的优先级、结合律以及运算对象的求值顺序。**\n\n### 重载运算符\n\n### 左值和右值\n\n左值可以位于赋值语句的左侧、右值则不能。\n\n当一个对象被用于右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的为止）。\n\n### 求值顺序（重点）\n\n优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。\n\n```C++\nint i = f1()*f2();\n```\n\n我们是无法知道到底f1在f2之前调用还是f2在f1之前调用。\n\n对于那些没有指定执行顺序的运算符来讲，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，比如：\n\n```C++\nint i = 0;\ncout<<i<<\" \"<<++i<<endl;\n```\n表达是的行为不可预知，编译器执行i或者++i的顺序是未知的。\n\n**以下4中运算符明确规定了运算对象的求值顺序**：<font color=red>**&&(逻辑与) ||(逻辑或) ?:(条件运算符) ,(逗号运算符)。**</font>\n\n\n### 求值顺序、优先级、结合律\n\n运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中：\n- 优先级规定，g()的返回值和h()的返回值相乘。\n- 结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。\n- 对于这些函数的调用顺序没有明确规定。\n\n如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。\n\n**建议：** 处理复合表达式以下两条经验准则对书写复合表达式有益：\n\n- 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。\n- 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。\n\n第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。\n\n\n## 算术运算符\n\n### %运算符\n\n如果m%n不等于0，则它的符号和m相同。\n\n    m%(-n)  等于  m%n\n    (-m)%n  等于 -(m%n)\n    -21 % -8 = -5\n    21 % -5 = 1\n    \n## 逻辑和关系运算符\n\n**逻辑与(&&)和逻辑或(||)** 都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 **短路求值**。\n\ntext是存储这string对象的vector，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。\n```C++\n//s是对常量的引用；元素既没有被拷贝也不会被改变\nfor(const auto &s : text) {  \n    cout<<s;\n    if(s.empty()||s[s.size()-1] == '.'){\n        cout<<endl;\n    }else{\n        cout<<\" \";\n    }\n}\n```\n\n**值得注意的是**，s被声明成对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以声明成对常量的引用。\n\n### 优先级注意\n\n<font color=red> **算数运算符>关系运算符>逻辑运算符** </font>\n\n### 赋值运算符满足右结合律\n\n赋值运算符满足右结合律，这一点与其他二元运算符不太一样。\n\n```C++\nint ival,jval;\nival = jval = 0;    //正确，都被赋值为0\n```\n\n因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0作为靠左的赋值运算符的右侧运算对象。又因为**赋值运算符返回的是其左侧运算对象**，所以靠右的赋值运算的结果（jval=2返回的结果为左侧运算对象jval）被赋给了ival。\n```C++\ncout<<(jval = 2)<<endl;      // 输出2\n```\n\n### 赋值运算符优先级较低\n\n```C++\nint i ;\n//一种很好的写法\nwhile((i=get_value()) != 42) {\n    //其他处理\n}\n```\n\n**注意：** 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。\n\n## 递增和递减运算符\n\n递增和递减有两种形式：前置版本和后置版本。\n\n```C++\nint i =0,j;\nj = ++i;              //j = 1,i = 1;   前置版本得到递增之后的值\nj = i++;              //j = 1,i = 2;   后置版本得到递增之前的值\n```\n\n**区别：前置版本将对象本身作为左值返回，后置版本则将对象的原始副本作为右值返回。**\n\n<font color=red> **建议：除非必须，否则不用递增递减运算符的后置版本** </font>                      \n\n有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，**后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。**\n\n对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。\n\n## 混用解引用和递增运算符\n\n```C++\n//推荐写法\ncout<<*iter++<<endl;    //等价于*(iter++)\n```\n后置运算符的优先级高于解引用运算符。\n\n\n```C++\nvec[ival++] <= vec[ival];        //未定义的错误，先求左侧的值还是先求右侧的值不确定\n```\n\n## 成员访问运算符\n\n点运算符和箭头运算符都可用与访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，<font color=red>表达式ptr->men等价于(*ptr)mem </font> :\n\n```C++\nstring s1 = \"a string\", *p = &s1;\nauto n = s1.size();        \nn = (*p).size();        //运行p所指对象的size成员\nn = p->size();          //等价于(*p).size()\n```\n\n**注意：解引用运算符的优先级低于点运算符。**\n\n```C++\n*p.size()          // 错误，p是一个指针，它没有名为size的成员\n```\n\n\n## 条件运算符\n\n**优先级**\n\n**条件运算符优先级高于赋值、逗号运算符，低于其他运算符。**\n\n例如：\n```\nm<n ? x : a+3                等价于：(m<n) ?(x) :(a+3)\na++>=10 && b-->20 ? a : b    等价于：(a++>=10 && b-->20) ? a : b\nx=3+a>5 ? 100 : 200          等价于：x= (( 3+a>5 ) ? 100 : 200 )\n```\n\n**结合性**\n\n**条件运算符具有右结合性。**\n\n当一个表达式中出现多个条件运算符时，应该将位于最右边的问号与离它最近的冒号配对，并按这一原则正确区分各条件运算符的运算对象。\n\n例如：\n\n     w<x ? x+w : x<y ? x : y\n    与 w<x ? x+w : ( x<y ? x : y) 等价\n    与 (w<x ? x+w : x<y) ? x : y 不等价\n\n\n<font color=red>注意： 随着条件运算嵌套的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。 </font>\n\n\n## 位运算符（基础，待补充）\n\n一个使用位运算符的例子\n\n假设一个班级有30个学生,我们用一个二进制位来代表某个学生在依次测试中是否通过，显然全班的测试结果可以用一个无符号整数来表示：\n\n```C++\nunsigned long quizl = 0 ;          //我们把这个值当成是位的集合来使用\n```\n将quizl类型定义位unsigned long，这样，quizl在任何机器上都将至少拥有32位；给quizl赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。\n\n```C++\n//1UL是一个unsigned long类型的整数字面值1\n//1UL<<27;    生成一个值，该值只有第27位为1\nquizl |= 1UL<<27;        //表示学生27通过了测试\n\nquizl &= ~(1UL<<27);     //学生27未通过测试\n\nbool status = quizl & (1UL<<27);   //学生27是否通过了测试？\n```\n\n## sizeof\n\nsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得到的值是一个size_t类型的常量表达式。\n\nsizeof的三种语法形式：\n\n```C++\nsizeof(object);        //sizeof(对象);\nsizeof(type_name);     //sizeof(类型);\nsizeof object;         //sizeof对象;\n```\n```C++\nint i;\nsizeof(i);     //ok\nsizeof i;      //ok\nsizeof(int);   //ok\nsizeof int;    //error\n```\n\n既然写法3可以用写法1代替，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。\n\n```C++\nsizeof(*p);          //指针所占的空间大小，与指针指向的类型无关\n```\n\nsizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针也不会有什么影响，在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。\n\n\nC++11新标准允许我们使用作用域来获取成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象。因为要想知道类成员的大小无须真的获取该成员。\n\nsizeof运算符的结果部分地依赖于其作用的类型：\n\n- 对char或者类型为char的表达式指向sizeof运算，结果为1；\n- 对引用类型执行sizeof运算得到被引用对象所占空间的大小；\n- 对指针指向sizeof运算得到指针本身所占空间的大小；\n- 对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效。\n- 对数组执行sizeof运算限制得到整个数组所占空间的大小，等价于对数组这所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理\n- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。\n\n因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：\n\n```C++\n// sizeof(ia)/sizeof(*ia)返回ia的元素数量  \nconstexpr size_t sz = sizeof(ia)/sizeof(*ia);  \nint arr2[sz];   // 正确：sizeof返回一个常量表达式\n```\n\n因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ","source":"_posts/表达式基础.md","raw":"---\ntitle: 表达式基础\ndate: 2017-10-14 22:00:00\nupdate: \ntags: [C++]\ncategories: C++\ncomments: true\n---\n# 一、前言\n\n介绍C++中常见的表达式。\n\n<!--more-->\n\n## 基础概念\n\n### 组合运算符和运算对象\n\n对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解**运算符的优先级、结合律以及运算对象的求值顺序。**\n\n### 重载运算符\n\n### 左值和右值\n\n左值可以位于赋值语句的左侧、右值则不能。\n\n当一个对象被用于右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的为止）。\n\n### 求值顺序（重点）\n\n优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。\n\n```C++\nint i = f1()*f2();\n```\n\n我们是无法知道到底f1在f2之前调用还是f2在f1之前调用。\n\n对于那些没有指定执行顺序的运算符来讲，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，比如：\n\n```C++\nint i = 0;\ncout<<i<<\" \"<<++i<<endl;\n```\n表达是的行为不可预知，编译器执行i或者++i的顺序是未知的。\n\n**以下4中运算符明确规定了运算对象的求值顺序**：<font color=red>**&&(逻辑与) ||(逻辑或) ?:(条件运算符) ,(逗号运算符)。**</font>\n\n\n### 求值顺序、优先级、结合律\n\n运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中：\n- 优先级规定，g()的返回值和h()的返回值相乘。\n- 结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。\n- 对于这些函数的调用顺序没有明确规定。\n\n如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。\n\n**建议：** 处理复合表达式以下两条经验准则对书写复合表达式有益：\n\n- 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。\n- 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。\n\n第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。\n\n\n## 算术运算符\n\n### %运算符\n\n如果m%n不等于0，则它的符号和m相同。\n\n    m%(-n)  等于  m%n\n    (-m)%n  等于 -(m%n)\n    -21 % -8 = -5\n    21 % -5 = 1\n    \n## 逻辑和关系运算符\n\n**逻辑与(&&)和逻辑或(||)** 都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 **短路求值**。\n\ntext是存储这string对象的vector，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。\n```C++\n//s是对常量的引用；元素既没有被拷贝也不会被改变\nfor(const auto &s : text) {  \n    cout<<s;\n    if(s.empty()||s[s.size()-1] == '.'){\n        cout<<endl;\n    }else{\n        cout<<\" \";\n    }\n}\n```\n\n**值得注意的是**，s被声明成对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以声明成对常量的引用。\n\n### 优先级注意\n\n<font color=red> **算数运算符>关系运算符>逻辑运算符** </font>\n\n### 赋值运算符满足右结合律\n\n赋值运算符满足右结合律，这一点与其他二元运算符不太一样。\n\n```C++\nint ival,jval;\nival = jval = 0;    //正确，都被赋值为0\n```\n\n因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0作为靠左的赋值运算符的右侧运算对象。又因为**赋值运算符返回的是其左侧运算对象**，所以靠右的赋值运算的结果（jval=2返回的结果为左侧运算对象jval）被赋给了ival。\n```C++\ncout<<(jval = 2)<<endl;      // 输出2\n```\n\n### 赋值运算符优先级较低\n\n```C++\nint i ;\n//一种很好的写法\nwhile((i=get_value()) != 42) {\n    //其他处理\n}\n```\n\n**注意：** 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。\n\n## 递增和递减运算符\n\n递增和递减有两种形式：前置版本和后置版本。\n\n```C++\nint i =0,j;\nj = ++i;              //j = 1,i = 1;   前置版本得到递增之后的值\nj = i++;              //j = 1,i = 2;   后置版本得到递增之前的值\n```\n\n**区别：前置版本将对象本身作为左值返回，后置版本则将对象的原始副本作为右值返回。**\n\n<font color=red> **建议：除非必须，否则不用递增递减运算符的后置版本** </font>                      \n\n有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，**后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。**\n\n对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。\n\n## 混用解引用和递增运算符\n\n```C++\n//推荐写法\ncout<<*iter++<<endl;    //等价于*(iter++)\n```\n后置运算符的优先级高于解引用运算符。\n\n\n```C++\nvec[ival++] <= vec[ival];        //未定义的错误，先求左侧的值还是先求右侧的值不确定\n```\n\n## 成员访问运算符\n\n点运算符和箭头运算符都可用与访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，<font color=red>表达式ptr->men等价于(*ptr)mem </font> :\n\n```C++\nstring s1 = \"a string\", *p = &s1;\nauto n = s1.size();        \nn = (*p).size();        //运行p所指对象的size成员\nn = p->size();          //等价于(*p).size()\n```\n\n**注意：解引用运算符的优先级低于点运算符。**\n\n```C++\n*p.size()          // 错误，p是一个指针，它没有名为size的成员\n```\n\n\n## 条件运算符\n\n**优先级**\n\n**条件运算符优先级高于赋值、逗号运算符，低于其他运算符。**\n\n例如：\n```\nm<n ? x : a+3                等价于：(m<n) ?(x) :(a+3)\na++>=10 && b-->20 ? a : b    等价于：(a++>=10 && b-->20) ? a : b\nx=3+a>5 ? 100 : 200          等价于：x= (( 3+a>5 ) ? 100 : 200 )\n```\n\n**结合性**\n\n**条件运算符具有右结合性。**\n\n当一个表达式中出现多个条件运算符时，应该将位于最右边的问号与离它最近的冒号配对，并按这一原则正确区分各条件运算符的运算对象。\n\n例如：\n\n     w<x ? x+w : x<y ? x : y\n    与 w<x ? x+w : ( x<y ? x : y) 等价\n    与 (w<x ? x+w : x<y) ? x : y 不等价\n\n\n<font color=red>注意： 随着条件运算嵌套的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。 </font>\n\n\n## 位运算符（基础，待补充）\n\n一个使用位运算符的例子\n\n假设一个班级有30个学生,我们用一个二进制位来代表某个学生在依次测试中是否通过，显然全班的测试结果可以用一个无符号整数来表示：\n\n```C++\nunsigned long quizl = 0 ;          //我们把这个值当成是位的集合来使用\n```\n将quizl类型定义位unsigned long，这样，quizl在任何机器上都将至少拥有32位；给quizl赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。\n\n```C++\n//1UL是一个unsigned long类型的整数字面值1\n//1UL<<27;    生成一个值，该值只有第27位为1\nquizl |= 1UL<<27;        //表示学生27通过了测试\n\nquizl &= ~(1UL<<27);     //学生27未通过测试\n\nbool status = quizl & (1UL<<27);   //学生27是否通过了测试？\n```\n\n## sizeof\n\nsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得到的值是一个size_t类型的常量表达式。\n\nsizeof的三种语法形式：\n\n```C++\nsizeof(object);        //sizeof(对象);\nsizeof(type_name);     //sizeof(类型);\nsizeof object;         //sizeof对象;\n```\n```C++\nint i;\nsizeof(i);     //ok\nsizeof i;      //ok\nsizeof(int);   //ok\nsizeof int;    //error\n```\n\n既然写法3可以用写法1代替，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。\n\n```C++\nsizeof(*p);          //指针所占的空间大小，与指针指向的类型无关\n```\n\nsizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针也不会有什么影响，在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。\n\n\nC++11新标准允许我们使用作用域来获取成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象。因为要想知道类成员的大小无须真的获取该成员。\n\nsizeof运算符的结果部分地依赖于其作用的类型：\n\n- 对char或者类型为char的表达式指向sizeof运算，结果为1；\n- 对引用类型执行sizeof运算得到被引用对象所占空间的大小；\n- 对指针指向sizeof运算得到指针本身所占空间的大小；\n- 对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效。\n- 对数组执行sizeof运算限制得到整个数组所占空间的大小，等价于对数组这所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理\n- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。\n\n因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：\n\n```C++\n// sizeof(ia)/sizeof(*ia)返回ia的元素数量  \nconstexpr size_t sz = sizeof(ia)/sizeof(*ia);  \nint arr2[sz];   // 正确：sizeof返回一个常量表达式\n```\n\n因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ","slug":"表达式基础","published":1,"updated":"2018-01-16T12:49:39.438Z","layout":"post","photos":[],"link":"","_id":"cjcj3yipi001qjgc97ny0umrf","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍C++中常见的表达式。</p>\n<a id=\"more\"></a>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"组合运算符和运算对象\"><a href=\"#组合运算符和运算对象\" class=\"headerlink\" title=\"组合运算符和运算对象\"></a>组合运算符和运算对象</h3><p>对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解<strong>运算符的优先级、结合律以及运算对象的求值顺序。</strong></p>\n<h3 id=\"重载运算符\"><a href=\"#重载运算符\" class=\"headerlink\" title=\"重载运算符\"></a>重载运算符</h3><h3 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h3><p>左值可以位于赋值语句的左侧、右值则不能。</p>\n<p>当一个对象被用于右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的为止）。</p>\n<h3 id=\"求值顺序（重点）\"><a href=\"#求值顺序（重点）\" class=\"headerlink\" title=\"求值顺序（重点）\"></a>求值顺序（重点）</h3><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = f1()*f2();</div></pre></td></tr></table></figure>\n<p>我们是无法知道到底f1在f2之前调用还是f2在f1之前调用。</p>\n<p>对于那些没有指定执行顺序的运算符来讲，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;++i&lt;&lt;<span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure>\n<p>表达是的行为不可预知，编译器执行i或者++i的顺序是未知的。</p>\n<p><strong>以下4中运算符明确规定了运算对象的求值顺序</strong>：<font color=\"red\"><strong>&amp;&amp;(逻辑与) ||(逻辑或) ?:(条件运算符) ,(逗号运算符)。</strong></font></p>\n<h3 id=\"求值顺序、优先级、结合律\"><a href=\"#求值顺序、优先级、结合律\" class=\"headerlink\" title=\"求值顺序、优先级、结合律\"></a>求值顺序、优先级、结合律</h3><p>运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中：</p>\n<ul>\n<li>优先级规定，g()的返回值和h()的返回值相乘。</li>\n<li>结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。</li>\n<li>对于这些函数的调用顺序没有明确规定。</li>\n</ul>\n<p>如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。</p>\n<p><strong>建议：</strong> 处理复合表达式以下两条经验准则对书写复合表达式有益：</p>\n<ul>\n<li>拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。</li>\n<li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</li>\n</ul>\n<p>第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"%运算符\"></a>%运算符</h3><p>如果m%n不等于0，则它的符号和m相同。</p>\n<pre><code>m%(-n)  等于  m%n\n(-m)%n  等于 -(m%n)\n-21 % -8 = -5\n21 % -5 = 1\n</code></pre><h2 id=\"逻辑和关系运算符\"><a href=\"#逻辑和关系运算符\" class=\"headerlink\" title=\"逻辑和关系运算符\"></a>逻辑和关系运算符</h2><p><strong>逻辑与(&amp;&amp;)和逻辑或(||)</strong> 都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 <strong>短路求值</strong>。</p>\n<p>text是存储这string对象的vector，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//s是对常量的引用；元素既没有被拷贝也不会被改变</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;s : text) &#123;  </div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;s;</div><div class=\"line\">    <span class=\"keyword\">if</span>(s.empty()||s[s.size()<span class=\"number\">-1</span>] == <span class=\"string\">'.'</span>)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>值得注意的是</strong>，s被声明成对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以声明成对常量的引用。</p>\n<h3 id=\"优先级注意\"><a href=\"#优先级注意\" class=\"headerlink\" title=\"优先级注意\"></a>优先级注意</h3><font color=\"red\"> <strong>算数运算符&gt;关系运算符&gt;逻辑运算符</strong> </font>\n\n<h3 id=\"赋值运算符满足右结合律\"><a href=\"#赋值运算符满足右结合律\" class=\"headerlink\" title=\"赋值运算符满足右结合律\"></a>赋值运算符满足右结合律</h3><p>赋值运算符满足右结合律，这一点与其他二元运算符不太一样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival,jval;</div><div class=\"line\">ival = jval = <span class=\"number\">0</span>;    <span class=\"comment\">//正确，都被赋值为0</span></div></pre></td></tr></table></figure>\n<p>因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0作为靠左的赋值运算符的右侧运算对象。又因为<strong>赋值运算符返回的是其左侧运算对象</strong>，所以靠右的赋值运算的结果（jval=2返回的结果为左侧运算对象jval）被赋给了ival。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;(jval = <span class=\"number\">2</span>)&lt;&lt;<span class=\"built_in\">endl</span>;      <span class=\"comment\">// 输出2</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"赋值运算符优先级较低\"><a href=\"#赋值运算符优先级较低\" class=\"headerlink\" title=\"赋值运算符优先级较低\"></a>赋值运算符优先级较低</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i ;</div><div class=\"line\"><span class=\"comment\">//一种很好的写法</span></div><div class=\"line\"><span class=\"keyword\">while</span>((i=get_value()) != <span class=\"number\">42</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">//其他处理</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。</p>\n<h2 id=\"递增和递减运算符\"><a href=\"#递增和递减运算符\" class=\"headerlink\" title=\"递增和递减运算符\"></a>递增和递减运算符</h2><p>递增和递减有两种形式：前置版本和后置版本。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i =<span class=\"number\">0</span>,j;</div><div class=\"line\">j = ++i;              <span class=\"comment\">//j = 1,i = 1;   前置版本得到递增之后的值</span></div><div class=\"line\">j = i++;              <span class=\"comment\">//j = 1,i = 2;   后置版本得到递增之前的值</span></div></pre></td></tr></table></figure>\n<p><strong>区别：前置版本将对象本身作为左值返回，后置版本则将对象的原始副本作为右值返回。</strong></p>\n<font color=\"red\"> <strong>建议：除非必须，否则不用递增递减运算符的后置版本</strong> </font>                      \n\n<p>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，<strong>后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</strong></p>\n<p>对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。</p>\n<h2 id=\"混用解引用和递增运算符\"><a href=\"#混用解引用和递增运算符\" class=\"headerlink\" title=\"混用解引用和递增运算符\"></a>混用解引用和递增运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//推荐写法</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;*iter++&lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//等价于*(iter++)</span></div></pre></td></tr></table></figure>\n<p>后置运算符的优先级高于解引用运算符。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vec[ival++] &lt;= vec[ival];        <span class=\"comment\">//未定义的错误，先求左侧的值还是先求右侧的值不确定</span></div></pre></td></tr></table></figure>\n<h2 id=\"成员访问运算符\"><a href=\"#成员访问运算符\" class=\"headerlink\" title=\"成员访问运算符\"></a>成员访问运算符</h2><p>点运算符和箭头运算符都可用与访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，<font color=\"red\">表达式ptr-&gt;men等价于(*ptr)mem </font> :</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s1 = <span class=\"string\">\"a string\"</span>, *p = &amp;s1;</div><div class=\"line\"><span class=\"keyword\">auto</span> n = s1.size();        </div><div class=\"line\">n = (*p).size();        <span class=\"comment\">//运行p所指对象的size成员</span></div><div class=\"line\">n = p-&gt;size();          <span class=\"comment\">//等价于(*p).size()</span></div></pre></td></tr></table></figure>\n<p><strong>注意：解引用运算符的优先级低于点运算符。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">*p.size()          <span class=\"comment\">// 错误，p是一个指针，它没有名为size的成员</span></div></pre></td></tr></table></figure>\n<h2 id=\"条件运算符\"><a href=\"#条件运算符\" class=\"headerlink\" title=\"条件运算符\"></a>条件运算符</h2><p><strong>优先级</strong></p>\n<p><strong>条件运算符优先级高于赋值、逗号运算符，低于其他运算符。</strong></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">m&lt;n ? x : a+3                等价于：(m&lt;n) ?(x) :(a+3)</div><div class=\"line\">a++&gt;=10 &amp;&amp; b--&gt;20 ? a : b    等价于：(a++&gt;=10 &amp;&amp; b--&gt;20) ? a : b</div><div class=\"line\">x=3+a&gt;5 ? 100 : 200          等价于：x= (( 3+a&gt;5 ) ? 100 : 200 )</div></pre></td></tr></table></figure></p>\n<p><strong>结合性</strong></p>\n<p><strong>条件运算符具有右结合性。</strong></p>\n<p>当一个表达式中出现多个条件运算符时，应该将位于最右边的问号与离它最近的冒号配对，并按这一原则正确区分各条件运算符的运算对象。</p>\n<p>例如：</p>\n<pre><code> w&lt;x ? x+w : x&lt;y ? x : y\n与 w&lt;x ? x+w : ( x&lt;y ? x : y) 等价\n与 (w&lt;x ? x+w : x&lt;y) ? x : y 不等价\n</code></pre><font color=\"red\">注意： 随着条件运算嵌套的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。 </font>\n\n\n<h2 id=\"位运算符（基础，待补充）\"><a href=\"#位运算符（基础，待补充）\" class=\"headerlink\" title=\"位运算符（基础，待补充）\"></a>位运算符（基础，待补充）</h2><p>一个使用位运算符的例子</p>\n<p>假设一个班级有30个学生,我们用一个二进制位来代表某个学生在依次测试中是否通过，显然全班的测试结果可以用一个无符号整数来表示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> quizl = <span class=\"number\">0</span> ;          <span class=\"comment\">//我们把这个值当成是位的集合来使用</span></div></pre></td></tr></table></figure>\n<p>将quizl类型定义位unsigned long，这样，quizl在任何机器上都将至少拥有32位；给quizl赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1UL是一个unsigned long类型的整数字面值1</span></div><div class=\"line\"><span class=\"comment\">//1UL&lt;&lt;27;    生成一个值，该值只有第27位为1</span></div><div class=\"line\">quizl |= <span class=\"number\">1U</span>L&lt;&lt;<span class=\"number\">27</span>;        <span class=\"comment\">//表示学生27通过了测试</span></div><div class=\"line\"></div><div class=\"line\">quizl &amp;= ~(<span class=\"number\">1U</span>L&lt;&lt;<span class=\"number\">27</span>);     <span class=\"comment\">//学生27未通过测试</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> status = quizl &amp; (<span class=\"number\">1U</span>L&lt;&lt;<span class=\"number\">27</span>);   <span class=\"comment\">//学生27是否通过了测试？</span></div></pre></td></tr></table></figure>\n<h2 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof\"></a>sizeof</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得到的值是一个size_t类型的常量表达式。</p>\n<p>sizeof的三种语法形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">sizeof</span>(object);        <span class=\"comment\">//sizeof(对象);</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span>(type_name);     <span class=\"comment\">//sizeof(类型);</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span> object;         <span class=\"comment\">//sizeof对象;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i;</div><div class=\"line\"><span class=\"keyword\">sizeof</span>(i);     <span class=\"comment\">//ok</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span> i;      <span class=\"comment\">//ok</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);   <span class=\"comment\">//ok</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span> <span class=\"keyword\">int</span>;    <span class=\"comment\">//error</span></div></pre></td></tr></table></figure>\n<p>既然写法3可以用写法1代替，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">sizeof</span>(*p);          <span class=\"comment\">//指针所占的空间大小，与指针指向的类型无关</span></div></pre></td></tr></table></figure>\n<p>sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针也不会有什么影响，在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。</p>\n<p>C++11新标准允许我们使用作用域来获取成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象。因为要想知道类成员的大小无须真的获取该成员。</p>\n<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>\n<ul>\n<li>对char或者类型为char的表达式指向sizeof运算，结果为1；</li>\n<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小；</li>\n<li>对指针指向sizeof运算得到指针本身所占空间的大小；</li>\n<li>对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效。</li>\n<li>对数组执行sizeof运算限制得到整个数组所占空间的大小，等价于对数组这所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理</li>\n<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>\n</ul>\n<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sizeof(ia)/sizeof(*ia)返回ia的元素数量  </span></div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">size_t</span> sz = <span class=\"keyword\">sizeof</span>(ia)/<span class=\"keyword\">sizeof</span>(*ia);  </div><div class=\"line\"><span class=\"keyword\">int</span> arr2[sz];   <span class=\"comment\">// 正确：sizeof返回一个常量表达式</span></div></pre></td></tr></table></figure>\n<p>因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>介绍C++中常见的表达式。</p>","more":"<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"组合运算符和运算对象\"><a href=\"#组合运算符和运算对象\" class=\"headerlink\" title=\"组合运算符和运算对象\"></a>组合运算符和运算对象</h3><p>对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解<strong>运算符的优先级、结合律以及运算对象的求值顺序。</strong></p>\n<h3 id=\"重载运算符\"><a href=\"#重载运算符\" class=\"headerlink\" title=\"重载运算符\"></a>重载运算符</h3><h3 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h3><p>左值可以位于赋值语句的左侧、右值则不能。</p>\n<p>当一个对象被用于右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的为止）。</p>\n<h3 id=\"求值顺序（重点）\"><a href=\"#求值顺序（重点）\" class=\"headerlink\" title=\"求值顺序（重点）\"></a>求值顺序（重点）</h3><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = f1()*f2();</div></pre></td></tr></table></figure>\n<p>我们是无法知道到底f1在f2之前调用还是f2在f1之前调用。</p>\n<p>对于那些没有指定执行顺序的运算符来讲，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;++i&lt;&lt;<span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure>\n<p>表达是的行为不可预知，编译器执行i或者++i的顺序是未知的。</p>\n<p><strong>以下4中运算符明确规定了运算对象的求值顺序</strong>：<font color=\"red\"><strong>&amp;&amp;(逻辑与) ||(逻辑或) ?:(条件运算符) ,(逗号运算符)。</strong></font></p>\n<h3 id=\"求值顺序、优先级、结合律\"><a href=\"#求值顺序、优先级、结合律\" class=\"headerlink\" title=\"求值顺序、优先级、结合律\"></a>求值顺序、优先级、结合律</h3><p>运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中：</p>\n<ul>\n<li>优先级规定，g()的返回值和h()的返回值相乘。</li>\n<li>结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。</li>\n<li>对于这些函数的调用顺序没有明确规定。</li>\n</ul>\n<p>如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。</p>\n<p><strong>建议：</strong> 处理复合表达式以下两条经验准则对书写复合表达式有益：</p>\n<ul>\n<li>拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。</li>\n<li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</li>\n</ul>\n<p>第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"%运算符\"></a>%运算符</h3><p>如果m%n不等于0，则它的符号和m相同。</p>\n<pre><code>m%(-n)  等于  m%n\n(-m)%n  等于 -(m%n)\n-21 % -8 = -5\n21 % -5 = 1\n</code></pre><h2 id=\"逻辑和关系运算符\"><a href=\"#逻辑和关系运算符\" class=\"headerlink\" title=\"逻辑和关系运算符\"></a>逻辑和关系运算符</h2><p><strong>逻辑与(&amp;&amp;)和逻辑或(||)</strong> 都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 <strong>短路求值</strong>。</p>\n<p>text是存储这string对象的vector，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//s是对常量的引用；元素既没有被拷贝也不会被改变</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;s : text) &#123;  </div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;s;</div><div class=\"line\">    <span class=\"keyword\">if</span>(s.empty()||s[s.size()<span class=\"number\">-1</span>] == <span class=\"string\">'.'</span>)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>值得注意的是</strong>，s被声明成对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以声明成对常量的引用。</p>\n<h3 id=\"优先级注意\"><a href=\"#优先级注意\" class=\"headerlink\" title=\"优先级注意\"></a>优先级注意</h3><font color=\"red\"> <strong>算数运算符&gt;关系运算符&gt;逻辑运算符</strong> </font>\n\n<h3 id=\"赋值运算符满足右结合律\"><a href=\"#赋值运算符满足右结合律\" class=\"headerlink\" title=\"赋值运算符满足右结合律\"></a>赋值运算符满足右结合律</h3><p>赋值运算符满足右结合律，这一点与其他二元运算符不太一样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ival,jval;</div><div class=\"line\">ival = jval = <span class=\"number\">0</span>;    <span class=\"comment\">//正确，都被赋值为0</span></div></pre></td></tr></table></figure>\n<p>因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0作为靠左的赋值运算符的右侧运算对象。又因为<strong>赋值运算符返回的是其左侧运算对象</strong>，所以靠右的赋值运算的结果（jval=2返回的结果为左侧运算对象jval）被赋给了ival。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;(jval = <span class=\"number\">2</span>)&lt;&lt;<span class=\"built_in\">endl</span>;      <span class=\"comment\">// 输出2</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"赋值运算符优先级较低\"><a href=\"#赋值运算符优先级较低\" class=\"headerlink\" title=\"赋值运算符优先级较低\"></a>赋值运算符优先级较低</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i ;</div><div class=\"line\"><span class=\"comment\">//一种很好的写法</span></div><div class=\"line\"><span class=\"keyword\">while</span>((i=get_value()) != <span class=\"number\">42</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">//其他处理</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。</p>\n<h2 id=\"递增和递减运算符\"><a href=\"#递增和递减运算符\" class=\"headerlink\" title=\"递增和递减运算符\"></a>递增和递减运算符</h2><p>递增和递减有两种形式：前置版本和后置版本。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i =<span class=\"number\">0</span>,j;</div><div class=\"line\">j = ++i;              <span class=\"comment\">//j = 1,i = 1;   前置版本得到递增之后的值</span></div><div class=\"line\">j = i++;              <span class=\"comment\">//j = 1,i = 2;   后置版本得到递增之前的值</span></div></pre></td></tr></table></figure>\n<p><strong>区别：前置版本将对象本身作为左值返回，后置版本则将对象的原始副本作为右值返回。</strong></p>\n<font color=\"red\"> <strong>建议：除非必须，否则不用递增递减运算符的后置版本</strong> </font>                      \n\n<p>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，<strong>后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</strong></p>\n<p>对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。</p>\n<h2 id=\"混用解引用和递增运算符\"><a href=\"#混用解引用和递增运算符\" class=\"headerlink\" title=\"混用解引用和递增运算符\"></a>混用解引用和递增运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//推荐写法</span></div><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;*iter++&lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//等价于*(iter++)</span></div></pre></td></tr></table></figure>\n<p>后置运算符的优先级高于解引用运算符。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vec[ival++] &lt;= vec[ival];        <span class=\"comment\">//未定义的错误，先求左侧的值还是先求右侧的值不确定</span></div></pre></td></tr></table></figure>\n<h2 id=\"成员访问运算符\"><a href=\"#成员访问运算符\" class=\"headerlink\" title=\"成员访问运算符\"></a>成员访问运算符</h2><p>点运算符和箭头运算符都可用与访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，<font color=\"red\">表达式ptr-&gt;men等价于(*ptr)mem </font> :</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s1 = <span class=\"string\">\"a string\"</span>, *p = &amp;s1;</div><div class=\"line\"><span class=\"keyword\">auto</span> n = s1.size();        </div><div class=\"line\">n = (*p).size();        <span class=\"comment\">//运行p所指对象的size成员</span></div><div class=\"line\">n = p-&gt;size();          <span class=\"comment\">//等价于(*p).size()</span></div></pre></td></tr></table></figure>\n<p><strong>注意：解引用运算符的优先级低于点运算符。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">*p.size()          <span class=\"comment\">// 错误，p是一个指针，它没有名为size的成员</span></div></pre></td></tr></table></figure>\n<h2 id=\"条件运算符\"><a href=\"#条件运算符\" class=\"headerlink\" title=\"条件运算符\"></a>条件运算符</h2><p><strong>优先级</strong></p>\n<p><strong>条件运算符优先级高于赋值、逗号运算符，低于其他运算符。</strong></p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">m&lt;n ? x : a+3                等价于：(m&lt;n) ?(x) :(a+3)</div><div class=\"line\">a++&gt;=10 &amp;&amp; b--&gt;20 ? a : b    等价于：(a++&gt;=10 &amp;&amp; b--&gt;20) ? a : b</div><div class=\"line\">x=3+a&gt;5 ? 100 : 200          等价于：x= (( 3+a&gt;5 ) ? 100 : 200 )</div></pre></td></tr></table></figure></p>\n<p><strong>结合性</strong></p>\n<p><strong>条件运算符具有右结合性。</strong></p>\n<p>当一个表达式中出现多个条件运算符时，应该将位于最右边的问号与离它最近的冒号配对，并按这一原则正确区分各条件运算符的运算对象。</p>\n<p>例如：</p>\n<pre><code> w&lt;x ? x+w : x&lt;y ? x : y\n与 w&lt;x ? x+w : ( x&lt;y ? x : y) 等价\n与 (w&lt;x ? x+w : x&lt;y) ? x : y 不等价\n</code></pre><font color=\"red\">注意： 随着条件运算嵌套的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。 </font>\n\n\n<h2 id=\"位运算符（基础，待补充）\"><a href=\"#位运算符（基础，待补充）\" class=\"headerlink\" title=\"位运算符（基础，待补充）\"></a>位运算符（基础，待补充）</h2><p>一个使用位运算符的例子</p>\n<p>假设一个班级有30个学生,我们用一个二进制位来代表某个学生在依次测试中是否通过，显然全班的测试结果可以用一个无符号整数来表示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> quizl = <span class=\"number\">0</span> ;          <span class=\"comment\">//我们把这个值当成是位的集合来使用</span></div></pre></td></tr></table></figure>\n<p>将quizl类型定义位unsigned long，这样，quizl在任何机器上都将至少拥有32位；给quizl赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1UL是一个unsigned long类型的整数字面值1</span></div><div class=\"line\"><span class=\"comment\">//1UL&lt;&lt;27;    生成一个值，该值只有第27位为1</span></div><div class=\"line\">quizl |= <span class=\"number\">1U</span>L&lt;&lt;<span class=\"number\">27</span>;        <span class=\"comment\">//表示学生27通过了测试</span></div><div class=\"line\"></div><div class=\"line\">quizl &amp;= ~(<span class=\"number\">1U</span>L&lt;&lt;<span class=\"number\">27</span>);     <span class=\"comment\">//学生27未通过测试</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">bool</span> status = quizl &amp; (<span class=\"number\">1U</span>L&lt;&lt;<span class=\"number\">27</span>);   <span class=\"comment\">//学生27是否通过了测试？</span></div></pre></td></tr></table></figure>\n<h2 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof\"></a>sizeof</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得到的值是一个size_t类型的常量表达式。</p>\n<p>sizeof的三种语法形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">sizeof</span>(object);        <span class=\"comment\">//sizeof(对象);</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span>(type_name);     <span class=\"comment\">//sizeof(类型);</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span> object;         <span class=\"comment\">//sizeof对象;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i;</div><div class=\"line\"><span class=\"keyword\">sizeof</span>(i);     <span class=\"comment\">//ok</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span> i;      <span class=\"comment\">//ok</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);   <span class=\"comment\">//ok</span></div><div class=\"line\"><span class=\"keyword\">sizeof</span> <span class=\"keyword\">int</span>;    <span class=\"comment\">//error</span></div></pre></td></tr></table></figure>\n<p>既然写法3可以用写法1代替，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">sizeof</span>(*p);          <span class=\"comment\">//指针所占的空间大小，与指针指向的类型无关</span></div></pre></td></tr></table></figure>\n<p>sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针也不会有什么影响，在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。</p>\n<p>C++11新标准允许我们使用作用域来获取成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象。因为要想知道类成员的大小无须真的获取该成员。</p>\n<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>\n<ul>\n<li>对char或者类型为char的表达式指向sizeof运算，结果为1；</li>\n<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小；</li>\n<li>对指针指向sizeof运算得到指针本身所占空间的大小；</li>\n<li>对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效。</li>\n<li>对数组执行sizeof运算限制得到整个数组所占空间的大小，等价于对数组这所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理</li>\n<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>\n</ul>\n<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sizeof(ia)/sizeof(*ia)返回ia的元素数量  </span></div><div class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">size_t</span> sz = <span class=\"keyword\">sizeof</span>(ia)/<span class=\"keyword\">sizeof</span>(*ia);  </div><div class=\"line\"><span class=\"keyword\">int</span> arr2[sz];   <span class=\"comment\">// 正确：sizeof返回一个常量表达式</span></div></pre></td></tr></table></figure>\n<p>因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。</p>"},{"title":"OOP概述（object-oriented programming）","date":"2017-11-19T13:59:00.000Z","update":null,"comments":1,"_content":"\n## 前言\n\n面向对象程序设计基于三个基本概念：**数据抽象、继承和动态绑定**。\n\n<!--more-->\n\n**继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。**\n\n## OOP：概述\n\n面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。\n\n### 继承\n\n通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。\n\n在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。\n\n### 动态绑定\n\n函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为**运行时绑定**。\n\n**note:** **在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定**。\n\n\n## 定义基类和派生类\n\n**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。**\n\n### 成员函数和继承\n\n派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以**覆盖**（override）从基类继承而来的旧定义。\n\n在C++语言中，基类必须将它的两种成员函数区分开来：**一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数**。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，**该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。**\n\n基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。**任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。**\n\n成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。\n\n### 访问控制与继承\n\n派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，**派生类能访问公用成员，而不能访问私有成员**。不过在某些时候基类中还有这样一种成员，**基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员**。\n\n- private member: base class itself and friend can access\n- protected members: base class itself,friend and derived classes can access\n\n## 定义派生类\n\n派生类必须通过使用**派生类列表**明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。\n\n如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。\n\n### 派生类中的虚函数\n\n派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。\n\nC++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字**override**。\n\n\n### 派生类对象及派生类向基类的类型转换\n\n一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。\n\n**在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。**\n\n### 派生类构造函数\n\n尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。\n\n```C++\n//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分\n    Bulk_quote(const string& book,double p,size_t qty,double disc):Quote(book,p),min_qty(qty),discount(disc) {}\n```\n\n<font color=red> **首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员** </font>\n\n\n### 派生类使用基类的成员\n\n**派生类可以访问基类的公有成员和受保护成员**：\n\n其中price是基类中的受保护成员\n\n```C++\n//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了\ndouble Bulk_quote::net_price(size_t cnt) const {\n    if(cnt >= min_qty) {\n        return cnt*(1-discount)*price;\n    }else{\n        return cnt*price;\n    }\n}\n```\n\n**遵循基类的接口**\n\n必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。\n\n因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。\n\n### 继承与静态成员\n\n如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。\n\n```C++\nclass Base{\npublic:\n    static void statmem();\n};\nclass Derived:public Base{\n    void f(const Derived&);\n};\n```\n\n静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它：\n\n```\nvoid Derived::f(const Derived &derived_obj){\n    Base::statmem();\n    Derived::statmem();\n    derived_obj.statmem();\n    statmem();         //通过this对象访问\n}\n```\n\n### 派生类的声明\n\n如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。\n\n一个类不能派生它本身。\n\n### 防止继承发生\n\n有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，**即在类名后跟一个关键字final**。\n\n\n## 类型抓换与继承\n\n**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。**\n\n通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：**我们可以将基类的指针或引用绑定到派生类对象上**。\n\n可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。\n\n### 不存在从基类向派生类的隐式类型转换\n\n\n因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换：\n\n```C++\nQuote base;\nBulk_quote* bulkP = &base;    //错误：不能将基类转换成派生类\nBulk_quote* bulkRef = base;   //错误：不能将基类转换成派生类\n```\n除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：\n\n```C++\nBulk_quote bulk;\nQuote *itemP = &bulk;      //正确：动态类型是Bulk_quote\nBulk_quote *bulkP = itemP;      //错误：不能将基类转换成派生类\n```\n\n### 在对象之间不存在类型转换\n\n派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。\n\n```C++\nBulk_quote bulk;      //派生类对象\nQuote item(bulk);     //使用Quote::Quote(const Quote&)  构造函数\nitem = bulk;          //调用Quote::operator=(const Quote&)\n```\n当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。\n\n**关键概念：存在继承关系的类型之间的转换规则**\n\n1、从派生类向基类的类型转换只对指针或引用类型有效。\n\n2、基类向派生类不存在隐式类型转换。\n\n3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。\n\n尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。\n\n\n\n","source":"_posts/OOP概述（object-oriented-programming）.md","raw":"---\ntitle: OOP概述（object-oriented programming）\ndate: 2017-11-19 21:59:00\nupdate: \ntags: [OOP]\ncategories: C++\ncomments: true\n---\n\n## 前言\n\n面向对象程序设计基于三个基本概念：**数据抽象、继承和动态绑定**。\n\n<!--more-->\n\n**继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。**\n\n## OOP：概述\n\n面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。\n\n### 继承\n\n通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。\n\n在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。\n\n### 动态绑定\n\n函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为**运行时绑定**。\n\n**note:** **在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定**。\n\n\n## 定义基类和派生类\n\n**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。**\n\n### 成员函数和继承\n\n派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以**覆盖**（override）从基类继承而来的旧定义。\n\n在C++语言中，基类必须将它的两种成员函数区分开来：**一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数**。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，**该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。**\n\n基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。**任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。**\n\n成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。\n\n### 访问控制与继承\n\n派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，**派生类能访问公用成员，而不能访问私有成员**。不过在某些时候基类中还有这样一种成员，**基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员**。\n\n- private member: base class itself and friend can access\n- protected members: base class itself,friend and derived classes can access\n\n## 定义派生类\n\n派生类必须通过使用**派生类列表**明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。\n\n如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。\n\n### 派生类中的虚函数\n\n派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。\n\nC++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字**override**。\n\n\n### 派生类对象及派生类向基类的类型转换\n\n一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。\n\n**在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。**\n\n### 派生类构造函数\n\n尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。\n\n```C++\n//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分\n    Bulk_quote(const string& book,double p,size_t qty,double disc):Quote(book,p),min_qty(qty),discount(disc) {}\n```\n\n<font color=red> **首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员** </font>\n\n\n### 派生类使用基类的成员\n\n**派生类可以访问基类的公有成员和受保护成员**：\n\n其中price是基类中的受保护成员\n\n```C++\n//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了\ndouble Bulk_quote::net_price(size_t cnt) const {\n    if(cnt >= min_qty) {\n        return cnt*(1-discount)*price;\n    }else{\n        return cnt*price;\n    }\n}\n```\n\n**遵循基类的接口**\n\n必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。\n\n因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。\n\n### 继承与静态成员\n\n如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。\n\n```C++\nclass Base{\npublic:\n    static void statmem();\n};\nclass Derived:public Base{\n    void f(const Derived&);\n};\n```\n\n静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它：\n\n```\nvoid Derived::f(const Derived &derived_obj){\n    Base::statmem();\n    Derived::statmem();\n    derived_obj.statmem();\n    statmem();         //通过this对象访问\n}\n```\n\n### 派生类的声明\n\n如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。\n\n一个类不能派生它本身。\n\n### 防止继承发生\n\n有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，**即在类名后跟一个关键字final**。\n\n\n## 类型抓换与继承\n\n**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。**\n\n通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：**我们可以将基类的指针或引用绑定到派生类对象上**。\n\n可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。\n\n### 不存在从基类向派生类的隐式类型转换\n\n\n因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换：\n\n```C++\nQuote base;\nBulk_quote* bulkP = &base;    //错误：不能将基类转换成派生类\nBulk_quote* bulkRef = base;   //错误：不能将基类转换成派生类\n```\n除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：\n\n```C++\nBulk_quote bulk;\nQuote *itemP = &bulk;      //正确：动态类型是Bulk_quote\nBulk_quote *bulkP = itemP;      //错误：不能将基类转换成派生类\n```\n\n### 在对象之间不存在类型转换\n\n派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。\n\n```C++\nBulk_quote bulk;      //派生类对象\nQuote item(bulk);     //使用Quote::Quote(const Quote&)  构造函数\nitem = bulk;          //调用Quote::operator=(const Quote&)\n```\n当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。\n\n**关键概念：存在继承关系的类型之间的转换规则**\n\n1、从派生类向基类的类型转换只对指针或引用类型有效。\n\n2、基类向派生类不存在隐式类型转换。\n\n3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。\n\n尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。\n\n\n\n","slug":"OOP概述（object-oriented-programming）","published":1,"updated":"2018-02-22T13:23:07.219Z","layout":"post","photos":[],"link":"","_id":"cjdz6yqtr00007wc9ojqyx5x5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面向对象程序设计基于三个基本概念：<strong>数据抽象、继承和动态绑定</strong>。</p>\n<a id=\"more\"></a>\n<p><strong>继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。</strong></p>\n<h2 id=\"OOP：概述\"><a href=\"#OOP：概述\" class=\"headerlink\" title=\"OOP：概述\"></a>OOP：概述</h2><p>面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为<strong>派生类</strong>。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>\n<p>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>。</p>\n<h3 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h3><p>函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为<strong>运行时绑定</strong>。</p>\n<p><strong>note:</strong> <strong>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong>。</p>\n<h2 id=\"定义基类和派生类\"><a href=\"#定义基类和派生类\" class=\"headerlink\" title=\"定义基类和派生类\"></a>定义基类和派生类</h2><p><strong>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</strong></p>\n<h3 id=\"成员函数和继承\"><a href=\"#成员函数和继承\" class=\"headerlink\" title=\"成员函数和继承\"></a>成员函数和继承</h3><p>派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以<strong>覆盖</strong>（override）从基类继承而来的旧定义。</p>\n<p>在C++语言中，基类必须将它的两种成员函数区分开来：<strong>一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数</strong>。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，<strong>该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</strong></p>\n<p>基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。<strong>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</strong></p>\n<p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>\n<h3 id=\"访问控制与继承\"><a href=\"#访问控制与继承\" class=\"headerlink\" title=\"访问控制与继承\"></a>访问控制与继承</h3><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，<strong>派生类能访问公用成员，而不能访问私有成员</strong>。不过在某些时候基类中还有这样一种成员，<strong>基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员</strong>。</p>\n<ul>\n<li>private member: base class itself and friend can access</li>\n<li>protected members: base class itself,friend and derived classes can access</li>\n</ul>\n<h2 id=\"定义派生类\"><a href=\"#定义派生类\" class=\"headerlink\" title=\"定义派生类\"></a>定义派生类</h2><p>派生类必须通过使用<strong>派生类列表</strong>明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。</p>\n<p>如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。</p>\n<h3 id=\"派生类中的虚函数\"><a href=\"#派生类中的虚函数\" class=\"headerlink\" title=\"派生类中的虚函数\"></a>派生类中的虚函数</h3><p>派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>\n<p>C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字<strong>override</strong>。</p>\n<h3 id=\"派生类对象及派生类向基类的类型转换\"><a href=\"#派生类对象及派生类向基类的类型转换\" class=\"headerlink\" title=\"派生类对象及派生类向基类的类型转换\"></a>派生类对象及派生类向基类的类型转换</h3><p>一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>\n<p><strong>在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。</strong></p>\n<h3 id=\"派生类构造函数\"><a href=\"#派生类构造函数\" class=\"headerlink\" title=\"派生类构造函数\"></a>派生类构造函数</h3><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分</span></div><div class=\"line\">    Bulk_quote(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; book,<span class=\"keyword\">double</span> p,<span class=\"keyword\">size_t</span> qty,<span class=\"keyword\">double</span> disc):Quote(book,p),min_qty(qty),discount(disc) &#123;&#125;</div></pre></td></tr></table></figure>\n<font color=\"red\"> <strong>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</strong> </font>\n\n\n<h3 id=\"派生类使用基类的成员\"><a href=\"#派生类使用基类的成员\" class=\"headerlink\" title=\"派生类使用基类的成员\"></a>派生类使用基类的成员</h3><p><strong>派生类可以访问基类的公有成员和受保护成员</strong>：</p>\n<p>其中price是基类中的受保护成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></div><div class=\"line\"><span class=\"keyword\">double</span> Bulk_quote::net_price(<span class=\"keyword\">size_t</span> cnt) <span class=\"keyword\">const</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(cnt &gt;= min_qty) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> cnt*(<span class=\"number\">1</span>-discount)*price;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> cnt*price;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>遵循基类的接口</strong></p>\n<p>必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。</p>\n<p>因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>\n<h3 id=\"继承与静态成员\"><a href=\"#继承与静态成员\" class=\"headerlink\" title=\"继承与静态成员\"></a>继承与静态成员</h3><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">statmem</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">const</span> Derived&amp;)</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Derived::f(const Derived &amp;derived_obj)&#123;</div><div class=\"line\">    Base::statmem();</div><div class=\"line\">    Derived::statmem();</div><div class=\"line\">    derived_obj.statmem();</div><div class=\"line\">    statmem();         //通过this对象访问</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"派生类的声明\"><a href=\"#派生类的声明\" class=\"headerlink\" title=\"派生类的声明\"></a>派生类的声明</h3><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p>\n<p>一个类不能派生它本身。</p>\n<h3 id=\"防止继承发生\"><a href=\"#防止继承发生\" class=\"headerlink\" title=\"防止继承发生\"></a>防止继承发生</h3><p>有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，<strong>即在类名后跟一个关键字final</strong>。</p>\n<h2 id=\"类型抓换与继承\"><a href=\"#类型抓换与继承\" class=\"headerlink\" title=\"类型抓换与继承\"></a>类型抓换与继承</h2><p><strong>理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。</strong></p>\n<p>通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：<strong>我们可以将基类的指针或引用绑定到派生类对象上</strong>。</p>\n<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>\n<h3 id=\"不存在从基类向派生类的隐式类型转换\"><a href=\"#不存在从基类向派生类的隐式类型转换\" class=\"headerlink\" title=\"不存在从基类向派生类的隐式类型转换\"></a>不存在从基类向派生类的隐式类型转换</h3><p>因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Quote base;</div><div class=\"line\">Bulk_quote* bulkP = &amp;base;    <span class=\"comment\">//错误：不能将基类转换成派生类</span></div><div class=\"line\">Bulk_quote* bulkRef = base;   <span class=\"comment\">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>\n<p>除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bulk_quote bulk;</div><div class=\"line\">Quote *itemP = &amp;bulk;      <span class=\"comment\">//正确：动态类型是Bulk_quote</span></div><div class=\"line\">Bulk_quote *bulkP = itemP;      <span class=\"comment\">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>\n<h3 id=\"在对象之间不存在类型转换\"><a href=\"#在对象之间不存在类型转换\" class=\"headerlink\" title=\"在对象之间不存在类型转换\"></a>在对象之间不存在类型转换</h3><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bulk_quote bulk;      <span class=\"comment\">//派生类对象</span></div><div class=\"line\"><span class=\"function\">Quote <span class=\"title\">item</span><span class=\"params\">(bulk)</span></span>;     <span class=\"comment\">//使用Quote::Quote(const Quote&amp;)  构造函数</span></div><div class=\"line\">item = bulk;          <span class=\"comment\">//调用Quote::operator=(const Quote&amp;)</span></div></pre></td></tr></table></figure>\n<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>\n<p><strong>关键概念：存在继承关系的类型之间的转换规则</strong></p>\n<p>1、从派生类向基类的类型转换只对指针或引用类型有效。</p>\n<p>2、基类向派生类不存在隐式类型转换。</p>\n<p>3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。</p>\n<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面向对象程序设计基于三个基本概念：<strong>数据抽象、继承和动态绑定</strong>。</p>","more":"<p><strong>继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。</strong></p>\n<h2 id=\"OOP：概述\"><a href=\"#OOP：概述\" class=\"headerlink\" title=\"OOP：概述\"></a>OOP：概述</h2><p>面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为<strong>派生类</strong>。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>\n<p>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>。</p>\n<h3 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h3><p>函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为<strong>运行时绑定</strong>。</p>\n<p><strong>note:</strong> <strong>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong>。</p>\n<h2 id=\"定义基类和派生类\"><a href=\"#定义基类和派生类\" class=\"headerlink\" title=\"定义基类和派生类\"></a>定义基类和派生类</h2><p><strong>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</strong></p>\n<h3 id=\"成员函数和继承\"><a href=\"#成员函数和继承\" class=\"headerlink\" title=\"成员函数和继承\"></a>成员函数和继承</h3><p>派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以<strong>覆盖</strong>（override）从基类继承而来的旧定义。</p>\n<p>在C++语言中，基类必须将它的两种成员函数区分开来：<strong>一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数</strong>。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，<strong>该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</strong></p>\n<p>基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。<strong>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</strong></p>\n<p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>\n<h3 id=\"访问控制与继承\"><a href=\"#访问控制与继承\" class=\"headerlink\" title=\"访问控制与继承\"></a>访问控制与继承</h3><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，<strong>派生类能访问公用成员，而不能访问私有成员</strong>。不过在某些时候基类中还有这样一种成员，<strong>基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员</strong>。</p>\n<ul>\n<li>private member: base class itself and friend can access</li>\n<li>protected members: base class itself,friend and derived classes can access</li>\n</ul>\n<h2 id=\"定义派生类\"><a href=\"#定义派生类\" class=\"headerlink\" title=\"定义派生类\"></a>定义派生类</h2><p>派生类必须通过使用<strong>派生类列表</strong>明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。</p>\n<p>如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。</p>\n<h3 id=\"派生类中的虚函数\"><a href=\"#派生类中的虚函数\" class=\"headerlink\" title=\"派生类中的虚函数\"></a>派生类中的虚函数</h3><p>派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>\n<p>C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字<strong>override</strong>。</p>\n<h3 id=\"派生类对象及派生类向基类的类型转换\"><a href=\"#派生类对象及派生类向基类的类型转换\" class=\"headerlink\" title=\"派生类对象及派生类向基类的类型转换\"></a>派生类对象及派生类向基类的类型转换</h3><p>一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>\n<p><strong>在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。</strong></p>\n<h3 id=\"派生类构造函数\"><a href=\"#派生类构造函数\" class=\"headerlink\" title=\"派生类构造函数\"></a>派生类构造函数</h3><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分</span></div><div class=\"line\">    Bulk_quote(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; book,<span class=\"keyword\">double</span> p,<span class=\"keyword\">size_t</span> qty,<span class=\"keyword\">double</span> disc):Quote(book,p),min_qty(qty),discount(disc) &#123;&#125;</div></pre></td></tr></table></figure>\n<font color=\"red\"> <strong>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</strong> </font>\n\n\n<h3 id=\"派生类使用基类的成员\"><a href=\"#派生类使用基类的成员\" class=\"headerlink\" title=\"派生类使用基类的成员\"></a>派生类使用基类的成员</h3><p><strong>派生类可以访问基类的公有成员和受保护成员</strong>：</p>\n<p>其中price是基类中的受保护成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></div><div class=\"line\"><span class=\"keyword\">double</span> Bulk_quote::net_price(<span class=\"keyword\">size_t</span> cnt) <span class=\"keyword\">const</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(cnt &gt;= min_qty) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> cnt*(<span class=\"number\">1</span>-discount)*price;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> cnt*price;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>遵循基类的接口</strong></p>\n<p>必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。</p>\n<p>因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>\n<h3 id=\"继承与静态成员\"><a href=\"#继承与静态成员\" class=\"headerlink\" title=\"继承与静态成员\"></a>继承与静态成员</h3><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">statmem</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">const</span> Derived&amp;)</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Derived::f(const Derived &amp;derived_obj)&#123;</div><div class=\"line\">    Base::statmem();</div><div class=\"line\">    Derived::statmem();</div><div class=\"line\">    derived_obj.statmem();</div><div class=\"line\">    statmem();         //通过this对象访问</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"派生类的声明\"><a href=\"#派生类的声明\" class=\"headerlink\" title=\"派生类的声明\"></a>派生类的声明</h3><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p>\n<p>一个类不能派生它本身。</p>\n<h3 id=\"防止继承发生\"><a href=\"#防止继承发生\" class=\"headerlink\" title=\"防止继承发生\"></a>防止继承发生</h3><p>有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，<strong>即在类名后跟一个关键字final</strong>。</p>\n<h2 id=\"类型抓换与继承\"><a href=\"#类型抓换与继承\" class=\"headerlink\" title=\"类型抓换与继承\"></a>类型抓换与继承</h2><p><strong>理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。</strong></p>\n<p>通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：<strong>我们可以将基类的指针或引用绑定到派生类对象上</strong>。</p>\n<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>\n<h3 id=\"不存在从基类向派生类的隐式类型转换\"><a href=\"#不存在从基类向派生类的隐式类型转换\" class=\"headerlink\" title=\"不存在从基类向派生类的隐式类型转换\"></a>不存在从基类向派生类的隐式类型转换</h3><p>因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Quote base;</div><div class=\"line\">Bulk_quote* bulkP = &amp;base;    <span class=\"comment\">//错误：不能将基类转换成派生类</span></div><div class=\"line\">Bulk_quote* bulkRef = base;   <span class=\"comment\">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>\n<p>除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bulk_quote bulk;</div><div class=\"line\">Quote *itemP = &amp;bulk;      <span class=\"comment\">//正确：动态类型是Bulk_quote</span></div><div class=\"line\">Bulk_quote *bulkP = itemP;      <span class=\"comment\">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>\n<h3 id=\"在对象之间不存在类型转换\"><a href=\"#在对象之间不存在类型转换\" class=\"headerlink\" title=\"在对象之间不存在类型转换\"></a>在对象之间不存在类型转换</h3><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bulk_quote bulk;      <span class=\"comment\">//派生类对象</span></div><div class=\"line\"><span class=\"function\">Quote <span class=\"title\">item</span><span class=\"params\">(bulk)</span></span>;     <span class=\"comment\">//使用Quote::Quote(const Quote&amp;)  构造函数</span></div><div class=\"line\">item = bulk;          <span class=\"comment\">//调用Quote::operator=(const Quote&amp;)</span></div></pre></td></tr></table></figure>\n<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>\n<p><strong>关键概念：存在继承关系的类型之间的转换规则</strong></p>\n<p>1、从派生类向基类的类型转换只对指针或引用类型有效。</p>\n<p>2、基类向派生类不存在隐式类型转换。</p>\n<p>3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。</p>\n<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。</p>"},{"title":"对象移动","date":"2017-11-15T13:59:00.000Z","update":null,"comments":1,"_content":"\n## 对象移动\n\n新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。\n\n<!--more-->\n\n**noet:** 标准库容器、string和shared_ptr类及支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。\n\n### 右值引用\n\n为了支持移动操作，新标准引入了一种新的引用类型——**右值引用**，就是必须绑定到右值的引用。**我们通过&&而不是&来获得右值引用**。右值引用一个重要的特性就是**只能绑定到将要销毁的对象。**\n\n左值和右值是表达式的属性，一些表达式生成或要求左值，而另一些则生成或要求右值。**一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的是对象的值。**（**可以取地址的、有名字的就是左值；不能取地址的、没有名字的就是右值**。）**两者明显的区别就是左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象**。\n\n类似于常规引用（左值引用），一个右值引用也不过是某个对象的另一个名字而已。我们不能将左值引用绑定到要求转换的表达式、字面常量或是返回值的表达式，也不能把右值应用直接绑定到一个左值上。但是，**常量左值引用可以绑定到非常量左值、常量左值、右值，是一个万能引用类型**。不过相比右值引用所引用的右值，常量左值引用所引用的右值在它的“余生”中只能是只读的。\n\n```C++\nint i = 42;\nint &r = i;     //r引用i\nint &r2 = i*2;    //错误，i*2是一个右值\nint &&rr = i；    //错误，不能将一个右值引用绑定到一个左值上\nint &&rr2 = i*2;   //正确，将rr2绑定到一个乘法结果上\nconst int &r3 = i*2; //正确，将一个常量引用绑定到一个右值上\n```\n\n### 左值持久；右值短暂\n\n考虑左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。\n\n由于右值引用只能绑定到临时对象，我们得知\n\n- 所引用的对象将要被销毁\n- 该对象没有其他用户\n\n这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。\n\n**注意：** 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态\n\n### 变量时左值\n\n```C++\nint &&rr1 = 42;   //正确：字面值常量是右值\nint &&rr2 = rr1;   //错误：表达式rr1是左值\n```\n\n变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。\n\n### 标准库move函数\n\n我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为**move**的新标准库函数来**获得绑定到左值上的右值引用**，此函数定义在**头文件utility**中。\n\n```\nint &&rr3 = std::move(rr1);     //ok\n```\n\n**note:** 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。\n\n**warning:** 使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。\n\n## 移动构造函数和移动赋值运算符\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct X{\n    string i;       //内置类型可以移动\n    string s;     //string定义了自己的移动操作\n};\n\nint main()\n{\n    X x;\n    x.i = \"cqu\";\n    x.s = \"wangxinri\";\n    cout<<x.i<<\" \"<<x.s<<endl;  //cqu wangxinri\n    //使用合成的移动构造函数\n    X x2 = std::move(x);   //移后源对象x必须保持有效的、可析构的状态\n    cout<<x2.i<<\" \"<<x2.s<<endl;  //cqu wangxinri\n    cout<<\"---------\"<<endl;\n    cout<<x.i<<\" \"<<x.s<<endl;    //输出空字符，说明x的值已经被x2接管了，x是一个可析构的状态\n    cout<<\"---------\"<<endl;\n    x.i = \"aaa\";\n    x.s = \"bbb\";\n    cout<<x.i<<\" \"<<x.s<<endl;   //  aaa  bbb\n    return 0;\n}\n```\n\n由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。\n\nmove用来将一个右值引用绑定到一个左值的标准库函数。调用move隐含地承诺我们将不会再使用移后源对象，除了销毁它或赋予它一个新值之外。\n\n\n","source":"_posts/对象移动.md","raw":"---\ntitle: 对象移动\ndate: 2017-11-15 21:59:00\nupdate: \ntags: [右值引用]\ncategories: C++\ncomments: true\n---\n\n## 对象移动\n\n新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。\n\n<!--more-->\n\n**noet:** 标准库容器、string和shared_ptr类及支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。\n\n### 右值引用\n\n为了支持移动操作，新标准引入了一种新的引用类型——**右值引用**，就是必须绑定到右值的引用。**我们通过&&而不是&来获得右值引用**。右值引用一个重要的特性就是**只能绑定到将要销毁的对象。**\n\n左值和右值是表达式的属性，一些表达式生成或要求左值，而另一些则生成或要求右值。**一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的是对象的值。**（**可以取地址的、有名字的就是左值；不能取地址的、没有名字的就是右值**。）**两者明显的区别就是左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象**。\n\n类似于常规引用（左值引用），一个右值引用也不过是某个对象的另一个名字而已。我们不能将左值引用绑定到要求转换的表达式、字面常量或是返回值的表达式，也不能把右值应用直接绑定到一个左值上。但是，**常量左值引用可以绑定到非常量左值、常量左值、右值，是一个万能引用类型**。不过相比右值引用所引用的右值，常量左值引用所引用的右值在它的“余生”中只能是只读的。\n\n```C++\nint i = 42;\nint &r = i;     //r引用i\nint &r2 = i*2;    //错误，i*2是一个右值\nint &&rr = i；    //错误，不能将一个右值引用绑定到一个左值上\nint &&rr2 = i*2;   //正确，将rr2绑定到一个乘法结果上\nconst int &r3 = i*2; //正确，将一个常量引用绑定到一个右值上\n```\n\n### 左值持久；右值短暂\n\n考虑左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。\n\n由于右值引用只能绑定到临时对象，我们得知\n\n- 所引用的对象将要被销毁\n- 该对象没有其他用户\n\n这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。\n\n**注意：** 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态\n\n### 变量时左值\n\n```C++\nint &&rr1 = 42;   //正确：字面值常量是右值\nint &&rr2 = rr1;   //错误：表达式rr1是左值\n```\n\n变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。\n\n### 标准库move函数\n\n我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为**move**的新标准库函数来**获得绑定到左值上的右值引用**，此函数定义在**头文件utility**中。\n\n```\nint &&rr3 = std::move(rr1);     //ok\n```\n\n**note:** 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。\n\n**warning:** 使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。\n\n## 移动构造函数和移动赋值运算符\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct X{\n    string i;       //内置类型可以移动\n    string s;     //string定义了自己的移动操作\n};\n\nint main()\n{\n    X x;\n    x.i = \"cqu\";\n    x.s = \"wangxinri\";\n    cout<<x.i<<\" \"<<x.s<<endl;  //cqu wangxinri\n    //使用合成的移动构造函数\n    X x2 = std::move(x);   //移后源对象x必须保持有效的、可析构的状态\n    cout<<x2.i<<\" \"<<x2.s<<endl;  //cqu wangxinri\n    cout<<\"---------\"<<endl;\n    cout<<x.i<<\" \"<<x.s<<endl;    //输出空字符，说明x的值已经被x2接管了，x是一个可析构的状态\n    cout<<\"---------\"<<endl;\n    x.i = \"aaa\";\n    x.s = \"bbb\";\n    cout<<x.i<<\" \"<<x.s<<endl;   //  aaa  bbb\n    return 0;\n}\n```\n\n由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。\n\nmove用来将一个右值引用绑定到一个左值的标准库函数。调用move隐含地承诺我们将不会再使用移后源对象，除了销毁它或赋予它一个新值之外。\n\n\n","slug":"对象移动","published":1,"updated":"2018-02-22T12:23:17.708Z","layout":"post","photos":[],"link":"","_id":"cjdz6yqtx00017wc9lk269ngh","content":"<h2 id=\"对象移动\"><a href=\"#对象移动\" class=\"headerlink\" title=\"对象移动\"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。</p>\n<a id=\"more\"></a>\n<p><strong>noet:</strong> 标准库容器、string和shared_ptr类及支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>\n<h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><p>为了支持移动操作，新标准引入了一种新的引用类型——<strong>右值引用</strong>，就是必须绑定到右值的引用。<strong>我们通过&amp;&amp;而不是&amp;来获得右值引用</strong>。右值引用一个重要的特性就是<strong>只能绑定到将要销毁的对象。</strong></p>\n<p>左值和右值是表达式的属性，一些表达式生成或要求左值，而另一些则生成或要求右值。<strong>一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的是对象的值。</strong>（<strong>可以取地址的、有名字的就是左值；不能取地址的、没有名字的就是右值</strong>。）<strong>两者明显的区别就是左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</strong>。</p>\n<p>类似于常规引用（左值引用），一个右值引用也不过是某个对象的另一个名字而已。我们不能将左值引用绑定到要求转换的表达式、字面常量或是返回值的表达式，也不能把右值应用直接绑定到一个左值上。但是，<strong>常量左值引用可以绑定到非常量左值、常量左值、右值，是一个万能引用类型</strong>。不过相比右值引用所引用的右值，常量左值引用所引用的右值在它的“余生”中只能是只读的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r = i;     <span class=\"comment\">//r引用i</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r2 = i*<span class=\"number\">2</span>;    <span class=\"comment\">//错误，i*2是一个右值</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i；    <span class=\"comment\">//错误，不能将一个右值引用绑定到一个左值上</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = i*<span class=\"number\">2</span>;   <span class=\"comment\">//正确，将rr2绑定到一个乘法结果上</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r3 = i*<span class=\"number\">2</span>; <span class=\"comment\">//正确，将一个常量引用绑定到一个右值上</span></div></pre></td></tr></table></figure>\n<h3 id=\"左值持久；右值短暂\"><a href=\"#左值持久；右值短暂\" class=\"headerlink\" title=\"左值持久；右值短暂\"></a>左值持久；右值短暂</h3><p>考虑左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>\n<p>由于右值引用只能绑定到临时对象，我们得知</p>\n<ul>\n<li>所引用的对象将要被销毁</li>\n<li>该对象没有其他用户</li>\n</ul>\n<p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p>\n<p><strong>注意：</strong> 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态</p>\n<h3 id=\"变量时左值\"><a href=\"#变量时左值\" class=\"headerlink\" title=\"变量时左值\"></a>变量时左值</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">//正确：字面值常量是右值</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;   <span class=\"comment\">//错误：表达式rr1是左值</span></div></pre></td></tr></table></figure>\n<p>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p>\n<h3 id=\"标准库move函数\"><a href=\"#标准库move函数\" class=\"headerlink\" title=\"标准库move函数\"></a>标准库move函数</h3><p>我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为<strong>move</strong>的新标准库函数来<strong>获得绑定到左值上的右值引用</strong>，此函数定义在<strong>头文件utility</strong>中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int &amp;&amp;rr3 = std::move(rr1);     //ok</div></pre></td></tr></table></figure>\n<p><strong>note:</strong> 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p>\n<p><strong>warning:</strong> 使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。</p>\n<h2 id=\"移动构造函数和移动赋值运算符\"><a href=\"#移动构造函数和移动赋值运算符\" class=\"headerlink\" title=\"移动构造函数和移动赋值运算符\"></a>移动构造函数和移动赋值运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span>&#123;</span></div><div class=\"line\">    <span class=\"built_in\">string</span> i;       <span class=\"comment\">//内置类型可以移动</span></div><div class=\"line\">    <span class=\"built_in\">string</span> s;     <span class=\"comment\">//string定义了自己的移动操作</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    X x;</div><div class=\"line\">    x.i = <span class=\"string\">\"cqu\"</span>;</div><div class=\"line\">    x.s = <span class=\"string\">\"wangxinri\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x.s&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//cqu wangxinri</span></div><div class=\"line\">    <span class=\"comment\">//使用合成的移动构造函数</span></div><div class=\"line\">    X x2 = <span class=\"built_in\">std</span>::move(x);   <span class=\"comment\">//移后源对象x必须保持有效的、可析构的状态</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x2.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x2.s&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//cqu wangxinri</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"---------\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x.s&lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//输出空字符，说明x的值已经被x2接管了，x是一个可析构的状态</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"---------\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    x.i = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\">    x.s = <span class=\"string\">\"bbb\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x.s&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//  aaa  bbb</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。</p>\n<p>move用来将一个右值引用绑定到一个左值的标准库函数。调用move隐含地承诺我们将不会再使用移后源对象，除了销毁它或赋予它一个新值之外。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"对象移动\"><a href=\"#对象移动\" class=\"headerlink\" title=\"对象移动\"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。</p>","more":"<p><strong>noet:</strong> 标准库容器、string和shared_ptr类及支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>\n<h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><p>为了支持移动操作，新标准引入了一种新的引用类型——<strong>右值引用</strong>，就是必须绑定到右值的引用。<strong>我们通过&amp;&amp;而不是&amp;来获得右值引用</strong>。右值引用一个重要的特性就是<strong>只能绑定到将要销毁的对象。</strong></p>\n<p>左值和右值是表达式的属性，一些表达式生成或要求左值，而另一些则生成或要求右值。<strong>一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的是对象的值。</strong>（<strong>可以取地址的、有名字的就是左值；不能取地址的、没有名字的就是右值</strong>。）<strong>两者明显的区别就是左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</strong>。</p>\n<p>类似于常规引用（左值引用），一个右值引用也不过是某个对象的另一个名字而已。我们不能将左值引用绑定到要求转换的表达式、字面常量或是返回值的表达式，也不能把右值应用直接绑定到一个左值上。但是，<strong>常量左值引用可以绑定到非常量左值、常量左值、右值，是一个万能引用类型</strong>。不过相比右值引用所引用的右值，常量左值引用所引用的右值在它的“余生”中只能是只读的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r = i;     <span class=\"comment\">//r引用i</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;r2 = i*<span class=\"number\">2</span>;    <span class=\"comment\">//错误，i*2是一个右值</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i；    <span class=\"comment\">//错误，不能将一个右值引用绑定到一个左值上</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = i*<span class=\"number\">2</span>;   <span class=\"comment\">//正确，将rr2绑定到一个乘法结果上</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r3 = i*<span class=\"number\">2</span>; <span class=\"comment\">//正确，将一个常量引用绑定到一个右值上</span></div></pre></td></tr></table></figure>\n<h3 id=\"左值持久；右值短暂\"><a href=\"#左值持久；右值短暂\" class=\"headerlink\" title=\"左值持久；右值短暂\"></a>左值持久；右值短暂</h3><p>考虑左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>\n<p>由于右值引用只能绑定到临时对象，我们得知</p>\n<ul>\n<li>所引用的对象将要被销毁</li>\n<li>该对象没有其他用户</li>\n</ul>\n<p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p>\n<p><strong>注意：</strong> 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态</p>\n<h3 id=\"变量时左值\"><a href=\"#变量时左值\" class=\"headerlink\" title=\"变量时左值\"></a>变量时左值</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">//正确：字面值常量是右值</span></div><div class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;   <span class=\"comment\">//错误：表达式rr1是左值</span></div></pre></td></tr></table></figure>\n<p>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p>\n<h3 id=\"标准库move函数\"><a href=\"#标准库move函数\" class=\"headerlink\" title=\"标准库move函数\"></a>标准库move函数</h3><p>我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为<strong>move</strong>的新标准库函数来<strong>获得绑定到左值上的右值引用</strong>，此函数定义在<strong>头文件utility</strong>中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int &amp;&amp;rr3 = std::move(rr1);     //ok</div></pre></td></tr></table></figure>\n<p><strong>note:</strong> 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p>\n<p><strong>warning:</strong> 使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。</p>\n<h2 id=\"移动构造函数和移动赋值运算符\"><a href=\"#移动构造函数和移动赋值运算符\" class=\"headerlink\" title=\"移动构造函数和移动赋值运算符\"></a>移动构造函数和移动赋值运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span>&#123;</span></div><div class=\"line\">    <span class=\"built_in\">string</span> i;       <span class=\"comment\">//内置类型可以移动</span></div><div class=\"line\">    <span class=\"built_in\">string</span> s;     <span class=\"comment\">//string定义了自己的移动操作</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    X x;</div><div class=\"line\">    x.i = <span class=\"string\">\"cqu\"</span>;</div><div class=\"line\">    x.s = <span class=\"string\">\"wangxinri\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x.s&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//cqu wangxinri</span></div><div class=\"line\">    <span class=\"comment\">//使用合成的移动构造函数</span></div><div class=\"line\">    X x2 = <span class=\"built_in\">std</span>::move(x);   <span class=\"comment\">//移后源对象x必须保持有效的、可析构的状态</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x2.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x2.s&lt;&lt;<span class=\"built_in\">endl</span>;  <span class=\"comment\">//cqu wangxinri</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"---------\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x.s&lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//输出空字符，说明x的值已经被x2接管了，x是一个可析构的状态</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"---------\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    x.i = <span class=\"string\">\"aaa\"</span>;</div><div class=\"line\">    x.s = <span class=\"string\">\"bbb\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x.i&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;x.s&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//  aaa  bbb</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。</p>\n<p>move用来将一个右值引用绑定到一个左值的标准库函数。调用move隐含地承诺我们将不会再使用移后源对象，除了销毁它或赋予它一个新值之外。</p>"},{"title":"关联容器概述","date":"2017-11-04T13:59:00.000Z","update":null,"comments":1,"_content":"# 一、前言\n\n关联容器分为有序关联容器和无序关联容器，有序关联容器按关键字有序保存元素，底层数据结构为红黑树；无序关联容器底层数据结构是hashtable，因此是无序的。\n<!--more-->\n\n\n\n## 关联容器\n\n关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。\n\n虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。\n\n关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素是一些关键字-值对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素包含一个关键字；set支持高效的关键字查询操作——检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。\n\n标准库提供8个关联容器，如下表所示。这8个容器间的不同体现在三个维度上：每个容器 **（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保存关键字按顺序存储的容器的名字都以单词unordered开头**。因此一个unordered_multi_set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。\n\n类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。\n\n **关联容器类型** \n\n```C++\n按关键字有序保存元素\nmap 　　　　　　　　关联数组：保存关键字-值对\nset　　　　　　　　　关键字即值，即只保存关键字的容器\nmultimap　　　　　　关键字可重复出现的map\nmultiset　　　　　　   关键字可重复出现的set\n无序容器\nunordered_map　　　用哈希函数组织的map\nunordered_set　　　　用哈希函数组织的set\nunordered_multimap　　哈希组织的map；关键字可以重复出现\nunordered_multiset　　  哈希组织的set；关键字可以重复出现\n```\n\n## 关联容器概述\n\n关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。\n\n除了顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外，无序容器还提供了一些用来调整哈希性能的操作。\n\n**关联容器的迭代器都是双向的（可读写，多遍扫描，可递增递减）**。\n\n### 定义关联容器\n\n当定义一个map时，必须既指明关键字类型又指明值类型。而定义一个set时，只需指明关键字类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器，我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器中所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化：\n\n```C++\nmap<string,size_t> word_count ; //空容器\n//列表初始化\nset<string> exclude={\"the\",\"but\",\"and\",\"or\",\"an\",\"a\",\"The\",\"But\",\"And\",\"Or\",\"An\",\"A\"};\n//三个元素；authors将姓映射到名\nmap<string,string> autors={ {\"Joyce\",\"James\"},\n　　　　　　　　　　　　  {\"Austen\",\"Jane\"},\n　　　　　　　　　　　　  {\"Dickens\",\"Charles\"}};\n```\n\n与以往一样，初始化器必须能转换为容器中元素的类型。对于set，元素类型就是关键字类型。\n当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中：\n```C++\n　{key,value}\n```\n来指出它们一起构成了map中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。因此，anthors将姓映射到名，初始化它包括三个元素。\n\n### 初始化multimap或multiset\n\n一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字。\n\n### 关键字类型的要求\n\n关联容器对其关键字类型有一些限制。对于无序容器中关键字的要求，我们后面介绍。对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型，在映射类型中，关键字类型是元素的第一部分的类型。因此，word_count的关键字类型是string。类似的，exclude的关键字类型也是string。\n\n### 有序容器的关键字类型\n\n可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个严格弱序。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：\n\n- 两个关键字不能同时“小于等于”对方：如果k1“小于等于”k2，那么k2绝不能“小于等于”k1.\n- 如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3\n- 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价与”k2，且k2“等价于”k3，那么k1必须“等价于”k3.\n\n如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map关键字时，只能有一个元素与这个关键字关联，我们可以用两者中任意一个来访问对应的值。\n\n### 使用关键字的比较函数\n\n用来组织一个容器中元素的操作的类型也是容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟这元素类型给出。\n\n在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。\n\n例如，我们不能直接定义一个Sales_data的multiset，因为Sales_data没有<运算符。但是，可以用定义的compareIsbn函数来定义一个multiset。此函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面这样定义\n\n```C++\nbool compareIsbn(const Sales_data &lhs,const Sales_data &rhs)\n{\n　　return lhs.isbn()<rhs.isbn();\n}\n```\n\n为了使用自己定义的操作，在定义multiset时我们必须提供两个类型。关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向compareIsbn的指针：\n\n```C++\n//bookstore中多条记录可以有相同的ISBN\n//bookstore中的元素以ISBN的顺序进行排序\nmultiset<Sales_data,decltype(compareIsbn)*> bookstore(compareIsbn);\n```\n\n此处，我们使用decltype来指出自定义操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。用compareIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过compareIsbn来为这些元素排序。即，bookstore中的元素将按它们的ISBN成员的值排序。可以用compareIsbn代替&compareIsbn作为构造函数的参数，因为当我们使用一个函数的名字时，在需要的情况下它会自动转化为一个指针。当然，使用&compareIsbn的效果也是一样的。\n\n## pair类型\n\n在介绍关联容器操作之前，我们需要了解名为pair的标准库类型，它定义在头文件utility中。\n\n一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样：\n\n```C++\npair<string,string> anon;  //保存两个string\npair<string,size_t> word_count;   //保存一个string和一个size_t\npair<string,vector<int>> line;  //保存string和vector<int>\n```\n\npair的默认构造函数对数据成员进行值初始化。因此，anon是一个包含两个空string的pair，line保存一个空string和一个空vector。word_count中的size_t 成员值为0，而string成员被初始化为空vector。\n\n我们也可以为每个成员提供初始化器：\n\n```C++\npair<string,string> author{\"James\",\"Joyce\"};\n```\n\n这条语句创建了一个名为author的pair，两个成员被初始化为\"James\"和\"Joyce\"。\n\n与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号来访问它们，例如\n\n```C++\ncout<<w.first<<\" occurs \"<<w.second<<endl;\n```\n\n此处，w 是指向某个元素的引用。map的元素是pair。在这条语句中，我们首先打印关键字——元素的first成员，接着打印计数器——second成员。标准库只定义了有限的几个pair操作，下表列出了这些操作：\n\n**pair上的操作** \n\n```C++\npair<T1,T2> p; 　　p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化\npair<T1,T2> p(v1,v2)　　p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化\npair<T1,T2> p={v1,v2};　　等价于p(v1,v2)\nmake_pair(v1,v2)　　返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来\np.first　　 返回p的名为first的（公有）数据成员\np.second　　返回p的名为second的（公有）数据成员\np1 relop p2　　　　　　　　　　　　　   关系运算符（<、>、<=、>=）按字典序定义；例如，当p1.first<p2.first或!(p2.first<p1.first)&&p1.second<p2.second成立时，p1<p2为true。关系运算符利用元素的<运算符来实现\np1==p2　当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现\np1!=p2　　　　　　　　　　　　　　　　\n```\n\n### 创建pair对象的函数\n\n想象有一个函数需要返回一个pair。在新标准下，我们可以对返回在进行列表初始化\n复制代码\n\n```C++\npair<string,int>\nprocess(vector<string> &v)\n{\n    //处理v\n    if(!v.empty())\n        return {v.back(),v.back().size()); // 列表初始化\n    else\n        return pair<string,int>();  //隐式构造返回值\n}\n```\n\n在较早的C++版本中，不允许用花括号包围的初始化器来返回pair这种类型的对象，必须显示构造返回值：\n\n```C++\nif(!v.empty())\n　　return pair<string,int>(v.back(),v.back().size());\n```\n我们还可以用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数：\n```C++\nif(!v.empty())\n　　return make_pair(v.back(),v.back().size());\n```\n\n## 无序容器\n\n新标准定义了4个无序关联容器。**这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显有序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很**有用。\n\n虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单。\n\n### 使用无序容器\n\n除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert等）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。\n\n### 管理桶\n\n**无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同的关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。**\n\n对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。\n\n无序容器提供了一组管理桶的函数。如表所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。\n\n**无序容器管理操作**\n\n```C++\n桶接口\nc.bucket_count()　　　　　　　　正在使用的桶的数目\nc.max_bucket_count() 　　　　　 容器能容纳的最多的桶的数量\nc.bucket_size(n)　　　　　　　　  第n个桶中有多少元素\nc.bucket(k)　　　　　　　　　　  关键字为k的元素在哪个桶中\n桶迭代\nlocal_iterator 　　　　　　　　　可以用来访问桶中元素的迭代器类型\nconst_local_iterator　　　　　　 桶迭代器的const版本\nc.begin(n),c.end(n)　　　　　　   桶n的首元素迭代器和尾后迭代器\nc.cbegin(n),c.cend(n)　　　　       返回const_local_iterator\n哈希策略\nc.load_factor()　　　　　　　　　每个桶的平均元素数量，返回float值\nc.max_load_factor()　　　　　　 c试图维护的平均桶大小，返回float值，c会在需要时添加新的桶，以使得load_factor<=max_load_factor\nc.rehash(n)　　　　　　　　　　重组存储，使得bucket_count>=n且bucket_count>size/max_load_factor\nc.reserve(n)　　　　　　　　　　重组存储，使得c可以保存n个元素且不必rehash\n```\n\n### 无序容器对关键字类型的要求\n\n**默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值**。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要介绍的智能指针类型定义了hash。因此，**我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针的无序容器。**\n\n但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。\n\n我们不能使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将Sales_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载函数开始：\n\n```C++\nsize_t hasher(const Sales_data &sd)\n{\n　　return hash<string>()(sd.isbn());\n}\n\nbool eqOp(const Sales_data &lhs,const Sales_data &rhs)\n{\n　　return lhs.isbn()==rhs.isbn();\n}\n```\n\n我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。\n\n我们使用这些函数来定义一个unordered_multiset\n\n```C++\nusing SD_multiset=unordered_multiset<Sales_data,decltypr(hasher)*,decltype(eqOp)*>;\n//参数是桶大小、哈希函数指针和相等型判断运算符指针\nSD_multiset bookstore(42,hasher,eqOp);\n```\n\n为了简化bookstore的定义，首先为unordered_multiset定义了一个类型别名，此集合的哈希和相等性判断操作与hasher和eqOp函数有着相同的类型。通过使用这种类型，在定义bookstore时可以将我们希望它使用的函数的指针传递给它。\n\n如果我们的类定义了==运算符，则可以只重载哈希函数：\n\n```C++\n//使用FooHash生成哈希值；Foo必须有==运算符\nunordered_set<Foo,decltype(FooHash)*> fooset(10,FooHash);\n```\n\n### 示例\n\n```C++\n#include <iostream>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n    unordered_map<string,int> word_count;\n    word_count[\"to\"] = 10;\n    word_count[\"be\"] = 20;\n    auto iter = word_count.find(\"be\");   //查找关键字为\"be\"的元素是否在unordered_map中，返回一个迭代器\n    cout<<iter->first<<endl;\n    cout<<iter->second<<endl;\n    auto bucket = word_count.bucket(\"to\");  //关键字为\"to\"的元素在那个桶上\n    cout<<bucket<<endl;\n    auto beg = word_count.begin(bucket);   //桶n的首元素迭代器，pair<string,int>类型\n    cout<<beg->first<<endl;\n    cout<<beg->second<<endl;\n    return 0;\n}\n```","source":"_posts/关联容器概述.md","raw":"---\ntitle: 关联容器概述\ndate: 2017-11-4 21:59:00\nupdate: \ntags: [关联容器]\ncategories: C++\ncomments: true\n---\n# 一、前言\n\n关联容器分为有序关联容器和无序关联容器，有序关联容器按关键字有序保存元素，底层数据结构为红黑树；无序关联容器底层数据结构是hashtable，因此是无序的。\n<!--more-->\n\n\n\n## 关联容器\n\n关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。\n\n虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。\n\n关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素是一些关键字-值对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素包含一个关键字；set支持高效的关键字查询操作——检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。\n\n标准库提供8个关联容器，如下表所示。这8个容器间的不同体现在三个维度上：每个容器 **（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保存关键字按顺序存储的容器的名字都以单词unordered开头**。因此一个unordered_multi_set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。\n\n类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。\n\n **关联容器类型** \n\n```C++\n按关键字有序保存元素\nmap 　　　　　　　　关联数组：保存关键字-值对\nset　　　　　　　　　关键字即值，即只保存关键字的容器\nmultimap　　　　　　关键字可重复出现的map\nmultiset　　　　　　   关键字可重复出现的set\n无序容器\nunordered_map　　　用哈希函数组织的map\nunordered_set　　　　用哈希函数组织的set\nunordered_multimap　　哈希组织的map；关键字可以重复出现\nunordered_multiset　　  哈希组织的set；关键字可以重复出现\n```\n\n## 关联容器概述\n\n关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。\n\n除了顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外，无序容器还提供了一些用来调整哈希性能的操作。\n\n**关联容器的迭代器都是双向的（可读写，多遍扫描，可递增递减）**。\n\n### 定义关联容器\n\n当定义一个map时，必须既指明关键字类型又指明值类型。而定义一个set时，只需指明关键字类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器，我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器中所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化：\n\n```C++\nmap<string,size_t> word_count ; //空容器\n//列表初始化\nset<string> exclude={\"the\",\"but\",\"and\",\"or\",\"an\",\"a\",\"The\",\"But\",\"And\",\"Or\",\"An\",\"A\"};\n//三个元素；authors将姓映射到名\nmap<string,string> autors={ {\"Joyce\",\"James\"},\n　　　　　　　　　　　　  {\"Austen\",\"Jane\"},\n　　　　　　　　　　　　  {\"Dickens\",\"Charles\"}};\n```\n\n与以往一样，初始化器必须能转换为容器中元素的类型。对于set，元素类型就是关键字类型。\n当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中：\n```C++\n　{key,value}\n```\n来指出它们一起构成了map中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。因此，anthors将姓映射到名，初始化它包括三个元素。\n\n### 初始化multimap或multiset\n\n一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字。\n\n### 关键字类型的要求\n\n关联容器对其关键字类型有一些限制。对于无序容器中关键字的要求，我们后面介绍。对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型，在映射类型中，关键字类型是元素的第一部分的类型。因此，word_count的关键字类型是string。类似的，exclude的关键字类型也是string。\n\n### 有序容器的关键字类型\n\n可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个严格弱序。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：\n\n- 两个关键字不能同时“小于等于”对方：如果k1“小于等于”k2，那么k2绝不能“小于等于”k1.\n- 如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3\n- 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价与”k2，且k2“等价于”k3，那么k1必须“等价于”k3.\n\n如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map关键字时，只能有一个元素与这个关键字关联，我们可以用两者中任意一个来访问对应的值。\n\n### 使用关键字的比较函数\n\n用来组织一个容器中元素的操作的类型也是容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟这元素类型给出。\n\n在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。\n\n例如，我们不能直接定义一个Sales_data的multiset，因为Sales_data没有<运算符。但是，可以用定义的compareIsbn函数来定义一个multiset。此函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面这样定义\n\n```C++\nbool compareIsbn(const Sales_data &lhs,const Sales_data &rhs)\n{\n　　return lhs.isbn()<rhs.isbn();\n}\n```\n\n为了使用自己定义的操作，在定义multiset时我们必须提供两个类型。关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向compareIsbn的指针：\n\n```C++\n//bookstore中多条记录可以有相同的ISBN\n//bookstore中的元素以ISBN的顺序进行排序\nmultiset<Sales_data,decltype(compareIsbn)*> bookstore(compareIsbn);\n```\n\n此处，我们使用decltype来指出自定义操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。用compareIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过compareIsbn来为这些元素排序。即，bookstore中的元素将按它们的ISBN成员的值排序。可以用compareIsbn代替&compareIsbn作为构造函数的参数，因为当我们使用一个函数的名字时，在需要的情况下它会自动转化为一个指针。当然，使用&compareIsbn的效果也是一样的。\n\n## pair类型\n\n在介绍关联容器操作之前，我们需要了解名为pair的标准库类型，它定义在头文件utility中。\n\n一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样：\n\n```C++\npair<string,string> anon;  //保存两个string\npair<string,size_t> word_count;   //保存一个string和一个size_t\npair<string,vector<int>> line;  //保存string和vector<int>\n```\n\npair的默认构造函数对数据成员进行值初始化。因此，anon是一个包含两个空string的pair，line保存一个空string和一个空vector。word_count中的size_t 成员值为0，而string成员被初始化为空vector。\n\n我们也可以为每个成员提供初始化器：\n\n```C++\npair<string,string> author{\"James\",\"Joyce\"};\n```\n\n这条语句创建了一个名为author的pair，两个成员被初始化为\"James\"和\"Joyce\"。\n\n与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号来访问它们，例如\n\n```C++\ncout<<w.first<<\" occurs \"<<w.second<<endl;\n```\n\n此处，w 是指向某个元素的引用。map的元素是pair。在这条语句中，我们首先打印关键字——元素的first成员，接着打印计数器——second成员。标准库只定义了有限的几个pair操作，下表列出了这些操作：\n\n**pair上的操作** \n\n```C++\npair<T1,T2> p; 　　p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化\npair<T1,T2> p(v1,v2)　　p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化\npair<T1,T2> p={v1,v2};　　等价于p(v1,v2)\nmake_pair(v1,v2)　　返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来\np.first　　 返回p的名为first的（公有）数据成员\np.second　　返回p的名为second的（公有）数据成员\np1 relop p2　　　　　　　　　　　　　   关系运算符（<、>、<=、>=）按字典序定义；例如，当p1.first<p2.first或!(p2.first<p1.first)&&p1.second<p2.second成立时，p1<p2为true。关系运算符利用元素的<运算符来实现\np1==p2　当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现\np1!=p2　　　　　　　　　　　　　　　　\n```\n\n### 创建pair对象的函数\n\n想象有一个函数需要返回一个pair。在新标准下，我们可以对返回在进行列表初始化\n复制代码\n\n```C++\npair<string,int>\nprocess(vector<string> &v)\n{\n    //处理v\n    if(!v.empty())\n        return {v.back(),v.back().size()); // 列表初始化\n    else\n        return pair<string,int>();  //隐式构造返回值\n}\n```\n\n在较早的C++版本中，不允许用花括号包围的初始化器来返回pair这种类型的对象，必须显示构造返回值：\n\n```C++\nif(!v.empty())\n　　return pair<string,int>(v.back(),v.back().size());\n```\n我们还可以用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数：\n```C++\nif(!v.empty())\n　　return make_pair(v.back(),v.back().size());\n```\n\n## 无序容器\n\n新标准定义了4个无序关联容器。**这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显有序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很**有用。\n\n虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单。\n\n### 使用无序容器\n\n除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert等）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。\n\n### 管理桶\n\n**无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同的关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。**\n\n对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。\n\n无序容器提供了一组管理桶的函数。如表所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。\n\n**无序容器管理操作**\n\n```C++\n桶接口\nc.bucket_count()　　　　　　　　正在使用的桶的数目\nc.max_bucket_count() 　　　　　 容器能容纳的最多的桶的数量\nc.bucket_size(n)　　　　　　　　  第n个桶中有多少元素\nc.bucket(k)　　　　　　　　　　  关键字为k的元素在哪个桶中\n桶迭代\nlocal_iterator 　　　　　　　　　可以用来访问桶中元素的迭代器类型\nconst_local_iterator　　　　　　 桶迭代器的const版本\nc.begin(n),c.end(n)　　　　　　   桶n的首元素迭代器和尾后迭代器\nc.cbegin(n),c.cend(n)　　　　       返回const_local_iterator\n哈希策略\nc.load_factor()　　　　　　　　　每个桶的平均元素数量，返回float值\nc.max_load_factor()　　　　　　 c试图维护的平均桶大小，返回float值，c会在需要时添加新的桶，以使得load_factor<=max_load_factor\nc.rehash(n)　　　　　　　　　　重组存储，使得bucket_count>=n且bucket_count>size/max_load_factor\nc.reserve(n)　　　　　　　　　　重组存储，使得c可以保存n个元素且不必rehash\n```\n\n### 无序容器对关键字类型的要求\n\n**默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值**。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要介绍的智能指针类型定义了hash。因此，**我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针的无序容器。**\n\n但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。\n\n我们不能使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将Sales_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载函数开始：\n\n```C++\nsize_t hasher(const Sales_data &sd)\n{\n　　return hash<string>()(sd.isbn());\n}\n\nbool eqOp(const Sales_data &lhs,const Sales_data &rhs)\n{\n　　return lhs.isbn()==rhs.isbn();\n}\n```\n\n我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。\n\n我们使用这些函数来定义一个unordered_multiset\n\n```C++\nusing SD_multiset=unordered_multiset<Sales_data,decltypr(hasher)*,decltype(eqOp)*>;\n//参数是桶大小、哈希函数指针和相等型判断运算符指针\nSD_multiset bookstore(42,hasher,eqOp);\n```\n\n为了简化bookstore的定义，首先为unordered_multiset定义了一个类型别名，此集合的哈希和相等性判断操作与hasher和eqOp函数有着相同的类型。通过使用这种类型，在定义bookstore时可以将我们希望它使用的函数的指针传递给它。\n\n如果我们的类定义了==运算符，则可以只重载哈希函数：\n\n```C++\n//使用FooHash生成哈希值；Foo必须有==运算符\nunordered_set<Foo,decltype(FooHash)*> fooset(10,FooHash);\n```\n\n### 示例\n\n```C++\n#include <iostream>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n    unordered_map<string,int> word_count;\n    word_count[\"to\"] = 10;\n    word_count[\"be\"] = 20;\n    auto iter = word_count.find(\"be\");   //查找关键字为\"be\"的元素是否在unordered_map中，返回一个迭代器\n    cout<<iter->first<<endl;\n    cout<<iter->second<<endl;\n    auto bucket = word_count.bucket(\"to\");  //关键字为\"to\"的元素在那个桶上\n    cout<<bucket<<endl;\n    auto beg = word_count.begin(bucket);   //桶n的首元素迭代器，pair<string,int>类型\n    cout<<beg->first<<endl;\n    cout<<beg->second<<endl;\n    return 0;\n}\n```","slug":"关联容器概述","published":1,"updated":"2018-02-22T12:01:26.900Z","layout":"post","photos":[],"link":"","_id":"cjdz6yqu600037wc9kzdlh71c","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>关联容器分为有序关联容器和无序关联容器，有序关联容器按关键字有序保存元素，底层数据结构为红黑树；无序关联容器底层数据结构是hashtable，因此是无序的。<br><a id=\"more\"></a></p>\n<h2 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h2><p>关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>\n<p>虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。</p>\n<p>关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素是一些关键字-值对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素包含一个关键字；set支持高效的关键字查询操作——检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。</p>\n<p>标准库提供8个关联容器，如下表所示。这8个容器间的不同体现在三个维度上：每个容器 <strong>（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保存关键字按顺序存储的容器的名字都以单词unordered开头</strong>。因此一个unordered_multi_set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。</p>\n<p>类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。</p>\n<p> <strong>关联容器类型</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">按关键字有序保存元素</div><div class=\"line\"><span class=\"built_in\">map</span> 　　　　　　　　关联数组：保存关键字-值对</div><div class=\"line\"><span class=\"built_in\">set</span>　　　　　　　　　关键字即值，即只保存关键字的容器</div><div class=\"line\"><span class=\"built_in\">multimap</span>　　　　　　关键字可重复出现的<span class=\"built_in\">map</span></div><div class=\"line\"><span class=\"built_in\">multiset</span>　　　　　　   关键字可重复出现的<span class=\"built_in\">set</span></div><div class=\"line\">无序容器</div><div class=\"line\"><span class=\"built_in\">unordered_map</span>　　　用哈希函数组织的<span class=\"built_in\">map</span></div><div class=\"line\"><span class=\"built_in\">unordered_set</span>　　　　用哈希函数组织的<span class=\"built_in\">set</span></div><div class=\"line\"><span class=\"built_in\">unordered_multimap</span>　　哈希组织的<span class=\"built_in\">map</span>；关键字可以重复出现</div><div class=\"line\"><span class=\"built_in\">unordered_multiset</span>　　  哈希组织的<span class=\"built_in\">set</span>；关键字可以重复出现</div></pre></td></tr></table></figure>\n<h2 id=\"关联容器概述\"><a href=\"#关联容器概述\" class=\"headerlink\" title=\"关联容器概述\"></a>关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p>\n<p>除了顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外，无序容器还提供了一些用来调整哈希性能的操作。</p>\n<p><strong>关联容器的迭代器都是双向的（可读写，多遍扫描，可递增递减）</strong>。</p>\n<h3 id=\"定义关联容器\"><a href=\"#定义关联容器\" class=\"headerlink\" title=\"定义关联容器\"></a>定义关联容器</h3><p>当定义一个map时，必须既指明关键字类型又指明值类型。而定义一个set时，只需指明关键字类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器，我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器中所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">size_t</span>&gt; word_count ; <span class=\"comment\">//空容器</span></div><div class=\"line\"><span class=\"comment\">//列表初始化</span></div><div class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; exclude=&#123;<span class=\"string\">\"the\"</span>,<span class=\"string\">\"but\"</span>,<span class=\"string\">\"and\"</span>,<span class=\"string\">\"or\"</span>,<span class=\"string\">\"an\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"The\"</span>,<span class=\"string\">\"But\"</span>,<span class=\"string\">\"And\"</span>,<span class=\"string\">\"Or\"</span>,<span class=\"string\">\"An\"</span>,<span class=\"string\">\"A\"</span>&#125;;</div><div class=\"line\"><span class=\"comment\">//三个元素；authors将姓映射到名</span></div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">string</span>&gt; autors=&#123; &#123;<span class=\"string\">\"Joyce\"</span>,<span class=\"string\">\"James\"</span>&#125;,</div><div class=\"line\">　　　　　　　　　　　　  &#123;<span class=\"string\">\"Austen\"</span>,<span class=\"string\">\"Jane\"</span>&#125;,</div><div class=\"line\">　　　　　　　　　　　　  &#123;<span class=\"string\">\"Dickens\"</span>,<span class=\"string\">\"Charles\"</span>&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>与以往一样，初始化器必须能转换为容器中元素的类型。对于set，元素类型就是关键字类型。<br>当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　&#123;key,value&#125;</div></pre></td></tr></table></figure></p>\n<p>来指出它们一起构成了map中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。因此，anthors将姓映射到名，初始化它包括三个元素。</p>\n<h3 id=\"初始化multimap或multiset\"><a href=\"#初始化multimap或multiset\" class=\"headerlink\" title=\"初始化multimap或multiset\"></a>初始化multimap或multiset</h3><p>一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字。</p>\n<h3 id=\"关键字类型的要求\"><a href=\"#关键字类型的要求\" class=\"headerlink\" title=\"关键字类型的要求\"></a>关键字类型的要求</h3><p>关联容器对其关键字类型有一些限制。对于无序容器中关键字的要求，我们后面介绍。对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型，在映射类型中，关键字类型是元素的第一部分的类型。因此，word_count的关键字类型是string。类似的，exclude的关键字类型也是string。</p>\n<h3 id=\"有序容器的关键字类型\"><a href=\"#有序容器的关键字类型\" class=\"headerlink\" title=\"有序容器的关键字类型\"></a>有序容器的关键字类型</h3><p>可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个严格弱序。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：</p>\n<ul>\n<li>两个关键字不能同时“小于等于”对方：如果k1“小于等于”k2，那么k2绝不能“小于等于”k1.</li>\n<li>如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3</li>\n<li>如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价与”k2，且k2“等价于”k3，那么k1必须“等价于”k3.</li>\n</ul>\n<p>如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map关键字时，只能有一个元素与这个关键字关联，我们可以用两者中任意一个来访问对应的值。</p>\n<h3 id=\"使用关键字的比较函数\"><a href=\"#使用关键字的比较函数\" class=\"headerlink\" title=\"使用关键字的比较函数\"></a>使用关键字的比较函数</h3><p>用来组织一个容器中元素的操作的类型也是容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟这元素类型给出。</p>\n<p>在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。</p>\n<p>例如，我们不能直接定义一个Sales_data的multiset，因为Sales_data没有&lt;运算符。但是，可以用定义的compareIsbn函数来定义一个multiset。此函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面这样定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compareIsbn</span><span class=\"params\">(<span class=\"keyword\">const</span> Sales_data &amp;lhs,<span class=\"keyword\">const</span> Sales_data &amp;rhs)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　<span class=\"keyword\">return</span> lhs.isbn()&lt;rhs.isbn();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了使用自己定义的操作，在定义multiset时我们必须提供两个类型。关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向compareIsbn的指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bookstore中多条记录可以有相同的ISBN</span></div><div class=\"line\"><span class=\"comment\">//bookstore中的元素以ISBN的顺序进行排序</span></div><div class=\"line\"><span class=\"built_in\">multiset</span>&lt;Sales_data,<span class=\"keyword\">decltype</span>(compareIsbn)*&gt; bookstore(compareIsbn);</div></pre></td></tr></table></figure>\n<p>此处，我们使用decltype来指出自定义操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。用compareIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过compareIsbn来为这些元素排序。即，bookstore中的元素将按它们的ISBN成员的值排序。可以用compareIsbn代替&amp;compareIsbn作为构造函数的参数，因为当我们使用一个函数的名字时，在需要的情况下它会自动转化为一个指针。当然，使用&amp;compareIsbn的效果也是一样的。</p>\n<h2 id=\"pair类型\"><a href=\"#pair类型\" class=\"headerlink\" title=\"pair类型\"></a>pair类型</h2><p>在介绍关联容器操作之前，我们需要了解名为pair的标准库类型，它定义在头文件utility中。</p>\n<p>一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">string</span>&gt; anon;  <span class=\"comment\">//保存两个string</span></div><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">size_t</span>&gt; word_count;   <span class=\"comment\">//保存一个string和一个size_t</span></div><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; line;  <span class=\"comment\">//保存string和vector&lt;int&gt;</span></div></pre></td></tr></table></figure>\n<p>pair的默认构造函数对数据成员进行值初始化。因此，anon是一个包含两个空string的pair，line保存一个空string和一个空vector。word_count中的size_t 成员值为0，而string成员被初始化为空vector。</p>\n<p>我们也可以为每个成员提供初始化器：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">string</span>&gt; author&#123;<span class=\"string\">\"James\"</span>,<span class=\"string\">\"Joyce\"</span>&#125;;</div></pre></td></tr></table></figure>\n<p>这条语句创建了一个名为author的pair，两个成员被初始化为”James”和”Joyce”。</p>\n<p>与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号来访问它们，例如</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;w.first&lt;&lt;<span class=\"string\">\" occurs \"</span>&lt;&lt;w.second&lt;&lt;<span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure>\n<p>此处，w 是指向某个元素的引用。map的元素是pair。在这条语句中，我们首先打印关键字——元素的first成员，接着打印计数器——second成员。标准库只定义了有限的几个pair操作，下表列出了这些操作：</p>\n<p><strong>pair上的操作</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;T1,T2&gt; p; 　　p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化</div><div class=\"line\">pair&lt;T1,T2&gt; p(v1,v2)　　p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化</div><div class=\"line\">pair&lt;T1,T2&gt; p=&#123;v1,v2&#125;;　　等价于p(v1,v2)</div><div class=\"line\">make_pair(v1,v2)　　返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来</div><div class=\"line\">p.first　　 返回p的名为first的（公有）数据成员</div><div class=\"line\">p.second　　返回p的名为second的（公有）数据成员</div><div class=\"line\">p1 relop p2　　　　　　　　　　　　　   关系运算符（&lt;、&gt;、&lt;=、&gt;=）按字典序定义；例如，当p1.first&lt;p2.first或!(p2.first&lt;p1.first)&amp;&amp;p1.second&lt;p2.second成立时，p1&lt;p2为<span class=\"literal\">true</span>。关系运算符利用元素的&lt;运算符来实现</div><div class=\"line\">p1==p2　当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现</div><div class=\"line\">p1!=p2</div></pre></td></tr></table></figure>\n<h3 id=\"创建pair对象的函数\"><a href=\"#创建pair对象的函数\" class=\"headerlink\" title=\"创建pair对象的函数\"></a>创建pair对象的函数</h3><p>想象有一个函数需要返回一个pair。在新标准下，我们可以对返回在进行列表初始化<br>复制代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt;</div><div class=\"line\">process(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;v)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//处理v</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!v.empty())</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;v.back(),v.back().size()); <span class=\"comment\">// 列表初始化</span></div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt;();  <span class=\"comment\">//隐式构造返回值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在较早的C++版本中，不允许用花括号包围的初始化器来返回pair这种类型的对象，必须显示构造返回值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!v.empty())</div><div class=\"line\">　　<span class=\"keyword\">return</span> pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt;(v.back(),v.back().size());</div></pre></td></tr></table></figure>\n<p>我们还可以用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!v.empty())</div><div class=\"line\">　　<span class=\"keyword\">return</span> make_pair(v.back(),v.back().size());</div></pre></td></tr></table></figure></p>\n<h2 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h2><p>新标准定义了4个无序关联容器。<strong>这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显有序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很</strong>有用。</p>\n<p>虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单。</p>\n<h3 id=\"使用无序容器\"><a href=\"#使用无序容器\" class=\"headerlink\" title=\"使用无序容器\"></a>使用无序容器</h3><p>除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert等）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。</p>\n<h3 id=\"管理桶\"><a href=\"#管理桶\" class=\"headerlink\" title=\"管理桶\"></a>管理桶</h3><p><strong>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同的关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</strong></p>\n<p>对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</p>\n<p>无序容器提供了一组管理桶的函数。如表所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p>\n<p><strong>无序容器管理操作</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">桶接口</div><div class=\"line\">c.bucket_count()　　　　　　　　正在使用的桶的数目</div><div class=\"line\">c.max_bucket_count() 　　　　　 容器能容纳的最多的桶的数量</div><div class=\"line\">c.bucket_size(n)　　　　　　　　  第n个桶中有多少元素</div><div class=\"line\">c.bucket(k)　　　　　　　　　　  关键字为k的元素在哪个桶中</div><div class=\"line\">桶迭代</div><div class=\"line\">local_iterator 　　　　　　　　　可以用来访问桶中元素的迭代器类型</div><div class=\"line\">const_local_iterator　　　　　　 桶迭代器的<span class=\"keyword\">const</span>版本</div><div class=\"line\">c.begin(n),c.end(n)　　　　　　   桶n的首元素迭代器和尾后迭代器</div><div class=\"line\">c.cbegin(n),c.cend(n)　　　　       返回const_local_iterator</div><div class=\"line\">哈希策略</div><div class=\"line\">c.load_factor()　　　　　　　　　每个桶的平均元素数量，返回<span class=\"keyword\">float</span>值</div><div class=\"line\">c.max_load_factor()　　　　　　 c试图维护的平均桶大小，返回<span class=\"keyword\">float</span>值，c会在需要时添加新的桶，以使得load_factor&lt;=max_load_factor</div><div class=\"line\">c.rehash(n)　　　　　　　　　　重组存储，使得bucket_count&gt;=n且bucket_count&gt;size/max_load_factor</div><div class=\"line\">c.reserve(n)　　　　　　　　　　重组存储，使得c可以保存n个元素且不必rehash</div></pre></td></tr></table></figure>\n<h3 id=\"无序容器对关键字类型的要求\"><a href=\"#无序容器对关键字类型的要求\" class=\"headerlink\" title=\"无序容器对关键字类型的要求\"></a>无序容器对关键字类型的要求</h3><p><strong>默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值</key_type></strong>。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要介绍的智能指针类型定义了hash。因此，<strong>我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针的无序容器。</strong></p>\n<p>但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。</p>\n<p>我们不能使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将Sales_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载函数开始：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> hasher(<span class=\"keyword\">const</span> Sales_data &amp;sd)</div><div class=\"line\">&#123;</div><div class=\"line\">　　<span class=\"keyword\">return</span> hash&lt;<span class=\"built_in\">string</span>&gt;()(sd.isbn());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">eqOp</span><span class=\"params\">(<span class=\"keyword\">const</span> Sales_data &amp;lhs,<span class=\"keyword\">const</span> Sales_data &amp;rhs)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　<span class=\"keyword\">return</span> lhs.isbn()==rhs.isbn();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。</p>\n<p>我们使用这些函数来定义一个unordered_multiset</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> SD_multiset=<span class=\"built_in\">unordered_multiset</span>&lt;Sales_data,decltypr(hasher)*,<span class=\"keyword\">decltype</span>(eqOp)*&gt;;</div><div class=\"line\"><span class=\"comment\">//参数是桶大小、哈希函数指针和相等型判断运算符指针</span></div><div class=\"line\"><span class=\"function\">SD_multiset <span class=\"title\">bookstore</span><span class=\"params\">(<span class=\"number\">42</span>,hasher,eqOp)</span></span>;</div></pre></td></tr></table></figure>\n<p>为了简化bookstore的定义，首先为unordered_multiset定义了一个类型别名，此集合的哈希和相等性判断操作与hasher和eqOp函数有着相同的类型。通过使用这种类型，在定义bookstore时可以将我们希望它使用的函数的指针传递给它。</p>\n<p>如果我们的类定义了==运算符，则可以只重载哈希函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用FooHash生成哈希值；Foo必须有==运算符</span></div><div class=\"line\"><span class=\"built_in\">unordered_set</span>&lt;Foo,<span class=\"keyword\">decltype</span>(FooHash)*&gt; fooset(<span class=\"number\">10</span>,FooHash);</div></pre></td></tr></table></figure>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unordered_map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt; word_count;</div><div class=\"line\">    word_count[<span class=\"string\">\"to\"</span>] = <span class=\"number\">10</span>;</div><div class=\"line\">    word_count[<span class=\"string\">\"be\"</span>] = <span class=\"number\">20</span>;</div><div class=\"line\">    <span class=\"keyword\">auto</span> iter = word_count.find(<span class=\"string\">\"be\"</span>);   <span class=\"comment\">//查找关键字为\"be\"的元素是否在unordered_map中，返回一个迭代器</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">auto</span> bucket = word_count.bucket(<span class=\"string\">\"to\"</span>);  <span class=\"comment\">//关键字为\"to\"的元素在那个桶上</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;bucket&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">auto</span> beg = word_count.begin(bucket);   <span class=\"comment\">//桶n的首元素迭代器，pair&lt;string,int&gt;类型</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;beg-&gt;first&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;beg-&gt;second&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>关联容器分为有序关联容器和无序关联容器，有序关联容器按关键字有序保存元素，底层数据结构为红黑树；无序关联容器底层数据结构是hashtable，因此是无序的。<br>","more":"</p>\n<h2 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h2><p>关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>\n<p>虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。</p>\n<p>关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素是一些关键字-值对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素包含一个关键字；set支持高效的关键字查询操作——检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。</p>\n<p>标准库提供8个关联容器，如下表所示。这8个容器间的不同体现在三个维度上：每个容器 <strong>（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保存关键字按顺序存储的容器的名字都以单词unordered开头</strong>。因此一个unordered_multi_set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。</p>\n<p>类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。</p>\n<p> <strong>关联容器类型</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">按关键字有序保存元素</div><div class=\"line\"><span class=\"built_in\">map</span> 　　　　　　　　关联数组：保存关键字-值对</div><div class=\"line\"><span class=\"built_in\">set</span>　　　　　　　　　关键字即值，即只保存关键字的容器</div><div class=\"line\"><span class=\"built_in\">multimap</span>　　　　　　关键字可重复出现的<span class=\"built_in\">map</span></div><div class=\"line\"><span class=\"built_in\">multiset</span>　　　　　　   关键字可重复出现的<span class=\"built_in\">set</span></div><div class=\"line\">无序容器</div><div class=\"line\"><span class=\"built_in\">unordered_map</span>　　　用哈希函数组织的<span class=\"built_in\">map</span></div><div class=\"line\"><span class=\"built_in\">unordered_set</span>　　　　用哈希函数组织的<span class=\"built_in\">set</span></div><div class=\"line\"><span class=\"built_in\">unordered_multimap</span>　　哈希组织的<span class=\"built_in\">map</span>；关键字可以重复出现</div><div class=\"line\"><span class=\"built_in\">unordered_multiset</span>　　  哈希组织的<span class=\"built_in\">set</span>；关键字可以重复出现</div></pre></td></tr></table></figure>\n<h2 id=\"关联容器概述\"><a href=\"#关联容器概述\" class=\"headerlink\" title=\"关联容器概述\"></a>关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p>\n<p>除了顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外，无序容器还提供了一些用来调整哈希性能的操作。</p>\n<p><strong>关联容器的迭代器都是双向的（可读写，多遍扫描，可递增递减）</strong>。</p>\n<h3 id=\"定义关联容器\"><a href=\"#定义关联容器\" class=\"headerlink\" title=\"定义关联容器\"></a>定义关联容器</h3><p>当定义一个map时，必须既指明关键字类型又指明值类型。而定义一个set时，只需指明关键字类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器，我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器中所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">size_t</span>&gt; word_count ; <span class=\"comment\">//空容器</span></div><div class=\"line\"><span class=\"comment\">//列表初始化</span></div><div class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; exclude=&#123;<span class=\"string\">\"the\"</span>,<span class=\"string\">\"but\"</span>,<span class=\"string\">\"and\"</span>,<span class=\"string\">\"or\"</span>,<span class=\"string\">\"an\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"The\"</span>,<span class=\"string\">\"But\"</span>,<span class=\"string\">\"And\"</span>,<span class=\"string\">\"Or\"</span>,<span class=\"string\">\"An\"</span>,<span class=\"string\">\"A\"</span>&#125;;</div><div class=\"line\"><span class=\"comment\">//三个元素；authors将姓映射到名</span></div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">string</span>&gt; autors=&#123; &#123;<span class=\"string\">\"Joyce\"</span>,<span class=\"string\">\"James\"</span>&#125;,</div><div class=\"line\">　　　　　　　　　　　　  &#123;<span class=\"string\">\"Austen\"</span>,<span class=\"string\">\"Jane\"</span>&#125;,</div><div class=\"line\">　　　　　　　　　　　　  &#123;<span class=\"string\">\"Dickens\"</span>,<span class=\"string\">\"Charles\"</span>&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>与以往一样，初始化器必须能转换为容器中元素的类型。对于set，元素类型就是关键字类型。<br>当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">　&#123;key,value&#125;</div></pre></td></tr></table></figure></p>\n<p>来指出它们一起构成了map中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。因此，anthors将姓映射到名，初始化它包括三个元素。</p>\n<h3 id=\"初始化multimap或multiset\"><a href=\"#初始化multimap或multiset\" class=\"headerlink\" title=\"初始化multimap或multiset\"></a>初始化multimap或multiset</h3><p>一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字。</p>\n<h3 id=\"关键字类型的要求\"><a href=\"#关键字类型的要求\" class=\"headerlink\" title=\"关键字类型的要求\"></a>关键字类型的要求</h3><p>关联容器对其关键字类型有一些限制。对于无序容器中关键字的要求，我们后面介绍。对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型，在映射类型中，关键字类型是元素的第一部分的类型。因此，word_count的关键字类型是string。类似的，exclude的关键字类型也是string。</p>\n<h3 id=\"有序容器的关键字类型\"><a href=\"#有序容器的关键字类型\" class=\"headerlink\" title=\"有序容器的关键字类型\"></a>有序容器的关键字类型</h3><p>可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个严格弱序。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：</p>\n<ul>\n<li>两个关键字不能同时“小于等于”对方：如果k1“小于等于”k2，那么k2绝不能“小于等于”k1.</li>\n<li>如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3</li>\n<li>如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价与”k2，且k2“等价于”k3，那么k1必须“等价于”k3.</li>\n</ul>\n<p>如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map关键字时，只能有一个元素与这个关键字关联，我们可以用两者中任意一个来访问对应的值。</p>\n<h3 id=\"使用关键字的比较函数\"><a href=\"#使用关键字的比较函数\" class=\"headerlink\" title=\"使用关键字的比较函数\"></a>使用关键字的比较函数</h3><p>用来组织一个容器中元素的操作的类型也是容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟这元素类型给出。</p>\n<p>在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。</p>\n<p>例如，我们不能直接定义一个Sales_data的multiset，因为Sales_data没有&lt;运算符。但是，可以用定义的compareIsbn函数来定义一个multiset。此函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面这样定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compareIsbn</span><span class=\"params\">(<span class=\"keyword\">const</span> Sales_data &amp;lhs,<span class=\"keyword\">const</span> Sales_data &amp;rhs)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　<span class=\"keyword\">return</span> lhs.isbn()&lt;rhs.isbn();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了使用自己定义的操作，在定义multiset时我们必须提供两个类型。关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向compareIsbn的指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bookstore中多条记录可以有相同的ISBN</span></div><div class=\"line\"><span class=\"comment\">//bookstore中的元素以ISBN的顺序进行排序</span></div><div class=\"line\"><span class=\"built_in\">multiset</span>&lt;Sales_data,<span class=\"keyword\">decltype</span>(compareIsbn)*&gt; bookstore(compareIsbn);</div></pre></td></tr></table></figure>\n<p>此处，我们使用decltype来指出自定义操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。用compareIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过compareIsbn来为这些元素排序。即，bookstore中的元素将按它们的ISBN成员的值排序。可以用compareIsbn代替&amp;compareIsbn作为构造函数的参数，因为当我们使用一个函数的名字时，在需要的情况下它会自动转化为一个指针。当然，使用&amp;compareIsbn的效果也是一样的。</p>\n<h2 id=\"pair类型\"><a href=\"#pair类型\" class=\"headerlink\" title=\"pair类型\"></a>pair类型</h2><p>在介绍关联容器操作之前，我们需要了解名为pair的标准库类型，它定义在头文件utility中。</p>\n<p>一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">string</span>&gt; anon;  <span class=\"comment\">//保存两个string</span></div><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">size_t</span>&gt; word_count;   <span class=\"comment\">//保存一个string和一个size_t</span></div><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; line;  <span class=\"comment\">//保存string和vector&lt;int&gt;</span></div></pre></td></tr></table></figure>\n<p>pair的默认构造函数对数据成员进行值初始化。因此，anon是一个包含两个空string的pair，line保存一个空string和一个空vector。word_count中的size_t 成员值为0，而string成员被初始化为空vector。</p>\n<p>我们也可以为每个成员提供初始化器：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">string</span>&gt; author&#123;<span class=\"string\">\"James\"</span>,<span class=\"string\">\"Joyce\"</span>&#125;;</div></pre></td></tr></table></figure>\n<p>这条语句创建了一个名为author的pair，两个成员被初始化为”James”和”Joyce”。</p>\n<p>与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号来访问它们，例如</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;w.first&lt;&lt;<span class=\"string\">\" occurs \"</span>&lt;&lt;w.second&lt;&lt;<span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure>\n<p>此处，w 是指向某个元素的引用。map的元素是pair。在这条语句中，我们首先打印关键字——元素的first成员，接着打印计数器——second成员。标准库只定义了有限的几个pair操作，下表列出了这些操作：</p>\n<p><strong>pair上的操作</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;T1,T2&gt; p; 　　p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化</div><div class=\"line\">pair&lt;T1,T2&gt; p(v1,v2)　　p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化</div><div class=\"line\">pair&lt;T1,T2&gt; p=&#123;v1,v2&#125;;　　等价于p(v1,v2)</div><div class=\"line\">make_pair(v1,v2)　　返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来</div><div class=\"line\">p.first　　 返回p的名为first的（公有）数据成员</div><div class=\"line\">p.second　　返回p的名为second的（公有）数据成员</div><div class=\"line\">p1 relop p2　　　　　　　　　　　　　   关系运算符（&lt;、&gt;、&lt;=、&gt;=）按字典序定义；例如，当p1.first&lt;p2.first或!(p2.first&lt;p1.first)&amp;&amp;p1.second&lt;p2.second成立时，p1&lt;p2为<span class=\"literal\">true</span>。关系运算符利用元素的&lt;运算符来实现</div><div class=\"line\">p1==p2　当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现</div><div class=\"line\">p1!=p2</div></pre></td></tr></table></figure>\n<h3 id=\"创建pair对象的函数\"><a href=\"#创建pair对象的函数\" class=\"headerlink\" title=\"创建pair对象的函数\"></a>创建pair对象的函数</h3><p>想象有一个函数需要返回一个pair。在新标准下，我们可以对返回在进行列表初始化<br>复制代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt;</div><div class=\"line\">process(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;v)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//处理v</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!v.empty())</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;v.back(),v.back().size()); <span class=\"comment\">// 列表初始化</span></div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt;();  <span class=\"comment\">//隐式构造返回值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在较早的C++版本中，不允许用花括号包围的初始化器来返回pair这种类型的对象，必须显示构造返回值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!v.empty())</div><div class=\"line\">　　<span class=\"keyword\">return</span> pair&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt;(v.back(),v.back().size());</div></pre></td></tr></table></figure>\n<p>我们还可以用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!v.empty())</div><div class=\"line\">　　<span class=\"keyword\">return</span> make_pair(v.back(),v.back().size());</div></pre></td></tr></table></figure></p>\n<h2 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h2><p>新标准定义了4个无序关联容器。<strong>这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显有序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很</strong>有用。</p>\n<p>虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单。</p>\n<h3 id=\"使用无序容器\"><a href=\"#使用无序容器\" class=\"headerlink\" title=\"使用无序容器\"></a>使用无序容器</h3><p>除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert等）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。</p>\n<h3 id=\"管理桶\"><a href=\"#管理桶\" class=\"headerlink\" title=\"管理桶\"></a>管理桶</h3><p><strong>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同的关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</strong></p>\n<p>对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</p>\n<p>无序容器提供了一组管理桶的函数。如表所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p>\n<p><strong>无序容器管理操作</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">桶接口</div><div class=\"line\">c.bucket_count()　　　　　　　　正在使用的桶的数目</div><div class=\"line\">c.max_bucket_count() 　　　　　 容器能容纳的最多的桶的数量</div><div class=\"line\">c.bucket_size(n)　　　　　　　　  第n个桶中有多少元素</div><div class=\"line\">c.bucket(k)　　　　　　　　　　  关键字为k的元素在哪个桶中</div><div class=\"line\">桶迭代</div><div class=\"line\">local_iterator 　　　　　　　　　可以用来访问桶中元素的迭代器类型</div><div class=\"line\">const_local_iterator　　　　　　 桶迭代器的<span class=\"keyword\">const</span>版本</div><div class=\"line\">c.begin(n),c.end(n)　　　　　　   桶n的首元素迭代器和尾后迭代器</div><div class=\"line\">c.cbegin(n),c.cend(n)　　　　       返回const_local_iterator</div><div class=\"line\">哈希策略</div><div class=\"line\">c.load_factor()　　　　　　　　　每个桶的平均元素数量，返回<span class=\"keyword\">float</span>值</div><div class=\"line\">c.max_load_factor()　　　　　　 c试图维护的平均桶大小，返回<span class=\"keyword\">float</span>值，c会在需要时添加新的桶，以使得load_factor&lt;=max_load_factor</div><div class=\"line\">c.rehash(n)　　　　　　　　　　重组存储，使得bucket_count&gt;=n且bucket_count&gt;size/max_load_factor</div><div class=\"line\">c.reserve(n)　　　　　　　　　　重组存储，使得c可以保存n个元素且不必rehash</div></pre></td></tr></table></figure>\n<h3 id=\"无序容器对关键字类型的要求\"><a href=\"#无序容器对关键字类型的要求\" class=\"headerlink\" title=\"无序容器对关键字类型的要求\"></a>无序容器对关键字类型的要求</h3><p><strong>默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值</key_type></strong>。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要介绍的智能指针类型定义了hash。因此，<strong>我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针的无序容器。</strong></p>\n<p>但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。</p>\n<p>我们不能使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将Sales_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载函数开始：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> hasher(<span class=\"keyword\">const</span> Sales_data &amp;sd)</div><div class=\"line\">&#123;</div><div class=\"line\">　　<span class=\"keyword\">return</span> hash&lt;<span class=\"built_in\">string</span>&gt;()(sd.isbn());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">eqOp</span><span class=\"params\">(<span class=\"keyword\">const</span> Sales_data &amp;lhs,<span class=\"keyword\">const</span> Sales_data &amp;rhs)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　<span class=\"keyword\">return</span> lhs.isbn()==rhs.isbn();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。</p>\n<p>我们使用这些函数来定义一个unordered_multiset</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> SD_multiset=<span class=\"built_in\">unordered_multiset</span>&lt;Sales_data,decltypr(hasher)*,<span class=\"keyword\">decltype</span>(eqOp)*&gt;;</div><div class=\"line\"><span class=\"comment\">//参数是桶大小、哈希函数指针和相等型判断运算符指针</span></div><div class=\"line\"><span class=\"function\">SD_multiset <span class=\"title\">bookstore</span><span class=\"params\">(<span class=\"number\">42</span>,hasher,eqOp)</span></span>;</div></pre></td></tr></table></figure>\n<p>为了简化bookstore的定义，首先为unordered_multiset定义了一个类型别名，此集合的哈希和相等性判断操作与hasher和eqOp函数有着相同的类型。通过使用这种类型，在定义bookstore时可以将我们希望它使用的函数的指针传递给它。</p>\n<p>如果我们的类定义了==运算符，则可以只重载哈希函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用FooHash生成哈希值；Foo必须有==运算符</span></div><div class=\"line\"><span class=\"built_in\">unordered_set</span>&lt;Foo,<span class=\"keyword\">decltype</span>(FooHash)*&gt; fooset(<span class=\"number\">10</span>,FooHash);</div></pre></td></tr></table></figure>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unordered_map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"built_in\">string</span>,<span class=\"keyword\">int</span>&gt; word_count;</div><div class=\"line\">    word_count[<span class=\"string\">\"to\"</span>] = <span class=\"number\">10</span>;</div><div class=\"line\">    word_count[<span class=\"string\">\"be\"</span>] = <span class=\"number\">20</span>;</div><div class=\"line\">    <span class=\"keyword\">auto</span> iter = word_count.find(<span class=\"string\">\"be\"</span>);   <span class=\"comment\">//查找关键字为\"be\"的元素是否在unordered_map中，返回一个迭代器</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">auto</span> bucket = word_count.bucket(<span class=\"string\">\"to\"</span>);  <span class=\"comment\">//关键字为\"to\"的元素在那个桶上</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;bucket&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">auto</span> beg = word_count.begin(bucket);   <span class=\"comment\">//桶n的首元素迭代器，pair&lt;string,int&gt;类型</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;beg-&gt;first&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;beg-&gt;second&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"动态内存与智能指针","date":"2017-11-10T13:59:00.000Z","update":null,"comments":1,"_content":"## 前言\n\n到目前为止，我们编写的程序中所使用的对象都有着严格定义的生命期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。\n\n<!--more-->\n\n除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。\n\n动态对象的正确释放被证明是编程中极其容器出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。\n\n### 静态内存、栈内存、堆\n\n**静态内存**：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。\n\n**栈内存**：用来保存定义在函数内的非static对象。\n\n分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。\n\n除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作**自由空间（free store）**或**堆（heap）**。程序用堆来存储**动态分配**（dynamically allocate）的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。\n\n**warning**：虽然使用动态内存有时是必要的，但众所周知，正确管理动态内存是非常棘手的。\n\n## 动态内存与智能指针\n\n**在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针。我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。**\n\n动态内存的使用很容易出问题，因为确保在正确的时间释放内存是及其困难的。有时我们会忘记释放内存，在这种情况下就会产生**内存泄漏**；有时在尚有指针引用内存的情况下我们就释放它了，在这种情况下就会产生**引用非法内存的指针**。\n\n为了更容易（同时也安全）地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。只能指针的行为类似常规指针，重要的区别是**它负责自动释放所指向的对象**。新标准库提供的这两种只能指针的区别在于管理底层指针的方式：**shared_ptr允许多个指针指向同一对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。**\n\n### shared_ptr类\n\n类似vector，只能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种指针的名字：\n\n```C++\nshared_ptr<string> p1 ; //shared_ptr,可以指向string\nshared_ptr<list<int> > p2;  //shared_ptr,可以指向int的list\n```\n\n默认初始化的智能指针中保存着一个空指针。\n\n只能指针的使用方式与普通指针类似。解引用一个智能指针返回它所指的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：\n\n```C++\n//如果p1不为空，检查它是否指向一个空string\nif(p1&&p1->empty())\n　　*p1=\"hi\";\n```\n\n下表列出了shared_ptr和unique_ptr都支持的操作。只适用shared_ptr的操作列入下面。\n\n **shared_ptr和unique_ptr都支持的操作** \n\n```C++\nshared_ptr<T> sp     空智能指针，可以指向类型为T的对象\nunique_ptr<T> up    \np　　　　　　将p用作一个条件判断，若p指向一个对象，则为true\n*p　　　　　　解引用p，获得它指向的对象\np->mem　　　　　等价于(*p).mem\np.get()　　　　　　返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了\nswap(p,q) 　　　　交换p和q中的指针\np.swap(q) \n```\n\n **shared_ptr独有的操作** \n\n```C++\nmake_shared<T>(args)　　　　　返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象\nshared_ptr<T> p(q)　　　　　　　p是shared_ptr q的一个拷贝，此操作会递增q中的计数器。q中的指针必须都能转换为T*\np=q　　　　　　　　　　　　　　p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为0，则将其管理　　　　　　　　　　　　　　　　的原内存释放\np.unique()  　　　　　　　　　　  若p.use_count()为1，返回true，否则返回false\np.use_count() 　　　　　　　　　返回与p共享对象的智能指针的数量；可能很慢，主要用于调试\n```\n\n### make_shared函数\n\n最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。**此函数在动态内存中分配一个对象并初始化它，返回指向对象的shared_ptr**。与智能指针一样，make_shared也定义在头文件memory中。\n\n当要使用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：\n\n```C++\n//指向一个值为42的int的shared_ptr\nshared_ptr<int> p3=make_shared<int> (42);\n//p4指向一个值为\"99999\"的string\nshared_ptr<string> p4=make_shared<string> (5,'9');\n//p5指向一个值初始化的int，即，值为0\nshared_ptr<int> p5=make_shared<int> ();\n```\n\n类似顺序容器的emplace成员，**make_shared用其参数来构造给定类型的对象**。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int> 时传递的参数必须能用来初始化一个int，依次类推。如果我们不传递任何参数，对象就会进行值初始化。\n\n当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式较简单：\n\n```C++\n//p6指向一个动态分配的空vector<string>\nauto p6=make_shared<vector<string>> ();\n```\n\n### shared_ptr的拷贝和赋值\n\n当进行拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。\n\n```C++\nauto p=make_shard<int>(42); //p指向的对象只有p一个引用者\nauto q(p);  //p和q指向相同的对象，此对象有两个引用者\n```\n\n我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器都会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域时，计数器就会递减）\n\n一旦一个shared_ptr的计算器变为0，它就会自动释放自己所管理的对象：\n\n```\nauto r=make_shared<int>(42);  //r指向的int只有一个引用者\nr=q;   //给r赋值，令它指向另一个地址，递增q指向的对象的引用计数，递减r原来指向的对象的引用计数，r原来指向的对象已没有引用者，会自动释放\n```\n\n此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一执行此int的shared_ptr，在把q赋给r的过程中，此int被自动释放。\n\n### shared_ptr自动销毁所管理的对象\n\n**当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象**。它是通过另一个特殊的成员函数——析构函数完成销毁工作的。类似与构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。\n\n**析构函数一般用来释放对象分配的资源**。例如，string的构造函数（以及其他string成员）会分配内存来保存构成string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。\n\n**shared_ptr的析构函数会递减它所指对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存**。\n\n### shared_ptr还会自动释放相关联的内存 \n\n当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如，我们可能有一个函数，它返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的：\n\n```C++\n//factory返回一个shared_ptr，指向一个动态分配的对象\nshared_ptr<Foo> factory(T arg)\n{\n    //恰当地处理arg\n    //shared_ptr负责释放内存\n    return make_shared<Foo>(arg);\n}\n```\n\n由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时刻被释放。例如，下面的函数将factory返回的shared_ptr保存在局部变量中：\n\n```C++\nvoid use_factory(T arg)\n{\n    shared_ptr<Foo> p=factory(arg);\n    //使用p\n    //p离开了作用域，它指向的内存会被自动释放掉\n}\n```\n\n由于p是use_factory的局部变量，在use_factory结束时它将被销毁。当p被销毁时，将递减其引用计数并检查它是否为0。在此例中，p是唯一引用factory返回的内存的对象。由于p将要销毁，p指向的这个对象也会被销毁，所占用的内存会被释放。\n\n但如果有其他的shared_ptr也指向这块内存，它就不会被释放掉：\n\n```C++\nvoid use_factory(T arg)\n{\n    shared_ptr<Foo> p=factory(arg);\n    //使用p\n    return p; //当我们返回p时，引用计数进行了递增操作\n} //p离开了作用域，但它指向的内存不会被释放\n```\n\n在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。\n\n由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。shared_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某种元素。在这种情况西下，你应该确保erase删除哪些不再需要的shared_ptr元素。\n\n**注意：如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。**\n\n### 使用了动态生存期的资源的类\n\n程序使用动态内存处于以下三种原因之一：\n\n1 程序不知道自己需要使用多少个对象；\n\n2 程序不知到所需的准确类型\n\n3 程序需要在多个对象间共享数据\n\n容器类是处于第一种原因而使用动态内存的典型例子。\n\n使用动态内存的一个常见原因是运行多个对象共享相同的状态。\n\n\n## 直接管理内存\n\nC++语言定义了两个运算符来分配和释放动态内存。**运算符new分配内存，delete释放new分配的内存。**\n\n相对于智能指针，使用这两个运算符管理内存非常容易出错，随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。\n\n### 使用new动态分配和初始化对象\n\n在自由空间分配的内存是无名的。因此，new无法为其分配的对象命名，而是返回一个执行对象的指针：\n\n```C++\nint *pi=new int ;   // pi指向一个动态分配的、未初始化的无名对象\n```\n\n此new表达式在自由空间构造一个int型对象，并返回指向该对象的指针。\n\n**默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化**：\n\n```C++\nstring *ps=new string; //初始化为空string\nint *pi=new int ; // pi指向一个未初始化的int\n```\n\n我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）：\n\n```C++\nint *pi=new int(1024)  ;//pi的对象的值为1024\nstring *ps=new string(10,'9') ; //vector有10个元素，值依次从0到9\nvector<int> *pv=new vector<int>{0,1,2,3,4,5,6,7,8,9};\n```\n\n也可以**对动态的对象进行值初始化，只需在类型名之后跟一对空括号即可**：\n\n```C++\nstring *ps1=new string;   //默认初始化为空string\nstring *ps=new string();  //值初始化为空string\nint *pi1=new int; //默认初始化：*pi1的值未定义\nint *pi2=new int();   // 值初始化为0 *pi2为0\n```\n\n对于定义与自己的构造函数的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。\n\n如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto：\n\n```C++\nauto p1=new auto(obj) ; //p指向一个与obj类型相同的对象\nauto p2=new auto(a,b,c) ;  //错误：括号中只能有单个初始化器\n```\n\np1的类型是一个指针，执行从obj自动推断的类型。若obj是一个int，那么p1就算int*；若obj是一个string，那么p1是一个string*；依次类推。新分配的对象用obj的值进行初始化。\n\n### 动态分配的const对象\n\n用new分配const对象是合法的：\n\n```C++\n//分配并初始化一个const int\nconst int *pci=new const int(1024);\n//分配并默认初始化一个const的空string\nconst string *pcs=new const string;\n```\n\n类似其他任何const对象，**一个动态分配的const对象必须进行初始化**。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，**new 返回的指针是一个指向const的指针**。\n\n### 内存耗尽\n\n虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败，默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：\n\n```C++\n//如果分配失败，new返回一个空指针\nint *p1=new int ; //如果分配失败，new抛出std::bad_alloc\nint *p2=new (nothrow) int ; //如果分配失败，new返回一个空指针\n```\n\n我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数，在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。\n\n### 释放动态内存\n\n为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式来将动态内存归还给系统。**delete表达式接受一个指针，指向我们想要释放的对象**：\n\n```C++\ndelete p; // p必须指向一个动态分配的对象或是一个空指针\n```\n\n与new 类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。\n\n### 指针值和delete\n\n我们传递给delete的指针必须指向动态分配的内存，或是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的：\n\n```C++\nint i,*pi1=&i,*pi2=nullptr;\ndouble *pd=new double(33),*pd2=pd;\ndelete i;  //错误，i不是一个指针\ndelete pi1; //未定义：pi1执行一个局部变量\ndelete pd; //正确\ndelete pd2;  //未定义，pd2指向的内存已经被释放了\ndelete pi2;  //正确：释放一个空指针总是没有错误的\n```\n\n对于delete i的请求，编译器会生成一个错误信息，因为它知道i不是一个指针。执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些delete表达式，大多数编译器会编译通过，尽管它们是错误的。\n\n虽然一个const对象的值不能被改变，但它本身是可以被销毁的，如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可。\n\n```C++\nconst int *pci=new const int(1024); \ndelete pci; //正确：释放一个从const对象\n```\n\n### 动态对象的生存期直到被释放时为止\n\n由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。**对于一个由内置指针管理的动态对象，直到被显示释放之前它都是存在的。**\n\n返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：\n\n```C++\n//factory返回一个指针，指向一个动态分配的对象\nFoo* factory(T arg)\n{\n　　//视情况处理arg\n　　return new Foo(arg); //调用者负责释放此内存\n}\n```\n\n类似我们之前定义的factory函数，这个版本的factory分配一个对象，但并不delete它。factory的调用者负责在不需要此对象时释放它。不幸的是，调用者经常忘记释放对象：\n\n```C++\nvoid use_factory(T arg)\n{\n　　Foo *p=factory(arg);\n　　//使用p但不delete它\n} //p离开了它的作用域，但它所指向的内存没有被释放\n```\n\n此外，use_factory函数调用factory，后者分配一个类型为Foo的新对象。当use_factory返回时，局部变量p被销毁，此变量是一个内置指针，而不是一个智能指针。\n\n与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。\n\n**注意**：**由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在**。\n\n在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，程序就没有办法释放这块内存了。根据整个程序的逻辑，修正这个错误的正确方法是在use_factory中记得要释放内存：\n\n```C++\nvoid use_factory(T arg)\n{ \n　　Foo *p=factory(arg);\n　　//使用p\n　　delete p ;  //现在记得释放内存，我们已经不需要它了\n}\n```\n\n还有一种可能，我们的系统中的其他代码要使用use_factory所分配的对象，我们就应该修改此函数，让他返回一个指针，指向它分配的内存：\n\n```C++\nFoo* use_factory(T arg)\n{\n　　Foo *p=factory(arg);\n　　//使用p\n　　return p; //调用者必须释放内存\n}\n```\n\n **小心：动态内存的管理非常容易出错** \n\n使用new和delete管理动态内存存在三个常见问题：\n\n- 忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。\n\n- 使用以及释放掉的对象，通过在释放内存后将指针置为空，有时可以检测出这种错误。\n\n- 同一块内存被释放两次，当有来年刚给指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了，如果我们随后又delete第一个指针，自由空间就可能会被破坏。\n\n相对于查找和修正这种错误来源，制造出这些错误要简单很多。\n\n**坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何只能智能指针指向它的情况下，智能指针才会自动释放它**。\n\n\n### delete之后重置指针值。。。。\n\n当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的**空悬指针**，即，指向一块层级保存数据对象但现在以及无效的内存的指针。\n\n为初始化指针的所有确定空悬指针也都有，有一种方法可以避免空悬指针的问题；在指针即将要离开其作用域之前释放掉它所关联的内存。这样在指针关联的内存被释放掉之后，就没有机会继续使用指针了。**如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。**\n\n### 这只是提供了有限的保护\n\n动态内存的一个基本问题是可能有多个指针指向相同的内存，在delete内存之后重置指针的方法只对这个指针有效，对其他任何指向（已释放的）内存的指针是没有作用的。例如：\n\n```C++\nint *p(new int (42));  //p指向动态内存\nauto q=p;  //p和q指向相同的内存\ndelete p; //p和q均变为无效\np=nullptr;  //指出p不再绑定到任何对象\n```\n\n本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr指出它不再指向任何对象，但是，重置p对q没有任何作用，在我们释放p所指向的（同时也是q所指向的）内存时，q也变为无效了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/动态内存与智能指针.md","raw":"---\ntitle: 动态内存与智能指针\ndate: 2017-11-10 21:59:00\nupdate: \ntags: [智能指针,内存分配]\ncategories: C++\ncomments: true\n---\n## 前言\n\n到目前为止，我们编写的程序中所使用的对象都有着严格定义的生命期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。\n\n<!--more-->\n\n除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。\n\n动态对象的正确释放被证明是编程中极其容器出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。\n\n### 静态内存、栈内存、堆\n\n**静态内存**：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。\n\n**栈内存**：用来保存定义在函数内的非static对象。\n\n分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。\n\n除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作**自由空间（free store）**或**堆（heap）**。程序用堆来存储**动态分配**（dynamically allocate）的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。\n\n**warning**：虽然使用动态内存有时是必要的，但众所周知，正确管理动态内存是非常棘手的。\n\n## 动态内存与智能指针\n\n**在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针。我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。**\n\n动态内存的使用很容易出问题，因为确保在正确的时间释放内存是及其困难的。有时我们会忘记释放内存，在这种情况下就会产生**内存泄漏**；有时在尚有指针引用内存的情况下我们就释放它了，在这种情况下就会产生**引用非法内存的指针**。\n\n为了更容易（同时也安全）地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。只能指针的行为类似常规指针，重要的区别是**它负责自动释放所指向的对象**。新标准库提供的这两种只能指针的区别在于管理底层指针的方式：**shared_ptr允许多个指针指向同一对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。**\n\n### shared_ptr类\n\n类似vector，只能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种指针的名字：\n\n```C++\nshared_ptr<string> p1 ; //shared_ptr,可以指向string\nshared_ptr<list<int> > p2;  //shared_ptr,可以指向int的list\n```\n\n默认初始化的智能指针中保存着一个空指针。\n\n只能指针的使用方式与普通指针类似。解引用一个智能指针返回它所指的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：\n\n```C++\n//如果p1不为空，检查它是否指向一个空string\nif(p1&&p1->empty())\n　　*p1=\"hi\";\n```\n\n下表列出了shared_ptr和unique_ptr都支持的操作。只适用shared_ptr的操作列入下面。\n\n **shared_ptr和unique_ptr都支持的操作** \n\n```C++\nshared_ptr<T> sp     空智能指针，可以指向类型为T的对象\nunique_ptr<T> up    \np　　　　　　将p用作一个条件判断，若p指向一个对象，则为true\n*p　　　　　　解引用p，获得它指向的对象\np->mem　　　　　等价于(*p).mem\np.get()　　　　　　返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了\nswap(p,q) 　　　　交换p和q中的指针\np.swap(q) \n```\n\n **shared_ptr独有的操作** \n\n```C++\nmake_shared<T>(args)　　　　　返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象\nshared_ptr<T> p(q)　　　　　　　p是shared_ptr q的一个拷贝，此操作会递增q中的计数器。q中的指针必须都能转换为T*\np=q　　　　　　　　　　　　　　p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为0，则将其管理　　　　　　　　　　　　　　　　的原内存释放\np.unique()  　　　　　　　　　　  若p.use_count()为1，返回true，否则返回false\np.use_count() 　　　　　　　　　返回与p共享对象的智能指针的数量；可能很慢，主要用于调试\n```\n\n### make_shared函数\n\n最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。**此函数在动态内存中分配一个对象并初始化它，返回指向对象的shared_ptr**。与智能指针一样，make_shared也定义在头文件memory中。\n\n当要使用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：\n\n```C++\n//指向一个值为42的int的shared_ptr\nshared_ptr<int> p3=make_shared<int> (42);\n//p4指向一个值为\"99999\"的string\nshared_ptr<string> p4=make_shared<string> (5,'9');\n//p5指向一个值初始化的int，即，值为0\nshared_ptr<int> p5=make_shared<int> ();\n```\n\n类似顺序容器的emplace成员，**make_shared用其参数来构造给定类型的对象**。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int> 时传递的参数必须能用来初始化一个int，依次类推。如果我们不传递任何参数，对象就会进行值初始化。\n\n当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式较简单：\n\n```C++\n//p6指向一个动态分配的空vector<string>\nauto p6=make_shared<vector<string>> ();\n```\n\n### shared_ptr的拷贝和赋值\n\n当进行拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。\n\n```C++\nauto p=make_shard<int>(42); //p指向的对象只有p一个引用者\nauto q(p);  //p和q指向相同的对象，此对象有两个引用者\n```\n\n我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器都会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域时，计数器就会递减）\n\n一旦一个shared_ptr的计算器变为0，它就会自动释放自己所管理的对象：\n\n```\nauto r=make_shared<int>(42);  //r指向的int只有一个引用者\nr=q;   //给r赋值，令它指向另一个地址，递增q指向的对象的引用计数，递减r原来指向的对象的引用计数，r原来指向的对象已没有引用者，会自动释放\n```\n\n此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一执行此int的shared_ptr，在把q赋给r的过程中，此int被自动释放。\n\n### shared_ptr自动销毁所管理的对象\n\n**当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象**。它是通过另一个特殊的成员函数——析构函数完成销毁工作的。类似与构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。\n\n**析构函数一般用来释放对象分配的资源**。例如，string的构造函数（以及其他string成员）会分配内存来保存构成string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。\n\n**shared_ptr的析构函数会递减它所指对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存**。\n\n### shared_ptr还会自动释放相关联的内存 \n\n当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如，我们可能有一个函数，它返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的：\n\n```C++\n//factory返回一个shared_ptr，指向一个动态分配的对象\nshared_ptr<Foo> factory(T arg)\n{\n    //恰当地处理arg\n    //shared_ptr负责释放内存\n    return make_shared<Foo>(arg);\n}\n```\n\n由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时刻被释放。例如，下面的函数将factory返回的shared_ptr保存在局部变量中：\n\n```C++\nvoid use_factory(T arg)\n{\n    shared_ptr<Foo> p=factory(arg);\n    //使用p\n    //p离开了作用域，它指向的内存会被自动释放掉\n}\n```\n\n由于p是use_factory的局部变量，在use_factory结束时它将被销毁。当p被销毁时，将递减其引用计数并检查它是否为0。在此例中，p是唯一引用factory返回的内存的对象。由于p将要销毁，p指向的这个对象也会被销毁，所占用的内存会被释放。\n\n但如果有其他的shared_ptr也指向这块内存，它就不会被释放掉：\n\n```C++\nvoid use_factory(T arg)\n{\n    shared_ptr<Foo> p=factory(arg);\n    //使用p\n    return p; //当我们返回p时，引用计数进行了递增操作\n} //p离开了作用域，但它指向的内存不会被释放\n```\n\n在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。\n\n由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。shared_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某种元素。在这种情况西下，你应该确保erase删除哪些不再需要的shared_ptr元素。\n\n**注意：如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。**\n\n### 使用了动态生存期的资源的类\n\n程序使用动态内存处于以下三种原因之一：\n\n1 程序不知道自己需要使用多少个对象；\n\n2 程序不知到所需的准确类型\n\n3 程序需要在多个对象间共享数据\n\n容器类是处于第一种原因而使用动态内存的典型例子。\n\n使用动态内存的一个常见原因是运行多个对象共享相同的状态。\n\n\n## 直接管理内存\n\nC++语言定义了两个运算符来分配和释放动态内存。**运算符new分配内存，delete释放new分配的内存。**\n\n相对于智能指针，使用这两个运算符管理内存非常容易出错，随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。\n\n### 使用new动态分配和初始化对象\n\n在自由空间分配的内存是无名的。因此，new无法为其分配的对象命名，而是返回一个执行对象的指针：\n\n```C++\nint *pi=new int ;   // pi指向一个动态分配的、未初始化的无名对象\n```\n\n此new表达式在自由空间构造一个int型对象，并返回指向该对象的指针。\n\n**默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化**：\n\n```C++\nstring *ps=new string; //初始化为空string\nint *pi=new int ; // pi指向一个未初始化的int\n```\n\n我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）：\n\n```C++\nint *pi=new int(1024)  ;//pi的对象的值为1024\nstring *ps=new string(10,'9') ; //vector有10个元素，值依次从0到9\nvector<int> *pv=new vector<int>{0,1,2,3,4,5,6,7,8,9};\n```\n\n也可以**对动态的对象进行值初始化，只需在类型名之后跟一对空括号即可**：\n\n```C++\nstring *ps1=new string;   //默认初始化为空string\nstring *ps=new string();  //值初始化为空string\nint *pi1=new int; //默认初始化：*pi1的值未定义\nint *pi2=new int();   // 值初始化为0 *pi2为0\n```\n\n对于定义与自己的构造函数的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。\n\n如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto：\n\n```C++\nauto p1=new auto(obj) ; //p指向一个与obj类型相同的对象\nauto p2=new auto(a,b,c) ;  //错误：括号中只能有单个初始化器\n```\n\np1的类型是一个指针，执行从obj自动推断的类型。若obj是一个int，那么p1就算int*；若obj是一个string，那么p1是一个string*；依次类推。新分配的对象用obj的值进行初始化。\n\n### 动态分配的const对象\n\n用new分配const对象是合法的：\n\n```C++\n//分配并初始化一个const int\nconst int *pci=new const int(1024);\n//分配并默认初始化一个const的空string\nconst string *pcs=new const string;\n```\n\n类似其他任何const对象，**一个动态分配的const对象必须进行初始化**。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，**new 返回的指针是一个指向const的指针**。\n\n### 内存耗尽\n\n虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败，默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：\n\n```C++\n//如果分配失败，new返回一个空指针\nint *p1=new int ; //如果分配失败，new抛出std::bad_alloc\nint *p2=new (nothrow) int ; //如果分配失败，new返回一个空指针\n```\n\n我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数，在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。\n\n### 释放动态内存\n\n为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式来将动态内存归还给系统。**delete表达式接受一个指针，指向我们想要释放的对象**：\n\n```C++\ndelete p; // p必须指向一个动态分配的对象或是一个空指针\n```\n\n与new 类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。\n\n### 指针值和delete\n\n我们传递给delete的指针必须指向动态分配的内存，或是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的：\n\n```C++\nint i,*pi1=&i,*pi2=nullptr;\ndouble *pd=new double(33),*pd2=pd;\ndelete i;  //错误，i不是一个指针\ndelete pi1; //未定义：pi1执行一个局部变量\ndelete pd; //正确\ndelete pd2;  //未定义，pd2指向的内存已经被释放了\ndelete pi2;  //正确：释放一个空指针总是没有错误的\n```\n\n对于delete i的请求，编译器会生成一个错误信息，因为它知道i不是一个指针。执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些delete表达式，大多数编译器会编译通过，尽管它们是错误的。\n\n虽然一个const对象的值不能被改变，但它本身是可以被销毁的，如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可。\n\n```C++\nconst int *pci=new const int(1024); \ndelete pci; //正确：释放一个从const对象\n```\n\n### 动态对象的生存期直到被释放时为止\n\n由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。**对于一个由内置指针管理的动态对象，直到被显示释放之前它都是存在的。**\n\n返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：\n\n```C++\n//factory返回一个指针，指向一个动态分配的对象\nFoo* factory(T arg)\n{\n　　//视情况处理arg\n　　return new Foo(arg); //调用者负责释放此内存\n}\n```\n\n类似我们之前定义的factory函数，这个版本的factory分配一个对象，但并不delete它。factory的调用者负责在不需要此对象时释放它。不幸的是，调用者经常忘记释放对象：\n\n```C++\nvoid use_factory(T arg)\n{\n　　Foo *p=factory(arg);\n　　//使用p但不delete它\n} //p离开了它的作用域，但它所指向的内存没有被释放\n```\n\n此外，use_factory函数调用factory，后者分配一个类型为Foo的新对象。当use_factory返回时，局部变量p被销毁，此变量是一个内置指针，而不是一个智能指针。\n\n与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。\n\n**注意**：**由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在**。\n\n在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，程序就没有办法释放这块内存了。根据整个程序的逻辑，修正这个错误的正确方法是在use_factory中记得要释放内存：\n\n```C++\nvoid use_factory(T arg)\n{ \n　　Foo *p=factory(arg);\n　　//使用p\n　　delete p ;  //现在记得释放内存，我们已经不需要它了\n}\n```\n\n还有一种可能，我们的系统中的其他代码要使用use_factory所分配的对象，我们就应该修改此函数，让他返回一个指针，指向它分配的内存：\n\n```C++\nFoo* use_factory(T arg)\n{\n　　Foo *p=factory(arg);\n　　//使用p\n　　return p; //调用者必须释放内存\n}\n```\n\n **小心：动态内存的管理非常容易出错** \n\n使用new和delete管理动态内存存在三个常见问题：\n\n- 忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。\n\n- 使用以及释放掉的对象，通过在释放内存后将指针置为空，有时可以检测出这种错误。\n\n- 同一块内存被释放两次，当有来年刚给指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了，如果我们随后又delete第一个指针，自由空间就可能会被破坏。\n\n相对于查找和修正这种错误来源，制造出这些错误要简单很多。\n\n**坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何只能智能指针指向它的情况下，智能指针才会自动释放它**。\n\n\n### delete之后重置指针值。。。。\n\n当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的**空悬指针**，即，指向一块层级保存数据对象但现在以及无效的内存的指针。\n\n为初始化指针的所有确定空悬指针也都有，有一种方法可以避免空悬指针的问题；在指针即将要离开其作用域之前释放掉它所关联的内存。这样在指针关联的内存被释放掉之后，就没有机会继续使用指针了。**如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。**\n\n### 这只是提供了有限的保护\n\n动态内存的一个基本问题是可能有多个指针指向相同的内存，在delete内存之后重置指针的方法只对这个指针有效，对其他任何指向（已释放的）内存的指针是没有作用的。例如：\n\n```C++\nint *p(new int (42));  //p指向动态内存\nauto q=p;  //p和q指向相同的内存\ndelete p; //p和q均变为无效\np=nullptr;  //指出p不再绑定到任何对象\n```\n\n本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr指出它不再指向任何对象，但是，重置p对q没有任何作用，在我们释放p所指向的（同时也是q所指向的）内存时，q也变为无效了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"动态内存与智能指针","published":1,"updated":"2018-02-22T12:18:17.254Z","layout":"post","photos":[],"link":"","_id":"cjdz6yqu900057wc94n6r7759","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>到目前为止，我们编写的程序中所使用的对象都有着严格定义的生命期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。</p>\n<a id=\"more\"></a>\n<p>除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。</p>\n<p>动态对象的正确释放被证明是编程中极其容器出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p>\n<h3 id=\"静态内存、栈内存、堆\"><a href=\"#静态内存、栈内存、堆\" class=\"headerlink\" title=\"静态内存、栈内存、堆\"></a>静态内存、栈内存、堆</h3><p><strong>静态内存</strong>：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</p>\n<p><strong>栈内存</strong>：用来保存定义在函数内的非static对象。</p>\n<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</p>\n<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间（free store）</strong>或<strong>堆（heap）</strong>。程序用堆来存储<strong>动态分配</strong>（dynamically allocate）的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</p>\n<p><strong>warning</strong>：虽然使用动态内存有时是必要的，但众所周知，正确管理动态内存是非常棘手的。</p>\n<h2 id=\"动态内存与智能指针\"><a href=\"#动态内存与智能指针\" class=\"headerlink\" title=\"动态内存与智能指针\"></a>动态内存与智能指针</h2><p><strong>在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针。我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</strong></p>\n<p>动态内存的使用很容易出问题，因为确保在正确的时间释放内存是及其困难的。有时我们会忘记释放内存，在这种情况下就会产生<strong>内存泄漏</strong>；有时在尚有指针引用内存的情况下我们就释放它了，在这种情况下就会产生<strong>引用非法内存的指针</strong>。</p>\n<p>为了更容易（同时也安全）地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。只能指针的行为类似常规指针，重要的区别是<strong>它负责自动释放所指向的对象</strong>。新标准库提供的这两种只能指针的区别在于管理底层指针的方式：<strong>shared_ptr允许多个指针指向同一对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</strong></p>\n<h3 id=\"shared-ptr类\"><a href=\"#shared-ptr类\" class=\"headerlink\" title=\"shared_ptr类\"></a>shared_ptr类</h3><p>类似vector，只能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种指针的名字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p1 ; <span class=\"comment\">//shared_ptr,可以指向string</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; p2;  <span class=\"comment\">//shared_ptr,可以指向int的list</span></div></pre></td></tr></table></figure>\n<p>默认初始化的智能指针中保存着一个空指针。</p>\n<p>只能指针的使用方式与普通指针类似。解引用一个智能指针返回它所指的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//如果p1不为空，检查它是否指向一个空string</span></div><div class=\"line\"><span class=\"keyword\">if</span>(p1&amp;&amp;p1-&gt;empty())</div><div class=\"line\">　　*p1=<span class=\"string\">\"hi\"</span>;</div></pre></td></tr></table></figure>\n<p>下表列出了shared_ptr和unique_ptr都支持的操作。只适用shared_ptr的操作列入下面。</p>\n<p> <strong>shared_ptr和unique_ptr都支持的操作</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; sp     空智能指针，可以指向类型为T的对象</div><div class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;T&gt; up    </div><div class=\"line\">p　　　　　　将p用作一个条件判断，若p指向一个对象，则为<span class=\"literal\">true</span></div><div class=\"line\">*p　　　　　　解引用p，获得它指向的对象</div><div class=\"line\">p-&gt;mem　　　　　等价于(*p).mem</div><div class=\"line\">p.get()　　　　　　返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</div><div class=\"line\">swap(p,q) 　　　　交换p和q中的指针</div><div class=\"line\">p.swap(q)</div></pre></td></tr></table></figure>\n<p> <strong>shared_ptr独有的操作</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">make_shared&lt;T&gt;(args)　　　　　返回一个<span class=\"built_in\">shared_ptr</span>，指向一个动态分配的类型为T的对象，使用args初始化此对象</div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; p(q)　　　　　　　p是<span class=\"built_in\">shared_ptr</span> q的一个拷贝，此操作会递增q中的计数器。q中的指针必须都能转换为T*</div><div class=\"line\">p=q　　　　　　　　　　　　　　p和q都是<span class=\"built_in\">shared_ptr</span>，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为<span class=\"number\">0</span>，则将其管理　　　　　　　　　　　　　　　　的原内存释放</div><div class=\"line\">p.unique()  　　　　　　　　　　  若p.use_count()为<span class=\"number\">1</span>，返回<span class=\"literal\">true</span>，否则返回<span class=\"literal\">false</span></div><div class=\"line\">p.use_count() 　　　　　　　　　返回与p共享对象的智能指针的数量；可能很慢，主要用于调试</div></pre></td></tr></table></figure>\n<h3 id=\"make-shared函数\"><a href=\"#make-shared函数\" class=\"headerlink\" title=\"make_shared函数\"></a>make_shared函数</h3><p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。<strong>此函数在动态内存中分配一个对象并初始化它，返回指向对象的shared_ptr</strong>。与智能指针一样，make_shared也定义在头文件memory中。</p>\n<p>当要使用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//指向一个值为42的int的shared_ptr</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p3=make_shared&lt;<span class=\"keyword\">int</span>&gt; (<span class=\"number\">42</span>);</div><div class=\"line\"><span class=\"comment\">//p4指向一个值为\"99999\"的string</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4=make_shared&lt;<span class=\"built_in\">string</span>&gt; (<span class=\"number\">5</span>,<span class=\"string\">'9'</span>);</div><div class=\"line\"><span class=\"comment\">//p5指向一个值初始化的int，即，值为0</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p5=make_shared&lt;<span class=\"keyword\">int</span>&gt; ();</div></pre></td></tr></table></figure>\n<p>类似顺序容器的emplace成员，<strong>make_shared用其参数来构造给定类型的对象</strong>。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int> 时传递的参数必须能用来初始化一个int，依次类推。如果我们不传递任何参数，对象就会进行值初始化。</int></string></p>\n<p>当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式较简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//p6指向一个动态分配的空vector&lt;string&gt;</span></div><div class=\"line\"><span class=\"keyword\">auto</span> p6=make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; ();</div></pre></td></tr></table></figure>\n<h3 id=\"shared-ptr的拷贝和赋值\"><a href=\"#shared-ptr的拷贝和赋值\" class=\"headerlink\" title=\"shared_ptr的拷贝和赋值\"></a>shared_ptr的拷贝和赋值</h3><p>当进行拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> p=make_shard&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>); <span class=\"comment\">//p指向的对象只有p一个引用者</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">q</span><span class=\"params\">(p)</span></span>;  <span class=\"comment\">//p和q指向相同的对象，此对象有两个引用者</span></div></pre></td></tr></table></figure>\n<p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器都会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域时，计数器就会递减）</p>\n<p>一旦一个shared_ptr的计算器变为0，它就会自动释放自己所管理的对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto r=make_shared&lt;int&gt;(42);  //r指向的int只有一个引用者</div><div class=\"line\">r=q;   //给r赋值，令它指向另一个地址，递增q指向的对象的引用计数，递减r原来指向的对象的引用计数，r原来指向的对象已没有引用者，会自动释放</div></pre></td></tr></table></figure>\n<p>此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一执行此int的shared_ptr，在把q赋给r的过程中，此int被自动释放。</p>\n<h3 id=\"shared-ptr自动销毁所管理的对象\"><a href=\"#shared-ptr自动销毁所管理的对象\" class=\"headerlink\" title=\"shared_ptr自动销毁所管理的对象\"></a>shared_ptr自动销毁所管理的对象</h3><p><strong>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象</strong>。它是通过另一个特殊的成员函数——析构函数完成销毁工作的。类似与构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。</p>\n<p><strong>析构函数一般用来释放对象分配的资源</strong>。例如，string的构造函数（以及其他string成员）会分配内存来保存构成string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。</p>\n<p><strong>shared_ptr的析构函数会递减它所指对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存</strong>。</p>\n<h3 id=\"shared-ptr还会自动释放相关联的内存\"><a href=\"#shared-ptr还会自动释放相关联的内存\" class=\"headerlink\" title=\"shared_ptr还会自动释放相关联的内存\"></a>shared_ptr还会自动释放相关联的内存</h3><p>当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如，我们可能有一个函数，它返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//factory返回一个shared_ptr，指向一个动态分配的对象</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;Foo&gt; factory(T arg)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//恰当地处理arg</span></div><div class=\"line\">    <span class=\"comment\">//shared_ptr负责释放内存</span></div><div class=\"line\">    <span class=\"keyword\">return</span> make_shared&lt;Foo&gt;(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时刻被释放。例如，下面的函数将factory返回的shared_ptr保存在局部变量中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</div><div class=\"line\">    <span class=\"comment\">//使用p</span></div><div class=\"line\">    <span class=\"comment\">//p离开了作用域，它指向的内存会被自动释放掉</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于p是use_factory的局部变量，在use_factory结束时它将被销毁。当p被销毁时，将递减其引用计数并检查它是否为0。在此例中，p是唯一引用factory返回的内存的对象。由于p将要销毁，p指向的这个对象也会被销毁，所占用的内存会被释放。</p>\n<p>但如果有其他的shared_ptr也指向这块内存，它就不会被释放掉：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</div><div class=\"line\">    <span class=\"comment\">//使用p</span></div><div class=\"line\">    <span class=\"keyword\">return</span> p; <span class=\"comment\">//当我们返回p时，引用计数进行了递增操作</span></div><div class=\"line\">&#125; <span class=\"comment\">//p离开了作用域，但它指向的内存不会被释放</span></div></pre></td></tr></table></figure>\n<p>在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。</p>\n<p>由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。shared_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某种元素。在这种情况西下，你应该确保erase删除哪些不再需要的shared_ptr元素。</p>\n<p><strong>注意：如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</strong></p>\n<h3 id=\"使用了动态生存期的资源的类\"><a href=\"#使用了动态生存期的资源的类\" class=\"headerlink\" title=\"使用了动态生存期的资源的类\"></a>使用了动态生存期的资源的类</h3><p>程序使用动态内存处于以下三种原因之一：</p>\n<p>1 程序不知道自己需要使用多少个对象；</p>\n<p>2 程序不知到所需的准确类型</p>\n<p>3 程序需要在多个对象间共享数据</p>\n<p>容器类是处于第一种原因而使用动态内存的典型例子。</p>\n<p>使用动态内存的一个常见原因是运行多个对象共享相同的状态。</p>\n<h2 id=\"直接管理内存\"><a href=\"#直接管理内存\" class=\"headerlink\" title=\"直接管理内存\"></a>直接管理内存</h2><p>C++语言定义了两个运算符来分配和释放动态内存。<strong>运算符new分配内存，delete释放new分配的内存。</strong></p>\n<p>相对于智能指针，使用这两个运算符管理内存非常容易出错，随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。</p>\n<h3 id=\"使用new动态分配和初始化对象\"><a href=\"#使用new动态分配和初始化对象\" class=\"headerlink\" title=\"使用new动态分配和初始化对象\"></a>使用new动态分配和初始化对象</h3><p>在自由空间分配的内存是无名的。因此，new无法为其分配的对象命名，而是返回一个执行对象的指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span> ;   <span class=\"comment\">// pi指向一个动态分配的、未初始化的无名对象</span></div></pre></td></tr></table></figure>\n<p>此new表达式在自由空间构造一个int型对象，并返回指向该对象的指针。</p>\n<p><strong>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> *ps=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>; <span class=\"comment\">//初始化为空string</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span> ; <span class=\"comment\">// pi指向一个未初始化的int</span></div></pre></td></tr></table></figure>\n<p>我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>)  ;<span class=\"comment\">//pi的对象的值为1024</span></div><div class=\"line\"><span class=\"built_in\">string</span> *ps=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"number\">10</span>,<span class=\"string\">'9'</span>) ; <span class=\"comment\">//vector有10个元素，值依次从0到9</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; *pv=<span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div></pre></td></tr></table></figure>\n<p>也可以<strong>对动态的对象进行值初始化，只需在类型名之后跟一对空括号即可</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> *ps1=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>;   <span class=\"comment\">//默认初始化为空string</span></div><div class=\"line\"><span class=\"built_in\">string</span> *ps=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>();  <span class=\"comment\">//值初始化为空string</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pi1=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>; <span class=\"comment\">//默认初始化：*pi1的值未定义</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pi2=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>();   <span class=\"comment\">// 值初始化为0 *pi2为0</span></div></pre></td></tr></table></figure>\n<p>对于定义与自己的构造函数的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。</p>\n<p>如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> p1=<span class=\"keyword\">new</span> <span class=\"keyword\">auto</span>(obj) ; <span class=\"comment\">//p指向一个与obj类型相同的对象</span></div><div class=\"line\"><span class=\"keyword\">auto</span> p2=<span class=\"keyword\">new</span> <span class=\"keyword\">auto</span>(a,b,c) ;  <span class=\"comment\">//错误：括号中只能有单个初始化器</span></div></pre></td></tr></table></figure>\n<p>p1的类型是一个指针，执行从obj自动推断的类型。若obj是一个int，那么p1就算int<em>；若obj是一个string，那么p1是一个string</em>；依次类推。新分配的对象用obj的值进行初始化。</p>\n<h3 id=\"动态分配的const对象\"><a href=\"#动态分配的const对象\" class=\"headerlink\" title=\"动态分配的const对象\"></a>动态分配的const对象</h3><p>用new分配const对象是合法的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//分配并初始化一个const int</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci=<span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>);</div><div class=\"line\"><span class=\"comment\">//分配并默认初始化一个const的空string</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> *pcs=<span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>;</div></pre></td></tr></table></figure>\n<p>类似其他任何const对象，<strong>一个动态分配的const对象必须进行初始化</strong>。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，<strong>new 返回的指针是一个指向const的指针</strong>。</p>\n<h3 id=\"内存耗尽\"><a href=\"#内存耗尽\" class=\"headerlink\" title=\"内存耗尽\"></a>内存耗尽</h3><p>虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败，默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//如果分配失败，new返回一个空指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p1=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span> ; <span class=\"comment\">//如果分配失败，new抛出std::bad_alloc</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p2=<span class=\"keyword\">new</span> (nothrow) <span class=\"keyword\">int</span> ; <span class=\"comment\">//如果分配失败，new返回一个空指针</span></div></pre></td></tr></table></figure>\n<p>我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数，在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。</p>\n<h3 id=\"释放动态内存\"><a href=\"#释放动态内存\" class=\"headerlink\" title=\"释放动态内存\"></a>释放动态内存</h3><p>为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式来将动态内存归还给系统。<strong>delete表达式接受一个指针，指向我们想要释放的对象</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">delete</span> p; <span class=\"comment\">// p必须指向一个动态分配的对象或是一个空指针</span></div></pre></td></tr></table></figure>\n<p>与new 类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。</p>\n<h3 id=\"指针值和delete\"><a href=\"#指针值和delete\" class=\"headerlink\" title=\"指针值和delete\"></a>指针值和delete</h3><p>我们传递给delete的指针必须指向动态分配的内存，或是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i,*pi1=&amp;i,*pi2=<span class=\"literal\">nullptr</span>;</div><div class=\"line\"><span class=\"keyword\">double</span> *pd=<span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">33</span>),*pd2=pd;</div><div class=\"line\"><span class=\"keyword\">delete</span> i;  <span class=\"comment\">//错误，i不是一个指针</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pi1; <span class=\"comment\">//未定义：pi1执行一个局部变量</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pd; <span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pd2;  <span class=\"comment\">//未定义，pd2指向的内存已经被释放了</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pi2;  <span class=\"comment\">//正确：释放一个空指针总是没有错误的</span></div></pre></td></tr></table></figure>\n<p>对于delete i的请求，编译器会生成一个错误信息，因为它知道i不是一个指针。执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些delete表达式，大多数编译器会编译通过，尽管它们是错误的。</p>\n<p>虽然一个const对象的值不能被改变，但它本身是可以被销毁的，如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci=<span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>); </div><div class=\"line\"><span class=\"keyword\">delete</span> pci; <span class=\"comment\">//正确：释放一个从const对象</span></div></pre></td></tr></table></figure>\n<h3 id=\"动态对象的生存期直到被释放时为止\"><a href=\"#动态对象的生存期直到被释放时为止\" class=\"headerlink\" title=\"动态对象的生存期直到被释放时为止\"></a>动态对象的生存期直到被释放时为止</h3><p>由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。<strong>对于一个由内置指针管理的动态对象，直到被显示释放之前它都是存在的。</strong></p>\n<p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//factory返回一个指针，指向一个动态分配的对象</span></div><div class=\"line\"><span class=\"function\">Foo* <span class=\"title\">factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//视情况处理arg</span></div><div class=\"line\">　　<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Foo(arg); <span class=\"comment\">//调用者负责释放此内存</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类似我们之前定义的factory函数，这个版本的factory分配一个对象，但并不delete它。factory的调用者负责在不需要此对象时释放它。不幸的是，调用者经常忘记释放对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　Foo *p=factory(arg);</div><div class=\"line\">　　<span class=\"comment\">//使用p但不delete它</span></div><div class=\"line\">&#125; <span class=\"comment\">//p离开了它的作用域，但它所指向的内存没有被释放</span></div></pre></td></tr></table></figure>\n<p>此外，use_factory函数调用factory，后者分配一个类型为Foo的新对象。当use_factory返回时，局部变量p被销毁，此变量是一个内置指针，而不是一个智能指针。</p>\n<p>与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。</p>\n<p><strong>注意</strong>：<strong>由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在</strong>。</p>\n<p>在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，程序就没有办法释放这块内存了。根据整个程序的逻辑，修正这个错误的正确方法是在use_factory中记得要释放内存：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123; </div><div class=\"line\">　　Foo *p=factory(arg);</div><div class=\"line\">　　<span class=\"comment\">//使用p</span></div><div class=\"line\">　　<span class=\"keyword\">delete</span> p ;  <span class=\"comment\">//现在记得释放内存，我们已经不需要它了</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还有一种可能，我们的系统中的其他代码要使用use_factory所分配的对象，我们就应该修改此函数，让他返回一个指针，指向它分配的内存：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Foo* <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　Foo *p=factory(arg);</div><div class=\"line\">　　<span class=\"comment\">//使用p</span></div><div class=\"line\">　　<span class=\"keyword\">return</span> p; <span class=\"comment\">//调用者必须释放内存</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>小心：动态内存的管理非常容易出错</strong> </p>\n<p>使用new和delete管理动态内存存在三个常见问题：</p>\n<ul>\n<li><p>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。</p>\n</li>\n<li><p>使用以及释放掉的对象，通过在释放内存后将指针置为空，有时可以检测出这种错误。</p>\n</li>\n<li><p>同一块内存被释放两次，当有来年刚给指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了，如果我们随后又delete第一个指针，自由空间就可能会被破坏。</p>\n</li>\n</ul>\n<p>相对于查找和修正这种错误来源，制造出这些错误要简单很多。</p>\n<p><strong>坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何只能智能指针指向它的情况下，智能指针才会自动释放它</strong>。</p>\n<h3 id=\"delete之后重置指针值。。。。\"><a href=\"#delete之后重置指针值。。。。\" class=\"headerlink\" title=\"delete之后重置指针值。。。。\"></a>delete之后重置指针值。。。。</h3><p>当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的<strong>空悬指针</strong>，即，指向一块层级保存数据对象但现在以及无效的内存的指针。</p>\n<p>为初始化指针的所有确定空悬指针也都有，有一种方法可以避免空悬指针的问题；在指针即将要离开其作用域之前释放掉它所关联的内存。这样在指针关联的内存被释放掉之后，就没有机会继续使用指针了。<strong>如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。</strong></p>\n<h3 id=\"这只是提供了有限的保护\"><a href=\"#这只是提供了有限的保护\" class=\"headerlink\" title=\"这只是提供了有限的保护\"></a>这只是提供了有限的保护</h3><p>动态内存的一个基本问题是可能有多个指针指向相同的内存，在delete内存之后重置指针的方法只对这个指针有效，对其他任何指向（已释放的）内存的指针是没有作用的。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *p(new int (42));  //p指向动态内存</div><div class=\"line\"><span class=\"keyword\">auto</span> q=p;  <span class=\"comment\">//p和q指向相同的内存</span></div><div class=\"line\"><span class=\"keyword\">delete</span> p; <span class=\"comment\">//p和q均变为无效</span></div><div class=\"line\">p=<span class=\"literal\">nullptr</span>;  <span class=\"comment\">//指出p不再绑定到任何对象</span></div></pre></td></tr></table></figure>\n<p>本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr指出它不再指向任何对象，但是，重置p对q没有任何作用，在我们释放p所指向的（同时也是q所指向的）内存时，q也变为无效了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>到目前为止，我们编写的程序中所使用的对象都有着严格定义的生命期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。</p>","more":"<p>除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。</p>\n<p>动态对象的正确释放被证明是编程中极其容器出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p>\n<h3 id=\"静态内存、栈内存、堆\"><a href=\"#静态内存、栈内存、堆\" class=\"headerlink\" title=\"静态内存、栈内存、堆\"></a>静态内存、栈内存、堆</h3><p><strong>静态内存</strong>：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</p>\n<p><strong>栈内存</strong>：用来保存定义在函数内的非static对象。</p>\n<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</p>\n<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间（free store）</strong>或<strong>堆（heap）</strong>。程序用堆来存储<strong>动态分配</strong>（dynamically allocate）的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</p>\n<p><strong>warning</strong>：虽然使用动态内存有时是必要的，但众所周知，正确管理动态内存是非常棘手的。</p>\n<h2 id=\"动态内存与智能指针\"><a href=\"#动态内存与智能指针\" class=\"headerlink\" title=\"动态内存与智能指针\"></a>动态内存与智能指针</h2><p><strong>在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针。我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</strong></p>\n<p>动态内存的使用很容易出问题，因为确保在正确的时间释放内存是及其困难的。有时我们会忘记释放内存，在这种情况下就会产生<strong>内存泄漏</strong>；有时在尚有指针引用内存的情况下我们就释放它了，在这种情况下就会产生<strong>引用非法内存的指针</strong>。</p>\n<p>为了更容易（同时也安全）地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。只能指针的行为类似常规指针，重要的区别是<strong>它负责自动释放所指向的对象</strong>。新标准库提供的这两种只能指针的区别在于管理底层指针的方式：<strong>shared_ptr允许多个指针指向同一对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</strong></p>\n<h3 id=\"shared-ptr类\"><a href=\"#shared-ptr类\" class=\"headerlink\" title=\"shared_ptr类\"></a>shared_ptr类</h3><p>类似vector，只能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种指针的名字：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p1 ; <span class=\"comment\">//shared_ptr,可以指向string</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; p2;  <span class=\"comment\">//shared_ptr,可以指向int的list</span></div></pre></td></tr></table></figure>\n<p>默认初始化的智能指针中保存着一个空指针。</p>\n<p>只能指针的使用方式与普通指针类似。解引用一个智能指针返回它所指的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//如果p1不为空，检查它是否指向一个空string</span></div><div class=\"line\"><span class=\"keyword\">if</span>(p1&amp;&amp;p1-&gt;empty())</div><div class=\"line\">　　*p1=<span class=\"string\">\"hi\"</span>;</div></pre></td></tr></table></figure>\n<p>下表列出了shared_ptr和unique_ptr都支持的操作。只适用shared_ptr的操作列入下面。</p>\n<p> <strong>shared_ptr和unique_ptr都支持的操作</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; sp     空智能指针，可以指向类型为T的对象</div><div class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;T&gt; up    </div><div class=\"line\">p　　　　　　将p用作一个条件判断，若p指向一个对象，则为<span class=\"literal\">true</span></div><div class=\"line\">*p　　　　　　解引用p，获得它指向的对象</div><div class=\"line\">p-&gt;mem　　　　　等价于(*p).mem</div><div class=\"line\">p.get()　　　　　　返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</div><div class=\"line\">swap(p,q) 　　　　交换p和q中的指针</div><div class=\"line\">p.swap(q)</div></pre></td></tr></table></figure>\n<p> <strong>shared_ptr独有的操作</strong> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">make_shared&lt;T&gt;(args)　　　　　返回一个<span class=\"built_in\">shared_ptr</span>，指向一个动态分配的类型为T的对象，使用args初始化此对象</div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; p(q)　　　　　　　p是<span class=\"built_in\">shared_ptr</span> q的一个拷贝，此操作会递增q中的计数器。q中的指针必须都能转换为T*</div><div class=\"line\">p=q　　　　　　　　　　　　　　p和q都是<span class=\"built_in\">shared_ptr</span>，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为<span class=\"number\">0</span>，则将其管理　　　　　　　　　　　　　　　　的原内存释放</div><div class=\"line\">p.unique()  　　　　　　　　　　  若p.use_count()为<span class=\"number\">1</span>，返回<span class=\"literal\">true</span>，否则返回<span class=\"literal\">false</span></div><div class=\"line\">p.use_count() 　　　　　　　　　返回与p共享对象的智能指针的数量；可能很慢，主要用于调试</div></pre></td></tr></table></figure>\n<h3 id=\"make-shared函数\"><a href=\"#make-shared函数\" class=\"headerlink\" title=\"make_shared函数\"></a>make_shared函数</h3><p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。<strong>此函数在动态内存中分配一个对象并初始化它，返回指向对象的shared_ptr</strong>。与智能指针一样，make_shared也定义在头文件memory中。</p>\n<p>当要使用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//指向一个值为42的int的shared_ptr</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p3=make_shared&lt;<span class=\"keyword\">int</span>&gt; (<span class=\"number\">42</span>);</div><div class=\"line\"><span class=\"comment\">//p4指向一个值为\"99999\"的string</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4=make_shared&lt;<span class=\"built_in\">string</span>&gt; (<span class=\"number\">5</span>,<span class=\"string\">'9'</span>);</div><div class=\"line\"><span class=\"comment\">//p5指向一个值初始化的int，即，值为0</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p5=make_shared&lt;<span class=\"keyword\">int</span>&gt; ();</div></pre></td></tr></table></figure>\n<p>类似顺序容器的emplace成员，<strong>make_shared用其参数来构造给定类型的对象</strong>。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int> 时传递的参数必须能用来初始化一个int，依次类推。如果我们不传递任何参数，对象就会进行值初始化。</int></string></p>\n<p>当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式较简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//p6指向一个动态分配的空vector&lt;string&gt;</span></div><div class=\"line\"><span class=\"keyword\">auto</span> p6=make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; ();</div></pre></td></tr></table></figure>\n<h3 id=\"shared-ptr的拷贝和赋值\"><a href=\"#shared-ptr的拷贝和赋值\" class=\"headerlink\" title=\"shared_ptr的拷贝和赋值\"></a>shared_ptr的拷贝和赋值</h3><p>当进行拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> p=make_shard&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>); <span class=\"comment\">//p指向的对象只有p一个引用者</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">q</span><span class=\"params\">(p)</span></span>;  <span class=\"comment\">//p和q指向相同的对象，此对象有两个引用者</span></div></pre></td></tr></table></figure>\n<p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器都会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域时，计数器就会递减）</p>\n<p>一旦一个shared_ptr的计算器变为0，它就会自动释放自己所管理的对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto r=make_shared&lt;int&gt;(42);  //r指向的int只有一个引用者</div><div class=\"line\">r=q;   //给r赋值，令它指向另一个地址，递增q指向的对象的引用计数，递减r原来指向的对象的引用计数，r原来指向的对象已没有引用者，会自动释放</div></pre></td></tr></table></figure>\n<p>此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一执行此int的shared_ptr，在把q赋给r的过程中，此int被自动释放。</p>\n<h3 id=\"shared-ptr自动销毁所管理的对象\"><a href=\"#shared-ptr自动销毁所管理的对象\" class=\"headerlink\" title=\"shared_ptr自动销毁所管理的对象\"></a>shared_ptr自动销毁所管理的对象</h3><p><strong>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象</strong>。它是通过另一个特殊的成员函数——析构函数完成销毁工作的。类似与构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。</p>\n<p><strong>析构函数一般用来释放对象分配的资源</strong>。例如，string的构造函数（以及其他string成员）会分配内存来保存构成string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。</p>\n<p><strong>shared_ptr的析构函数会递减它所指对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存</strong>。</p>\n<h3 id=\"shared-ptr还会自动释放相关联的内存\"><a href=\"#shared-ptr还会自动释放相关联的内存\" class=\"headerlink\" title=\"shared_ptr还会自动释放相关联的内存\"></a>shared_ptr还会自动释放相关联的内存</h3><p>当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如，我们可能有一个函数，它返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//factory返回一个shared_ptr，指向一个动态分配的对象</span></div><div class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;Foo&gt; factory(T arg)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//恰当地处理arg</span></div><div class=\"line\">    <span class=\"comment\">//shared_ptr负责释放内存</span></div><div class=\"line\">    <span class=\"keyword\">return</span> make_shared&lt;Foo&gt;(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时刻被释放。例如，下面的函数将factory返回的shared_ptr保存在局部变量中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</div><div class=\"line\">    <span class=\"comment\">//使用p</span></div><div class=\"line\">    <span class=\"comment\">//p离开了作用域，它指向的内存会被自动释放掉</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于p是use_factory的局部变量，在use_factory结束时它将被销毁。当p被销毁时，将递减其引用计数并检查它是否为0。在此例中，p是唯一引用factory返回的内存的对象。由于p将要销毁，p指向的这个对象也会被销毁，所占用的内存会被释放。</p>\n<p>但如果有其他的shared_ptr也指向这块内存，它就不会被释放掉：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</div><div class=\"line\">    <span class=\"comment\">//使用p</span></div><div class=\"line\">    <span class=\"keyword\">return</span> p; <span class=\"comment\">//当我们返回p时，引用计数进行了递增操作</span></div><div class=\"line\">&#125; <span class=\"comment\">//p离开了作用域，但它指向的内存不会被释放</span></div></pre></td></tr></table></figure>\n<p>在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。</p>\n<p>由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。shared_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某种元素。在这种情况西下，你应该确保erase删除哪些不再需要的shared_ptr元素。</p>\n<p><strong>注意：如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</strong></p>\n<h3 id=\"使用了动态生存期的资源的类\"><a href=\"#使用了动态生存期的资源的类\" class=\"headerlink\" title=\"使用了动态生存期的资源的类\"></a>使用了动态生存期的资源的类</h3><p>程序使用动态内存处于以下三种原因之一：</p>\n<p>1 程序不知道自己需要使用多少个对象；</p>\n<p>2 程序不知到所需的准确类型</p>\n<p>3 程序需要在多个对象间共享数据</p>\n<p>容器类是处于第一种原因而使用动态内存的典型例子。</p>\n<p>使用动态内存的一个常见原因是运行多个对象共享相同的状态。</p>\n<h2 id=\"直接管理内存\"><a href=\"#直接管理内存\" class=\"headerlink\" title=\"直接管理内存\"></a>直接管理内存</h2><p>C++语言定义了两个运算符来分配和释放动态内存。<strong>运算符new分配内存，delete释放new分配的内存。</strong></p>\n<p>相对于智能指针，使用这两个运算符管理内存非常容易出错，随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。</p>\n<h3 id=\"使用new动态分配和初始化对象\"><a href=\"#使用new动态分配和初始化对象\" class=\"headerlink\" title=\"使用new动态分配和初始化对象\"></a>使用new动态分配和初始化对象</h3><p>在自由空间分配的内存是无名的。因此，new无法为其分配的对象命名，而是返回一个执行对象的指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span> ;   <span class=\"comment\">// pi指向一个动态分配的、未初始化的无名对象</span></div></pre></td></tr></table></figure>\n<p>此new表达式在自由空间构造一个int型对象，并返回指向该对象的指针。</p>\n<p><strong>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> *ps=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>; <span class=\"comment\">//初始化为空string</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span> ; <span class=\"comment\">// pi指向一个未初始化的int</span></div></pre></td></tr></table></figure>\n<p>我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>)  ;<span class=\"comment\">//pi的对象的值为1024</span></div><div class=\"line\"><span class=\"built_in\">string</span> *ps=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"number\">10</span>,<span class=\"string\">'9'</span>) ; <span class=\"comment\">//vector有10个元素，值依次从0到9</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; *pv=<span class=\"keyword\">new</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div></pre></td></tr></table></figure>\n<p>也可以<strong>对动态的对象进行值初始化，只需在类型名之后跟一对空括号即可</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> *ps1=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>;   <span class=\"comment\">//默认初始化为空string</span></div><div class=\"line\"><span class=\"built_in\">string</span> *ps=<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>();  <span class=\"comment\">//值初始化为空string</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pi1=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>; <span class=\"comment\">//默认初始化：*pi1的值未定义</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pi2=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>();   <span class=\"comment\">// 值初始化为0 *pi2为0</span></div></pre></td></tr></table></figure>\n<p>对于定义与自己的构造函数的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。</p>\n<p>如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> p1=<span class=\"keyword\">new</span> <span class=\"keyword\">auto</span>(obj) ; <span class=\"comment\">//p指向一个与obj类型相同的对象</span></div><div class=\"line\"><span class=\"keyword\">auto</span> p2=<span class=\"keyword\">new</span> <span class=\"keyword\">auto</span>(a,b,c) ;  <span class=\"comment\">//错误：括号中只能有单个初始化器</span></div></pre></td></tr></table></figure>\n<p>p1的类型是一个指针，执行从obj自动推断的类型。若obj是一个int，那么p1就算int<em>；若obj是一个string，那么p1是一个string</em>；依次类推。新分配的对象用obj的值进行初始化。</p>\n<h3 id=\"动态分配的const对象\"><a href=\"#动态分配的const对象\" class=\"headerlink\" title=\"动态分配的const对象\"></a>动态分配的const对象</h3><p>用new分配const对象是合法的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//分配并初始化一个const int</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci=<span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>);</div><div class=\"line\"><span class=\"comment\">//分配并默认初始化一个const的空string</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> *pcs=<span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>;</div></pre></td></tr></table></figure>\n<p>类似其他任何const对象，<strong>一个动态分配的const对象必须进行初始化</strong>。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，<strong>new 返回的指针是一个指向const的指针</strong>。</p>\n<h3 id=\"内存耗尽\"><a href=\"#内存耗尽\" class=\"headerlink\" title=\"内存耗尽\"></a>内存耗尽</h3><p>虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败，默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//如果分配失败，new返回一个空指针</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p1=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span> ; <span class=\"comment\">//如果分配失败，new抛出std::bad_alloc</span></div><div class=\"line\"><span class=\"keyword\">int</span> *p2=<span class=\"keyword\">new</span> (nothrow) <span class=\"keyword\">int</span> ; <span class=\"comment\">//如果分配失败，new返回一个空指针</span></div></pre></td></tr></table></figure>\n<p>我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数，在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。</p>\n<h3 id=\"释放动态内存\"><a href=\"#释放动态内存\" class=\"headerlink\" title=\"释放动态内存\"></a>释放动态内存</h3><p>为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式来将动态内存归还给系统。<strong>delete表达式接受一个指针，指向我们想要释放的对象</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">delete</span> p; <span class=\"comment\">// p必须指向一个动态分配的对象或是一个空指针</span></div></pre></td></tr></table></figure>\n<p>与new 类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。</p>\n<h3 id=\"指针值和delete\"><a href=\"#指针值和delete\" class=\"headerlink\" title=\"指针值和delete\"></a>指针值和delete</h3><p>我们传递给delete的指针必须指向动态分配的内存，或是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i,*pi1=&amp;i,*pi2=<span class=\"literal\">nullptr</span>;</div><div class=\"line\"><span class=\"keyword\">double</span> *pd=<span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">33</span>),*pd2=pd;</div><div class=\"line\"><span class=\"keyword\">delete</span> i;  <span class=\"comment\">//错误，i不是一个指针</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pi1; <span class=\"comment\">//未定义：pi1执行一个局部变量</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pd; <span class=\"comment\">//正确</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pd2;  <span class=\"comment\">//未定义，pd2指向的内存已经被释放了</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pi2;  <span class=\"comment\">//正确：释放一个空指针总是没有错误的</span></div></pre></td></tr></table></figure>\n<p>对于delete i的请求，编译器会生成一个错误信息，因为它知道i不是一个指针。执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些delete表达式，大多数编译器会编译通过，尽管它们是错误的。</p>\n<p>虽然一个const对象的值不能被改变，但它本身是可以被销毁的，如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci=<span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>); </div><div class=\"line\"><span class=\"keyword\">delete</span> pci; <span class=\"comment\">//正确：释放一个从const对象</span></div></pre></td></tr></table></figure>\n<h3 id=\"动态对象的生存期直到被释放时为止\"><a href=\"#动态对象的生存期直到被释放时为止\" class=\"headerlink\" title=\"动态对象的生存期直到被释放时为止\"></a>动态对象的生存期直到被释放时为止</h3><p>由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。<strong>对于一个由内置指针管理的动态对象，直到被显示释放之前它都是存在的。</strong></p>\n<p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//factory返回一个指针，指向一个动态分配的对象</span></div><div class=\"line\"><span class=\"function\">Foo* <span class=\"title\">factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//视情况处理arg</span></div><div class=\"line\">　　<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Foo(arg); <span class=\"comment\">//调用者负责释放此内存</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类似我们之前定义的factory函数，这个版本的factory分配一个对象，但并不delete它。factory的调用者负责在不需要此对象时释放它。不幸的是，调用者经常忘记释放对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　Foo *p=factory(arg);</div><div class=\"line\">　　<span class=\"comment\">//使用p但不delete它</span></div><div class=\"line\">&#125; <span class=\"comment\">//p离开了它的作用域，但它所指向的内存没有被释放</span></div></pre></td></tr></table></figure>\n<p>此外，use_factory函数调用factory，后者分配一个类型为Foo的新对象。当use_factory返回时，局部变量p被销毁，此变量是一个内置指针，而不是一个智能指针。</p>\n<p>与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。</p>\n<p><strong>注意</strong>：<strong>由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在</strong>。</p>\n<p>在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，程序就没有办法释放这块内存了。根据整个程序的逻辑，修正这个错误的正确方法是在use_factory中记得要释放内存：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123; </div><div class=\"line\">　　Foo *p=factory(arg);</div><div class=\"line\">　　<span class=\"comment\">//使用p</span></div><div class=\"line\">　　<span class=\"keyword\">delete</span> p ;  <span class=\"comment\">//现在记得释放内存，我们已经不需要它了</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还有一种可能，我们的系统中的其他代码要使用use_factory所分配的对象，我们就应该修改此函数，让他返回一个指针，指向它分配的内存：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Foo* <span class=\"title\">use_factory</span><span class=\"params\">(T arg)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">　　Foo *p=factory(arg);</div><div class=\"line\">　　<span class=\"comment\">//使用p</span></div><div class=\"line\">　　<span class=\"keyword\">return</span> p; <span class=\"comment\">//调用者必须释放内存</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <strong>小心：动态内存的管理非常容易出错</strong> </p>\n<p>使用new和delete管理动态内存存在三个常见问题：</p>\n<ul>\n<li><p>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。</p>\n</li>\n<li><p>使用以及释放掉的对象，通过在释放内存后将指针置为空，有时可以检测出这种错误。</p>\n</li>\n<li><p>同一块内存被释放两次，当有来年刚给指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了，如果我们随后又delete第一个指针，自由空间就可能会被破坏。</p>\n</li>\n</ul>\n<p>相对于查找和修正这种错误来源，制造出这些错误要简单很多。</p>\n<p><strong>坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何只能智能指针指向它的情况下，智能指针才会自动释放它</strong>。</p>\n<h3 id=\"delete之后重置指针值。。。。\"><a href=\"#delete之后重置指针值。。。。\" class=\"headerlink\" title=\"delete之后重置指针值。。。。\"></a>delete之后重置指针值。。。。</h3><p>当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的<strong>空悬指针</strong>，即，指向一块层级保存数据对象但现在以及无效的内存的指针。</p>\n<p>为初始化指针的所有确定空悬指针也都有，有一种方法可以避免空悬指针的问题；在指针即将要离开其作用域之前释放掉它所关联的内存。这样在指针关联的内存被释放掉之后，就没有机会继续使用指针了。<strong>如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。</strong></p>\n<h3 id=\"这只是提供了有限的保护\"><a href=\"#这只是提供了有限的保护\" class=\"headerlink\" title=\"这只是提供了有限的保护\"></a>这只是提供了有限的保护</h3><p>动态内存的一个基本问题是可能有多个指针指向相同的内存，在delete内存之后重置指针的方法只对这个指针有效，对其他任何指向（已释放的）内存的指针是没有作用的。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *p(new int (42));  //p指向动态内存</div><div class=\"line\"><span class=\"keyword\">auto</span> q=p;  <span class=\"comment\">//p和q指向相同的内存</span></div><div class=\"line\"><span class=\"keyword\">delete</span> p; <span class=\"comment\">//p和q均变为无效</span></div><div class=\"line\">p=<span class=\"literal\">nullptr</span>;  <span class=\"comment\">//指出p不再绑定到任何对象</span></div></pre></td></tr></table></figure>\n<p>本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr指出它不再指向任何对象，但是，重置p对q没有任何作用，在我们释放p所指向的（同时也是q所指向的）内存时，q也变为无效了。</p>"},{"title":"虚函数与抽象基类","date":"2017-11-23T13:59:00.000Z","update":null,"comments":1,"_content":"\n## 虚函数\n\n在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，**所以所有的虚函数都必须有定义**。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。\n\n<!--more-->\n\n### 对虚函数的调用可能在运行时才被解析\n\n当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。\n\n必须要搞清楚一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。\n\n```C++\nbase = derived;     //把derived的Quote部分拷贝给base\nbase.net_price(20);     //调用Quote::net_price\n```\n\n**注意：** 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。\n\n### 派生类中的虚函数\n\n当我们在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。\n\n**一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。**\n\n同样，派生类中虚函数的返回类型也必须与基类匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。\n\n\n### final和override说明符\n\n#### override\n\n在类的设计中常常会用到虚函数。但是存在一个问题，在派生类中本来是要重写基类中的虚函数的时候，由于写错参数类型，写错函数名等问题，造成重新定义了一个函数，这往往会造成意想不到的错误。想要调试并发现这样的错误显然非常困难，c++11引入关键字**override**。在派生类中重写了虚函数以后，可以使用override来修饰重写的虚函数，这个时候如果基类中没有这个虚函数，此时编译器将报错。\n\n```C++\nstruct B{\n    virtual void f1(int) const;\n    virtual void f2();\n    void f3();\n};\nstruct D1:B{\n    void f1(int) const override;    //正确：f1与基类中的f1匹配\n    void f2(int) override;         //错误：B没有形如f2(int)的函数\n    void f3() override;         //错误：f3不是虚函数\n    void f4() override;           //错误：B没有名为f4的函数\n};\n```\n\n\n#### final\n\n在设计基类的时候，有时候我们不想后续的的派生类覆盖某个方法，这个时候，我们可以将这个方法修饰为 final 。派生类中任何试图覆盖该函数的行为都将导致错误。\n\n```C++\nstruct D2:B{\n    //从B继承f2()和f3(),覆盖f1(int)\n    void f1(int) const final;        //不允许后续的其他类覆盖f1(int)\n};\n\nstruct D3:D2 {\n    void f2();    //正确：覆盖从间接基类B继承而来的f2\n    void f1(int) const;      //错误：D2已经将f2声明成final\n};\n```\n### 虚函数与默认实参\n\n**虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。**\n\n换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。\n\n**建议：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。**\n\n### 回避虚函数的机制\n\n在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。**使用作用域运算符可以实现这一目的**。\n\n```C++\n//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么\ndouble undiscounted = baseP->Quote::net_price(42);\n```\n该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。\n\n## 抽象基类\n\n### 纯虚函数\n**和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。**\n\n值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能再类的内部为一个=0的函数提供函数体。\n\n### 含有纯虚函数的类是抽象基类\n\n含有（或者未经覆盖直接继承）纯虚函数的类是**抽象基类**（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。**我们不能（直接）创建一个抽象基类的对象。**\n\n```C++\n//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数\nDisc_quote discounted;        //错误：不能定义Disc_quote的对象\nBulk_quote bulk;              //正确：Bulk_quote中没有纯虚函数\n```\n**note:** <font color=red> **我们不能创建抽象基类的对象。** </font>\n\n### 派生类构造函数只初始化它的直接基类\n\n先初始化基类的构造函数、再初始化自己的构造函数，最后执行构造函数体部分。\n\n\n","source":"_posts/虚函数与抽象基类.md","raw":"---\ntitle: 虚函数与抽象基类\ndate: 2017-11-23 21:59:00\nupdate: \ntags: [虚函数]\ncategories: C++\ncomments: true\n---\n\n## 虚函数\n\n在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，**所以所有的虚函数都必须有定义**。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。\n\n<!--more-->\n\n### 对虚函数的调用可能在运行时才被解析\n\n当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。\n\n必须要搞清楚一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。\n\n```C++\nbase = derived;     //把derived的Quote部分拷贝给base\nbase.net_price(20);     //调用Quote::net_price\n```\n\n**注意：** 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。\n\n### 派生类中的虚函数\n\n当我们在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。\n\n**一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。**\n\n同样，派生类中虚函数的返回类型也必须与基类匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。\n\n\n### final和override说明符\n\n#### override\n\n在类的设计中常常会用到虚函数。但是存在一个问题，在派生类中本来是要重写基类中的虚函数的时候，由于写错参数类型，写错函数名等问题，造成重新定义了一个函数，这往往会造成意想不到的错误。想要调试并发现这样的错误显然非常困难，c++11引入关键字**override**。在派生类中重写了虚函数以后，可以使用override来修饰重写的虚函数，这个时候如果基类中没有这个虚函数，此时编译器将报错。\n\n```C++\nstruct B{\n    virtual void f1(int) const;\n    virtual void f2();\n    void f3();\n};\nstruct D1:B{\n    void f1(int) const override;    //正确：f1与基类中的f1匹配\n    void f2(int) override;         //错误：B没有形如f2(int)的函数\n    void f3() override;         //错误：f3不是虚函数\n    void f4() override;           //错误：B没有名为f4的函数\n};\n```\n\n\n#### final\n\n在设计基类的时候，有时候我们不想后续的的派生类覆盖某个方法，这个时候，我们可以将这个方法修饰为 final 。派生类中任何试图覆盖该函数的行为都将导致错误。\n\n```C++\nstruct D2:B{\n    //从B继承f2()和f3(),覆盖f1(int)\n    void f1(int) const final;        //不允许后续的其他类覆盖f1(int)\n};\n\nstruct D3:D2 {\n    void f2();    //正确：覆盖从间接基类B继承而来的f2\n    void f1(int) const;      //错误：D2已经将f2声明成final\n};\n```\n### 虚函数与默认实参\n\n**虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。**\n\n换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。\n\n**建议：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。**\n\n### 回避虚函数的机制\n\n在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。**使用作用域运算符可以实现这一目的**。\n\n```C++\n//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么\ndouble undiscounted = baseP->Quote::net_price(42);\n```\n该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。\n\n## 抽象基类\n\n### 纯虚函数\n**和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。**\n\n值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能再类的内部为一个=0的函数提供函数体。\n\n### 含有纯虚函数的类是抽象基类\n\n含有（或者未经覆盖直接继承）纯虚函数的类是**抽象基类**（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。**我们不能（直接）创建一个抽象基类的对象。**\n\n```C++\n//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数\nDisc_quote discounted;        //错误：不能定义Disc_quote的对象\nBulk_quote bulk;              //正确：Bulk_quote中没有纯虚函数\n```\n**note:** <font color=red> **我们不能创建抽象基类的对象。** </font>\n\n### 派生类构造函数只初始化它的直接基类\n\n先初始化基类的构造函数、再初始化自己的构造函数，最后执行构造函数体部分。\n\n\n","slug":"虚函数与抽象基类","published":1,"updated":"2018-02-23T00:58:41.576Z","_id":"cjdz6yquc00077wc9bdc5y44u","layout":"post","photos":[],"link":"","content":"<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，<strong>所以所有的虚函数都必须有定义</strong>。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。</p>\n<a id=\"more\"></a>\n<h3 id=\"对虚函数的调用可能在运行时才被解析\"><a href=\"#对虚函数的调用可能在运行时才被解析\" class=\"headerlink\" title=\"对虚函数的调用可能在运行时才被解析\"></a>对虚函数的调用可能在运行时才被解析</h3><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。</p>\n<p>必须要搞清楚一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">base = derived;     <span class=\"comment\">//把derived的Quote部分拷贝给base</span></div><div class=\"line\">base.net_price(<span class=\"number\">20</span>);     <span class=\"comment\">//调用Quote::net_price</span></div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</p>\n<h3 id=\"派生类中的虚函数\"><a href=\"#派生类中的虚函数\" class=\"headerlink\" title=\"派生类中的虚函数\"></a>派生类中的虚函数</h3><p>当我们在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>\n<p><strong>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</strong></p>\n<p>同样，派生类中虚函数的返回类型也必须与基类匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。</p>\n<h3 id=\"final和override说明符\"><a href=\"#final和override说明符\" class=\"headerlink\" title=\"final和override说明符\"></a>final和override说明符</h3><h4 id=\"override\"><a href=\"#override\" class=\"headerlink\" title=\"override\"></a>override</h4><p>在类的设计中常常会用到虚函数。但是存在一个问题，在派生类中本来是要重写基类中的虚函数的时候，由于写错参数类型，写错函数名等问题，造成重新定义了一个函数，这往往会造成意想不到的错误。想要调试并发现这样的错误显然非常困难，c++11引入关键字<strong>override</strong>。在派生类中重写了虚函数以后，可以使用override来修饰重写的虚函数，这个时候如果基类中没有这个虚函数，此时编译器将报错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span>&#123;</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D1</span>:</span>B&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span> override</span>;    <span class=\"comment\">//正确：f1与基类中的f1匹配</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> override</span>;         <span class=\"comment\">//错误：B没有形如f2(int)的函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span> override</span>;         <span class=\"comment\">//错误：f3不是虚函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f4</span><span class=\"params\">()</span> override</span>;           <span class=\"comment\">//错误：B没有名为f4的函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>在设计基类的时候，有时候我们不想后续的的派生类覆盖某个方法，这个时候，我们可以将这个方法修饰为 final 。派生类中任何试图覆盖该函数的行为都将导致错误。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D2</span>:</span>B&#123;</div><div class=\"line\">    <span class=\"comment\">//从B继承f2()和f3(),覆盖f1(int)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span> final</span>;        <span class=\"comment\">//不允许后续的其他类覆盖f1(int)</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D3</span>:</span>D2 &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;    <span class=\"comment\">//正确：覆盖从间接基类B继承而来的f2</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span></span>;      <span class=\"comment\">//错误：D2已经将f2声明成final</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"虚函数与默认实参\"><a href=\"#虚函数与默认实参\" class=\"headerlink\" title=\"虚函数与默认实参\"></a>虚函数与默认实参</h3><p><strong>虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</strong></p>\n<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>\n<p><strong>建议：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>\n<h3 id=\"回避虚函数的机制\"><a href=\"#回避虚函数的机制\" class=\"headerlink\" title=\"回避虚函数的机制\"></a>回避虚函数的机制</h3><p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。<strong>使用作用域运算符可以实现这一目的</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></div><div class=\"line\"><span class=\"keyword\">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class=\"number\">42</span>);</div></pre></td></tr></table></figure>\n<p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>\n<h2 id=\"抽象基类\"><a href=\"#抽象基类\" class=\"headerlink\" title=\"抽象基类\"></a>抽象基类</h2><h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p><strong>和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。</strong></p>\n<p>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能再类的内部为一个=0的函数提供函数体。</p>\n<h3 id=\"含有纯虚函数的类是抽象基类\"><a href=\"#含有纯虚函数的类是抽象基类\" class=\"headerlink\" title=\"含有纯虚函数的类是抽象基类\"></a>含有纯虚函数的类是抽象基类</h3><p>含有（或者未经覆盖直接继承）纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。<strong>我们不能（直接）创建一个抽象基类的对象。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></div><div class=\"line\">Disc_quote discounted;        <span class=\"comment\">//错误：不能定义Disc_quote的对象</span></div><div class=\"line\">Bulk_quote bulk;              <span class=\"comment\">//正确：Bulk_quote中没有纯虚函数</span></div></pre></td></tr></table></figure>\n<p><strong>note:</strong> <font color=\"red\"> <strong>我们不能创建抽象基类的对象。</strong> </font></p>\n<h3 id=\"派生类构造函数只初始化它的直接基类\"><a href=\"#派生类构造函数只初始化它的直接基类\" class=\"headerlink\" title=\"派生类构造函数只初始化它的直接基类\"></a>派生类构造函数只初始化它的直接基类</h3><p>先初始化基类的构造函数、再初始化自己的构造函数，最后执行构造函数体部分。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，<strong>所以所有的虚函数都必须有定义</strong>。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。</p>","more":"<h3 id=\"对虚函数的调用可能在运行时才被解析\"><a href=\"#对虚函数的调用可能在运行时才被解析\" class=\"headerlink\" title=\"对虚函数的调用可能在运行时才被解析\"></a>对虚函数的调用可能在运行时才被解析</h3><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。</p>\n<p>必须要搞清楚一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">base = derived;     <span class=\"comment\">//把derived的Quote部分拷贝给base</span></div><div class=\"line\">base.net_price(<span class=\"number\">20</span>);     <span class=\"comment\">//调用Quote::net_price</span></div></pre></td></tr></table></figure>\n<p><strong>注意：</strong> 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</p>\n<h3 id=\"派生类中的虚函数\"><a href=\"#派生类中的虚函数\" class=\"headerlink\" title=\"派生类中的虚函数\"></a>派生类中的虚函数</h3><p>当我们在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>\n<p><strong>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</strong></p>\n<p>同样，派生类中虚函数的返回类型也必须与基类匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。</p>\n<h3 id=\"final和override说明符\"><a href=\"#final和override说明符\" class=\"headerlink\" title=\"final和override说明符\"></a>final和override说明符</h3><h4 id=\"override\"><a href=\"#override\" class=\"headerlink\" title=\"override\"></a>override</h4><p>在类的设计中常常会用到虚函数。但是存在一个问题，在派生类中本来是要重写基类中的虚函数的时候，由于写错参数类型，写错函数名等问题，造成重新定义了一个函数，这往往会造成意想不到的错误。想要调试并发现这样的错误显然非常困难，c++11引入关键字<strong>override</strong>。在派生类中重写了虚函数以后，可以使用override来修饰重写的虚函数，这个时候如果基类中没有这个虚函数，此时编译器将报错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span>&#123;</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D1</span>:</span>B&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span> override</span>;    <span class=\"comment\">//正确：f1与基类中的f1匹配</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> override</span>;         <span class=\"comment\">//错误：B没有形如f2(int)的函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span> override</span>;         <span class=\"comment\">//错误：f3不是虚函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f4</span><span class=\"params\">()</span> override</span>;           <span class=\"comment\">//错误：B没有名为f4的函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>在设计基类的时候，有时候我们不想后续的的派生类覆盖某个方法，这个时候，我们可以将这个方法修饰为 final 。派生类中任何试图覆盖该函数的行为都将导致错误。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D2</span>:</span>B&#123;</div><div class=\"line\">    <span class=\"comment\">//从B继承f2()和f3(),覆盖f1(int)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span> final</span>;        <span class=\"comment\">//不允许后续的其他类覆盖f1(int)</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D3</span>:</span>D2 &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;    <span class=\"comment\">//正确：覆盖从间接基类B继承而来的f2</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">const</span></span>;      <span class=\"comment\">//错误：D2已经将f2声明成final</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"虚函数与默认实参\"><a href=\"#虚函数与默认实参\" class=\"headerlink\" title=\"虚函数与默认实参\"></a>虚函数与默认实参</h3><p><strong>虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</strong></p>\n<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>\n<p><strong>建议：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>\n<h3 id=\"回避虚函数的机制\"><a href=\"#回避虚函数的机制\" class=\"headerlink\" title=\"回避虚函数的机制\"></a>回避虚函数的机制</h3><p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。<strong>使用作用域运算符可以实现这一目的</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></div><div class=\"line\"><span class=\"keyword\">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class=\"number\">42</span>);</div></pre></td></tr></table></figure>\n<p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>\n<h2 id=\"抽象基类\"><a href=\"#抽象基类\" class=\"headerlink\" title=\"抽象基类\"></a>抽象基类</h2><h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p><strong>和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。</strong></p>\n<p>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能再类的内部为一个=0的函数提供函数体。</p>\n<h3 id=\"含有纯虚函数的类是抽象基类\"><a href=\"#含有纯虚函数的类是抽象基类\" class=\"headerlink\" title=\"含有纯虚函数的类是抽象基类\"></a>含有纯虚函数的类是抽象基类</h3><p>含有（或者未经覆盖直接继承）纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。<strong>我们不能（直接）创建一个抽象基类的对象。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></div><div class=\"line\">Disc_quote discounted;        <span class=\"comment\">//错误：不能定义Disc_quote的对象</span></div><div class=\"line\">Bulk_quote bulk;              <span class=\"comment\">//正确：Bulk_quote中没有纯虚函数</span></div></pre></td></tr></table></figure>\n<p><strong>note:</strong> <font color=\"red\"> <strong>我们不能创建抽象基类的对象。</strong> </font></p>\n<h3 id=\"派生类构造函数只初始化它的直接基类\"><a href=\"#派生类构造函数只初始化它的直接基类\" class=\"headerlink\" title=\"派生类构造函数只初始化它的直接基类\"></a>派生类构造函数只初始化它的直接基类</h3><p>先初始化基类的构造函数、再初始化自己的构造函数，最后执行构造函数体部分。</p>"},{"title":"构造函数和拷贝控制","date":"2017-10-26T13:59:00.000Z","update":null,"comments":1,"_content":"\n## 构造函数和拷贝控制\n\n### 虚析构函数\n\n继承关系对基类拷贝控制最直接的影响是**基类通常应该定义一个虚析构函数**，这样我们就能动态分配继承体系中的对象了。\n\n<!--more-->\n\n**原因：** 当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型（基类）的指针，则该指针有可能实际指向了一个Bulk_quote（派生类）类型的对象。如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。\n\n```C++\nclass Quote{\npublic:\n    //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数\n    virtual ~Quote()  = default;      //动态绑定析构函数\n};\n```\n\n```C++\nQuote *itemP = new Quote;      //静态类型与动态类型一致\ndelete itemP;                 //调用Quote的析构函数\nitemP = new Bulk_quote;       //静态类型与动态类型不一致\ndelete itemP;                //调用Bulk_quote的析构函数\n```\n\n**警告：** 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。\n\n#### 虚析构函数将阻止合成移动操作\n\n基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。\n\n### 合成的拷贝控制与继承\n\n基类或派生类的合成构造函数控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，**这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作**。\n\n**对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。**\n\n#### 派生类中删除的拷贝控制与基类的关系 （略）\n\n#### 移动操作与继承\n\n如前所述，大多数基类都会定义一个虚析构函数。（如果一个类需要析构函数，那么它同样需要拷贝和控制操作，基类的析构函数并不遵循上诉准则），因此在默认情况下，基类通常不含有合成的移动操作，而且它的派生类中也没有合成的移动操作（如果我们定义了拷贝构造函数，则编译器将不会为类合成一个移动构造函数）。\n\n**因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦Quote定义了自己的移动操作，那么它必须同时显式地定义拷贝操作**。\n\n```C++\nclass Quote{\npublic:\n    Quote() = default;      //对成员依次进行默认初始化\n    Quote(const Quote&) = default;          //对成员依次拷贝\n    Quote(Quote&&) = default;            //对成员依次拷贝\n    Quote& operator= (const Quote&) = default;       //拷贝赋值\n    Quote& operator=(Quote&&) = default;           //移动赋值\n    virtual ~Quote() = default; \n    //其他成员与之前的版本一致\n}\n```\n\n### 派生类的拷贝控制成员\n\n派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。\n\n和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。\n\n**警告：** 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。\n\n#### 定义派生类的拷贝或移动构造函数\n\n **当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。**\n\n```C++\nclass Base{\npublic:\n    Base() = default;\n    Base(int value):val(value) {}\n    Base(const Base &b) { this->val = b.val;}   //拷贝构造函数\n    void show() {cout<<\"Base::\"<<val<<endl;}\nprivate:\n    int val;\n};\nclass D:public Base{\npublic:\n    D() = default;\n    D(int dval,int bval):Base(bval),Dval(dval) {}\n    D(const D &d):Base(d),Dval(d.Dval) {}    //派生类的拷贝构造函数\n    void show()  {cout<<\"D::\"<<Dval<<endl;}\nprivate:\n    int Dval;\n};\n```\n\n```C++\n//D的这个拷贝构造函数很可能是不正确的定义\n//基类部分被默认初始化，而非拷贝\nD(const D &d)   /*成员初始值，但是没有提供基类初始值*/\n{\n    /* .... */\n}\n```\n\n在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的。\n\n**警告：** **默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。**\n\n\n#### 派生类赋值运算符\n\n与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：\n\n```C++\n//Base::operator=(const Base&) 不会被自动调用\nD &D::operator=(const D &rhs){\n    Base::operator=(rhs);    //为基类部分赋值\n    //按照过去的方式为派生类的成员赋值\n    //酌情处理自赋值及释放已有资源等情况\n    return *this;\n}\n```\n\n值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用他们。例如，对于Base::operator=的调用语句将执行Base的拷贝赋值运算符，至于该运算符是由Base显式定义的还是由编译器合成的无关紧要。\n\n#### 派生类析构函数\n\n如前所述，**在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的**。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：\n\n```C++\nclass D:public Base{\npublic:\n    //Base::~Base被自动调用执行\n    ~D() { /*该处由用户定义清除派生类成员的操作*/ }\n};\n```\n\n对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。\n\n#### 在构造函数和析构函数中调用虚函数\n\n**如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。**\n\n#### 继承的构造函数\n\n在C++新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，**一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数**。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。\n\n派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。\n\n```C++\nclass Base{\npublic:\n    Base() = default;\n    Base(int value):val(value) {}  //构造函数\n    void show() {cout<<\"Base::\"<<val<<endl;}\nprivate:\n    int val;\n};\nclass D:public Base{\npublic:\n    D() = default;\n    using Base::Base;  //继承基类的构造函数\n    void show()  {cout<<\"D::\"<<Dval<<endl;}\nprivate:\n    int Dval;\n};\n```\n\n通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。\n\n这些编译器生成的构造函数形如：\n\n```C++\nderived(parms):base(args) {}\n```\n\n其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。上述继承的构造函数等价于：\n\n```C++\nD(int value):Base(value) {}\n```\n\n**如果派生类含有自己的数据成员，则这些成员将被默认初始化。**\n\n#### 继承构造函数的特点\n\n- 一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。\n- 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。\n- 默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。\n\n","source":"_posts/构造函数和拷贝控制.md","raw":"---\ntitle: 构造函数和拷贝控制\ndate: 2017-10-26 21:59:00\nupdate: \ntags: [构造函数,拷贝控制]\ncategories: C++\ncomments: true\n---\n\n## 构造函数和拷贝控制\n\n### 虚析构函数\n\n继承关系对基类拷贝控制最直接的影响是**基类通常应该定义一个虚析构函数**，这样我们就能动态分配继承体系中的对象了。\n\n<!--more-->\n\n**原因：** 当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型（基类）的指针，则该指针有可能实际指向了一个Bulk_quote（派生类）类型的对象。如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。\n\n```C++\nclass Quote{\npublic:\n    //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数\n    virtual ~Quote()  = default;      //动态绑定析构函数\n};\n```\n\n```C++\nQuote *itemP = new Quote;      //静态类型与动态类型一致\ndelete itemP;                 //调用Quote的析构函数\nitemP = new Bulk_quote;       //静态类型与动态类型不一致\ndelete itemP;                //调用Bulk_quote的析构函数\n```\n\n**警告：** 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。\n\n#### 虚析构函数将阻止合成移动操作\n\n基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。\n\n### 合成的拷贝控制与继承\n\n基类或派生类的合成构造函数控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，**这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作**。\n\n**对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。**\n\n#### 派生类中删除的拷贝控制与基类的关系 （略）\n\n#### 移动操作与继承\n\n如前所述，大多数基类都会定义一个虚析构函数。（如果一个类需要析构函数，那么它同样需要拷贝和控制操作，基类的析构函数并不遵循上诉准则），因此在默认情况下，基类通常不含有合成的移动操作，而且它的派生类中也没有合成的移动操作（如果我们定义了拷贝构造函数，则编译器将不会为类合成一个移动构造函数）。\n\n**因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦Quote定义了自己的移动操作，那么它必须同时显式地定义拷贝操作**。\n\n```C++\nclass Quote{\npublic:\n    Quote() = default;      //对成员依次进行默认初始化\n    Quote(const Quote&) = default;          //对成员依次拷贝\n    Quote(Quote&&) = default;            //对成员依次拷贝\n    Quote& operator= (const Quote&) = default;       //拷贝赋值\n    Quote& operator=(Quote&&) = default;           //移动赋值\n    virtual ~Quote() = default; \n    //其他成员与之前的版本一致\n}\n```\n\n### 派生类的拷贝控制成员\n\n派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。\n\n和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。\n\n**警告：** 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。\n\n#### 定义派生类的拷贝或移动构造函数\n\n **当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。**\n\n```C++\nclass Base{\npublic:\n    Base() = default;\n    Base(int value):val(value) {}\n    Base(const Base &b) { this->val = b.val;}   //拷贝构造函数\n    void show() {cout<<\"Base::\"<<val<<endl;}\nprivate:\n    int val;\n};\nclass D:public Base{\npublic:\n    D() = default;\n    D(int dval,int bval):Base(bval),Dval(dval) {}\n    D(const D &d):Base(d),Dval(d.Dval) {}    //派生类的拷贝构造函数\n    void show()  {cout<<\"D::\"<<Dval<<endl;}\nprivate:\n    int Dval;\n};\n```\n\n```C++\n//D的这个拷贝构造函数很可能是不正确的定义\n//基类部分被默认初始化，而非拷贝\nD(const D &d)   /*成员初始值，但是没有提供基类初始值*/\n{\n    /* .... */\n}\n```\n\n在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的。\n\n**警告：** **默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。**\n\n\n#### 派生类赋值运算符\n\n与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：\n\n```C++\n//Base::operator=(const Base&) 不会被自动调用\nD &D::operator=(const D &rhs){\n    Base::operator=(rhs);    //为基类部分赋值\n    //按照过去的方式为派生类的成员赋值\n    //酌情处理自赋值及释放已有资源等情况\n    return *this;\n}\n```\n\n值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用他们。例如，对于Base::operator=的调用语句将执行Base的拷贝赋值运算符，至于该运算符是由Base显式定义的还是由编译器合成的无关紧要。\n\n#### 派生类析构函数\n\n如前所述，**在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的**。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：\n\n```C++\nclass D:public Base{\npublic:\n    //Base::~Base被自动调用执行\n    ~D() { /*该处由用户定义清除派生类成员的操作*/ }\n};\n```\n\n对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。\n\n#### 在构造函数和析构函数中调用虚函数\n\n**如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。**\n\n#### 继承的构造函数\n\n在C++新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，**一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数**。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。\n\n派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。\n\n```C++\nclass Base{\npublic:\n    Base() = default;\n    Base(int value):val(value) {}  //构造函数\n    void show() {cout<<\"Base::\"<<val<<endl;}\nprivate:\n    int val;\n};\nclass D:public Base{\npublic:\n    D() = default;\n    using Base::Base;  //继承基类的构造函数\n    void show()  {cout<<\"D::\"<<Dval<<endl;}\nprivate:\n    int Dval;\n};\n```\n\n通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。\n\n这些编译器生成的构造函数形如：\n\n```C++\nderived(parms):base(args) {}\n```\n\n其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。上述继承的构造函数等价于：\n\n```C++\nD(int value):Base(value) {}\n```\n\n**如果派生类含有自己的数据成员，则这些成员将被默认初始化。**\n\n#### 继承构造函数的特点\n\n- 一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。\n- 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。\n- 默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。\n\n","slug":"构造函数和拷贝控制","published":1,"updated":"2018-02-23T00:59:07.606Z","_id":"cjdz6yqug000b7wc9yfs6tevw","layout":"post","photos":[],"link":"","content":"<h2 id=\"构造函数和拷贝控制\"><a href=\"#构造函数和拷贝控制\" class=\"headerlink\" title=\"构造函数和拷贝控制\"></a>构造函数和拷贝控制</h2><h3 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是<strong>基类通常应该定义一个虚析构函数</strong>，这样我们就能动态分配继承体系中的对象了。</p>\n<a id=\"more\"></a>\n<p><strong>原因：</strong> 当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型（基类）的指针，则该指针有可能实际指向了一个Bulk_quote（派生类）类型的对象。如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Quote</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~Quote()  = <span class=\"keyword\">default</span>;      <span class=\"comment\">//动态绑定析构函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Quote *itemP = <span class=\"keyword\">new</span> Quote;      <span class=\"comment\">//静态类型与动态类型一致</span></div><div class=\"line\"><span class=\"keyword\">delete</span> itemP;                 <span class=\"comment\">//调用Quote的析构函数</span></div><div class=\"line\">itemP = <span class=\"keyword\">new</span> Bulk_quote;       <span class=\"comment\">//静态类型与动态类型不一致</span></div><div class=\"line\"><span class=\"keyword\">delete</span> itemP;                <span class=\"comment\">//调用Bulk_quote的析构函数</span></div></pre></td></tr></table></figure>\n<p><strong>警告：</strong> 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>\n<h4 id=\"虚析构函数将阻止合成移动操作\"><a href=\"#虚析构函数将阻止合成移动操作\" class=\"headerlink\" title=\"虚析构函数将阻止合成移动操作\"></a>虚析构函数将阻止合成移动操作</h4><p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>\n<h3 id=\"合成的拷贝控制与继承\"><a href=\"#合成的拷贝控制与继承\" class=\"headerlink\" title=\"合成的拷贝控制与继承\"></a>合成的拷贝控制与继承</h3><p>基类或派生类的合成构造函数控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，<strong>这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作</strong>。</p>\n<p><strong>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</strong></p>\n<h4 id=\"派生类中删除的拷贝控制与基类的关系-（略）\"><a href=\"#派生类中删除的拷贝控制与基类的关系-（略）\" class=\"headerlink\" title=\"派生类中删除的拷贝控制与基类的关系 （略）\"></a>派生类中删除的拷贝控制与基类的关系 （略）</h4><h4 id=\"移动操作与继承\"><a href=\"#移动操作与继承\" class=\"headerlink\" title=\"移动操作与继承\"></a>移动操作与继承</h4><p>如前所述，大多数基类都会定义一个虚析构函数。（如果一个类需要析构函数，那么它同样需要拷贝和控制操作，基类的析构函数并不遵循上诉准则），因此在默认情况下，基类通常不含有合成的移动操作，而且它的派生类中也没有合成的移动操作（如果我们定义了拷贝构造函数，则编译器将不会为类合成一个移动构造函数）。</p>\n<p><strong>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦Quote定义了自己的移动操作，那么它必须同时显式地定义拷贝操作</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Quote</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Quote() = <span class=\"keyword\">default</span>;      <span class=\"comment\">//对成员依次进行默认初始化</span></div><div class=\"line\">    Quote(<span class=\"keyword\">const</span> Quote&amp;) = <span class=\"keyword\">default</span>;          <span class=\"comment\">//对成员依次拷贝</span></div><div class=\"line\">    Quote(Quote&amp;&amp;) = <span class=\"keyword\">default</span>;            <span class=\"comment\">//对成员依次拷贝</span></div><div class=\"line\">    Quote&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> Quote&amp;) = <span class=\"keyword\">default</span>;       <span class=\"comment\">//拷贝赋值</span></div><div class=\"line\">    Quote&amp; <span class=\"keyword\">operator</span>=(Quote&amp;&amp;) = <span class=\"keyword\">default</span>;           <span class=\"comment\">//移动赋值</span></div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~Quote() = <span class=\"keyword\">default</span>; </div><div class=\"line\">    <span class=\"comment\">//其他成员与之前的版本一致</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"派生类的拷贝控制成员\"><a href=\"#派生类的拷贝控制成员\" class=\"headerlink\" title=\"派生类的拷贝控制成员\"></a>派生类的拷贝控制成员</h3><p>派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>\n<p>和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。</p>\n<p><strong>警告：</strong> 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p>\n<h4 id=\"定义派生类的拷贝或移动构造函数\"><a href=\"#定义派生类的拷贝或移动构造函数\" class=\"headerlink\" title=\"定义派生类的拷贝或移动构造函数\"></a>定义派生类的拷贝或移动构造函数</h4><p> <strong>当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Base() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base(<span class=\"keyword\">int</span> value):val(value) &#123;&#125;</div><div class=\"line\">    Base(<span class=\"keyword\">const</span> Base &amp;b) &#123; <span class=\"keyword\">this</span>-&gt;val = b.val;&#125;   <span class=\"comment\">//拷贝构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Base::\"</span>&lt;&lt;val&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    D() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    D(<span class=\"keyword\">int</span> dval,<span class=\"keyword\">int</span> bval):Base(bval),Dval(dval) &#123;&#125;</div><div class=\"line\">    D(<span class=\"keyword\">const</span> D &amp;d):Base(d),Dval(d.Dval) &#123;&#125;    <span class=\"comment\">//派生类的拷贝构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span>  </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"D::\"</span>&lt;&lt;Dval&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> Dval;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//D的这个拷贝构造函数很可能是不正确的定义</span></div><div class=\"line\"><span class=\"comment\">//基类部分被默认初始化，而非拷贝</span></div><div class=\"line\">D(<span class=\"keyword\">const</span> D &amp;d)   <span class=\"comment\">/*成员初始值，但是没有提供基类初始值*/</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">/* .... */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的。</p>\n<p><strong>警告：</strong> <strong>默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。</strong></p>\n<h4 id=\"派生类赋值运算符\"><a href=\"#派生类赋值运算符\" class=\"headerlink\" title=\"派生类赋值运算符\"></a>派生类赋值运算符</h4><p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Base::operator=(const Base&amp;) 不会被自动调用</span></div><div class=\"line\">D &amp;D::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> D &amp;rhs)&#123;</div><div class=\"line\">    Base::<span class=\"keyword\">operator</span>=(rhs);    <span class=\"comment\">//为基类部分赋值</span></div><div class=\"line\">    <span class=\"comment\">//按照过去的方式为派生类的成员赋值</span></div><div class=\"line\">    <span class=\"comment\">//酌情处理自赋值及释放已有资源等情况</span></div><div class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用他们。例如，对于Base::operator=的调用语句将执行Base的拷贝赋值运算符，至于该运算符是由Base显式定义的还是由编译器合成的无关紧要。</p>\n<h4 id=\"派生类析构函数\"><a href=\"#派生类析构函数\" class=\"headerlink\" title=\"派生类析构函数\"></a>派生类析构函数</h4><p>如前所述，<strong>在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的</strong>。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//Base::~Base被自动调用执行</span></div><div class=\"line\">    ~D() &#123; <span class=\"comment\">/*该处由用户定义清除派生类成员的操作*/</span> &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p>\n<h4 id=\"在构造函数和析构函数中调用虚函数\"><a href=\"#在构造函数和析构函数中调用虚函数\" class=\"headerlink\" title=\"在构造函数和析构函数中调用虚函数\"></a>在构造函数和析构函数中调用虚函数</h4><p><strong>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</strong></p>\n<h4 id=\"继承的构造函数\"><a href=\"#继承的构造函数\" class=\"headerlink\" title=\"继承的构造函数\"></a>继承的构造函数</h4><p>在C++新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，<strong>一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数</strong>。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>\n<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Base() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base(<span class=\"keyword\">int</span> value):val(value) &#123;&#125;  <span class=\"comment\">//构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Base::\"</span>&lt;&lt;val&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    D() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    <span class=\"keyword\">using</span> Base::Base;  <span class=\"comment\">//继承基类的构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span>  </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"D::\"</span>&lt;&lt;Dval&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> Dval;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>\n<p>这些编译器生成的构造函数形如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">derived(parms):base(args) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。上述继承的构造函数等价于：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D(<span class=\"keyword\">int</span> value):Base(value) &#123;&#125;</div></pre></td></tr></table></figure>\n<p><strong>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</strong></p>\n<h4 id=\"继承构造函数的特点\"><a href=\"#继承构造函数的特点\" class=\"headerlink\" title=\"继承构造函数的特点\"></a>继承构造函数的特点</h4><ul>\n<li>一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。</li>\n<li>如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。</li>\n<li>默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"构造函数和拷贝控制\"><a href=\"#构造函数和拷贝控制\" class=\"headerlink\" title=\"构造函数和拷贝控制\"></a>构造函数和拷贝控制</h2><h3 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是<strong>基类通常应该定义一个虚析构函数</strong>，这样我们就能动态分配继承体系中的对象了。</p>","more":"<p><strong>原因：</strong> 当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型（基类）的指针，则该指针有可能实际指向了一个Bulk_quote（派生类）类型的对象。如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Quote</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~Quote()  = <span class=\"keyword\">default</span>;      <span class=\"comment\">//动态绑定析构函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Quote *itemP = <span class=\"keyword\">new</span> Quote;      <span class=\"comment\">//静态类型与动态类型一致</span></div><div class=\"line\"><span class=\"keyword\">delete</span> itemP;                 <span class=\"comment\">//调用Quote的析构函数</span></div><div class=\"line\">itemP = <span class=\"keyword\">new</span> Bulk_quote;       <span class=\"comment\">//静态类型与动态类型不一致</span></div><div class=\"line\"><span class=\"keyword\">delete</span> itemP;                <span class=\"comment\">//调用Bulk_quote的析构函数</span></div></pre></td></tr></table></figure>\n<p><strong>警告：</strong> 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>\n<h4 id=\"虚析构函数将阻止合成移动操作\"><a href=\"#虚析构函数将阻止合成移动操作\" class=\"headerlink\" title=\"虚析构函数将阻止合成移动操作\"></a>虚析构函数将阻止合成移动操作</h4><p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>\n<h3 id=\"合成的拷贝控制与继承\"><a href=\"#合成的拷贝控制与继承\" class=\"headerlink\" title=\"合成的拷贝控制与继承\"></a>合成的拷贝控制与继承</h3><p>基类或派生类的合成构造函数控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，<strong>这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作</strong>。</p>\n<p><strong>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</strong></p>\n<h4 id=\"派生类中删除的拷贝控制与基类的关系-（略）\"><a href=\"#派生类中删除的拷贝控制与基类的关系-（略）\" class=\"headerlink\" title=\"派生类中删除的拷贝控制与基类的关系 （略）\"></a>派生类中删除的拷贝控制与基类的关系 （略）</h4><h4 id=\"移动操作与继承\"><a href=\"#移动操作与继承\" class=\"headerlink\" title=\"移动操作与继承\"></a>移动操作与继承</h4><p>如前所述，大多数基类都会定义一个虚析构函数。（如果一个类需要析构函数，那么它同样需要拷贝和控制操作，基类的析构函数并不遵循上诉准则），因此在默认情况下，基类通常不含有合成的移动操作，而且它的派生类中也没有合成的移动操作（如果我们定义了拷贝构造函数，则编译器将不会为类合成一个移动构造函数）。</p>\n<p><strong>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦Quote定义了自己的移动操作，那么它必须同时显式地定义拷贝操作</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Quote</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Quote() = <span class=\"keyword\">default</span>;      <span class=\"comment\">//对成员依次进行默认初始化</span></div><div class=\"line\">    Quote(<span class=\"keyword\">const</span> Quote&amp;) = <span class=\"keyword\">default</span>;          <span class=\"comment\">//对成员依次拷贝</span></div><div class=\"line\">    Quote(Quote&amp;&amp;) = <span class=\"keyword\">default</span>;            <span class=\"comment\">//对成员依次拷贝</span></div><div class=\"line\">    Quote&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> Quote&amp;) = <span class=\"keyword\">default</span>;       <span class=\"comment\">//拷贝赋值</span></div><div class=\"line\">    Quote&amp; <span class=\"keyword\">operator</span>=(Quote&amp;&amp;) = <span class=\"keyword\">default</span>;           <span class=\"comment\">//移动赋值</span></div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~Quote() = <span class=\"keyword\">default</span>; </div><div class=\"line\">    <span class=\"comment\">//其他成员与之前的版本一致</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"派生类的拷贝控制成员\"><a href=\"#派生类的拷贝控制成员\" class=\"headerlink\" title=\"派生类的拷贝控制成员\"></a>派生类的拷贝控制成员</h3><p>派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>\n<p>和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。</p>\n<p><strong>警告：</strong> 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p>\n<h4 id=\"定义派生类的拷贝或移动构造函数\"><a href=\"#定义派生类的拷贝或移动构造函数\" class=\"headerlink\" title=\"定义派生类的拷贝或移动构造函数\"></a>定义派生类的拷贝或移动构造函数</h4><p> <strong>当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Base() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base(<span class=\"keyword\">int</span> value):val(value) &#123;&#125;</div><div class=\"line\">    Base(<span class=\"keyword\">const</span> Base &amp;b) &#123; <span class=\"keyword\">this</span>-&gt;val = b.val;&#125;   <span class=\"comment\">//拷贝构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Base::\"</span>&lt;&lt;val&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    D() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    D(<span class=\"keyword\">int</span> dval,<span class=\"keyword\">int</span> bval):Base(bval),Dval(dval) &#123;&#125;</div><div class=\"line\">    D(<span class=\"keyword\">const</span> D &amp;d):Base(d),Dval(d.Dval) &#123;&#125;    <span class=\"comment\">//派生类的拷贝构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span>  </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"D::\"</span>&lt;&lt;Dval&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> Dval;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//D的这个拷贝构造函数很可能是不正确的定义</span></div><div class=\"line\"><span class=\"comment\">//基类部分被默认初始化，而非拷贝</span></div><div class=\"line\">D(<span class=\"keyword\">const</span> D &amp;d)   <span class=\"comment\">/*成员初始值，但是没有提供基类初始值*/</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">/* .... */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的。</p>\n<p><strong>警告：</strong> <strong>默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。</strong></p>\n<h4 id=\"派生类赋值运算符\"><a href=\"#派生类赋值运算符\" class=\"headerlink\" title=\"派生类赋值运算符\"></a>派生类赋值运算符</h4><p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Base::operator=(const Base&amp;) 不会被自动调用</span></div><div class=\"line\">D &amp;D::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> D &amp;rhs)&#123;</div><div class=\"line\">    Base::<span class=\"keyword\">operator</span>=(rhs);    <span class=\"comment\">//为基类部分赋值</span></div><div class=\"line\">    <span class=\"comment\">//按照过去的方式为派生类的成员赋值</span></div><div class=\"line\">    <span class=\"comment\">//酌情处理自赋值及释放已有资源等情况</span></div><div class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用他们。例如，对于Base::operator=的调用语句将执行Base的拷贝赋值运算符，至于该运算符是由Base显式定义的还是由编译器合成的无关紧要。</p>\n<h4 id=\"派生类析构函数\"><a href=\"#派生类析构函数\" class=\"headerlink\" title=\"派生类析构函数\"></a>派生类析构函数</h4><p>如前所述，<strong>在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的</strong>。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"comment\">//Base::~Base被自动调用执行</span></div><div class=\"line\">    ~D() &#123; <span class=\"comment\">/*该处由用户定义清除派生类成员的操作*/</span> &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p>\n<h4 id=\"在构造函数和析构函数中调用虚函数\"><a href=\"#在构造函数和析构函数中调用虚函数\" class=\"headerlink\" title=\"在构造函数和析构函数中调用虚函数\"></a>在构造函数和析构函数中调用虚函数</h4><p><strong>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</strong></p>\n<h4 id=\"继承的构造函数\"><a href=\"#继承的构造函数\" class=\"headerlink\" title=\"继承的构造函数\"></a>继承的构造函数</h4><p>在C++新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，<strong>一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数</strong>。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>\n<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Base() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base(<span class=\"keyword\">int</span> value):val(value) &#123;&#125;  <span class=\"comment\">//构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Base::\"</span>&lt;&lt;val&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span><span class=\"keyword\">public</span> Base&#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    D() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    <span class=\"keyword\">using</span> Base::Base;  <span class=\"comment\">//继承基类的构造函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span>  </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"D::\"</span>&lt;&lt;Dval&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> Dval;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>\n<p>这些编译器生成的构造函数形如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">derived(parms):base(args) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。上述继承的构造函数等价于：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D(<span class=\"keyword\">int</span> value):Base(value) &#123;&#125;</div></pre></td></tr></table></figure>\n<p><strong>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</strong></p>\n<h4 id=\"继承构造函数的特点\"><a href=\"#继承构造函数的特点\" class=\"headerlink\" title=\"继承构造函数的特点\"></a>继承构造函数的特点</h4><ul>\n<li>一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。</li>\n<li>如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。</li>\n<li>默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。</li>\n</ul>"},{"title":"泛型算法概述","date":"2017-10-30T13:59:00.000Z","update":null,"comments":1,"_content":"## 泛型算法概述\n\n顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。\n\n<!--more-->\n\n如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，**而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如vector或list，还包括内置的数组类型）**。\n\n### 概述\n\n大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。\n\n一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。例如，假定我们有一个int的vector，希望指定vector中是否包含一个特定值。回答这个问题最方便的方法是调用标准库算法find：\n\n```C++\nint val=42;     //我们将查找的值\n//如果在vec中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()\nauto result=find(vec.cbegin(),vec.cend(),val);\n```\n\n传递给find的前两个参数是表示元素范围的迭代器，第三个参数是一个值。find将范围中每个元素与给定值进行比较。**它返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败**。因此，我们可以通过比较返回值和第二个参数来判断搜索是否成功。\n\n由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。例如，可以用find在一个string的list中查找一个给定值：\n\n```C++\nstring val=\"a value\";\nauto result=find(lst.cbegin(),lst.cend(),val);\n```\n\n类似的，由于指针就像内置数组上的迭代器一样，我们可以用find在数组中查找值：\n\n```C++\nint ia[]={27,210,12,47,109,83};\nint val=83;\nint *result=find(begin(ia),end(ia),val);\n```\n\n此例中我们使用了标准库begin和end函数来获得指向ia中首元素和尾元素之后的指针，并传递给find。\n\n还可以在序列的子范围中查找，只需要指向子范围首元素和尾元素之后位置的迭代器（指针）传递给find。例如，下面的语句在ia[1],ia[2]和ia[3]中查找指定的元素：\n\n```C++\nauto result=find(ia+1,ia+4;val);\n```\n### 算法如何工作\n\n为了弄清这些算法如何用于不同类型的容器，让我们来观察一下find。find的工作是在一个未排序的元素序列中查找一个特定的元素。概念上，find应该执行如下步骤：\n\n1 访问序列中的首元素\n\n2 比较此元素与我们要查找的值\n\n3 如果此元素与我们要查找的值匹配，find返回标识此元素的值。\n\n4 否则，find前进到下一个元素，重复执行步骤2和3\n\n5 如果到达序列尾，find应停止\n\n6 如果find到达序列尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。\n\n这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个迭代器可用来访问元素，find就完全不依赖于容器类型（甚至无须理会保存元素的是不是容器）。\n\n\n### 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\n\n虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，在步骤2中，find用元素的==运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持<运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。\n\n **注意：算法永远不会执行容器的操作** \n\n泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。\n\n## 初始泛型算法\n\n除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。\n\n虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。**理解算法的最基本的方法就是了解它们是否读取元素、改变元素、或是重排元素顺序。**\n\n\n### 只读算法\n\n一些算法只会读取其输入范围内的元素，而从不改变元素。find就是这样一种算法。\n\n另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列，则：\n\n```C++\n//对vec中元素的求和，和的初值是0\nint sum=accumulate(vec.cbegin(),vec.cend(),0);\n```\n\n这条语句将sum设置为vec中元素的和，和的初值被设置为0.\n\n**accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型**。\n\n#### 算法和元素类型\n\naccumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。\n\n下面是另一个例子，由于string定义了+运算符，所有我们可以通过调用accumulate来将vector中所有string元素连接起来“\n\nstring sum=accumulate(v.cbegin(),v.cend(),string(\"\"));\n\n此调用将v中每个元素连接到一个string上，该string初始时是空串。**注意，我们通过第三个参数显式地创建了一个string。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。**\n\n```C++\n//错误：const char*上没有定义+运算符\nstring sum=accumulate(v.cbegin(),v.cend(),\"\");\n```\n\n原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char*。如前所述，此类型决定了使用哪个+运算符。由于const char*并没有+运算符，此调用将产生编译错误。\n\n#### 操作两个序列的算法\n\n另一个只读算法是**equal**，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。**此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素**：\n\n```C++\n//roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(),roster1.cend(),roster2.cbegin());\n```\n\n由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<string>,而roster2是list<const char*>。\n\n**但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。 此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素**。\n\n\n### 写容器元素的算法\n\n一些算法将新值赋予序列中的元素。当我们使用这类算法时，**必须注意确保序列原大小至少不小于我们要求算法写入的元素数目**。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。\n\n一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。\n\n例如，算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。\n\n```C++\nfill(vec.begin(),vec.end(),0); //将每个元素重置为0\n//将容器的一个子序列设置为10\nfill(vec.begin(),vec.begin()+vec.size()/2,10);\n```\n\n由于fill向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。\n\n**关键概念：迭代器参数**\n\n一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如，第一个序列可能保存于一个vector中，而第二个序列可能保存于一个list、deque、内置数组或其它容器中。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。例如，对equal算法，元素类型不要求相同，但是我们必须能使用==来比较来自两个序列中的元素。\n\n操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如equal，接受三个迭代器：前两个表示一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。\n\n**用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长**。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。\n\n#### 算法不检查写操作\n\n一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素：\n\n```C++\nvector<int> vec;  //空vector\n//使用vec，赋予它不同值\nfill_n(vec.begin(),vec.size(),0);  //将所有元素重置为0\n```\n\n函数fill_n假定写入指定个元素是安全的。即，如下形式的调用\n\n```C++\nfill_n(dest,n,val)\n```\n\n函数fill_n假定dest指向一个元素，而dest开始的序列至少包含n个元素。\n\n一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）：\n\n```C++\nvector<int> vec;  //空向量\n//灾难：修改vec中10个（不存在）元素\nfill_n(vec.begin(),10,0);\n```\n\n这个调用是一场灾难，我们指定了要写入10个元素，但vec中并没有元素——它是空的，这条语句的结果是未定义的。\n\n**向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素**。\n\n#### 介绍back_inserter\n\n一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。**插入迭代器（insert iterator）** 是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。**而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中**。\n\n为了展示如何用算法向容器中写入数据，我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。\n\nback_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：\n\n```C++\nvector<int> vec;   //空容器\nauto it=back_inserter(vec); //通过它赋值会将元素添加到vec中\n*it=42;//vec现在有一个元素，值为42\n```\n\n我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：\n\n```C++\nvector<int> vec;  //空向量\n//正确：back_inserter创建一个插入迭代器，可以用来向vec添加元素\nfill_n(back_inserter(vec),10,0);  //添加10个元素到vec\n```\n\n在每步迭代中，fill_n向给定容器序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，这条fill_n调用语句向vec的末尾添加了10个元素，每个元素的值都是0.\n\n#### 拷贝算法\n\n拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。**传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。**\n\n我们可以用copy实现内置数组的拷贝，如下面代码所示：\n\n```C++\nint a[]={0,1,2,3,4,5,6,7,8,9};\nint a2[sizeof(a1)/sizeof(*a1)];\nauto ret=copy(begin(a1),end(a1),a2); //把a1的内容拷贝到a2\n```\n\n**copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。**\n\n多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。\n\n例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：\n\n```C++\n//将所有值为0的元素改为42\nreplace(ilist.begin(),ilist.end(),0,42);\n```\n\n此调用将序列中所有0都替换为42,。**如果我们希望保留原序列不变**，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：\n\n```C++\n//使用back_inserter按需要增长目标序列\nvector<int> ivec = {1,2,3,3,3,4,4,5,6,7};\nvector<int> a;\nreplace_copy(ivec.cbegin(),ivec.cend(),back_inserter(a),4,19);\n```\n\n此调用后，ivec并未改变，a包含与ivec的一份拷贝，不过原来在ivec中值为0的元素在a中都变为42。\n\n### 重排容器元素的算法\n\n某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。\n\n#### 消除重复单词\n\n为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，**我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分（重复的元素都在末尾，返回指向不重复区域之后一个位置的迭代器）**，由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作：\n\n```C++\nvector<string> words = {\"to\",\"be\",\"or\",\"not\",\"not\",\"to\",\"be\"};\n//按字典序排序words,以便查找重复单词\nsort(words.begin(),words.end());\n//unique重排输入范围，使得每个单词只出现一次,重复的单词放在后面\n//排列在范围的前部，返回指向不重复区域之后一个位置的迭代器\nauto end_unique = unique(words.begin(),words.end());\n//使用向量操作erase删除重复单词\nwords.erase(end_unique,words.end());\n```\n\n#### 使用unique\n\nwords排序完毕后，我们希望将每个单词都只保存一次。unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。\n\nwords的大小并未改变，但是这些元素的顺序被改变了——相邻的重复元素被“删除”了。我们将删除打引号是因为unique并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，重复的元素出现在后面部分，unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。\n\n标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。\n\n#### 使用容器操作删除元素\n\n为了真正删除无用元素，我们必须使用容器操作，本例中使用erase。我们删除从end_unique开始直至words末尾的范围内的所有元素。这个调用之后，words包含的重复元素真正被删除了。\n\n值得注意的是，即使words中没有重复单词，这样调用erase也是安全的。在此情况下，unique会返回words.end()。因此，传递给erase的两个参数具有系相同的值：words.end()。迭代器相等意味着传递给erase的元素范围为空。删除一个空范围没有什么不良后果，因此程序中即使在输入元素中无重复元素的情况下也是正确的。\n\n\n","source":"_posts/泛型算法概述.md","raw":"---\ntitle: 泛型算法概述\ndate: 2017-10-30 21:59:00\nupdate: \ntags: [泛型]\ncategories: C++\ncomments: true\n---\n## 泛型算法概述\n\n顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。\n\n<!--more-->\n\n如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，**而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如vector或list，还包括内置的数组类型）**。\n\n### 概述\n\n大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。\n\n一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。例如，假定我们有一个int的vector，希望指定vector中是否包含一个特定值。回答这个问题最方便的方法是调用标准库算法find：\n\n```C++\nint val=42;     //我们将查找的值\n//如果在vec中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()\nauto result=find(vec.cbegin(),vec.cend(),val);\n```\n\n传递给find的前两个参数是表示元素范围的迭代器，第三个参数是一个值。find将范围中每个元素与给定值进行比较。**它返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败**。因此，我们可以通过比较返回值和第二个参数来判断搜索是否成功。\n\n由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。例如，可以用find在一个string的list中查找一个给定值：\n\n```C++\nstring val=\"a value\";\nauto result=find(lst.cbegin(),lst.cend(),val);\n```\n\n类似的，由于指针就像内置数组上的迭代器一样，我们可以用find在数组中查找值：\n\n```C++\nint ia[]={27,210,12,47,109,83};\nint val=83;\nint *result=find(begin(ia),end(ia),val);\n```\n\n此例中我们使用了标准库begin和end函数来获得指向ia中首元素和尾元素之后的指针，并传递给find。\n\n还可以在序列的子范围中查找，只需要指向子范围首元素和尾元素之后位置的迭代器（指针）传递给find。例如，下面的语句在ia[1],ia[2]和ia[3]中查找指定的元素：\n\n```C++\nauto result=find(ia+1,ia+4;val);\n```\n### 算法如何工作\n\n为了弄清这些算法如何用于不同类型的容器，让我们来观察一下find。find的工作是在一个未排序的元素序列中查找一个特定的元素。概念上，find应该执行如下步骤：\n\n1 访问序列中的首元素\n\n2 比较此元素与我们要查找的值\n\n3 如果此元素与我们要查找的值匹配，find返回标识此元素的值。\n\n4 否则，find前进到下一个元素，重复执行步骤2和3\n\n5 如果到达序列尾，find应停止\n\n6 如果find到达序列尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。\n\n这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个迭代器可用来访问元素，find就完全不依赖于容器类型（甚至无须理会保存元素的是不是容器）。\n\n\n### 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\n\n虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，在步骤2中，find用元素的==运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持<运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。\n\n **注意：算法永远不会执行容器的操作** \n\n泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。\n\n## 初始泛型算法\n\n除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。\n\n虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。**理解算法的最基本的方法就是了解它们是否读取元素、改变元素、或是重排元素顺序。**\n\n\n### 只读算法\n\n一些算法只会读取其输入范围内的元素，而从不改变元素。find就是这样一种算法。\n\n另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列，则：\n\n```C++\n//对vec中元素的求和，和的初值是0\nint sum=accumulate(vec.cbegin(),vec.cend(),0);\n```\n\n这条语句将sum设置为vec中元素的和，和的初值被设置为0.\n\n**accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型**。\n\n#### 算法和元素类型\n\naccumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。\n\n下面是另一个例子，由于string定义了+运算符，所有我们可以通过调用accumulate来将vector中所有string元素连接起来“\n\nstring sum=accumulate(v.cbegin(),v.cend(),string(\"\"));\n\n此调用将v中每个元素连接到一个string上，该string初始时是空串。**注意，我们通过第三个参数显式地创建了一个string。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。**\n\n```C++\n//错误：const char*上没有定义+运算符\nstring sum=accumulate(v.cbegin(),v.cend(),\"\");\n```\n\n原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char*。如前所述，此类型决定了使用哪个+运算符。由于const char*并没有+运算符，此调用将产生编译错误。\n\n#### 操作两个序列的算法\n\n另一个只读算法是**equal**，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。**此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素**：\n\n```C++\n//roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(),roster1.cend(),roster2.cbegin());\n```\n\n由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<string>,而roster2是list<const char*>。\n\n**但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。 此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素**。\n\n\n### 写容器元素的算法\n\n一些算法将新值赋予序列中的元素。当我们使用这类算法时，**必须注意确保序列原大小至少不小于我们要求算法写入的元素数目**。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。\n\n一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。\n\n例如，算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。\n\n```C++\nfill(vec.begin(),vec.end(),0); //将每个元素重置为0\n//将容器的一个子序列设置为10\nfill(vec.begin(),vec.begin()+vec.size()/2,10);\n```\n\n由于fill向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。\n\n**关键概念：迭代器参数**\n\n一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如，第一个序列可能保存于一个vector中，而第二个序列可能保存于一个list、deque、内置数组或其它容器中。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。例如，对equal算法，元素类型不要求相同，但是我们必须能使用==来比较来自两个序列中的元素。\n\n操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如equal，接受三个迭代器：前两个表示一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。\n\n**用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长**。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。\n\n#### 算法不检查写操作\n\n一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素：\n\n```C++\nvector<int> vec;  //空vector\n//使用vec，赋予它不同值\nfill_n(vec.begin(),vec.size(),0);  //将所有元素重置为0\n```\n\n函数fill_n假定写入指定个元素是安全的。即，如下形式的调用\n\n```C++\nfill_n(dest,n,val)\n```\n\n函数fill_n假定dest指向一个元素，而dest开始的序列至少包含n个元素。\n\n一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）：\n\n```C++\nvector<int> vec;  //空向量\n//灾难：修改vec中10个（不存在）元素\nfill_n(vec.begin(),10,0);\n```\n\n这个调用是一场灾难，我们指定了要写入10个元素，但vec中并没有元素——它是空的，这条语句的结果是未定义的。\n\n**向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素**。\n\n#### 介绍back_inserter\n\n一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。**插入迭代器（insert iterator）** 是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。**而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中**。\n\n为了展示如何用算法向容器中写入数据，我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。\n\nback_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：\n\n```C++\nvector<int> vec;   //空容器\nauto it=back_inserter(vec); //通过它赋值会将元素添加到vec中\n*it=42;//vec现在有一个元素，值为42\n```\n\n我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：\n\n```C++\nvector<int> vec;  //空向量\n//正确：back_inserter创建一个插入迭代器，可以用来向vec添加元素\nfill_n(back_inserter(vec),10,0);  //添加10个元素到vec\n```\n\n在每步迭代中，fill_n向给定容器序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，这条fill_n调用语句向vec的末尾添加了10个元素，每个元素的值都是0.\n\n#### 拷贝算法\n\n拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。**传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。**\n\n我们可以用copy实现内置数组的拷贝，如下面代码所示：\n\n```C++\nint a[]={0,1,2,3,4,5,6,7,8,9};\nint a2[sizeof(a1)/sizeof(*a1)];\nauto ret=copy(begin(a1),end(a1),a2); //把a1的内容拷贝到a2\n```\n\n**copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。**\n\n多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。\n\n例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：\n\n```C++\n//将所有值为0的元素改为42\nreplace(ilist.begin(),ilist.end(),0,42);\n```\n\n此调用将序列中所有0都替换为42,。**如果我们希望保留原序列不变**，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：\n\n```C++\n//使用back_inserter按需要增长目标序列\nvector<int> ivec = {1,2,3,3,3,4,4,5,6,7};\nvector<int> a;\nreplace_copy(ivec.cbegin(),ivec.cend(),back_inserter(a),4,19);\n```\n\n此调用后，ivec并未改变，a包含与ivec的一份拷贝，不过原来在ivec中值为0的元素在a中都变为42。\n\n### 重排容器元素的算法\n\n某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。\n\n#### 消除重复单词\n\n为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，**我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分（重复的元素都在末尾，返回指向不重复区域之后一个位置的迭代器）**，由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作：\n\n```C++\nvector<string> words = {\"to\",\"be\",\"or\",\"not\",\"not\",\"to\",\"be\"};\n//按字典序排序words,以便查找重复单词\nsort(words.begin(),words.end());\n//unique重排输入范围，使得每个单词只出现一次,重复的单词放在后面\n//排列在范围的前部，返回指向不重复区域之后一个位置的迭代器\nauto end_unique = unique(words.begin(),words.end());\n//使用向量操作erase删除重复单词\nwords.erase(end_unique,words.end());\n```\n\n#### 使用unique\n\nwords排序完毕后，我们希望将每个单词都只保存一次。unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。\n\nwords的大小并未改变，但是这些元素的顺序被改变了——相邻的重复元素被“删除”了。我们将删除打引号是因为unique并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，重复的元素出现在后面部分，unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。\n\n标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。\n\n#### 使用容器操作删除元素\n\n为了真正删除无用元素，我们必须使用容器操作，本例中使用erase。我们删除从end_unique开始直至words末尾的范围内的所有元素。这个调用之后，words包含的重复元素真正被删除了。\n\n值得注意的是，即使words中没有重复单词，这样调用erase也是安全的。在此情况下，unique会返回words.end()。因此，传递给erase的两个参数具有系相同的值：words.end()。迭代器相等意味着传递给erase的元素范围为空。删除一个空范围没有什么不良后果，因此程序中即使在输入元素中无重复元素的情况下也是正确的。\n\n\n","slug":"泛型算法概述","published":1,"updated":"2018-02-22T12:07:14.500Z","layout":"post","photos":[],"link":"","_id":"cjdz6yquj000d7wc9iylm35c2","content":"<h2 id=\"泛型算法概述\"><a href=\"#泛型算法概述\" class=\"headerlink\" title=\"泛型算法概述\"></a>泛型算法概述</h2><p>顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。</p>\n<a id=\"more\"></a>\n<p>如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，<strong>而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如vector或list，还包括内置的数组类型）</strong>。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。</p>\n<p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。例如，假定我们有一个int的vector，希望指定vector中是否包含一个特定值。回答这个问题最方便的方法是调用标准库算法find：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> val=<span class=\"number\">42</span>;     <span class=\"comment\">//我们将查找的值</span></div><div class=\"line\"><span class=\"comment\">//如果在vec中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()</span></div><div class=\"line\"><span class=\"keyword\">auto</span> result=find(vec.cbegin(),vec.cend(),val);</div></pre></td></tr></table></figure>\n<p>传递给find的前两个参数是表示元素范围的迭代器，第三个参数是一个值。find将范围中每个元素与给定值进行比较。<strong>它返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败</strong>。因此，我们可以通过比较返回值和第二个参数来判断搜索是否成功。</p>\n<p>由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。例如，可以用find在一个string的list中查找一个给定值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> val=<span class=\"string\">\"a value\"</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> result=find(lst.cbegin(),lst.cend(),val);</div></pre></td></tr></table></figure>\n<p>类似的，由于指针就像内置数组上的迭代器一样，我们可以用find在数组中查找值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[]=&#123;<span class=\"number\">27</span>,<span class=\"number\">210</span>,<span class=\"number\">12</span>,<span class=\"number\">47</span>,<span class=\"number\">109</span>,<span class=\"number\">83</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> val=<span class=\"number\">83</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *result=find(begin(ia),end(ia),val);</div></pre></td></tr></table></figure>\n<p>此例中我们使用了标准库begin和end函数来获得指向ia中首元素和尾元素之后的指针，并传递给find。</p>\n<p>还可以在序列的子范围中查找，只需要指向子范围首元素和尾元素之后位置的迭代器（指针）传递给find。例如，下面的语句在ia[1],ia[2]和ia[3]中查找指定的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> result=find(ia+<span class=\"number\">1</span>,ia+<span class=\"number\">4</span>;val);</div></pre></td></tr></table></figure>\n<h3 id=\"算法如何工作\"><a href=\"#算法如何工作\" class=\"headerlink\" title=\"算法如何工作\"></a>算法如何工作</h3><p>为了弄清这些算法如何用于不同类型的容器，让我们来观察一下find。find的工作是在一个未排序的元素序列中查找一个特定的元素。概念上，find应该执行如下步骤：</p>\n<p>1 访问序列中的首元素</p>\n<p>2 比较此元素与我们要查找的值</p>\n<p>3 如果此元素与我们要查找的值匹配，find返回标识此元素的值。</p>\n<p>4 否则，find前进到下一个元素，重复执行步骤2和3</p>\n<p>5 如果到达序列尾，find应停止</p>\n<p>6 如果find到达序列尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。</p>\n<p>这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个迭代器可用来访问元素，find就完全不依赖于容器类型（甚至无须理会保存元素的是不是容器）。</p>\n<h3 id=\"迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\"><a href=\"#迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\" class=\"headerlink\" title=\"迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\"></a>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作</h3><p>虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，在步骤2中，find用元素的==运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持&lt;运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。</p>\n<p> <strong>注意：算法永远不会执行容器的操作</strong> </p>\n<p>泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>\n<h2 id=\"初始泛型算法\"><a href=\"#初始泛型算法\" class=\"headerlink\" title=\"初始泛型算法\"></a>初始泛型算法</h2><p>除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。</p>\n<p>虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。<strong>理解算法的最基本的方法就是了解它们是否读取元素、改变元素、或是重排元素顺序。</strong></p>\n<h3 id=\"只读算法\"><a href=\"#只读算法\" class=\"headerlink\" title=\"只读算法\"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。find就是这样一种算法。</p>\n<p>另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列，则：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//对vec中元素的求和，和的初值是0</span></div><div class=\"line\"><span class=\"keyword\">int</span> sum=accumulate(vec.cbegin(),vec.cend(),<span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>这条语句将sum设置为vec中元素的和，和的初值被设置为0.</p>\n<p><strong>accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型</strong>。</p>\n<h4 id=\"算法和元素类型\"><a href=\"#算法和元素类型\" class=\"headerlink\" title=\"算法和元素类型\"></a>算法和元素类型</h4><p>accumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。</p>\n<p>下面是另一个例子，由于string定义了+运算符，所有我们可以通过调用accumulate来将vector中所有string元素连接起来“</p>\n<p>string sum=accumulate(v.cbegin(),v.cend(),string(“”));</p>\n<p>此调用将v中每个元素连接到一个string上，该string初始时是空串。<strong>注意，我们通过第三个参数显式地创建了一个string。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：const char*上没有定义+运算符</span></div><div class=\"line\"><span class=\"built_in\">string</span> sum=accumulate(v.cbegin(),v.cend(),<span class=\"string\">\"\"</span>);</div></pre></td></tr></table></figure>\n<p>原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char<em>。如前所述，此类型决定了使用哪个+运算符。由于const char</em>并没有+运算符，此调用将产生编译错误。</p>\n<h4 id=\"操作两个序列的算法\"><a href=\"#操作两个序列的算法\" class=\"headerlink\" title=\"操作两个序列的算法\"></a>操作两个序列的算法</h4><p>另一个只读算法是<strong>equal</strong>，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。<strong>此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//roster2中的元素数目应该至少与roster1一样多</span></div><div class=\"line\">equal(roster1.cbegin(),roster1.cend(),roster2.cbegin());</div></pre></td></tr></table></figure>\n<p>由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<string>,而roster2是list<const char*=\"\">。</const></string></p>\n<p><strong>但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。 此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素</strong>。</p>\n<h3 id=\"写容器元素的算法\"><a href=\"#写容器元素的算法\" class=\"headerlink\" title=\"写容器元素的算法\"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时，<strong>必须注意确保序列原大小至少不小于我们要求算法写入的元素数目</strong>。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。</p>\n<p>一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。</p>\n<p>例如，算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fill(vec.begin(),vec.end(),<span class=\"number\">0</span>); <span class=\"comment\">//将每个元素重置为0</span></div><div class=\"line\"><span class=\"comment\">//将容器的一个子序列设置为10</span></div><div class=\"line\">fill(vec.begin(),vec.begin()+vec.size()/<span class=\"number\">2</span>,<span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<p>由于fill向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。</p>\n<p><strong>关键概念：迭代器参数</strong></p>\n<p>一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如，第一个序列可能保存于一个vector中，而第二个序列可能保存于一个list、deque、内置数组或其它容器中。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。例如，对equal算法，元素类型不要求相同，但是我们必须能使用==来比较来自两个序列中的元素。</p>\n<p>操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如equal，接受三个迭代器：前两个表示一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。</p>\n<p><strong>用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长</strong>。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。</p>\n<h4 id=\"算法不检查写操作\"><a href=\"#算法不检查写操作\" class=\"headerlink\" title=\"算法不检查写操作\"></a>算法不检查写操作</h4><p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;  <span class=\"comment\">//空vector</span></div><div class=\"line\"><span class=\"comment\">//使用vec，赋予它不同值</span></div><div class=\"line\">fill_n(vec.begin(),vec.size(),<span class=\"number\">0</span>);  <span class=\"comment\">//将所有元素重置为0</span></div></pre></td></tr></table></figure>\n<p>函数fill_n假定写入指定个元素是安全的。即，如下形式的调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fill_n(dest,n,val)</div></pre></td></tr></table></figure>\n<p>函数fill_n假定dest指向一个元素，而dest开始的序列至少包含n个元素。</p>\n<p>一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;  <span class=\"comment\">//空向量</span></div><div class=\"line\"><span class=\"comment\">//灾难：修改vec中10个（不存在）元素</span></div><div class=\"line\">fill_n(vec.begin(),<span class=\"number\">10</span>,<span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>这个调用是一场灾难，我们指定了要写入10个元素，但vec中并没有元素——它是空的，这条语句的结果是未定义的。</p>\n<p><strong>向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素</strong>。</p>\n<h4 id=\"介绍back-inserter\"><a href=\"#介绍back-inserter\" class=\"headerlink\" title=\"介绍back_inserter\"></a>介绍back_inserter</h4><p>一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。<strong>插入迭代器（insert iterator）</strong> 是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。<strong>而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中</strong>。</p>\n<p>为了展示如何用算法向容器中写入数据，我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。</p>\n<p>back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;   <span class=\"comment\">//空容器</span></div><div class=\"line\"><span class=\"keyword\">auto</span> it=back_inserter(vec); <span class=\"comment\">//通过它赋值会将元素添加到vec中</span></div><div class=\"line\">*it=<span class=\"number\">42</span>;<span class=\"comment\">//vec现在有一个元素，值为42</span></div></pre></td></tr></table></figure>\n<p>我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;  <span class=\"comment\">//空向量</span></div><div class=\"line\"><span class=\"comment\">//正确：back_inserter创建一个插入迭代器，可以用来向vec添加元素</span></div><div class=\"line\">fill_n(back_inserter(vec),<span class=\"number\">10</span>,<span class=\"number\">0</span>);  <span class=\"comment\">//添加10个元素到vec</span></div></pre></td></tr></table></figure>\n<p>在每步迭代中，fill_n向给定容器序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，这条fill_n调用语句向vec的末尾添加了10个元素，每个元素的值都是0.</p>\n<h4 id=\"拷贝算法\"><a href=\"#拷贝算法\" class=\"headerlink\" title=\"拷贝算法\"></a>拷贝算法</h4><p>拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。<strong>传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。</strong></p>\n<p>我们可以用copy实现内置数组的拷贝，如下面代码所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> a2[<span class=\"keyword\">sizeof</span>(a1)/<span class=\"keyword\">sizeof</span>(*a1)];</div><div class=\"line\"><span class=\"keyword\">auto</span> ret=copy(begin(a1),end(a1),a2); <span class=\"comment\">//把a1的内容拷贝到a2</span></div></pre></td></tr></table></figure>\n<p><strong>copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。</strong></p>\n<p>多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。</p>\n<p>例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//将所有值为0的元素改为42</span></div><div class=\"line\">replace(ilist.begin(),ilist.end(),<span class=\"number\">0</span>,<span class=\"number\">42</span>);</div></pre></td></tr></table></figure>\n<p>此调用将序列中所有0都替换为42,。<strong>如果我们希望保留原序列不变</strong>，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用back_inserter按需要增长目标序列</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; a;</div><div class=\"line\">replace_copy(ivec.cbegin(),ivec.cend(),back_inserter(a),<span class=\"number\">4</span>,<span class=\"number\">19</span>);</div></pre></td></tr></table></figure>\n<p>此调用后，ivec并未改变，a包含与ivec的一份拷贝，不过原来在ivec中值为0的元素在a中都变为42。</p>\n<h3 id=\"重排容器元素的算法\"><a href=\"#重排容器元素的算法\" class=\"headerlink\" title=\"重排容器元素的算法\"></a>重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。</p>\n<h4 id=\"消除重复单词\"><a href=\"#消除重复单词\" class=\"headerlink\" title=\"消除重复单词\"></a>消除重复单词</h4><p>为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，<strong>我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分（重复的元素都在末尾，返回指向不重复区域之后一个位置的迭代器）</strong>，由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; words = &#123;<span class=\"string\">\"to\"</span>,<span class=\"string\">\"be\"</span>,<span class=\"string\">\"or\"</span>,<span class=\"string\">\"not\"</span>,<span class=\"string\">\"not\"</span>,<span class=\"string\">\"to\"</span>,<span class=\"string\">\"be\"</span>&#125;;</div><div class=\"line\"><span class=\"comment\">//按字典序排序words,以便查找重复单词</span></div><div class=\"line\">sort(words.begin(),words.end());</div><div class=\"line\"><span class=\"comment\">//unique重排输入范围，使得每个单词只出现一次,重复的单词放在后面</span></div><div class=\"line\"><span class=\"comment\">//排列在范围的前部，返回指向不重复区域之后一个位置的迭代器</span></div><div class=\"line\"><span class=\"keyword\">auto</span> end_unique = unique(words.begin(),words.end());</div><div class=\"line\"><span class=\"comment\">//使用向量操作erase删除重复单词</span></div><div class=\"line\">words.erase(end_unique,words.end());</div></pre></td></tr></table></figure>\n<h4 id=\"使用unique\"><a href=\"#使用unique\" class=\"headerlink\" title=\"使用unique\"></a>使用unique</h4><p>words排序完毕后，我们希望将每个单词都只保存一次。unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。</p>\n<p>words的大小并未改变，但是这些元素的顺序被改变了——相邻的重复元素被“删除”了。我们将删除打引号是因为unique并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，重复的元素出现在后面部分，unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。</p>\n<p>标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。</p>\n<h4 id=\"使用容器操作删除元素\"><a href=\"#使用容器操作删除元素\" class=\"headerlink\" title=\"使用容器操作删除元素\"></a>使用容器操作删除元素</h4><p>为了真正删除无用元素，我们必须使用容器操作，本例中使用erase。我们删除从end_unique开始直至words末尾的范围内的所有元素。这个调用之后，words包含的重复元素真正被删除了。</p>\n<p>值得注意的是，即使words中没有重复单词，这样调用erase也是安全的。在此情况下，unique会返回words.end()。因此，传递给erase的两个参数具有系相同的值：words.end()。迭代器相等意味着传递给erase的元素范围为空。删除一个空范围没有什么不良后果，因此程序中即使在输入元素中无重复元素的情况下也是正确的。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"泛型算法概述\"><a href=\"#泛型算法概述\" class=\"headerlink\" title=\"泛型算法概述\"></a>泛型算法概述</h2><p>顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。</p>","more":"<p>如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，<strong>而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如vector或list，还包括内置的数组类型）</strong>。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。</p>\n<p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。例如，假定我们有一个int的vector，希望指定vector中是否包含一个特定值。回答这个问题最方便的方法是调用标准库算法find：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> val=<span class=\"number\">42</span>;     <span class=\"comment\">//我们将查找的值</span></div><div class=\"line\"><span class=\"comment\">//如果在vec中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()</span></div><div class=\"line\"><span class=\"keyword\">auto</span> result=find(vec.cbegin(),vec.cend(),val);</div></pre></td></tr></table></figure>\n<p>传递给find的前两个参数是表示元素范围的迭代器，第三个参数是一个值。find将范围中每个元素与给定值进行比较。<strong>它返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败</strong>。因此，我们可以通过比较返回值和第二个参数来判断搜索是否成功。</p>\n<p>由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。例如，可以用find在一个string的list中查找一个给定值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> val=<span class=\"string\">\"a value\"</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> result=find(lst.cbegin(),lst.cend(),val);</div></pre></td></tr></table></figure>\n<p>类似的，由于指针就像内置数组上的迭代器一样，我们可以用find在数组中查找值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> ia[]=&#123;<span class=\"number\">27</span>,<span class=\"number\">210</span>,<span class=\"number\">12</span>,<span class=\"number\">47</span>,<span class=\"number\">109</span>,<span class=\"number\">83</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> val=<span class=\"number\">83</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> *result=find(begin(ia),end(ia),val);</div></pre></td></tr></table></figure>\n<p>此例中我们使用了标准库begin和end函数来获得指向ia中首元素和尾元素之后的指针，并传递给find。</p>\n<p>还可以在序列的子范围中查找，只需要指向子范围首元素和尾元素之后位置的迭代器（指针）传递给find。例如，下面的语句在ia[1],ia[2]和ia[3]中查找指定的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> result=find(ia+<span class=\"number\">1</span>,ia+<span class=\"number\">4</span>;val);</div></pre></td></tr></table></figure>\n<h3 id=\"算法如何工作\"><a href=\"#算法如何工作\" class=\"headerlink\" title=\"算法如何工作\"></a>算法如何工作</h3><p>为了弄清这些算法如何用于不同类型的容器，让我们来观察一下find。find的工作是在一个未排序的元素序列中查找一个特定的元素。概念上，find应该执行如下步骤：</p>\n<p>1 访问序列中的首元素</p>\n<p>2 比较此元素与我们要查找的值</p>\n<p>3 如果此元素与我们要查找的值匹配，find返回标识此元素的值。</p>\n<p>4 否则，find前进到下一个元素，重复执行步骤2和3</p>\n<p>5 如果到达序列尾，find应停止</p>\n<p>6 如果find到达序列尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。</p>\n<p>这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个迭代器可用来访问元素，find就完全不依赖于容器类型（甚至无须理会保存元素的是不是容器）。</p>\n<h3 id=\"迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\"><a href=\"#迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\" class=\"headerlink\" title=\"迭代器令算法不依赖于容器，但算法依赖于元素类型的操作\"></a>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作</h3><p>虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，在步骤2中，find用元素的==运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持&lt;运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。</p>\n<p> <strong>注意：算法永远不会执行容器的操作</strong> </p>\n<p>泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>\n<h2 id=\"初始泛型算法\"><a href=\"#初始泛型算法\" class=\"headerlink\" title=\"初始泛型算法\"></a>初始泛型算法</h2><p>除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。</p>\n<p>虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。<strong>理解算法的最基本的方法就是了解它们是否读取元素、改变元素、或是重排元素顺序。</strong></p>\n<h3 id=\"只读算法\"><a href=\"#只读算法\" class=\"headerlink\" title=\"只读算法\"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。find就是这样一种算法。</p>\n<p>另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列，则：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//对vec中元素的求和，和的初值是0</span></div><div class=\"line\"><span class=\"keyword\">int</span> sum=accumulate(vec.cbegin(),vec.cend(),<span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>这条语句将sum设置为vec中元素的和，和的初值被设置为0.</p>\n<p><strong>accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型</strong>。</p>\n<h4 id=\"算法和元素类型\"><a href=\"#算法和元素类型\" class=\"headerlink\" title=\"算法和元素类型\"></a>算法和元素类型</h4><p>accumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。</p>\n<p>下面是另一个例子，由于string定义了+运算符，所有我们可以通过调用accumulate来将vector中所有string元素连接起来“</p>\n<p>string sum=accumulate(v.cbegin(),v.cend(),string(“”));</p>\n<p>此调用将v中每个元素连接到一个string上，该string初始时是空串。<strong>注意，我们通过第三个参数显式地创建了一个string。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：const char*上没有定义+运算符</span></div><div class=\"line\"><span class=\"built_in\">string</span> sum=accumulate(v.cbegin(),v.cend(),<span class=\"string\">\"\"</span>);</div></pre></td></tr></table></figure>\n<p>原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char<em>。如前所述，此类型决定了使用哪个+运算符。由于const char</em>并没有+运算符，此调用将产生编译错误。</p>\n<h4 id=\"操作两个序列的算法\"><a href=\"#操作两个序列的算法\" class=\"headerlink\" title=\"操作两个序列的算法\"></a>操作两个序列的算法</h4><p>另一个只读算法是<strong>equal</strong>，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。<strong>此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//roster2中的元素数目应该至少与roster1一样多</span></div><div class=\"line\">equal(roster1.cbegin(),roster1.cend(),roster2.cbegin());</div></pre></td></tr></table></figure>\n<p>由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<string>,而roster2是list<const char*=\"\">。</const></string></p>\n<p><strong>但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。 此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素</strong>。</p>\n<h3 id=\"写容器元素的算法\"><a href=\"#写容器元素的算法\" class=\"headerlink\" title=\"写容器元素的算法\"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时，<strong>必须注意确保序列原大小至少不小于我们要求算法写入的元素数目</strong>。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。</p>\n<p>一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。</p>\n<p>例如，算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fill(vec.begin(),vec.end(),<span class=\"number\">0</span>); <span class=\"comment\">//将每个元素重置为0</span></div><div class=\"line\"><span class=\"comment\">//将容器的一个子序列设置为10</span></div><div class=\"line\">fill(vec.begin(),vec.begin()+vec.size()/<span class=\"number\">2</span>,<span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<p>由于fill向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。</p>\n<p><strong>关键概念：迭代器参数</strong></p>\n<p>一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如，第一个序列可能保存于一个vector中，而第二个序列可能保存于一个list、deque、内置数组或其它容器中。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。例如，对equal算法，元素类型不要求相同，但是我们必须能使用==来比较来自两个序列中的元素。</p>\n<p>操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如equal，接受三个迭代器：前两个表示一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。</p>\n<p><strong>用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长</strong>。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。</p>\n<h4 id=\"算法不检查写操作\"><a href=\"#算法不检查写操作\" class=\"headerlink\" title=\"算法不检查写操作\"></a>算法不检查写操作</h4><p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;  <span class=\"comment\">//空vector</span></div><div class=\"line\"><span class=\"comment\">//使用vec，赋予它不同值</span></div><div class=\"line\">fill_n(vec.begin(),vec.size(),<span class=\"number\">0</span>);  <span class=\"comment\">//将所有元素重置为0</span></div></pre></td></tr></table></figure>\n<p>函数fill_n假定写入指定个元素是安全的。即，如下形式的调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fill_n(dest,n,val)</div></pre></td></tr></table></figure>\n<p>函数fill_n假定dest指向一个元素，而dest开始的序列至少包含n个元素。</p>\n<p>一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;  <span class=\"comment\">//空向量</span></div><div class=\"line\"><span class=\"comment\">//灾难：修改vec中10个（不存在）元素</span></div><div class=\"line\">fill_n(vec.begin(),<span class=\"number\">10</span>,<span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>这个调用是一场灾难，我们指定了要写入10个元素，但vec中并没有元素——它是空的，这条语句的结果是未定义的。</p>\n<p><strong>向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素</strong>。</p>\n<h4 id=\"介绍back-inserter\"><a href=\"#介绍back-inserter\" class=\"headerlink\" title=\"介绍back_inserter\"></a>介绍back_inserter</h4><p>一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。<strong>插入迭代器（insert iterator）</strong> 是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。<strong>而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中</strong>。</p>\n<p>为了展示如何用算法向容器中写入数据，我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。</p>\n<p>back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;   <span class=\"comment\">//空容器</span></div><div class=\"line\"><span class=\"keyword\">auto</span> it=back_inserter(vec); <span class=\"comment\">//通过它赋值会将元素添加到vec中</span></div><div class=\"line\">*it=<span class=\"number\">42</span>;<span class=\"comment\">//vec现在有一个元素，值为42</span></div></pre></td></tr></table></figure>\n<p>我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;  <span class=\"comment\">//空向量</span></div><div class=\"line\"><span class=\"comment\">//正确：back_inserter创建一个插入迭代器，可以用来向vec添加元素</span></div><div class=\"line\">fill_n(back_inserter(vec),<span class=\"number\">10</span>,<span class=\"number\">0</span>);  <span class=\"comment\">//添加10个元素到vec</span></div></pre></td></tr></table></figure>\n<p>在每步迭代中，fill_n向给定容器序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，这条fill_n调用语句向vec的末尾添加了10个元素，每个元素的值都是0.</p>\n<h4 id=\"拷贝算法\"><a href=\"#拷贝算法\" class=\"headerlink\" title=\"拷贝算法\"></a>拷贝算法</h4><p>拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。<strong>传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。</strong></p>\n<p>我们可以用copy实现内置数组的拷贝，如下面代码所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> a2[<span class=\"keyword\">sizeof</span>(a1)/<span class=\"keyword\">sizeof</span>(*a1)];</div><div class=\"line\"><span class=\"keyword\">auto</span> ret=copy(begin(a1),end(a1),a2); <span class=\"comment\">//把a1的内容拷贝到a2</span></div></pre></td></tr></table></figure>\n<p><strong>copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。</strong></p>\n<p>多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。</p>\n<p>例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//将所有值为0的元素改为42</span></div><div class=\"line\">replace(ilist.begin(),ilist.end(),<span class=\"number\">0</span>,<span class=\"number\">42</span>);</div></pre></td></tr></table></figure>\n<p>此调用将序列中所有0都替换为42,。<strong>如果我们希望保留原序列不变</strong>，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用back_inserter按需要增长目标序列</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; a;</div><div class=\"line\">replace_copy(ivec.cbegin(),ivec.cend(),back_inserter(a),<span class=\"number\">4</span>,<span class=\"number\">19</span>);</div></pre></td></tr></table></figure>\n<p>此调用后，ivec并未改变，a包含与ivec的一份拷贝，不过原来在ivec中值为0的元素在a中都变为42。</p>\n<h3 id=\"重排容器元素的算法\"><a href=\"#重排容器元素的算法\" class=\"headerlink\" title=\"重排容器元素的算法\"></a>重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。</p>\n<h4 id=\"消除重复单词\"><a href=\"#消除重复单词\" class=\"headerlink\" title=\"消除重复单词\"></a>消除重复单词</h4><p>为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，<strong>我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分（重复的元素都在末尾，返回指向不重复区域之后一个位置的迭代器）</strong>，由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; words = &#123;<span class=\"string\">\"to\"</span>,<span class=\"string\">\"be\"</span>,<span class=\"string\">\"or\"</span>,<span class=\"string\">\"not\"</span>,<span class=\"string\">\"not\"</span>,<span class=\"string\">\"to\"</span>,<span class=\"string\">\"be\"</span>&#125;;</div><div class=\"line\"><span class=\"comment\">//按字典序排序words,以便查找重复单词</span></div><div class=\"line\">sort(words.begin(),words.end());</div><div class=\"line\"><span class=\"comment\">//unique重排输入范围，使得每个单词只出现一次,重复的单词放在后面</span></div><div class=\"line\"><span class=\"comment\">//排列在范围的前部，返回指向不重复区域之后一个位置的迭代器</span></div><div class=\"line\"><span class=\"keyword\">auto</span> end_unique = unique(words.begin(),words.end());</div><div class=\"line\"><span class=\"comment\">//使用向量操作erase删除重复单词</span></div><div class=\"line\">words.erase(end_unique,words.end());</div></pre></td></tr></table></figure>\n<h4 id=\"使用unique\"><a href=\"#使用unique\" class=\"headerlink\" title=\"使用unique\"></a>使用unique</h4><p>words排序完毕后，我们希望将每个单词都只保存一次。unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。</p>\n<p>words的大小并未改变，但是这些元素的顺序被改变了——相邻的重复元素被“删除”了。我们将删除打引号是因为unique并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，重复的元素出现在后面部分，unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。</p>\n<p>标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。</p>\n<h4 id=\"使用容器操作删除元素\"><a href=\"#使用容器操作删除元素\" class=\"headerlink\" title=\"使用容器操作删除元素\"></a>使用容器操作删除元素</h4><p>为了真正删除无用元素，我们必须使用容器操作，本例中使用erase。我们删除从end_unique开始直至words末尾的范围内的所有元素。这个调用之后，words包含的重复元素真正被删除了。</p>\n<p>值得注意的是，即使words中没有重复单词，这样调用erase也是安全的。在此情况下，unique会返回words.end()。因此，传递给erase的两个参数具有系相同的值：words.end()。迭代器相等意味着传递给erase的元素范围为空。删除一个空范围没有什么不良后果，因此程序中即使在输入元素中无重复元素的情况下也是正确的。</p>"},{"title":"常用运算符重载","date":"2017-11-18T13:59:00.000Z","update":null,"comments":1,"_content":"\n## 前言\n\n当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。\n\n<!--more-->\n\n## 基本概念\n\n重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。\n\n重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。\n\n**如果一个运算符函数是成员函数，这他的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。**\n\n对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：\n\n```C++\n//错误：不能为int重定义内置的运算符\nint operator+(int,int);\n```\n\n这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。\n\n### 直接调用一个重载的运算符函数\n\n```C++\n//一个非成员运算符函数的等价调用\ndata1 + data2;          //普通的表达式\noperator+(data1,data2);       //等价的函数调用\n```\n\n这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。\n\n```C++\n//一个成员运算符函数的等价调用\ndata1 += data2;        //基于“调用”的表达式\ndata1.operator+=(data2);         //对成员运算符\n```\n\n这两天语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。\n\n### 某些运算符不应该被重载\n\n某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。\n\n比如：&& 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，这两个运算对象总是会被求值。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。\n\n**通常情况下：不应该重载逗号、取地址、逻辑与和逻辑或运算符。**\n\n### 赋值和复合赋值运算符\n\n赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧的运算对象的一个引用。重载的赋值运算符应该继承而非违背其内置版本的含义。\n\n如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。+=运算符的行为显然与其内置版本一致，即先执行+，再执行=。\n\n### 选择作为成员或者非成员 （重点）\n\n当我们定义重载的运算符必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。\n\n下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：\n\n- 赋值（=）、下标（[])、调用（（））和成员访问箭头（->）运算符必须是成员\n- 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。\n- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。\n- 具有对称性的运算符可以转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。\n\n\n例如，我们能求一个int和一个double的和，因为它们中任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。**如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。**\n\n当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象，例如：\n\n```C++\nstring s = \"world\";\nstring t = s + \"!\";    //正确：我们能把一个const char*加到一个string对象中\nstring u = \"hi\" + s;     //如果 + 是string的成员，则产生错误\n```\n\n如果operator+是string类的成员，则上面的第一个加法等价于s.operator+(\"!\")。同样的，\"hi\"+s等价于\"hi\".operator+(s)。显然\"hi\"的类型是const char*,这是一种内置类型，根本就没有成员函数。\n\n因为string将+定义成了普通的非成员函数，所以\"hi\"+s等价于operator+(\"hi\",s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准备无误地转换成string。\n\n\n## 输入和输出运算符\n\nIO标准库分别使用>>和<<执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。\n\n### 重载输出运算符<<\n\n通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用时因为我们无法直接赋值一个ostream对象。\n\n第二个形参一般来说是一个常量的引用，因为打印对象不会改变对象的内容，为了与其他输出运算符保持一致，operator<<一般要返回它的ostream形参。\n\n```C++\nostream &operator<<(ostream &os,const Sales_data &item){\n    os<<item.isbn()<<item.avg_price();\n    return os;\n}\n```\n\n**输入输出运算符必须是非成员函数**，通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。\n\n### 重载输入运算符>>\n\n通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。\n\n```C++\nistream& operator>>(istream &is,Sales_data &item){\n    double price ;\n    is>>item.bookNo>>item.units_sold>>price;  \n    if(is){    //检查输入是否成功\n        item.revenue = item.units_sold*price;\n    }else{\n        item = Sales_data();       //输入失败：对象被赋予默认的状态\n    }\n    return is;\n}\n```\n\n**note:** 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。\n\n## 算术和关系运算符\n\n如果类同时定义了算符运算符和相关的复合赋值运算符（+=），则通常情况下应该使用复合赋值来实现算术运算符。\n\n### 相等运算符  （==）\n\n如果某个类在逻辑上有相等性的含义，则该类应该定义operator == ，这样做可以使得用户更容易使用标准库算法来处理这个类。\n\n### 关系运算符 （<）\n\n定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator<会比较有用。\n\n通常情况下关系运算符应该\n\n- 定义顺序关系，令其与关联容器中对关键字的要求一致。\n- 如果类同时也包含==运算符的话，则定义一种关系令其与 ==保持一致。特别是，如果两个对象是!=的，那么一个对象应该<另外一个。\n\n**注意：** 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和 ==产生的结果一致时才定义 <运算符。\n\n## 赋值运算符\n\n我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数\n\n### 复合赋值运算符\n\n**赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。**\n\n```C++\n//作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\n//假定两个对象表示的是同一本书\nSales_data& Sales_data::operator+= (const Sales_data &rhs){\n    this.units_sole += rhs.units_sole;\n    this.revenue += rhs.revenue;\n    return *this;\n}\n```\n## 下标运算符\n\n表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。\n\n**note: 下标运算符必须是成员函数。**\n\n为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。**进一步，我们最好定义下标运算符的常量版本和非常量版本，当作用与一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值**。\n\n定义StrVec的下标运算符：\n\n```C++\nclass StrVec {\npublic:\n    string& operator[](size_t n) {return elements[n];}\n    const string& operator[](size_t n) const {return elements[n];}\n    //其他成员定义\nprivate:\n    string *element;         //指向数组首元素的指针\n}\n```\n\n当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值：\n\n```C++\n// 假设svec是一个StrVec对象\nconst StrVec cvec = svec;      //把svec的元素拷贝到cvec中\n//如果svec中含有元素，对第一个元素运行string的empty函数\nif(svec.size() && svec[0].empty()) {\n    svec[0] = \"zero\";      //正确:下标运算符返回string的引用\n    cvec[0] = \"zip\";       //错误：对cvec取下标返回的是常量引用，不能再赋值\n}\n```\n\n## 递增和递减运算符 （重点）\n\nC++语言并不要求递增和递减运算符必须是类的成员，**但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。**\n\n**定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类成员。**\n\n### 定义前置递增/递减运算符\n\n与内置版本保持一致，**前置运算符应该返回递增或递减后对象的引用。 **\n\n```C++\nInteger& operator++(){ ++value; return *this;}    //前置运算符\n```\n\n### 后置运算符\n\n后置版本接受一个额外的（不被使用）int类型的形参，因为我们不会用到int形参，所以无须为其命令。\n\n为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。\n\n```C++\nInteger operator++(int) {   //后置运算符\n    Integer ret = *this; \n    ++value; \n    return ret;\n}  \n```\n\n### 显示调用后置运算符\n\n通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值\n\n```C++\nInteger INT;\nINT.operator++(0);   //调用后置版本的operator++\nINT.operator++();    //调用前置版本的operator++\n```\n\n\n完整代码实现：\n\n```C++\n#include <iostream>\nusing namespace std;\nclass Integer{\npublic:\n    Integer(int a = 0):value(a){}    //默认值参数，如果不提供参数，调用默认构造函数，提供参数则调用构造函数\n    Integer(const Integer& Int):value(Int.value){}   //拷贝构造函数\n    Integer& operator=(const Integer &Int) { value = Int.value; return *this;}  //拷贝赋值运算符\n    Integer& operator++(){ ++value; return *this;}    //前置运算符\n    Integer operator++(int) { Integer ret = *this; ++value; return ret;}  //后置运算符\n    int value;   //含有一个数据类型\n};\n\nint main()\n{\n    Integer a;\n    cout<<a.value<<endl;\n    a.value = 10;\n    Integer b(a);   //调用拷贝构造函数\n    cout<<b.value<<endl;\n    Integer c;\n    c = a;    //调用拷贝赋值运算符\n    cout<<c.value<<endl;\n    ++c;   //调用重载前置运算符\n    cout<<c.value<<endl;\n    cout<<(c++).value<<endl;   //调用重载后置运算符\n    cout<<c.value<<endl;\n    return 0;\n}\n```\n\n","source":"_posts/常用运算符重载.md","raw":"---\ntitle: 常用运算符重载\ndate: 2017-11-18 21:59:00\nupdate: \ntags: [运算符重载]\ncategories: C++\ncomments: true\n---\n\n## 前言\n\n当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。\n\n<!--more-->\n\n## 基本概念\n\n重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。\n\n重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。\n\n**如果一个运算符函数是成员函数，这他的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。**\n\n对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：\n\n```C++\n//错误：不能为int重定义内置的运算符\nint operator+(int,int);\n```\n\n这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。\n\n### 直接调用一个重载的运算符函数\n\n```C++\n//一个非成员运算符函数的等价调用\ndata1 + data2;          //普通的表达式\noperator+(data1,data2);       //等价的函数调用\n```\n\n这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。\n\n```C++\n//一个成员运算符函数的等价调用\ndata1 += data2;        //基于“调用”的表达式\ndata1.operator+=(data2);         //对成员运算符\n```\n\n这两天语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。\n\n### 某些运算符不应该被重载\n\n某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。\n\n比如：&& 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，这两个运算对象总是会被求值。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。\n\n**通常情况下：不应该重载逗号、取地址、逻辑与和逻辑或运算符。**\n\n### 赋值和复合赋值运算符\n\n赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧的运算对象的一个引用。重载的赋值运算符应该继承而非违背其内置版本的含义。\n\n如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。+=运算符的行为显然与其内置版本一致，即先执行+，再执行=。\n\n### 选择作为成员或者非成员 （重点）\n\n当我们定义重载的运算符必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。\n\n下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：\n\n- 赋值（=）、下标（[])、调用（（））和成员访问箭头（->）运算符必须是成员\n- 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。\n- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。\n- 具有对称性的运算符可以转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。\n\n\n例如，我们能求一个int和一个double的和，因为它们中任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。**如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。**\n\n当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象，例如：\n\n```C++\nstring s = \"world\";\nstring t = s + \"!\";    //正确：我们能把一个const char*加到一个string对象中\nstring u = \"hi\" + s;     //如果 + 是string的成员，则产生错误\n```\n\n如果operator+是string类的成员，则上面的第一个加法等价于s.operator+(\"!\")。同样的，\"hi\"+s等价于\"hi\".operator+(s)。显然\"hi\"的类型是const char*,这是一种内置类型，根本就没有成员函数。\n\n因为string将+定义成了普通的非成员函数，所以\"hi\"+s等价于operator+(\"hi\",s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准备无误地转换成string。\n\n\n## 输入和输出运算符\n\nIO标准库分别使用>>和<<执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。\n\n### 重载输出运算符<<\n\n通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用时因为我们无法直接赋值一个ostream对象。\n\n第二个形参一般来说是一个常量的引用，因为打印对象不会改变对象的内容，为了与其他输出运算符保持一致，operator<<一般要返回它的ostream形参。\n\n```C++\nostream &operator<<(ostream &os,const Sales_data &item){\n    os<<item.isbn()<<item.avg_price();\n    return os;\n}\n```\n\n**输入输出运算符必须是非成员函数**，通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。\n\n### 重载输入运算符>>\n\n通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。\n\n```C++\nistream& operator>>(istream &is,Sales_data &item){\n    double price ;\n    is>>item.bookNo>>item.units_sold>>price;  \n    if(is){    //检查输入是否成功\n        item.revenue = item.units_sold*price;\n    }else{\n        item = Sales_data();       //输入失败：对象被赋予默认的状态\n    }\n    return is;\n}\n```\n\n**note:** 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。\n\n## 算术和关系运算符\n\n如果类同时定义了算符运算符和相关的复合赋值运算符（+=），则通常情况下应该使用复合赋值来实现算术运算符。\n\n### 相等运算符  （==）\n\n如果某个类在逻辑上有相等性的含义，则该类应该定义operator == ，这样做可以使得用户更容易使用标准库算法来处理这个类。\n\n### 关系运算符 （<）\n\n定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator<会比较有用。\n\n通常情况下关系运算符应该\n\n- 定义顺序关系，令其与关联容器中对关键字的要求一致。\n- 如果类同时也包含==运算符的话，则定义一种关系令其与 ==保持一致。特别是，如果两个对象是!=的，那么一个对象应该<另外一个。\n\n**注意：** 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和 ==产生的结果一致时才定义 <运算符。\n\n## 赋值运算符\n\n我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数\n\n### 复合赋值运算符\n\n**赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。**\n\n```C++\n//作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\n//假定两个对象表示的是同一本书\nSales_data& Sales_data::operator+= (const Sales_data &rhs){\n    this.units_sole += rhs.units_sole;\n    this.revenue += rhs.revenue;\n    return *this;\n}\n```\n## 下标运算符\n\n表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。\n\n**note: 下标运算符必须是成员函数。**\n\n为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。**进一步，我们最好定义下标运算符的常量版本和非常量版本，当作用与一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值**。\n\n定义StrVec的下标运算符：\n\n```C++\nclass StrVec {\npublic:\n    string& operator[](size_t n) {return elements[n];}\n    const string& operator[](size_t n) const {return elements[n];}\n    //其他成员定义\nprivate:\n    string *element;         //指向数组首元素的指针\n}\n```\n\n当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值：\n\n```C++\n// 假设svec是一个StrVec对象\nconst StrVec cvec = svec;      //把svec的元素拷贝到cvec中\n//如果svec中含有元素，对第一个元素运行string的empty函数\nif(svec.size() && svec[0].empty()) {\n    svec[0] = \"zero\";      //正确:下标运算符返回string的引用\n    cvec[0] = \"zip\";       //错误：对cvec取下标返回的是常量引用，不能再赋值\n}\n```\n\n## 递增和递减运算符 （重点）\n\nC++语言并不要求递增和递减运算符必须是类的成员，**但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。**\n\n**定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类成员。**\n\n### 定义前置递增/递减运算符\n\n与内置版本保持一致，**前置运算符应该返回递增或递减后对象的引用。 **\n\n```C++\nInteger& operator++(){ ++value; return *this;}    //前置运算符\n```\n\n### 后置运算符\n\n后置版本接受一个额外的（不被使用）int类型的形参，因为我们不会用到int形参，所以无须为其命令。\n\n为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。\n\n```C++\nInteger operator++(int) {   //后置运算符\n    Integer ret = *this; \n    ++value; \n    return ret;\n}  \n```\n\n### 显示调用后置运算符\n\n通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值\n\n```C++\nInteger INT;\nINT.operator++(0);   //调用后置版本的operator++\nINT.operator++();    //调用前置版本的operator++\n```\n\n\n完整代码实现：\n\n```C++\n#include <iostream>\nusing namespace std;\nclass Integer{\npublic:\n    Integer(int a = 0):value(a){}    //默认值参数，如果不提供参数，调用默认构造函数，提供参数则调用构造函数\n    Integer(const Integer& Int):value(Int.value){}   //拷贝构造函数\n    Integer& operator=(const Integer &Int) { value = Int.value; return *this;}  //拷贝赋值运算符\n    Integer& operator++(){ ++value; return *this;}    //前置运算符\n    Integer operator++(int) { Integer ret = *this; ++value; return ret;}  //后置运算符\n    int value;   //含有一个数据类型\n};\n\nint main()\n{\n    Integer a;\n    cout<<a.value<<endl;\n    a.value = 10;\n    Integer b(a);   //调用拷贝构造函数\n    cout<<b.value<<endl;\n    Integer c;\n    c = a;    //调用拷贝赋值运算符\n    cout<<c.value<<endl;\n    ++c;   //调用重载前置运算符\n    cout<<c.value<<endl;\n    cout<<(c++).value<<endl;   //调用重载后置运算符\n    cout<<c.value<<endl;\n    return 0;\n}\n```\n\n","slug":"常用运算符重载","published":1,"updated":"2018-02-22T12:27:58.644Z","layout":"post","photos":[],"link":"","_id":"cjdz6yqve000w7wc9ynwvhrhc","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。</p>\n<a id=\"more\"></a>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>\n<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。</p>\n<p><strong>如果一个运算符函数是成员函数，这他的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。</strong></p>\n<p>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：不能为int重定义内置的运算符</span></div><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">operator</span>+(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>);</div></pre></td></tr></table></figure>\n<p>这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</p>\n<h3 id=\"直接调用一个重载的运算符函数\"><a href=\"#直接调用一个重载的运算符函数\" class=\"headerlink\" title=\"直接调用一个重载的运算符函数\"></a>直接调用一个重载的运算符函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个非成员运算符函数的等价调用</span></div><div class=\"line\">data1 + data2;          <span class=\"comment\">//普通的表达式</span></div><div class=\"line\"><span class=\"keyword\">operator</span>+(data1,data2);       <span class=\"comment\">//等价的函数调用</span></div></pre></td></tr></table></figure>\n<p>这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个成员运算符函数的等价调用</span></div><div class=\"line\">data1 += data2;        <span class=\"comment\">//基于“调用”的表达式</span></div><div class=\"line\">data1.<span class=\"keyword\">operator</span>+=(data2);         <span class=\"comment\">//对成员运算符</span></div></pre></td></tr></table></figure>\n<p>这两天语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。</p>\n<h3 id=\"某些运算符不应该被重载\"><a href=\"#某些运算符不应该被重载\" class=\"headerlink\" title=\"某些运算符不应该被重载\"></a>某些运算符不应该被重载</h3><p>某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。</p>\n<p>比如：&amp;&amp; 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，这两个运算对象总是会被求值。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。</p>\n<p><strong>通常情况下：不应该重载逗号、取地址、逻辑与和逻辑或运算符。</strong></p>\n<h3 id=\"赋值和复合赋值运算符\"><a href=\"#赋值和复合赋值运算符\" class=\"headerlink\" title=\"赋值和复合赋值运算符\"></a>赋值和复合赋值运算符</h3><p>赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧的运算对象的一个引用。重载的赋值运算符应该继承而非违背其内置版本的含义。</p>\n<p>如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。+=运算符的行为显然与其内置版本一致，即先执行+，再执行=。</p>\n<h3 id=\"选择作为成员或者非成员-（重点）\"><a href=\"#选择作为成员或者非成员-（重点）\" class=\"headerlink\" title=\"选择作为成员或者非成员 （重点）\"></a>选择作为成员或者非成员 （重点）</h3><p>当我们定义重载的运算符必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。</p>\n<p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：</p>\n<ul>\n<li>赋值（=）、下标（[])、调用（（））和成员访问箭头（-&gt;）运算符必须是成员</li>\n<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>\n<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li>\n<li>具有对称性的运算符可以转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>\n</ul>\n<p>例如，我们能求一个int和一个double的和，因为它们中任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。<strong>如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。</strong></p>\n<p>当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s = <span class=\"string\">\"world\"</span>;</div><div class=\"line\"><span class=\"built_in\">string</span> t = s + <span class=\"string\">\"!\"</span>;    <span class=\"comment\">//正确：我们能把一个const char*加到一个string对象中</span></div><div class=\"line\"><span class=\"built_in\">string</span> u = <span class=\"string\">\"hi\"</span> + s;     <span class=\"comment\">//如果 + 是string的成员，则产生错误</span></div></pre></td></tr></table></figure>\n<p>如果operator+是string类的成员，则上面的第一个加法等价于s.operator+(“!”)。同样的，”hi”+s等价于”hi”.operator+(s)。显然”hi”的类型是const char*,这是一种内置类型，根本就没有成员函数。</p>\n<p>因为string将+定义成了普通的非成员函数，所以”hi”+s等价于operator+(“hi”,s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准备无误地转换成string。</p>\n<h2 id=\"输入和输出运算符\"><a href=\"#输入和输出运算符\" class=\"headerlink\" title=\"输入和输出运算符\"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。</p>\n<h3 id=\"重载输出运算符-lt-lt\"><a href=\"#重载输出运算符-lt-lt\" class=\"headerlink\" title=\"重载输出运算符&lt;&lt;\"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用时因为我们无法直接赋值一个ostream对象。</p>\n<p>第二个形参一般来说是一个常量的引用，因为打印对象不会改变对象的内容，为了与其他输出运算符保持一致，operator&lt;&lt;一般要返回它的ostream形参。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;os,<span class=\"keyword\">const</span> Sales_data &amp;item)&#123;</div><div class=\"line\">    os&lt;&lt;item.isbn()&lt;&lt;item.avg_price();</div><div class=\"line\">    <span class=\"keyword\">return</span> os;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>输入输出运算符必须是非成员函数</strong>，通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>\n<h3 id=\"重载输入运算符-gt-gt\"><a href=\"#重载输入运算符-gt-gt\" class=\"headerlink\" title=\"重载输入运算符&gt;&gt;\"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream &amp;is,Sales_data &amp;item)&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> price ;</div><div class=\"line\">    is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price;  </div><div class=\"line\">    <span class=\"keyword\">if</span>(is)&#123;    <span class=\"comment\">//检查输入是否成功</span></div><div class=\"line\">        item.revenue = item.units_sold*price;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        item = Sales_data();       <span class=\"comment\">//输入失败：对象被赋予默认的状态</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> is;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>note:</strong> 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。</p>\n<h2 id=\"算术和关系运算符\"><a href=\"#算术和关系运算符\" class=\"headerlink\" title=\"算术和关系运算符\"></a>算术和关系运算符</h2><p>如果类同时定义了算符运算符和相关的复合赋值运算符（+=），则通常情况下应该使用复合赋值来实现算术运算符。</p>\n<h3 id=\"相等运算符-（-）\"><a href=\"#相等运算符-（-）\" class=\"headerlink\" title=\"相等运算符  （==）\"></a>相等运算符  （==）</h3><p>如果某个类在逻辑上有相等性的含义，则该类应该定义operator == ，这样做可以使得用户更容易使用标准库算法来处理这个类。</p>\n<h3 id=\"关系运算符-（-lt-）\"><a href=\"#关系运算符-（-lt-）\" class=\"headerlink\" title=\"关系运算符 （&lt;）\"></a>关系运算符 （&lt;）</h3><p>定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较有用。</p>\n<p>通常情况下关系运算符应该</p>\n<ul>\n<li>定义顺序关系，令其与关联容器中对关键字的要求一致。</li>\n<li>如果类同时也包含==运算符的话，则定义一种关系令其与 ==保持一致。特别是，如果两个对象是!=的，那么一个对象应该&lt;另外一个。</li>\n</ul>\n<p><strong>注意：</strong> 如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和 ==产生的结果一致时才定义 &lt;运算符。</p>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数</p>\n<h3 id=\"复合赋值运算符\"><a href=\"#复合赋值运算符\" class=\"headerlink\" title=\"复合赋值运算符\"></a>复合赋值运算符</h3><p><strong>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//作为成员的二元运算符：左侧运算对象绑定到隐式的this指针</span></div><div class=\"line\"><span class=\"comment\">//假定两个对象表示的是同一本书</span></div><div class=\"line\">Sales_data&amp; Sales_data::<span class=\"keyword\">operator</span>+= (<span class=\"keyword\">const</span> Sales_data &amp;rhs)&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.units_sole += rhs.units_sole;</div><div class=\"line\">    <span class=\"keyword\">this</span>.revenue += rhs.revenue;</div><div class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"下标运算符\"><a href=\"#下标运算符\" class=\"headerlink\" title=\"下标运算符\"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p>\n<p><strong>note: 下标运算符必须是成员函数。</strong></p>\n<p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。<strong>进一步，我们最好定义下标运算符的常量版本和非常量版本，当作用与一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值</strong>。</p>\n<p>定义StrVec的下标运算符：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrVec</span> &#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> n) &#123;<span class=\"keyword\">return</span> elements[n];&#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> n) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> elements[n];&#125;</div><div class=\"line\">    <span class=\"comment\">//其他成员定义</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> *element;         <span class=\"comment\">//指向数组首元素的指针</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 假设svec是一个StrVec对象</span></div><div class=\"line\"><span class=\"keyword\">const</span> StrVec cvec = svec;      <span class=\"comment\">//把svec的元素拷贝到cvec中</span></div><div class=\"line\"><span class=\"comment\">//如果svec中含有元素，对第一个元素运行string的empty函数</span></div><div class=\"line\"><span class=\"keyword\">if</span>(svec.size() &amp;&amp; svec[<span class=\"number\">0</span>].empty()) &#123;</div><div class=\"line\">    svec[<span class=\"number\">0</span>] = <span class=\"string\">\"zero\"</span>;      <span class=\"comment\">//正确:下标运算符返回string的引用</span></div><div class=\"line\">    cvec[<span class=\"number\">0</span>] = <span class=\"string\">\"zip\"</span>;       <span class=\"comment\">//错误：对cvec取下标返回的是常量引用，不能再赋值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"递增和递减运算符-（重点）\"><a href=\"#递增和递减运算符-（重点）\" class=\"headerlink\" title=\"递增和递减运算符 （重点）\"></a>递增和递减运算符 （重点）</h2><p>C++语言并不要求递增和递减运算符必须是类的成员，<strong>但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。</strong></p>\n<p><strong>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类成员。</strong></p>\n<h3 id=\"定义前置递增-递减运算符\"><a href=\"#定义前置递增-递减运算符\" class=\"headerlink\" title=\"定义前置递增/递减运算符\"></a>定义前置递增/递减运算符</h3><p>与内置版本保持一致，<strong>前置运算符应该返回递增或递减后对象的引用。 </strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer&amp; <span class=\"keyword\">operator</span>++()&#123; ++value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;    <span class=\"comment\">//前置运算符</span></div></pre></td></tr></table></figure>\n<h3 id=\"后置运算符\"><a href=\"#后置运算符\" class=\"headerlink\" title=\"后置运算符\"></a>后置运算符</h3><p>后置版本接受一个额外的（不被使用）int类型的形参，因为我们不会用到int形参，所以无须为其命令。</p>\n<p>为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>) &#123;   <span class=\"comment\">//后置运算符</span></div><div class=\"line\">    Integer ret = *<span class=\"keyword\">this</span>; </div><div class=\"line\">    ++value; </div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"显示调用后置运算符\"><a href=\"#显示调用后置运算符\" class=\"headerlink\" title=\"显示调用后置运算符\"></a>显示调用后置运算符</h3><p>通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer INT;</div><div class=\"line\">INT.<span class=\"keyword\">operator</span>++(<span class=\"number\">0</span>);   <span class=\"comment\">//调用后置版本的operator++</span></div><div class=\"line\">INT.<span class=\"keyword\">operator</span>++();    <span class=\"comment\">//调用前置版本的operator++</span></div></pre></td></tr></table></figure>\n<p>完整代码实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Integer</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Integer(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>):value(a)&#123;&#125;    <span class=\"comment\">//默认值参数，如果不提供参数，调用默认构造函数，提供参数则调用构造函数</span></div><div class=\"line\">    Integer(<span class=\"keyword\">const</span> Integer&amp; Int):value(Int.value)&#123;&#125;   <span class=\"comment\">//拷贝构造函数</span></div><div class=\"line\">    Integer&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Integer &amp;Int) &#123; value = Int.value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;  <span class=\"comment\">//拷贝赋值运算符</span></div><div class=\"line\">    Integer&amp; <span class=\"keyword\">operator</span>++()&#123; ++value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;    <span class=\"comment\">//前置运算符</span></div><div class=\"line\">    Integer <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>) &#123; Integer ret = *<span class=\"keyword\">this</span>; ++value; <span class=\"keyword\">return</span> ret;&#125;  <span class=\"comment\">//后置运算符</span></div><div class=\"line\">    <span class=\"keyword\">int</span> value;   <span class=\"comment\">//含有一个数据类型</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    Integer a;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a.value = <span class=\"number\">10</span>;</div><div class=\"line\">    <span class=\"function\">Integer <span class=\"title\">b</span><span class=\"params\">(a)</span></span>;   <span class=\"comment\">//调用拷贝构造函数</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;b.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    Integer c;</div><div class=\"line\">    c = a;    <span class=\"comment\">//调用拷贝赋值运算符</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    ++c;   <span class=\"comment\">//调用重载前置运算符</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(c++).value&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//调用重载后置运算符</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。</p>","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>\n<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。</p>\n<p><strong>如果一个运算符函数是成员函数，这他的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。</strong></p>\n<p>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：不能为int重定义内置的运算符</span></div><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">operator</span>+(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>);</div></pre></td></tr></table></figure>\n<p>这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</p>\n<h3 id=\"直接调用一个重载的运算符函数\"><a href=\"#直接调用一个重载的运算符函数\" class=\"headerlink\" title=\"直接调用一个重载的运算符函数\"></a>直接调用一个重载的运算符函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个非成员运算符函数的等价调用</span></div><div class=\"line\">data1 + data2;          <span class=\"comment\">//普通的表达式</span></div><div class=\"line\"><span class=\"keyword\">operator</span>+(data1,data2);       <span class=\"comment\">//等价的函数调用</span></div></pre></td></tr></table></figure>\n<p>这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个成员运算符函数的等价调用</span></div><div class=\"line\">data1 += data2;        <span class=\"comment\">//基于“调用”的表达式</span></div><div class=\"line\">data1.<span class=\"keyword\">operator</span>+=(data2);         <span class=\"comment\">//对成员运算符</span></div></pre></td></tr></table></figure>\n<p>这两天语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。</p>\n<h3 id=\"某些运算符不应该被重载\"><a href=\"#某些运算符不应该被重载\" class=\"headerlink\" title=\"某些运算符不应该被重载\"></a>某些运算符不应该被重载</h3><p>某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。</p>\n<p>比如：&amp;&amp; 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，这两个运算对象总是会被求值。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。</p>\n<p><strong>通常情况下：不应该重载逗号、取地址、逻辑与和逻辑或运算符。</strong></p>\n<h3 id=\"赋值和复合赋值运算符\"><a href=\"#赋值和复合赋值运算符\" class=\"headerlink\" title=\"赋值和复合赋值运算符\"></a>赋值和复合赋值运算符</h3><p>赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧的运算对象的一个引用。重载的赋值运算符应该继承而非违背其内置版本的含义。</p>\n<p>如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。+=运算符的行为显然与其内置版本一致，即先执行+，再执行=。</p>\n<h3 id=\"选择作为成员或者非成员-（重点）\"><a href=\"#选择作为成员或者非成员-（重点）\" class=\"headerlink\" title=\"选择作为成员或者非成员 （重点）\"></a>选择作为成员或者非成员 （重点）</h3><p>当我们定义重载的运算符必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。</p>\n<p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：</p>\n<ul>\n<li>赋值（=）、下标（[])、调用（（））和成员访问箭头（-&gt;）运算符必须是成员</li>\n<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>\n<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li>\n<li>具有对称性的运算符可以转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>\n</ul>\n<p>例如，我们能求一个int和一个double的和，因为它们中任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。<strong>如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。</strong></p>\n<p>当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">string</span> s = <span class=\"string\">\"world\"</span>;</div><div class=\"line\"><span class=\"built_in\">string</span> t = s + <span class=\"string\">\"!\"</span>;    <span class=\"comment\">//正确：我们能把一个const char*加到一个string对象中</span></div><div class=\"line\"><span class=\"built_in\">string</span> u = <span class=\"string\">\"hi\"</span> + s;     <span class=\"comment\">//如果 + 是string的成员，则产生错误</span></div></pre></td></tr></table></figure>\n<p>如果operator+是string类的成员，则上面的第一个加法等价于s.operator+(“!”)。同样的，”hi”+s等价于”hi”.operator+(s)。显然”hi”的类型是const char*,这是一种内置类型，根本就没有成员函数。</p>\n<p>因为string将+定义成了普通的非成员函数，所以”hi”+s等价于operator+(“hi”,s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准备无误地转换成string。</p>\n<h2 id=\"输入和输出运算符\"><a href=\"#输入和输出运算符\" class=\"headerlink\" title=\"输入和输出运算符\"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。</p>\n<h3 id=\"重载输出运算符-lt-lt\"><a href=\"#重载输出运算符-lt-lt\" class=\"headerlink\" title=\"重载输出运算符&lt;&lt;\"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用时因为我们无法直接赋值一个ostream对象。</p>\n<p>第二个形参一般来说是一个常量的引用，因为打印对象不会改变对象的内容，为了与其他输出运算符保持一致，operator&lt;&lt;一般要返回它的ostream形参。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;os,<span class=\"keyword\">const</span> Sales_data &amp;item)&#123;</div><div class=\"line\">    os&lt;&lt;item.isbn()&lt;&lt;item.avg_price();</div><div class=\"line\">    <span class=\"keyword\">return</span> os;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>输入输出运算符必须是非成员函数</strong>，通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>\n<h3 id=\"重载输入运算符-gt-gt\"><a href=\"#重载输入运算符-gt-gt\" class=\"headerlink\" title=\"重载输入运算符&gt;&gt;\"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream &amp;is,Sales_data &amp;item)&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> price ;</div><div class=\"line\">    is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price;  </div><div class=\"line\">    <span class=\"keyword\">if</span>(is)&#123;    <span class=\"comment\">//检查输入是否成功</span></div><div class=\"line\">        item.revenue = item.units_sold*price;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        item = Sales_data();       <span class=\"comment\">//输入失败：对象被赋予默认的状态</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> is;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>note:</strong> 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。</p>\n<h2 id=\"算术和关系运算符\"><a href=\"#算术和关系运算符\" class=\"headerlink\" title=\"算术和关系运算符\"></a>算术和关系运算符</h2><p>如果类同时定义了算符运算符和相关的复合赋值运算符（+=），则通常情况下应该使用复合赋值来实现算术运算符。</p>\n<h3 id=\"相等运算符-（-）\"><a href=\"#相等运算符-（-）\" class=\"headerlink\" title=\"相等运算符  （==）\"></a>相等运算符  （==）</h3><p>如果某个类在逻辑上有相等性的含义，则该类应该定义operator == ，这样做可以使得用户更容易使用标准库算法来处理这个类。</p>\n<h3 id=\"关系运算符-（-lt-）\"><a href=\"#关系运算符-（-lt-）\" class=\"headerlink\" title=\"关系运算符 （&lt;）\"></a>关系运算符 （&lt;）</h3><p>定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较有用。</p>\n<p>通常情况下关系运算符应该</p>\n<ul>\n<li>定义顺序关系，令其与关联容器中对关键字的要求一致。</li>\n<li>如果类同时也包含==运算符的话，则定义一种关系令其与 ==保持一致。特别是，如果两个对象是!=的，那么一个对象应该&lt;另外一个。</li>\n</ul>\n<p><strong>注意：</strong> 如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和 ==产生的结果一致时才定义 &lt;运算符。</p>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数</p>\n<h3 id=\"复合赋值运算符\"><a href=\"#复合赋值运算符\" class=\"headerlink\" title=\"复合赋值运算符\"></a>复合赋值运算符</h3><p><strong>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//作为成员的二元运算符：左侧运算对象绑定到隐式的this指针</span></div><div class=\"line\"><span class=\"comment\">//假定两个对象表示的是同一本书</span></div><div class=\"line\">Sales_data&amp; Sales_data::<span class=\"keyword\">operator</span>+= (<span class=\"keyword\">const</span> Sales_data &amp;rhs)&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.units_sole += rhs.units_sole;</div><div class=\"line\">    <span class=\"keyword\">this</span>.revenue += rhs.revenue;</div><div class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"下标运算符\"><a href=\"#下标运算符\" class=\"headerlink\" title=\"下标运算符\"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p>\n<p><strong>note: 下标运算符必须是成员函数。</strong></p>\n<p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。<strong>进一步，我们最好定义下标运算符的常量版本和非常量版本，当作用与一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值</strong>。</p>\n<p>定义StrVec的下标运算符：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrVec</span> &#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> n) &#123;<span class=\"keyword\">return</span> elements[n];&#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">size_t</span> n) <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> elements[n];&#125;</div><div class=\"line\">    <span class=\"comment\">//其他成员定义</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">string</span> *element;         <span class=\"comment\">//指向数组首元素的指针</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 假设svec是一个StrVec对象</span></div><div class=\"line\"><span class=\"keyword\">const</span> StrVec cvec = svec;      <span class=\"comment\">//把svec的元素拷贝到cvec中</span></div><div class=\"line\"><span class=\"comment\">//如果svec中含有元素，对第一个元素运行string的empty函数</span></div><div class=\"line\"><span class=\"keyword\">if</span>(svec.size() &amp;&amp; svec[<span class=\"number\">0</span>].empty()) &#123;</div><div class=\"line\">    svec[<span class=\"number\">0</span>] = <span class=\"string\">\"zero\"</span>;      <span class=\"comment\">//正确:下标运算符返回string的引用</span></div><div class=\"line\">    cvec[<span class=\"number\">0</span>] = <span class=\"string\">\"zip\"</span>;       <span class=\"comment\">//错误：对cvec取下标返回的是常量引用，不能再赋值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"递增和递减运算符-（重点）\"><a href=\"#递增和递减运算符-（重点）\" class=\"headerlink\" title=\"递增和递减运算符 （重点）\"></a>递增和递减运算符 （重点）</h2><p>C++语言并不要求递增和递减运算符必须是类的成员，<strong>但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。</strong></p>\n<p><strong>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类成员。</strong></p>\n<h3 id=\"定义前置递增-递减运算符\"><a href=\"#定义前置递增-递减运算符\" class=\"headerlink\" title=\"定义前置递增/递减运算符\"></a>定义前置递增/递减运算符</h3><p>与内置版本保持一致，<strong>前置运算符应该返回递增或递减后对象的引用。 </strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer&amp; <span class=\"keyword\">operator</span>++()&#123; ++value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;    <span class=\"comment\">//前置运算符</span></div></pre></td></tr></table></figure>\n<h3 id=\"后置运算符\"><a href=\"#后置运算符\" class=\"headerlink\" title=\"后置运算符\"></a>后置运算符</h3><p>后置版本接受一个额外的（不被使用）int类型的形参，因为我们不会用到int形参，所以无须为其命令。</p>\n<p>为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>) &#123;   <span class=\"comment\">//后置运算符</span></div><div class=\"line\">    Integer ret = *<span class=\"keyword\">this</span>; </div><div class=\"line\">    ++value; </div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"显示调用后置运算符\"><a href=\"#显示调用后置运算符\" class=\"headerlink\" title=\"显示调用后置运算符\"></a>显示调用后置运算符</h3><p>通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer INT;</div><div class=\"line\">INT.<span class=\"keyword\">operator</span>++(<span class=\"number\">0</span>);   <span class=\"comment\">//调用后置版本的operator++</span></div><div class=\"line\">INT.<span class=\"keyword\">operator</span>++();    <span class=\"comment\">//调用前置版本的operator++</span></div></pre></td></tr></table></figure>\n<p>完整代码实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Integer</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Integer(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>):value(a)&#123;&#125;    <span class=\"comment\">//默认值参数，如果不提供参数，调用默认构造函数，提供参数则调用构造函数</span></div><div class=\"line\">    Integer(<span class=\"keyword\">const</span> Integer&amp; Int):value(Int.value)&#123;&#125;   <span class=\"comment\">//拷贝构造函数</span></div><div class=\"line\">    Integer&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Integer &amp;Int) &#123; value = Int.value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;  <span class=\"comment\">//拷贝赋值运算符</span></div><div class=\"line\">    Integer&amp; <span class=\"keyword\">operator</span>++()&#123; ++value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;    <span class=\"comment\">//前置运算符</span></div><div class=\"line\">    Integer <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>) &#123; Integer ret = *<span class=\"keyword\">this</span>; ++value; <span class=\"keyword\">return</span> ret;&#125;  <span class=\"comment\">//后置运算符</span></div><div class=\"line\">    <span class=\"keyword\">int</span> value;   <span class=\"comment\">//含有一个数据类型</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    Integer a;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    a.value = <span class=\"number\">10</span>;</div><div class=\"line\">    <span class=\"function\">Integer <span class=\"title\">b</span><span class=\"params\">(a)</span></span>;   <span class=\"comment\">//调用拷贝构造函数</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;b.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    Integer c;</div><div class=\"line\">    c = a;    <span class=\"comment\">//调用拷贝赋值运算符</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    ++c;   <span class=\"comment\">//调用重载前置运算符</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(c++).value&lt;&lt;<span class=\"built_in\">endl</span>;   <span class=\"comment\">//调用重载后置运算符</span></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;c.value&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"函数模版和类模板","date":"2017-12-01T02:59:00.000Z","update":null,"comments":1,"_content":"\n## 前言\n\n面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。\n\n<!--more-->\n\n本书第Ⅱ部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。\n\n例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。\n\n模版是泛型编程的基础。我们不必了解模版是如何定义的就能使用它们，实际上我们已经这样用了。\n\n**模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。** \n\n## 定义模版\n\n### 函数模板\n\n我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：\n\n```C++\ntemplate <typename T>\nint compare(const T &v1,const T &v2){\n    if(v1<v2) return -1;\n    if(v2<v1) return 1;\n    return 0;\n}\n```\n\n模版定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（<）和大于号（>）包围起来。\n\n**note: 在模板定义中，模板参数列表不能为空。**\n\n模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。\n\nT表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。\n\n#### 实例化函数模板\n\n当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用参数的类型来确定绑定到模板参数T的类型。\n\n```C++\ncout << compare(1,0) <<endl;    //T为int\n```\n\n实参类型是int。编译器会推断出模板参数为int，并将它绑定到模板参数T。\n\n编译器用推断出的模板参数来为我们**实例化**（instantiate）一个特定版本的函数。\n\n如上调用将实例化：\n\n```C++\n//实例化出 int compare(const int&, const int&) { ...; }\ncout << compare(1,0) <<endl;    //T为int\n```\n\n#### 模板类型参数\n\n一般来说，我们可以将模板类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：\n\n```C++\n//正确：返回类型和参数类型相同\ntemplate <typename T> \nT foo(T *p){\n    T tem = *p;\n    //...\n    return temp;\n}\n```\n\n类型参数前必须使用关键字typename 或 class\n\n```C++\n//错误：U之前必须加上class或typename\ntemplate <typename T,U>\n//正确：在模板参数列表中，typename和class没有什么不同\ntemplate<typename T, class U>\n```\n\ntypename是在模板已经广泛使用之后才引入C++语言的，推荐使用。\n\n#### 非类型模板参数\n\n除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。\n\n当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。\n\n例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char 的数组。由于我们不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度：\n\n```C++\ntemplate<unsigned N,unsigned M>\nint compare(const char (&p1)[N], const char (&p2)[M]){\n    return strcmp(p1,p2);\n}\n```\n\n当我们调用这个版本的compare时：\n\n```C++\ncompare(\"hi\",\"mom\")\n```\n\n编译器会实例化出如下版本：\n\n```C++\nint compare(const char (&p1)[3], const char (&p2)[4])\n```\n\n在模板定义内，模板非类型参数时一个常量值。在需要常量表达式的地方，可以使用非类型参数。\n\n**note: 非类型模板参数的模板实参必须是常量表达式。**\n\n#### inline 和 constexpr的函数模板\n\n函数模板可以声明为inline或constexpr的，如同非模板函数一样。**inline或constexpr说明符放在模板参数之后，返回类型之前。**\n\n```C++\n//正确：inline说明符跟在模板参数列表之后\ntemplate <typename T> inline T min(const T&,const T&);\n```\n\n#### 编写类型无关的代码\n\n我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：\n\n- 模板中的函数参数是const的引用。\n- 函数体中的条件判断仅使用<比较运算。\n\n大多数类型都允许拷贝，但是，不允许拷贝的类类型也是存在的。通过设置为引用，保证这写类型可以处理。而且，当处理大对象时，这种设计策略还能使函数运行得更快。\n\n**注意： 模板程序应该尽量减少对实参类型的要求。**\n\n#### 模板编译\n\n当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。\n\n**note: 函数模板和雷模板成员函数的定义通常放在头文件中**。\n\n<font color=red > **警告：保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。** </font>\n\n示例：定义自己版本的begin和end，同时编写一个constexpr模板，返回给定数组的大小\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// the same as std::begin\ntemplate<typename T, unsigned size>\nT* begin_def(T(&arr)[size]){   //arr数组的引用\n    return arr;\n}\n// the same as std::end\ntemplate<typename T, unsigned size>\nT* end_def(T(&arr)[size]){\n    //We usually don't use a function name which is the same as the function of standard libary\n    //This should not be const\n    return arr + size;\n}\ntemplate<typename T,unsigned size>\nconstexpr unsigned getSize(const T(&arr)[size]){\n    return size;\n}\n\nint main()\n{\n    string s[] = { \"sssss\",\"ss\",\"ss\",\"ssssszzzz\" };\n    cout << *(begin_def(s)) << endl;\n    cout << *(end_def(s) - 1) << endl;\n    string s1[] = { \"sss\" };\n    cout << getSize(s1) << endl;    //1\n    char c[] = \"s\";\n    cout << getSize(c) << endl;    //2\n    return 0;\n}\n```\n\n### 类模板\n\n**类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息----用来代替模板参数的模板实参列表。**\n\n#### 定义类模板\n\n类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。\n\n#### 实例化类模板\n\n一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。\n\n#### 类模板的成员函数\n\n类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，**定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。**\n\n对应的Blob的成员应该是这样的：\n\n```C++\ntemplate <typename T>\nret-type Blob<T>::member-name(parm-list)\n```\n\n#### 类模板成员函数的实例化\n\n默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。\n\n#### 在类代码内简化模板类名的使用\n\n当我们使用一个类模板类型时必须提供模板参数，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参\n\n#### 在类模板外使用类模板名\n\n当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。\n\n```C++\n//重载BlobPtr<T>模板类的后置递增运算符\ntemplate <typename T>\nBlobPtr<T> BlobPtr<T>::operator++(int) {   //类外，返回类型BlobPtr<T>\n    //类内，BlobPtr无须提供模板参数，写成 BlobPtr 等价 BlobPtr<T> ret = *this;\n    BlobPtr ret = *this;   \n    ++*this;\n    return ret;     //返回保存的类型\n}\n```\n\n类模板完整示例代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <memory>\nusing namespace std;\n\ntemplate <typename T>\nclass Blob{    //typedef int size;\npublic:\n    typedef T value_type;\n    typedef typename vector<T>::size_type size_type;\n    //构造函数\n    Blob();\n    Blob(initializer_list<T> i1);\n    //Blob中的元素数目\n    size_type size() const { return data->size(); }\n    bool empty() const { return data->empty(); }\n    //添加和删除元素\n    void push_back(const T &t) { data->push_back(t); }\n    //移动版本\n    void push_back(T &&t) { data->push_back(move(t)); }\n    void pop_back();\n    //元素访问\n    T& back();\n    T& operator[] (size_type i);\nprivate:\n    shared_ptr<vector<T>> data;\n    //若data[i]无效，则抛出msg\n    void check(size_type i,const string &msg) const;\n};\n\ntemplate <typename T>\nT& Blob<T>::back(){\n    check(0,\"subscript out of range\");\n    return data->back();\n}\n\ntemplate <typename T>\nT& Blob<T>::operator[](size_type i) {\n    check(i,\"subscript out of range\");\n    (*data)[i];\n}\n\ntemplate <typename T>\nvoid Blob<T>::pop_back(){\n    check(0,\"pop_back on empty Blob\");\n    data->pop_back();\n}\n\ntemplate <typename T>\nBlob<T>::Blob():data(make_shared<vector<T>>()) {}\n\ntemplate <typename T>\nBlob<T>::Blob(initializer_list<T> i1): data(make_shared<vector<T>>(i1)) {}\n\ntemplate <typename T>\nvoid Blob<T>::check(size_type i,const string &msg) const{\n    if(i>=data->size()) throw out_of_range(msg);\n}\nint main()\n{\n    Blob<int> ib = {1,2,3,4,5,6};\n    int back = ib.back();\n    cout<<back<<endl;\n    cout<<ib.size()<<endl;\n    return 0;\n}\n```\n\n\n**在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数。**\n\n#### 类模板和友元（暂时不看）\n\n#### 类模板的static成员\n\n与任何其他类相同，类模板可以声明static成员\n\n```C++\ntemplate <typename T>\nclass Foo{\npublic:\n    static size_t count() { return ctr; }\n    //其他接口成员\nprivate:\n    static size_t ctr;\n    //其他实现成员\n};\n```\n\n每个Foo的实例都有其自己的static成员实例。即，对于任意给定类型X，都有一个Foo<X>::ctr和一个Foo<X>::count成员。所有Foo<X>类型的对象共享相同的ctr对象和count对象。\n\n我们将static数据成员也定义为模板：\n\n```C++\ntemplate <typename T>\nsize_t Foo<T>::ctr = 0;  //定义并初始化ctr\n```\n\n访问类模板的static成员\n\n```C++\nFoo<int> fi;     //实例化Foo<int>类和static数据成员ctr\nauto ct = Foo<int>:count();       //实例化Foo<int>::count\nct = fi.count();        //使用Foo<int>::count\nct = Foo::count();       //错误：使用哪个模板实例的count?\n```\n\n类似于任何其他成员函数，一个static成员函数只有在使用时才会实例化。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/函数模版和类模板.md","raw":"---\ntitle: 函数模版和类模板\ndate: 2017-12-01 10:59:00\nupdate: \ntags: [模板]\ncategories: C++\ncomments: true\n---\n\n## 前言\n\n面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。\n\n<!--more-->\n\n本书第Ⅱ部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。\n\n例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。\n\n模版是泛型编程的基础。我们不必了解模版是如何定义的就能使用它们，实际上我们已经这样用了。\n\n**模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。** \n\n## 定义模版\n\n### 函数模板\n\n我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：\n\n```C++\ntemplate <typename T>\nint compare(const T &v1,const T &v2){\n    if(v1<v2) return -1;\n    if(v2<v1) return 1;\n    return 0;\n}\n```\n\n模版定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（<）和大于号（>）包围起来。\n\n**note: 在模板定义中，模板参数列表不能为空。**\n\n模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。\n\nT表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。\n\n#### 实例化函数模板\n\n当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用参数的类型来确定绑定到模板参数T的类型。\n\n```C++\ncout << compare(1,0) <<endl;    //T为int\n```\n\n实参类型是int。编译器会推断出模板参数为int，并将它绑定到模板参数T。\n\n编译器用推断出的模板参数来为我们**实例化**（instantiate）一个特定版本的函数。\n\n如上调用将实例化：\n\n```C++\n//实例化出 int compare(const int&, const int&) { ...; }\ncout << compare(1,0) <<endl;    //T为int\n```\n\n#### 模板类型参数\n\n一般来说，我们可以将模板类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：\n\n```C++\n//正确：返回类型和参数类型相同\ntemplate <typename T> \nT foo(T *p){\n    T tem = *p;\n    //...\n    return temp;\n}\n```\n\n类型参数前必须使用关键字typename 或 class\n\n```C++\n//错误：U之前必须加上class或typename\ntemplate <typename T,U>\n//正确：在模板参数列表中，typename和class没有什么不同\ntemplate<typename T, class U>\n```\n\ntypename是在模板已经广泛使用之后才引入C++语言的，推荐使用。\n\n#### 非类型模板参数\n\n除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。\n\n当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。\n\n例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char 的数组。由于我们不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度：\n\n```C++\ntemplate<unsigned N,unsigned M>\nint compare(const char (&p1)[N], const char (&p2)[M]){\n    return strcmp(p1,p2);\n}\n```\n\n当我们调用这个版本的compare时：\n\n```C++\ncompare(\"hi\",\"mom\")\n```\n\n编译器会实例化出如下版本：\n\n```C++\nint compare(const char (&p1)[3], const char (&p2)[4])\n```\n\n在模板定义内，模板非类型参数时一个常量值。在需要常量表达式的地方，可以使用非类型参数。\n\n**note: 非类型模板参数的模板实参必须是常量表达式。**\n\n#### inline 和 constexpr的函数模板\n\n函数模板可以声明为inline或constexpr的，如同非模板函数一样。**inline或constexpr说明符放在模板参数之后，返回类型之前。**\n\n```C++\n//正确：inline说明符跟在模板参数列表之后\ntemplate <typename T> inline T min(const T&,const T&);\n```\n\n#### 编写类型无关的代码\n\n我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：\n\n- 模板中的函数参数是const的引用。\n- 函数体中的条件判断仅使用<比较运算。\n\n大多数类型都允许拷贝，但是，不允许拷贝的类类型也是存在的。通过设置为引用，保证这写类型可以处理。而且，当处理大对象时，这种设计策略还能使函数运行得更快。\n\n**注意： 模板程序应该尽量减少对实参类型的要求。**\n\n#### 模板编译\n\n当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。\n\n**note: 函数模板和雷模板成员函数的定义通常放在头文件中**。\n\n<font color=red > **警告：保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。** </font>\n\n示例：定义自己版本的begin和end，同时编写一个constexpr模板，返回给定数组的大小\n\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// the same as std::begin\ntemplate<typename T, unsigned size>\nT* begin_def(T(&arr)[size]){   //arr数组的引用\n    return arr;\n}\n// the same as std::end\ntemplate<typename T, unsigned size>\nT* end_def(T(&arr)[size]){\n    //We usually don't use a function name which is the same as the function of standard libary\n    //This should not be const\n    return arr + size;\n}\ntemplate<typename T,unsigned size>\nconstexpr unsigned getSize(const T(&arr)[size]){\n    return size;\n}\n\nint main()\n{\n    string s[] = { \"sssss\",\"ss\",\"ss\",\"ssssszzzz\" };\n    cout << *(begin_def(s)) << endl;\n    cout << *(end_def(s) - 1) << endl;\n    string s1[] = { \"sss\" };\n    cout << getSize(s1) << endl;    //1\n    char c[] = \"s\";\n    cout << getSize(c) << endl;    //2\n    return 0;\n}\n```\n\n### 类模板\n\n**类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息----用来代替模板参数的模板实参列表。**\n\n#### 定义类模板\n\n类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。\n\n#### 实例化类模板\n\n一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。\n\n#### 类模板的成员函数\n\n类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，**定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。**\n\n对应的Blob的成员应该是这样的：\n\n```C++\ntemplate <typename T>\nret-type Blob<T>::member-name(parm-list)\n```\n\n#### 类模板成员函数的实例化\n\n默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。\n\n#### 在类代码内简化模板类名的使用\n\n当我们使用一个类模板类型时必须提供模板参数，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参\n\n#### 在类模板外使用类模板名\n\n当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。\n\n```C++\n//重载BlobPtr<T>模板类的后置递增运算符\ntemplate <typename T>\nBlobPtr<T> BlobPtr<T>::operator++(int) {   //类外，返回类型BlobPtr<T>\n    //类内，BlobPtr无须提供模板参数，写成 BlobPtr 等价 BlobPtr<T> ret = *this;\n    BlobPtr ret = *this;   \n    ++*this;\n    return ret;     //返回保存的类型\n}\n```\n\n类模板完整示例代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <memory>\nusing namespace std;\n\ntemplate <typename T>\nclass Blob{    //typedef int size;\npublic:\n    typedef T value_type;\n    typedef typename vector<T>::size_type size_type;\n    //构造函数\n    Blob();\n    Blob(initializer_list<T> i1);\n    //Blob中的元素数目\n    size_type size() const { return data->size(); }\n    bool empty() const { return data->empty(); }\n    //添加和删除元素\n    void push_back(const T &t) { data->push_back(t); }\n    //移动版本\n    void push_back(T &&t) { data->push_back(move(t)); }\n    void pop_back();\n    //元素访问\n    T& back();\n    T& operator[] (size_type i);\nprivate:\n    shared_ptr<vector<T>> data;\n    //若data[i]无效，则抛出msg\n    void check(size_type i,const string &msg) const;\n};\n\ntemplate <typename T>\nT& Blob<T>::back(){\n    check(0,\"subscript out of range\");\n    return data->back();\n}\n\ntemplate <typename T>\nT& Blob<T>::operator[](size_type i) {\n    check(i,\"subscript out of range\");\n    (*data)[i];\n}\n\ntemplate <typename T>\nvoid Blob<T>::pop_back(){\n    check(0,\"pop_back on empty Blob\");\n    data->pop_back();\n}\n\ntemplate <typename T>\nBlob<T>::Blob():data(make_shared<vector<T>>()) {}\n\ntemplate <typename T>\nBlob<T>::Blob(initializer_list<T> i1): data(make_shared<vector<T>>(i1)) {}\n\ntemplate <typename T>\nvoid Blob<T>::check(size_type i,const string &msg) const{\n    if(i>=data->size()) throw out_of_range(msg);\n}\nint main()\n{\n    Blob<int> ib = {1,2,3,4,5,6};\n    int back = ib.back();\n    cout<<back<<endl;\n    cout<<ib.size()<<endl;\n    return 0;\n}\n```\n\n\n**在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数。**\n\n#### 类模板和友元（暂时不看）\n\n#### 类模板的static成员\n\n与任何其他类相同，类模板可以声明static成员\n\n```C++\ntemplate <typename T>\nclass Foo{\npublic:\n    static size_t count() { return ctr; }\n    //其他接口成员\nprivate:\n    static size_t ctr;\n    //其他实现成员\n};\n```\n\n每个Foo的实例都有其自己的static成员实例。即，对于任意给定类型X，都有一个Foo<X>::ctr和一个Foo<X>::count成员。所有Foo<X>类型的对象共享相同的ctr对象和count对象。\n\n我们将static数据成员也定义为模板：\n\n```C++\ntemplate <typename T>\nsize_t Foo<T>::ctr = 0;  //定义并初始化ctr\n```\n\n访问类模板的static成员\n\n```C++\nFoo<int> fi;     //实例化Foo<int>类和static数据成员ctr\nauto ct = Foo<int>:count();       //实例化Foo<int>::count\nct = fi.count();        //使用Foo<int>::count\nct = Foo::count();       //错误：使用哪个模板实例的count?\n```\n\n类似于任何其他成员函数，一个static成员函数只有在使用时才会实例化。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"函数模版和类模板","published":1,"updated":"2018-02-23T07:21:59.655Z","layout":"post","photos":[],"link":"","_id":"cjdznieh40000h4c9bzv2pz5e","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p>\n<a id=\"more\"></a>\n<p>本书第Ⅱ部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。</p>\n<p>例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。</p>\n<p>模版是泛型编程的基础。我们不必了解模版是如何定义的就能使用它们，实际上我们已经这样用了。</p>\n<p><strong>模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。</strong> </p>\n<h2 id=\"定义模版\"><a href=\"#定义模版\" class=\"headerlink\" title=\"定义模版\"></a>定义模版</h2><h3 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h3><p>我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;v1,<span class=\"keyword\">const</span> T &amp;v2)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(v1&lt;v2) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(v2&lt;v1) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>模版定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p>\n<p><strong>note: 在模板定义中，模板参数列表不能为空。</strong></p>\n<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。</p>\n<p>T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。</p>\n<h4 id=\"实例化函数模板\"><a href=\"#实例化函数模板\" class=\"headerlink\" title=\"实例化函数模板\"></a>实例化函数模板</h4><p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用参数的类型来确定绑定到模板参数T的类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; compare(<span class=\"number\">1</span>,<span class=\"number\">0</span>) &lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//T为int</span></div></pre></td></tr></table></figure>\n<p>实参类型是int。编译器会推断出模板参数为int，并将它绑定到模板参数T。</p>\n<p>编译器用推断出的模板参数来为我们<strong>实例化</strong>（instantiate）一个特定版本的函数。</p>\n<p>如上调用将实例化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//实例化出 int compare(const int&amp;, const int&amp;) &#123; ...; &#125;</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; compare(<span class=\"number\">1</span>,<span class=\"number\">0</span>) &lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//T为int</span></div></pre></td></tr></table></figure>\n<h4 id=\"模板类型参数\"><a href=\"#模板类型参数\" class=\"headerlink\" title=\"模板类型参数\"></a>模板类型参数</h4><p>一般来说，我们可以将模板类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//正确：返回类型和参数类型相同</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </div><div class=\"line\"><span class=\"function\">T <span class=\"title\">foo</span><span class=\"params\">(T *p)</span></span>&#123;</div><div class=\"line\">    T tem = *p;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型参数前必须使用关键字typename 或 class</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：U之前必须加上class或typename</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T,U&gt;</div><div class=\"line\"><span class=\"comment\">//正确：在模板参数列表中，typename和class没有什么不同</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">U</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>typename是在模板已经广泛使用之后才引入C++语言的，推荐使用。</p>\n<h4 id=\"非类型模板参数\"><a href=\"#非类型模板参数\" class=\"headerlink\" title=\"非类型模板参数\"></a>非类型模板参数</h4><p>除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。</p>\n<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>\n<p>例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char 的数组。由于我们不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">unsigned</span> N,<span class=\"keyword\">unsigned</span> M&gt;</div><div class=\"line\">int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(p1,p2);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当我们调用这个版本的compare时：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">compare(<span class=\"string\">\"hi\"</span>,<span class=\"string\">\"mom\"</span>)</div></pre></td></tr></table></figure>\n<p>编译器会实例化出如下版本：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</div></pre></td></tr></table></figure>\n<p>在模板定义内，模板非类型参数时一个常量值。在需要常量表达式的地方，可以使用非类型参数。</p>\n<p><strong>note: 非类型模板参数的模板实参必须是常量表达式。</strong></p>\n<h4 id=\"inline-和-constexpr的函数模板\"><a href=\"#inline-和-constexpr的函数模板\" class=\"headerlink\" title=\"inline 和 constexpr的函数模板\"></a>inline 和 constexpr的函数模板</h4><p>函数模板可以声明为inline或constexpr的，如同非模板函数一样。<strong>inline或constexpr说明符放在模板参数之后，返回类型之前。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//正确：inline说明符跟在模板参数列表之后</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> T <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;,<span class=\"keyword\">const</span> T&amp;)</span></span>;</div></pre></td></tr></table></figure>\n<h4 id=\"编写类型无关的代码\"><a href=\"#编写类型无关的代码\" class=\"headerlink\" title=\"编写类型无关的代码\"></a>编写类型无关的代码</h4><p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：</p>\n<ul>\n<li>模板中的函数参数是const的引用。</li>\n<li>函数体中的条件判断仅使用&lt;比较运算。</li>\n</ul>\n<p>大多数类型都允许拷贝，但是，不允许拷贝的类类型也是存在的。通过设置为引用，保证这写类型可以处理。而且，当处理大对象时，这种设计策略还能使函数运行得更快。</p>\n<p><strong>注意： 模板程序应该尽量减少对实参类型的要求。</strong></p>\n<h4 id=\"模板编译\"><a href=\"#模板编译\" class=\"headerlink\" title=\"模板编译\"></a>模板编译</h4><p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。</p>\n<p><strong>note: 函数模板和雷模板成员函数的定义通常放在头文件中</strong>。</p>\n<font color=\"red\"> <strong>警告：保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。</strong> </font>\n\n<p>示例：定义自己版本的begin和end，同时编写一个constexpr模板，返回给定数组的大小</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// the same as std::begin</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">unsigned</span> size&gt;</div><div class=\"line\">T* begin_def(T(&amp;arr)[size])&#123;   //arr数组的引用</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// the same as std::end</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">unsigned</span> size&gt;</div><div class=\"line\">T* end_def(T(&amp;arr)[size])&#123;</div><div class=\"line\">    <span class=\"comment\">//We usually don't use a function name which is the same as the function of standard libary</span></div><div class=\"line\">    <span class=\"comment\">//This should not be const</span></div><div class=\"line\">    <span class=\"keyword\">return</span> arr + size;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T,<span class=\"keyword\">unsigned</span> size&gt;</div><div class=\"line\">constexpr unsigned getSize(const T(&amp;arr)[size])&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> size;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> s[] = &#123; <span class=\"string\">\"sssss\"</span>,<span class=\"string\">\"ss\"</span>,<span class=\"string\">\"ss\"</span>,<span class=\"string\">\"ssssszzzz\"</span> &#125;;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *(begin_def(s)) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *(end_def(s) - <span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s1[] = &#123; <span class=\"string\">\"sss\"</span> &#125;;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; getSize(s1) &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//1</span></div><div class=\"line\">    <span class=\"keyword\">char</span> c[] = <span class=\"string\">\"s\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; getSize(c) &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//2</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h3><p><strong>类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息—-用来代替模板参数的模板实参列表。</strong></p>\n<h4 id=\"定义类模板\"><a href=\"#定义类模板\" class=\"headerlink\" title=\"定义类模板\"></a>定义类模板</h4><p>类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。</p>\n<h4 id=\"实例化类模板\"><a href=\"#实例化类模板\" class=\"headerlink\" title=\"实例化类模板\"></a>实例化类模板</h4><p>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。</string></p>\n<h4 id=\"类模板的成员函数\"><a href=\"#类模板的成员函数\" class=\"headerlink\" title=\"类模板的成员函数\"></a>类模板的成员函数</h4><p>类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，<strong>定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</strong></p>\n<p>对应的Blob的成员应该是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">ret-type Blob&lt;T&gt;::member-name(parm-<span class=\"built_in\">list</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"类模板成员函数的实例化\"><a href=\"#类模板成员函数的实例化\" class=\"headerlink\" title=\"类模板成员函数的实例化\"></a>类模板成员函数的实例化</h4><p>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p>\n<h4 id=\"在类代码内简化模板类名的使用\"><a href=\"#在类代码内简化模板类名的使用\" class=\"headerlink\" title=\"在类代码内简化模板类名的使用\"></a>在类代码内简化模板类名的使用</h4><p>当我们使用一个类模板类型时必须提供模板参数，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参</p>\n<h4 id=\"在类模板外使用类模板名\"><a href=\"#在类模板外使用类模板名\" class=\"headerlink\" title=\"在类模板外使用类模板名\"></a>在类模板外使用类模板名</h4><p>当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//重载BlobPtr&lt;T&gt;模板类的后置递增运算符</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>) &#123;   <span class=\"comment\">//类外，返回类型BlobPtr&lt;T&gt;</span></div><div class=\"line\">    <span class=\"comment\">//类内，BlobPtr无须提供模板参数，写成 BlobPtr 等价 BlobPtr&lt;T&gt; ret = *this;</span></div><div class=\"line\">    BlobPtr ret = *<span class=\"keyword\">this</span>;   </div><div class=\"line\">    ++*<span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;     <span class=\"comment\">//返回保存的类型</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类模板完整示例代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blob</span>&#123;</span>    <span class=\"comment\">//typedef int size;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</div><div class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> <span class=\"built_in\">vector</span>&lt;T&gt;::size_type size_type;</div><div class=\"line\">    <span class=\"comment\">//构造函数</span></div><div class=\"line\">    Blob();</div><div class=\"line\">    Blob(<span class=\"built_in\">initializer_list</span>&lt;T&gt; i1);</div><div class=\"line\">    <span class=\"comment\">//Blob中的元素数目</span></div><div class=\"line\">    <span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;size(); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;empty(); &#125;</div><div class=\"line\">    <span class=\"comment\">//添加和删除元素</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class=\"line\">    <span class=\"comment\">//移动版本</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(T &amp;&amp;t)</span> </span>&#123; data-&gt;push_back(move(t)); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"comment\">//元素访问</span></div><div class=\"line\">    <span class=\"function\">T&amp; <span class=\"title\">back</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[] (size_type i);</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt; data;</div><div class=\"line\">    <span class=\"comment\">//若data[i]无效，则抛出msg</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i,<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">T&amp; Blob&lt;T&gt;::back()&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>,<span class=\"string\">\"subscript out of range\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">T&amp; Blob&lt;T&gt;::<span class=\"keyword\">operator</span>[](size_type i) &#123;</div><div class=\"line\">    check(i,<span class=\"string\">\"subscript out of range\"</span>);</div><div class=\"line\">    (*data)[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> Blob&lt;T&gt;::pop_back()&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>,<span class=\"string\">\"pop_back on empty Blob\"</span>);</div><div class=\"line\">    data-&gt;pop_back();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">Blob&lt;T&gt;::Blob():data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">Blob&lt;T&gt;::Blob(<span class=\"built_in\">initializer_list</span>&lt;T&gt; i1): data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt;(i1)) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> Blob&lt;T&gt;::check(size_type i,<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg) <span class=\"keyword\">const</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i&gt;=data-&gt;size()) <span class=\"keyword\">throw</span> out_of_range(msg);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    Blob&lt;<span class=\"keyword\">int</span>&gt; ib = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> back = ib.back();</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;back&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;ib.size()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数。</strong></p>\n<h4 id=\"类模板和友元（暂时不看）\"><a href=\"#类模板和友元（暂时不看）\" class=\"headerlink\" title=\"类模板和友元（暂时不看）\"></a>类模板和友元（暂时不看）</h4><h4 id=\"类模板的static成员\"><a href=\"#类模板的static成员\" class=\"headerlink\" title=\"类模板的static成员\"></a>类模板的static成员</h4><p>与任何其他类相同，类模板可以声明static成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> size_t <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> ctr; &#125;</div><div class=\"line\">    <span class=\"comment\">//其他接口成员</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> ctr;</div><div class=\"line\">    <span class=\"comment\">//其他实现成员</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>每个Foo的实例都有其自己的static成员实例。即，对于任意给定类型X，都有一个Foo<x>::ctr和一个Foo<x>::count成员。所有Foo<x>类型的对象共享相同的ctr对象和count对象。</x></x></x></p>\n<p>我们将static数据成员也定义为模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">size_t</span> Foo&lt;T&gt;::ctr = <span class=\"number\">0</span>;  <span class=\"comment\">//定义并初始化ctr</span></div></pre></td></tr></table></figure>\n<p>访问类模板的static成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foo&lt;<span class=\"keyword\">int</span>&gt; fi;     <span class=\"comment\">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></div><div class=\"line\"><span class=\"keyword\">auto</span> ct = Foo&lt;<span class=\"keyword\">int</span>&gt;:count();       <span class=\"comment\">//实例化Foo&lt;int&gt;::count</span></div><div class=\"line\">ct = fi.count();        <span class=\"comment\">//使用Foo&lt;int&gt;::count</span></div><div class=\"line\">ct = Foo::count();       <span class=\"comment\">//错误：使用哪个模板实例的count?</span></div></pre></td></tr></table></figure>\n<p>类似于任何其他成员函数，一个static成员函数只有在使用时才会实例化。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p>","more":"<p>本书第Ⅱ部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。</p>\n<p>例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。</p>\n<p>模版是泛型编程的基础。我们不必了解模版是如何定义的就能使用它们，实际上我们已经这样用了。</p>\n<p><strong>模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。</strong> </p>\n<h2 id=\"定义模版\"><a href=\"#定义模版\" class=\"headerlink\" title=\"定义模版\"></a>定义模版</h2><h3 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h3><p>我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;v1,<span class=\"keyword\">const</span> T &amp;v2)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(v1&lt;v2) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(v2&lt;v1) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>模版定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p>\n<p><strong>note: 在模板定义中，模板参数列表不能为空。</strong></p>\n<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。</p>\n<p>T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。</p>\n<h4 id=\"实例化函数模板\"><a href=\"#实例化函数模板\" class=\"headerlink\" title=\"实例化函数模板\"></a>实例化函数模板</h4><p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用参数的类型来确定绑定到模板参数T的类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; compare(<span class=\"number\">1</span>,<span class=\"number\">0</span>) &lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//T为int</span></div></pre></td></tr></table></figure>\n<p>实参类型是int。编译器会推断出模板参数为int，并将它绑定到模板参数T。</p>\n<p>编译器用推断出的模板参数来为我们<strong>实例化</strong>（instantiate）一个特定版本的函数。</p>\n<p>如上调用将实例化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//实例化出 int compare(const int&amp;, const int&amp;) &#123; ...; &#125;</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; compare(<span class=\"number\">1</span>,<span class=\"number\">0</span>) &lt;&lt;<span class=\"built_in\">endl</span>;    <span class=\"comment\">//T为int</span></div></pre></td></tr></table></figure>\n<h4 id=\"模板类型参数\"><a href=\"#模板类型参数\" class=\"headerlink\" title=\"模板类型参数\"></a>模板类型参数</h4><p>一般来说，我们可以将模板类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//正确：返回类型和参数类型相同</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; </div><div class=\"line\"><span class=\"function\">T <span class=\"title\">foo</span><span class=\"params\">(T *p)</span></span>&#123;</div><div class=\"line\">    T tem = *p;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类型参数前必须使用关键字typename 或 class</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：U之前必须加上class或typename</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T,U&gt;</div><div class=\"line\"><span class=\"comment\">//正确：在模板参数列表中，typename和class没有什么不同</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">U</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>typename是在模板已经广泛使用之后才引入C++语言的，推荐使用。</p>\n<h4 id=\"非类型模板参数\"><a href=\"#非类型模板参数\" class=\"headerlink\" title=\"非类型模板参数\"></a>非类型模板参数</h4><p>除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。</p>\n<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>\n<p>例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char 的数组。由于我们不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">unsigned</span> N,<span class=\"keyword\">unsigned</span> M&gt;</div><div class=\"line\">int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(p1,p2);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当我们调用这个版本的compare时：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">compare(<span class=\"string\">\"hi\"</span>,<span class=\"string\">\"mom\"</span>)</div></pre></td></tr></table></figure>\n<p>编译器会实例化出如下版本：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</div></pre></td></tr></table></figure>\n<p>在模板定义内，模板非类型参数时一个常量值。在需要常量表达式的地方，可以使用非类型参数。</p>\n<p><strong>note: 非类型模板参数的模板实参必须是常量表达式。</strong></p>\n<h4 id=\"inline-和-constexpr的函数模板\"><a href=\"#inline-和-constexpr的函数模板\" class=\"headerlink\" title=\"inline 和 constexpr的函数模板\"></a>inline 和 constexpr的函数模板</h4><p>函数模板可以声明为inline或constexpr的，如同非模板函数一样。<strong>inline或constexpr说明符放在模板参数之后，返回类型之前。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//正确：inline说明符跟在模板参数列表之后</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> T <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;,<span class=\"keyword\">const</span> T&amp;)</span></span>;</div></pre></td></tr></table></figure>\n<h4 id=\"编写类型无关的代码\"><a href=\"#编写类型无关的代码\" class=\"headerlink\" title=\"编写类型无关的代码\"></a>编写类型无关的代码</h4><p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：</p>\n<ul>\n<li>模板中的函数参数是const的引用。</li>\n<li>函数体中的条件判断仅使用&lt;比较运算。</li>\n</ul>\n<p>大多数类型都允许拷贝，但是，不允许拷贝的类类型也是存在的。通过设置为引用，保证这写类型可以处理。而且，当处理大对象时，这种设计策略还能使函数运行得更快。</p>\n<p><strong>注意： 模板程序应该尽量减少对实参类型的要求。</strong></p>\n<h4 id=\"模板编译\"><a href=\"#模板编译\" class=\"headerlink\" title=\"模板编译\"></a>模板编译</h4><p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。</p>\n<p><strong>note: 函数模板和雷模板成员函数的定义通常放在头文件中</strong>。</p>\n<font color=\"red\"> <strong>警告：保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。</strong> </font>\n\n<p>示例：定义自己版本的begin和end，同时编写一个constexpr模板，返回给定数组的大小</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// the same as std::begin</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">unsigned</span> size&gt;</div><div class=\"line\">T* begin_def(T(&amp;arr)[size])&#123;   //arr数组的引用</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// the same as std::end</span></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">unsigned</span> size&gt;</div><div class=\"line\">T* end_def(T(&amp;arr)[size])&#123;</div><div class=\"line\">    <span class=\"comment\">//We usually don't use a function name which is the same as the function of standard libary</span></div><div class=\"line\">    <span class=\"comment\">//This should not be const</span></div><div class=\"line\">    <span class=\"keyword\">return</span> arr + size;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T,<span class=\"keyword\">unsigned</span> size&gt;</div><div class=\"line\">constexpr unsigned getSize(const T(&amp;arr)[size])&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> size;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> s[] = &#123; <span class=\"string\">\"sssss\"</span>,<span class=\"string\">\"ss\"</span>,<span class=\"string\">\"ss\"</span>,<span class=\"string\">\"ssssszzzz\"</span> &#125;;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *(begin_def(s)) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; *(end_def(s) - <span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s1[] = &#123; <span class=\"string\">\"sss\"</span> &#125;;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; getSize(s1) &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//1</span></div><div class=\"line\">    <span class=\"keyword\">char</span> c[] = <span class=\"string\">\"s\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; getSize(c) &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//2</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h3><p><strong>类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息—-用来代替模板参数的模板实参列表。</strong></p>\n<h4 id=\"定义类模板\"><a href=\"#定义类模板\" class=\"headerlink\" title=\"定义类模板\"></a>定义类模板</h4><p>类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。</p>\n<h4 id=\"实例化类模板\"><a href=\"#实例化类模板\" class=\"headerlink\" title=\"实例化类模板\"></a>实例化类模板</h4><p>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。</string></p>\n<h4 id=\"类模板的成员函数\"><a href=\"#类模板的成员函数\" class=\"headerlink\" title=\"类模板的成员函数\"></a>类模板的成员函数</h4><p>类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，<strong>定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</strong></p>\n<p>对应的Blob的成员应该是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">ret-type Blob&lt;T&gt;::member-name(parm-<span class=\"built_in\">list</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"类模板成员函数的实例化\"><a href=\"#类模板成员函数的实例化\" class=\"headerlink\" title=\"类模板成员函数的实例化\"></a>类模板成员函数的实例化</h4><p>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p>\n<h4 id=\"在类代码内简化模板类名的使用\"><a href=\"#在类代码内简化模板类名的使用\" class=\"headerlink\" title=\"在类代码内简化模板类名的使用\"></a>在类代码内简化模板类名的使用</h4><p>当我们使用一个类模板类型时必须提供模板参数，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参</p>\n<h4 id=\"在类模板外使用类模板名\"><a href=\"#在类模板外使用类模板名\" class=\"headerlink\" title=\"在类模板外使用类模板名\"></a>在类模板外使用类模板名</h4><p>当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//重载BlobPtr&lt;T&gt;模板类的后置递增运算符</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>) &#123;   <span class=\"comment\">//类外，返回类型BlobPtr&lt;T&gt;</span></div><div class=\"line\">    <span class=\"comment\">//类内，BlobPtr无须提供模板参数，写成 BlobPtr 等价 BlobPtr&lt;T&gt; ret = *this;</span></div><div class=\"line\">    BlobPtr ret = *<span class=\"keyword\">this</span>;   </div><div class=\"line\">    ++*<span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;     <span class=\"comment\">//返回保存的类型</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类模板完整示例代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blob</span>&#123;</span>    <span class=\"comment\">//typedef int size;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</div><div class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> <span class=\"built_in\">vector</span>&lt;T&gt;::size_type size_type;</div><div class=\"line\">    <span class=\"comment\">//构造函数</span></div><div class=\"line\">    Blob();</div><div class=\"line\">    Blob(<span class=\"built_in\">initializer_list</span>&lt;T&gt; i1);</div><div class=\"line\">    <span class=\"comment\">//Blob中的元素数目</span></div><div class=\"line\">    <span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;size(); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> data-&gt;empty(); &#125;</div><div class=\"line\">    <span class=\"comment\">//添加和删除元素</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class=\"line\">    <span class=\"comment\">//移动版本</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(T &amp;&amp;t)</span> </span>&#123; data-&gt;push_back(move(t)); &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"comment\">//元素访问</span></div><div class=\"line\">    <span class=\"function\">T&amp; <span class=\"title\">back</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[] (size_type i);</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt; data;</div><div class=\"line\">    <span class=\"comment\">//若data[i]无效，则抛出msg</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i,<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">T&amp; Blob&lt;T&gt;::back()&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>,<span class=\"string\">\"subscript out of range\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> data-&gt;back();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">T&amp; Blob&lt;T&gt;::<span class=\"keyword\">operator</span>[](size_type i) &#123;</div><div class=\"line\">    check(i,<span class=\"string\">\"subscript out of range\"</span>);</div><div class=\"line\">    (*data)[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> Blob&lt;T&gt;::pop_back()&#123;</div><div class=\"line\">    check(<span class=\"number\">0</span>,<span class=\"string\">\"pop_back on empty Blob\"</span>);</div><div class=\"line\">    data-&gt;pop_back();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">Blob&lt;T&gt;::Blob():data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">Blob&lt;T&gt;::Blob(<span class=\"built_in\">initializer_list</span>&lt;T&gt; i1): data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt;(i1)) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> Blob&lt;T&gt;::check(size_type i,<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg) <span class=\"keyword\">const</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i&gt;=data-&gt;size()) <span class=\"keyword\">throw</span> out_of_range(msg);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    Blob&lt;<span class=\"keyword\">int</span>&gt; ib = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> back = ib.back();</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;back&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;ib.size()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数。</strong></p>\n<h4 id=\"类模板和友元（暂时不看）\"><a href=\"#类模板和友元（暂时不看）\" class=\"headerlink\" title=\"类模板和友元（暂时不看）\"></a>类模板和友元（暂时不看）</h4><h4 id=\"类模板的static成员\"><a href=\"#类模板的static成员\" class=\"headerlink\" title=\"类模板的static成员\"></a>类模板的static成员</h4><p>与任何其他类相同，类模板可以声明static成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> size_t <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> ctr; &#125;</div><div class=\"line\">    <span class=\"comment\">//其他接口成员</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> ctr;</div><div class=\"line\">    <span class=\"comment\">//其他实现成员</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>每个Foo的实例都有其自己的static成员实例。即，对于任意给定类型X，都有一个Foo<x>::ctr和一个Foo<x>::count成员。所有Foo<x>类型的对象共享相同的ctr对象和count对象。</x></x></x></p>\n<p>我们将static数据成员也定义为模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">size_t</span> Foo&lt;T&gt;::ctr = <span class=\"number\">0</span>;  <span class=\"comment\">//定义并初始化ctr</span></div></pre></td></tr></table></figure>\n<p>访问类模板的static成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foo&lt;<span class=\"keyword\">int</span>&gt; fi;     <span class=\"comment\">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></div><div class=\"line\"><span class=\"keyword\">auto</span> ct = Foo&lt;<span class=\"keyword\">int</span>&gt;:count();       <span class=\"comment\">//实例化Foo&lt;int&gt;::count</span></div><div class=\"line\">ct = fi.count();        <span class=\"comment\">//使用Foo&lt;int&gt;::count</span></div><div class=\"line\">ct = Foo::count();       <span class=\"comment\">//错误：使用哪个模板实例的count?</span></div></pre></td></tr></table></figure>\n<p>类似于任何其他成员函数，一个static成员函数只有在使用时才会实例化。</p>"},{"title":"多重继承与虚继承","date":"2017-12-04T02:59:00.000Z","update":null,"comments":1,"_content":"\n## 多重继承与虚继承\n\n**多重继承**（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。\n\n<!--more-->\n\n### 多重派生\n\n在派生类的派生列表中可以包含多个基类：\n\n```\nclass Bear : public ZooAnimal { /* ... */ };\nclass Panda : public Bear,public Endangered { /* ... */ };\n```\n\n**和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的**。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。\n\n#### 多重继承的派生类从每个基类中继承状态\n\n在多重继承关系中，派生类的对象包含有每个基类的子对象。在panda对象中含有Bear部分（其中又含有ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。\n\n![image](http://ou6yob3zd.bkt.clouddn.com/201712041506.png)\n\n#### 派生类构造函数初始化所有基类\n\n构造一个派生类的对象将同时构造并初始化它的所有基类子对象。但只能初始化它的直接基类：\n\n```C++\n//显式地初始化所有基类\nPanda::Panda(string name,bool onExhibit):Bear(name,onExhibit,\"Panda\"),Endangered(Endangered::critical) {}\n//隐式地使用Bear的默认构造函数初始化Bear子对象\nPanda::Panda():Endangered(Endangered::critical) {}\n```\n\n派生类的构造函数初始化列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类出现顺序一致，而与派生类构造函数初始值列表中基类的顺序无关。\n\n一个Panda对象按照如下词序进行初始化：\n\n- ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。\n- 接下来初始化Panda的第一个直接基类Bear。\n- 然后初始化Panda的第二个直接基类Endangered。\n- 最后初始化Panda。\n\n\n#### 继承的构造函数与多重继承\n\n在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：\n\n```C++\nstruct Base1{\n    Base1() default;\n    Base1(const string&);\n    Base1(shared_ptr<int>);\n};\nstruct Base2{\n    Base2() = default;\n    Base2(const string&);\n    Base2(int);\n}\n//错误：D1试图从两个基类中都继承D1::D1(const string&)\nstruct D1: public Base1,public Base2 {\n    using Base1::Base1;      //从Base1继承构造函数\n    using Base2::Base2;      //从Base2继承构造函数\n}\n```\n\n如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：\n\n```C++\nstruct D1: public Base1,public Base2 {\n    using Base1::Base1;      //从Base1继承构造函数\n    using Base2::Base2;      //从Base2继承构造函数\n    //D2必须自定义一个接受string的构造函数\n    D2(const string &s):Base1(s),Base2(s) {}\n    D2() = default;  //一旦定义了自己的构造函数，系统不提供默认构造函数\n}\n```\n\n#### 析构函数与多重继承\n\n和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。\n\n析构函数的调用顺序正好与构造函数相反。\n\n### 类型转换与多个基类\n\n我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。\n\n与只有一个基类的继承一样，**对象、指针或引用的静态类型决定了我们能够使用哪些成员。**\n如果我们使用一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered特有的部分都不可见。\n\n### 多重继承下的类作用域\n\n在只有一个基类的情况下，派生类的作用域嵌套在直接和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。\n\n在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。\n\n### 虚继承\n\n尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。\n\n在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。\n\n为避免产生多个子对象，在C++语言中我们通过**虚继承**（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为**虚基类**（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。\n\n**note: 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。**\n\n### 使用虚基类\n\n我们指定虚基类的方式是在派生列表中添加关键字virtual：\n\n```C++\n//关键字public和virtual的顺序随意\nclass Raccoon : public virtual ZooAnimal { /* ... */}\nclass Bear : virtual public ZooAnimal { /* ... */}\n```\n\n通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类\n\nvirtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。\n\n如果某个类指定了虚基类，则该类的派生仍按常规方式进行：\n\n```C++\nclass Panda : public Bear,public Raccoon,public Endangered{\n    //...\n};\n```\nPanda中只有一个ZooAnimal基类部分\n\n### 虚基类成员的可见性\n\n因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。\n\n与非虚的多重继承体系一样，**解决这种二义性问题最好的方法是在派生类中为成员自定义新的示例。**\n\n### 构造函数与虚继承\n\n**在虚派生中，虚基类是由最底层的派生类（也就是最最后面的派生类）初始化的。**，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。\n\n为了理解这一规则，我们不妨假设当以普通规则处理初始任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。\n\n当创建一个Bear（或Raccoon）的对象时，将直接初始化其ZooAnimal基类部分。\n\n当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal。\n\n```C++\nPanda::Panda(string name,bool onExhibit):ZooAnimal(name,onExhibit,\"Panda\"),\n                Bear(name,onExhibit),Raccoon(name,onExhibit),\n                Endangered(Endangered::critical),sleeping_flag(false) {}\n```\n\n### 虚继承的对象的构造方式\n\n含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。\n\n例如：当我们创建一个Panda对象时：\n- 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。\n- 接下来构造Bear部分\n- 然后构造Raccoon部分\n- 然后构造第三个直接基类Endangered\n- 最后构造Panda部分\n\n如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。\n\n**note: 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。**\n\n### 构造函数与析构函数的次序\n\n一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类：\n\n```C++\nclass Character { ...};\nclass BookCharacter : public Character { ...};\nclass ToyAnimal { ...};\nclass TeddyBear : public BookCharacter,public Bear,public virtual ToyAnimal {...};\n```\n\n编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，创建一个TeddyBear对象，需要按照如下次序调用这些构造函数：\n\n```\nZooAnimal();      //Bear的虚基类\nToyAnimal();      //直接虚基类\nCharacter();      //第一个非虚基类的间接基类\nBookCharacter();     //第一个直接非虚基类\nBear();           //第二个直接非虚基类\nTeddyBear();      //最低层的派生类\n```\n\n合成的拷贝和移动构造函数按照完成相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后ZooAnimal部分。\n","source":"_posts/多重继承与虚继承.md","raw":"---\ntitle: 多重继承与虚继承\ndate: 2017-12-04 10:59:00\nupdate: \ntags: [虚继承]\ncategories: C++\ncomments: true\n---\n\n## 多重继承与虚继承\n\n**多重继承**（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。\n\n<!--more-->\n\n### 多重派生\n\n在派生类的派生列表中可以包含多个基类：\n\n```\nclass Bear : public ZooAnimal { /* ... */ };\nclass Panda : public Bear,public Endangered { /* ... */ };\n```\n\n**和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的**。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。\n\n#### 多重继承的派生类从每个基类中继承状态\n\n在多重继承关系中，派生类的对象包含有每个基类的子对象。在panda对象中含有Bear部分（其中又含有ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。\n\n![image](http://ou6yob3zd.bkt.clouddn.com/201712041506.png)\n\n#### 派生类构造函数初始化所有基类\n\n构造一个派生类的对象将同时构造并初始化它的所有基类子对象。但只能初始化它的直接基类：\n\n```C++\n//显式地初始化所有基类\nPanda::Panda(string name,bool onExhibit):Bear(name,onExhibit,\"Panda\"),Endangered(Endangered::critical) {}\n//隐式地使用Bear的默认构造函数初始化Bear子对象\nPanda::Panda():Endangered(Endangered::critical) {}\n```\n\n派生类的构造函数初始化列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类出现顺序一致，而与派生类构造函数初始值列表中基类的顺序无关。\n\n一个Panda对象按照如下词序进行初始化：\n\n- ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。\n- 接下来初始化Panda的第一个直接基类Bear。\n- 然后初始化Panda的第二个直接基类Endangered。\n- 最后初始化Panda。\n\n\n#### 继承的构造函数与多重继承\n\n在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：\n\n```C++\nstruct Base1{\n    Base1() default;\n    Base1(const string&);\n    Base1(shared_ptr<int>);\n};\nstruct Base2{\n    Base2() = default;\n    Base2(const string&);\n    Base2(int);\n}\n//错误：D1试图从两个基类中都继承D1::D1(const string&)\nstruct D1: public Base1,public Base2 {\n    using Base1::Base1;      //从Base1继承构造函数\n    using Base2::Base2;      //从Base2继承构造函数\n}\n```\n\n如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：\n\n```C++\nstruct D1: public Base1,public Base2 {\n    using Base1::Base1;      //从Base1继承构造函数\n    using Base2::Base2;      //从Base2继承构造函数\n    //D2必须自定义一个接受string的构造函数\n    D2(const string &s):Base1(s),Base2(s) {}\n    D2() = default;  //一旦定义了自己的构造函数，系统不提供默认构造函数\n}\n```\n\n#### 析构函数与多重继承\n\n和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。\n\n析构函数的调用顺序正好与构造函数相反。\n\n### 类型转换与多个基类\n\n我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。\n\n与只有一个基类的继承一样，**对象、指针或引用的静态类型决定了我们能够使用哪些成员。**\n如果我们使用一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered特有的部分都不可见。\n\n### 多重继承下的类作用域\n\n在只有一个基类的情况下，派生类的作用域嵌套在直接和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。\n\n在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。\n\n### 虚继承\n\n尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。\n\n在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。\n\n为避免产生多个子对象，在C++语言中我们通过**虚继承**（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为**虚基类**（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。\n\n**note: 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。**\n\n### 使用虚基类\n\n我们指定虚基类的方式是在派生列表中添加关键字virtual：\n\n```C++\n//关键字public和virtual的顺序随意\nclass Raccoon : public virtual ZooAnimal { /* ... */}\nclass Bear : virtual public ZooAnimal { /* ... */}\n```\n\n通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类\n\nvirtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。\n\n如果某个类指定了虚基类，则该类的派生仍按常规方式进行：\n\n```C++\nclass Panda : public Bear,public Raccoon,public Endangered{\n    //...\n};\n```\nPanda中只有一个ZooAnimal基类部分\n\n### 虚基类成员的可见性\n\n因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。\n\n与非虚的多重继承体系一样，**解决这种二义性问题最好的方法是在派生类中为成员自定义新的示例。**\n\n### 构造函数与虚继承\n\n**在虚派生中，虚基类是由最底层的派生类（也就是最最后面的派生类）初始化的。**，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。\n\n为了理解这一规则，我们不妨假设当以普通规则处理初始任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。\n\n当创建一个Bear（或Raccoon）的对象时，将直接初始化其ZooAnimal基类部分。\n\n当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal。\n\n```C++\nPanda::Panda(string name,bool onExhibit):ZooAnimal(name,onExhibit,\"Panda\"),\n                Bear(name,onExhibit),Raccoon(name,onExhibit),\n                Endangered(Endangered::critical),sleeping_flag(false) {}\n```\n\n### 虚继承的对象的构造方式\n\n含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。\n\n例如：当我们创建一个Panda对象时：\n- 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。\n- 接下来构造Bear部分\n- 然后构造Raccoon部分\n- 然后构造第三个直接基类Endangered\n- 最后构造Panda部分\n\n如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。\n\n**note: 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。**\n\n### 构造函数与析构函数的次序\n\n一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类：\n\n```C++\nclass Character { ...};\nclass BookCharacter : public Character { ...};\nclass ToyAnimal { ...};\nclass TeddyBear : public BookCharacter,public Bear,public virtual ToyAnimal {...};\n```\n\n编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，创建一个TeddyBear对象，需要按照如下次序调用这些构造函数：\n\n```\nZooAnimal();      //Bear的虚基类\nToyAnimal();      //直接虚基类\nCharacter();      //第一个非虚基类的间接基类\nBookCharacter();     //第一个直接非虚基类\nBear();           //第二个直接非虚基类\nTeddyBear();      //最低层的派生类\n```\n\n合成的拷贝和移动构造函数按照完成相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后ZooAnimal部分。\n","slug":"多重继承与虚继承","published":1,"updated":"2018-02-23T08:00:41.355Z","layout":"post","photos":[],"link":"","_id":"cjdzniehg0001h4c98czz6779","content":"<h2 id=\"多重继承与虚继承\"><a href=\"#多重继承与虚继承\" class=\"headerlink\" title=\"多重继承与虚继承\"></a>多重继承与虚继承</h2><p><strong>多重继承</strong>（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</p>\n<a id=\"more\"></a>\n<h3 id=\"多重派生\"><a href=\"#多重派生\" class=\"headerlink\" title=\"多重派生\"></a>多重派生</h3><p>在派生类的派生列表中可以包含多个基类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Bear : public ZooAnimal &#123; /* ... */ &#125;;</div><div class=\"line\">class Panda : public Bear,public Endangered &#123; /* ... */ &#125;;</div></pre></td></tr></table></figure>\n<p><strong>和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的</strong>。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。</p>\n<h4 id=\"多重继承的派生类从每个基类中继承状态\"><a href=\"#多重继承的派生类从每个基类中继承状态\" class=\"headerlink\" title=\"多重继承的派生类从每个基类中继承状态\"></a>多重继承的派生类从每个基类中继承状态</h4><p>在多重继承关系中，派生类的对象包含有每个基类的子对象。在panda对象中含有Bear部分（其中又含有ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/201712041506.png\" alt=\"image\"></p>\n<h4 id=\"派生类构造函数初始化所有基类\"><a href=\"#派生类构造函数初始化所有基类\" class=\"headerlink\" title=\"派生类构造函数初始化所有基类\"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象。但只能初始化它的直接基类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//显式地初始化所有基类</span></div><div class=\"line\">Panda::Panda(<span class=\"built_in\">string</span> name,<span class=\"keyword\">bool</span> onExhibit):Bear(name,onExhibit,<span class=\"string\">\"Panda\"</span>),Endangered(Endangered::critical) &#123;&#125;</div><div class=\"line\"><span class=\"comment\">//隐式地使用Bear的默认构造函数初始化Bear子对象</span></div><div class=\"line\">Panda::Panda():Endangered(Endangered::critical) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>派生类的构造函数初始化列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类出现顺序一致，而与派生类构造函数初始值列表中基类的顺序无关。</p>\n<p>一个Panda对象按照如下词序进行初始化：</p>\n<ul>\n<li>ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。</li>\n<li>接下来初始化Panda的第一个直接基类Bear。</li>\n<li>然后初始化Panda的第二个直接基类Endangered。</li>\n<li>最后初始化Panda。</li>\n</ul>\n<h4 id=\"继承的构造函数与多重继承\"><a href=\"#继承的构造函数与多重继承\" class=\"headerlink\" title=\"继承的构造函数与多重继承\"></a>继承的构造函数与多重继承</h4><p>在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base1</span>&#123;</span></div><div class=\"line\">    Base1() <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base1(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;);</div><div class=\"line\">    Base1(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt;);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base2</span>&#123;</span></div><div class=\"line\">    Base2() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base2(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;);</div><div class=\"line\">    Base2(<span class=\"keyword\">int</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//错误：D1试图从两个基类中都继承D1::D1(const string&amp;)</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base1,<span class=\"keyword\">public</span> Base2 &#123;</div><div class=\"line\">    <span class=\"keyword\">using</span> Base1::Base1;      <span class=\"comment\">//从Base1继承构造函数</span></div><div class=\"line\">    <span class=\"keyword\">using</span> Base2::Base2;      <span class=\"comment\">//从Base2继承构造函数</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base1,<span class=\"keyword\">public</span> Base2 &#123;</div><div class=\"line\">    <span class=\"keyword\">using</span> Base1::Base1;      <span class=\"comment\">//从Base1继承构造函数</span></div><div class=\"line\">    <span class=\"keyword\">using</span> Base2::Base2;      <span class=\"comment\">//从Base2继承构造函数</span></div><div class=\"line\">    <span class=\"comment\">//D2必须自定义一个接受string的构造函数</span></div><div class=\"line\">    D2(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s):Base1(s),Base2(s) &#123;&#125;</div><div class=\"line\">    D2() = <span class=\"keyword\">default</span>;  <span class=\"comment\">//一旦定义了自己的构造函数，系统不提供默认构造函数</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"析构函数与多重继承\"><a href=\"#析构函数与多重继承\" class=\"headerlink\" title=\"析构函数与多重继承\"></a>析构函数与多重继承</h4><p>和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</p>\n<p>析构函数的调用顺序正好与构造函数相反。</p>\n<h3 id=\"类型转换与多个基类\"><a href=\"#类型转换与多个基类\" class=\"headerlink\" title=\"类型转换与多个基类\"></a>类型转换与多个基类</h3><p>我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。</p>\n<p>与只有一个基类的继承一样，<strong>对象、指针或引用的静态类型决定了我们能够使用哪些成员。</strong><br>如果我们使用一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered特有的部分都不可见。</p>\n<h3 id=\"多重继承下的类作用域\"><a href=\"#多重继承下的类作用域\" class=\"headerlink\" title=\"多重继承下的类作用域\"></a>多重继承下的类作用域</h3><p>在只有一个基类的情况下，派生类的作用域嵌套在直接和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。</p>\n<p>在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。</p>\n<h3 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。</p>\n<p>在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。</p>\n<p>为避免产生多个子对象，在C++语言中我们通过<strong>虚继承</strong>（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为<strong>虚基类</strong>（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</p>\n<p><strong>note: 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</strong></p>\n<h3 id=\"使用虚基类\"><a href=\"#使用虚基类\" class=\"headerlink\" title=\"使用虚基类\"></a>使用虚基类</h3><p>我们指定虚基类的方式是在派生列表中添加关键字virtual：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//关键字public和virtual的顺序随意</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Raccoon</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ZooAnimal &#123; <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bear</span> :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> ZooAnimal &#123; <span class=\"comment\">/* ... */</span>&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类</p>\n<p>virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。</p>\n<p>如果某个类指定了虚基类，则该类的派生仍按常规方式进行：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Panda</span> :</span> <span class=\"keyword\">public</span> Bear,<span class=\"keyword\">public</span> Raccoon,<span class=\"keyword\">public</span> Endangered&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Panda中只有一个ZooAnimal基类部分</p>\n<h3 id=\"虚基类成员的可见性\"><a href=\"#虚基类成员的可见性\" class=\"headerlink\" title=\"虚基类成员的可见性\"></a>虚基类成员的可见性</h3><p>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。</p>\n<p>与非虚的多重继承体系一样，<strong>解决这种二义性问题最好的方法是在派生类中为成员自定义新的示例。</strong></p>\n<h3 id=\"构造函数与虚继承\"><a href=\"#构造函数与虚继承\" class=\"headerlink\" title=\"构造函数与虚继承\"></a>构造函数与虚继承</h3><p><strong>在虚派生中，虚基类是由最底层的派生类（也就是最最后面的派生类）初始化的。</strong>，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。</p>\n<p>为了理解这一规则，我们不妨假设当以普通规则处理初始任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。</p>\n<p>当创建一个Bear（或Raccoon）的对象时，将直接初始化其ZooAnimal基类部分。</p>\n<p>当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Panda::Panda(<span class=\"built_in\">string</span> name,<span class=\"keyword\">bool</span> onExhibit):ZooAnimal(name,onExhibit,<span class=\"string\">\"Panda\"</span>),</div><div class=\"line\">                Bear(name,onExhibit),Raccoon(name,onExhibit),</div><div class=\"line\">                Endangered(Endangered::critical),sleeping_flag(<span class=\"literal\">false</span>) &#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"虚继承的对象的构造方式\"><a href=\"#虚继承的对象的构造方式\" class=\"headerlink\" title=\"虚继承的对象的构造方式\"></a>虚继承的对象的构造方式</h3><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。</p>\n<p>例如：当我们创建一个Panda对象时：</p>\n<ul>\n<li>首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</li>\n<li>接下来构造Bear部分</li>\n<li>然后构造Raccoon部分</li>\n<li>然后构造第三个直接基类Endangered</li>\n<li>最后构造Panda部分</li>\n</ul>\n<p>如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。</p>\n<p><strong>note: 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</strong></p>\n<h3 id=\"构造函数与析构函数的次序\"><a href=\"#构造函数与析构函数的次序\" class=\"headerlink\" title=\"构造函数与析构函数的次序\"></a>构造函数与析构函数的次序</h3><p>一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Character</span> &#123;</span> ...&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookCharacter</span> :</span> <span class=\"keyword\">public</span> Character &#123; ...&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToyAnimal</span> &#123;</span> ...&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeddyBear</span> :</span> <span class=\"keyword\">public</span> BookCharacter,<span class=\"keyword\">public</span> Bear,<span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ToyAnimal &#123;...&#125;;</div></pre></td></tr></table></figure>\n<p>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，创建一个TeddyBear对象，需要按照如下次序调用这些构造函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZooAnimal();      //Bear的虚基类</div><div class=\"line\">ToyAnimal();      //直接虚基类</div><div class=\"line\">Character();      //第一个非虚基类的间接基类</div><div class=\"line\">BookCharacter();     //第一个直接非虚基类</div><div class=\"line\">Bear();           //第二个直接非虚基类</div><div class=\"line\">TeddyBear();      //最低层的派生类</div></pre></td></tr></table></figure>\n<p>合成的拷贝和移动构造函数按照完成相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后ZooAnimal部分。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"多重继承与虚继承\"><a href=\"#多重继承与虚继承\" class=\"headerlink\" title=\"多重继承与虚继承\"></a>多重继承与虚继承</h2><p><strong>多重继承</strong>（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</p>","more":"<h3 id=\"多重派生\"><a href=\"#多重派生\" class=\"headerlink\" title=\"多重派生\"></a>多重派生</h3><p>在派生类的派生列表中可以包含多个基类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Bear : public ZooAnimal &#123; /* ... */ &#125;;</div><div class=\"line\">class Panda : public Bear,public Endangered &#123; /* ... */ &#125;;</div></pre></td></tr></table></figure>\n<p><strong>和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的</strong>。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。</p>\n<h4 id=\"多重继承的派生类从每个基类中继承状态\"><a href=\"#多重继承的派生类从每个基类中继承状态\" class=\"headerlink\" title=\"多重继承的派生类从每个基类中继承状态\"></a>多重继承的派生类从每个基类中继承状态</h4><p>在多重继承关系中，派生类的对象包含有每个基类的子对象。在panda对象中含有Bear部分（其中又含有ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。</p>\n<p><img src=\"http://ou6yob3zd.bkt.clouddn.com/201712041506.png\" alt=\"image\"></p>\n<h4 id=\"派生类构造函数初始化所有基类\"><a href=\"#派生类构造函数初始化所有基类\" class=\"headerlink\" title=\"派生类构造函数初始化所有基类\"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象。但只能初始化它的直接基类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//显式地初始化所有基类</span></div><div class=\"line\">Panda::Panda(<span class=\"built_in\">string</span> name,<span class=\"keyword\">bool</span> onExhibit):Bear(name,onExhibit,<span class=\"string\">\"Panda\"</span>),Endangered(Endangered::critical) &#123;&#125;</div><div class=\"line\"><span class=\"comment\">//隐式地使用Bear的默认构造函数初始化Bear子对象</span></div><div class=\"line\">Panda::Panda():Endangered(Endangered::critical) &#123;&#125;</div></pre></td></tr></table></figure>\n<p>派生类的构造函数初始化列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类出现顺序一致，而与派生类构造函数初始值列表中基类的顺序无关。</p>\n<p>一个Panda对象按照如下词序进行初始化：</p>\n<ul>\n<li>ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。</li>\n<li>接下来初始化Panda的第一个直接基类Bear。</li>\n<li>然后初始化Panda的第二个直接基类Endangered。</li>\n<li>最后初始化Panda。</li>\n</ul>\n<h4 id=\"继承的构造函数与多重继承\"><a href=\"#继承的构造函数与多重继承\" class=\"headerlink\" title=\"继承的构造函数与多重继承\"></a>继承的构造函数与多重继承</h4><p>在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base1</span>&#123;</span></div><div class=\"line\">    Base1() <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base1(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;);</div><div class=\"line\">    Base1(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt;);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base2</span>&#123;</span></div><div class=\"line\">    Base2() = <span class=\"keyword\">default</span>;</div><div class=\"line\">    Base2(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;);</div><div class=\"line\">    Base2(<span class=\"keyword\">int</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//错误：D1试图从两个基类中都继承D1::D1(const string&amp;)</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base1,<span class=\"keyword\">public</span> Base2 &#123;</div><div class=\"line\">    <span class=\"keyword\">using</span> Base1::Base1;      <span class=\"comment\">//从Base1继承构造函数</span></div><div class=\"line\">    <span class=\"keyword\">using</span> Base2::Base2;      <span class=\"comment\">//从Base2继承构造函数</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base1,<span class=\"keyword\">public</span> Base2 &#123;</div><div class=\"line\">    <span class=\"keyword\">using</span> Base1::Base1;      <span class=\"comment\">//从Base1继承构造函数</span></div><div class=\"line\">    <span class=\"keyword\">using</span> Base2::Base2;      <span class=\"comment\">//从Base2继承构造函数</span></div><div class=\"line\">    <span class=\"comment\">//D2必须自定义一个接受string的构造函数</span></div><div class=\"line\">    D2(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;s):Base1(s),Base2(s) &#123;&#125;</div><div class=\"line\">    D2() = <span class=\"keyword\">default</span>;  <span class=\"comment\">//一旦定义了自己的构造函数，系统不提供默认构造函数</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"析构函数与多重继承\"><a href=\"#析构函数与多重继承\" class=\"headerlink\" title=\"析构函数与多重继承\"></a>析构函数与多重继承</h4><p>和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</p>\n<p>析构函数的调用顺序正好与构造函数相反。</p>\n<h3 id=\"类型转换与多个基类\"><a href=\"#类型转换与多个基类\" class=\"headerlink\" title=\"类型转换与多个基类\"></a>类型转换与多个基类</h3><p>我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。</p>\n<p>与只有一个基类的继承一样，<strong>对象、指针或引用的静态类型决定了我们能够使用哪些成员。</strong><br>如果我们使用一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered特有的部分都不可见。</p>\n<h3 id=\"多重继承下的类作用域\"><a href=\"#多重继承下的类作用域\" class=\"headerlink\" title=\"多重继承下的类作用域\"></a>多重继承下的类作用域</h3><p>在只有一个基类的情况下，派生类的作用域嵌套在直接和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。</p>\n<p>在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。</p>\n<h3 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。</p>\n<p>在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。</p>\n<p>为避免产生多个子对象，在C++语言中我们通过<strong>虚继承</strong>（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为<strong>虚基类</strong>（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</p>\n<p><strong>note: 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</strong></p>\n<h3 id=\"使用虚基类\"><a href=\"#使用虚基类\" class=\"headerlink\" title=\"使用虚基类\"></a>使用虚基类</h3><p>我们指定虚基类的方式是在派生列表中添加关键字virtual：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//关键字public和virtual的顺序随意</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Raccoon</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ZooAnimal &#123; <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bear</span> :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> ZooAnimal &#123; <span class=\"comment\">/* ... */</span>&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类</p>\n<p>virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。</p>\n<p>如果某个类指定了虚基类，则该类的派生仍按常规方式进行：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Panda</span> :</span> <span class=\"keyword\">public</span> Bear,<span class=\"keyword\">public</span> Raccoon,<span class=\"keyword\">public</span> Endangered&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Panda中只有一个ZooAnimal基类部分</p>\n<h3 id=\"虚基类成员的可见性\"><a href=\"#虚基类成员的可见性\" class=\"headerlink\" title=\"虚基类成员的可见性\"></a>虚基类成员的可见性</h3><p>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。</p>\n<p>与非虚的多重继承体系一样，<strong>解决这种二义性问题最好的方法是在派生类中为成员自定义新的示例。</strong></p>\n<h3 id=\"构造函数与虚继承\"><a href=\"#构造函数与虚继承\" class=\"headerlink\" title=\"构造函数与虚继承\"></a>构造函数与虚继承</h3><p><strong>在虚派生中，虚基类是由最底层的派生类（也就是最最后面的派生类）初始化的。</strong>，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。</p>\n<p>为了理解这一规则，我们不妨假设当以普通规则处理初始任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。</p>\n<p>当创建一个Bear（或Raccoon）的对象时，将直接初始化其ZooAnimal基类部分。</p>\n<p>当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Panda::Panda(<span class=\"built_in\">string</span> name,<span class=\"keyword\">bool</span> onExhibit):ZooAnimal(name,onExhibit,<span class=\"string\">\"Panda\"</span>),</div><div class=\"line\">                Bear(name,onExhibit),Raccoon(name,onExhibit),</div><div class=\"line\">                Endangered(Endangered::critical),sleeping_flag(<span class=\"literal\">false</span>) &#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"虚继承的对象的构造方式\"><a href=\"#虚继承的对象的构造方式\" class=\"headerlink\" title=\"虚继承的对象的构造方式\"></a>虚继承的对象的构造方式</h3><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。</p>\n<p>例如：当我们创建一个Panda对象时：</p>\n<ul>\n<li>首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</li>\n<li>接下来构造Bear部分</li>\n<li>然后构造Raccoon部分</li>\n<li>然后构造第三个直接基类Endangered</li>\n<li>最后构造Panda部分</li>\n</ul>\n<p>如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。</p>\n<p><strong>note: 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</strong></p>\n<h3 id=\"构造函数与析构函数的次序\"><a href=\"#构造函数与析构函数的次序\" class=\"headerlink\" title=\"构造函数与析构函数的次序\"></a>构造函数与析构函数的次序</h3><p>一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Character</span> &#123;</span> ...&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookCharacter</span> :</span> <span class=\"keyword\">public</span> Character &#123; ...&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToyAnimal</span> &#123;</span> ...&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeddyBear</span> :</span> <span class=\"keyword\">public</span> BookCharacter,<span class=\"keyword\">public</span> Bear,<span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ToyAnimal &#123;...&#125;;</div></pre></td></tr></table></figure>\n<p>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，创建一个TeddyBear对象，需要按照如下次序调用这些构造函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZooAnimal();      //Bear的虚基类</div><div class=\"line\">ToyAnimal();      //直接虚基类</div><div class=\"line\">Character();      //第一个非虚基类的间接基类</div><div class=\"line\">BookCharacter();     //第一个直接非虚基类</div><div class=\"line\">Bear();           //第二个直接非虚基类</div><div class=\"line\">TeddyBear();      //最低层的派生类</div></pre></td></tr></table></figure>\n<p>合成的拷贝和移动构造函数按照完成相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后ZooAnimal部分。</p>"},{"title":"异常处理与命令空间","date":"2017-12-03T02:59:00.000Z","update":null,"comments":1,"_content":"\n## 异常处理\n\n**异常处理**（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。\n\n<!--more-->\n\n当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。\n\n因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。\n\n### 栈展开\n\n当抛出一个异常时，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch字句。当throw出现在一个**try语句块**内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。\n\n上述过程被称为**栈展开**（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。\n\n假设找到了一个匹配的catch字句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。\n\n如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数**terminate**，顾名思义，terminate负责终止程序的执行过程。\n\n**note:** 一个异常如果没有被捕获，则它将终止当前的程序。\n\n### 栈展开过程中对象被自动销毁\n\n块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。\n\n如果异常发生在构造函数中，则当前的对象可能只构造了一部分。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。数组或标准库容器的元素初始化过程中，也是一样的。\n\n### 析构函数与异常\n\n在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。\n\n### 异常对象\n\n异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。\n\n异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。\n\n当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。\n\n### 捕获异常\n\ncatch子句中的**异常声明**（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。\n\n通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。\n\n#### 查找匹配的处理代码\n\n在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。\n\n因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，**使得派生类异常的处理代码出现在基类异常的处理代码之前。**\n\n\n## 命名空间\n\n大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会在某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发**命名空间污染**。\n\n**命名空间**（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命令空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。\n\n### 命名空间定义\n\n一个命令空间的定义包含两个部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。\n\n**using声明：** 是一种将命名空间中的某个名字注入当前作用域的机制：\n\n```C++\nusing std::cout;\n```\n\n上述语句使得命令空间std中的名字cout在当前作用域可见。之后，我们将可以直接使用cout而无须前缀std::了。\n\n**using指示：** 是具有如下形式的声明：\n\n```C++\nusing NS;\n```\n\n上述语句使得命名空间NS的所有名字在using指示所在的作用域以及NS所在的作用域都变得可见。\n","source":"_posts/异常处理与命令空间.md","raw":"---\ntitle: 异常处理与命令空间\ndate: 2017-12-03 10:59:00\nupdate: \ntags: [异常处理]\ncategories: C++\ncomments: true\n---\n\n## 异常处理\n\n**异常处理**（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。\n\n<!--more-->\n\n当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。\n\n因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。\n\n### 栈展开\n\n当抛出一个异常时，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch字句。当throw出现在一个**try语句块**内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。\n\n上述过程被称为**栈展开**（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。\n\n假设找到了一个匹配的catch字句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。\n\n如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数**terminate**，顾名思义，terminate负责终止程序的执行过程。\n\n**note:** 一个异常如果没有被捕获，则它将终止当前的程序。\n\n### 栈展开过程中对象被自动销毁\n\n块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。\n\n如果异常发生在构造函数中，则当前的对象可能只构造了一部分。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。数组或标准库容器的元素初始化过程中，也是一样的。\n\n### 析构函数与异常\n\n在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。\n\n### 异常对象\n\n异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。\n\n异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。\n\n当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。\n\n### 捕获异常\n\ncatch子句中的**异常声明**（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。\n\n通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。\n\n#### 查找匹配的处理代码\n\n在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。\n\n因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，**使得派生类异常的处理代码出现在基类异常的处理代码之前。**\n\n\n## 命名空间\n\n大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会在某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发**命名空间污染**。\n\n**命名空间**（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命令空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。\n\n### 命名空间定义\n\n一个命令空间的定义包含两个部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。\n\n**using声明：** 是一种将命名空间中的某个名字注入当前作用域的机制：\n\n```C++\nusing std::cout;\n```\n\n上述语句使得命令空间std中的名字cout在当前作用域可见。之后，我们将可以直接使用cout而无须前缀std::了。\n\n**using指示：** 是具有如下形式的声明：\n\n```C++\nusing NS;\n```\n\n上述语句使得命名空间NS的所有名字在using指示所在的作用域以及NS所在的作用域都变得可见。\n","slug":"异常处理与命令空间","published":1,"updated":"2018-02-23T08:03:17.685Z","layout":"post","photos":[],"link":"","_id":"cjdzniehw0003h4c9mqyoxzxd","content":"<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p><strong>异常处理</strong>（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。</p>\n<a id=\"more\"></a>\n<p>当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。</p>\n<p>因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。</p>\n<h3 id=\"栈展开\"><a href=\"#栈展开\" class=\"headerlink\" title=\"栈展开\"></a>栈展开</h3><p>当抛出一个异常时，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch字句。当throw出现在一个<strong>try语句块</strong>内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。</p>\n<p>上述过程被称为<strong>栈展开</strong>（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。</p>\n<p>假设找到了一个匹配的catch字句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。</p>\n<p>如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数<strong>terminate</strong>，顾名思义，terminate负责终止程序的执行过程。</p>\n<p><strong>note:</strong> 一个异常如果没有被捕获，则它将终止当前的程序。</p>\n<h3 id=\"栈展开过程中对象被自动销毁\"><a href=\"#栈展开过程中对象被自动销毁\" class=\"headerlink\" title=\"栈展开过程中对象被自动销毁\"></a>栈展开过程中对象被自动销毁</h3><p>块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。</p>\n<p>如果异常发生在构造函数中，则当前的对象可能只构造了一部分。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。数组或标准库容器的元素初始化过程中，也是一样的。</p>\n<h3 id=\"析构函数与异常\"><a href=\"#析构函数与异常\" class=\"headerlink\" title=\"析构函数与异常\"></a>析构函数与异常</h3><p>在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。</p>\n<h3 id=\"异常对象\"><a href=\"#异常对象\" class=\"headerlink\" title=\"异常对象\"></a>异常对象</h3><p>异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。</p>\n<p>异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。</p>\n<p>当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。</p>\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p>catch子句中的<strong>异常声明</strong>（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>\n<p>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。</p>\n<h4 id=\"查找匹配的处理代码\"><a href=\"#查找匹配的处理代码\" class=\"headerlink\" title=\"查找匹配的处理代码\"></a>查找匹配的处理代码</h4><p>在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。</p>\n<p>因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，<strong>使得派生类异常的处理代码出现在基类异常的处理代码之前。</strong></p>\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会在某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发<strong>命名空间污染</strong>。</p>\n<p><strong>命名空间</strong>（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命令空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。</p>\n<h3 id=\"命名空间定义\"><a href=\"#命名空间定义\" class=\"headerlink\" title=\"命名空间定义\"></a>命名空间定义</h3><p>一个命令空间的定义包含两个部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。</p>\n<p><strong>using声明：</strong> 是一种将命名空间中的某个名字注入当前作用域的机制：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</div></pre></td></tr></table></figure>\n<p>上述语句使得命令空间std中的名字cout在当前作用域可见。之后，我们将可以直接使用cout而无须前缀std::了。</p>\n<p><strong>using指示：</strong> 是具有如下形式的声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> NS;</div></pre></td></tr></table></figure>\n<p>上述语句使得命名空间NS的所有名字在using指示所在的作用域以及NS所在的作用域都变得可见。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p><strong>异常处理</strong>（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。</p>","more":"<p>当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。</p>\n<p>因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。</p>\n<h3 id=\"栈展开\"><a href=\"#栈展开\" class=\"headerlink\" title=\"栈展开\"></a>栈展开</h3><p>当抛出一个异常时，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch字句。当throw出现在一个<strong>try语句块</strong>内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。</p>\n<p>上述过程被称为<strong>栈展开</strong>（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。</p>\n<p>假设找到了一个匹配的catch字句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。</p>\n<p>如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数<strong>terminate</strong>，顾名思义，terminate负责终止程序的执行过程。</p>\n<p><strong>note:</strong> 一个异常如果没有被捕获，则它将终止当前的程序。</p>\n<h3 id=\"栈展开过程中对象被自动销毁\"><a href=\"#栈展开过程中对象被自动销毁\" class=\"headerlink\" title=\"栈展开过程中对象被自动销毁\"></a>栈展开过程中对象被自动销毁</h3><p>块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。</p>\n<p>如果异常发生在构造函数中，则当前的对象可能只构造了一部分。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。数组或标准库容器的元素初始化过程中，也是一样的。</p>\n<h3 id=\"析构函数与异常\"><a href=\"#析构函数与异常\" class=\"headerlink\" title=\"析构函数与异常\"></a>析构函数与异常</h3><p>在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。</p>\n<h3 id=\"异常对象\"><a href=\"#异常对象\" class=\"headerlink\" title=\"异常对象\"></a>异常对象</h3><p>异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。</p>\n<p>异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。</p>\n<p>当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。</p>\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p>catch子句中的<strong>异常声明</strong>（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>\n<p>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。</p>\n<h4 id=\"查找匹配的处理代码\"><a href=\"#查找匹配的处理代码\" class=\"headerlink\" title=\"查找匹配的处理代码\"></a>查找匹配的处理代码</h4><p>在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。</p>\n<p>因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，<strong>使得派生类异常的处理代码出现在基类异常的处理代码之前。</strong></p>\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会在某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发<strong>命名空间污染</strong>。</p>\n<p><strong>命名空间</strong>（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命令空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。</p>\n<h3 id=\"命名空间定义\"><a href=\"#命名空间定义\" class=\"headerlink\" title=\"命名空间定义\"></a>命名空间定义</h3><p>一个命令空间的定义包含两个部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。</p>\n<p><strong>using声明：</strong> 是一种将命名空间中的某个名字注入当前作用域的机制：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</div></pre></td></tr></table></figure>\n<p>上述语句使得命令空间std中的名字cout在当前作用域可见。之后，我们将可以直接使用cout而无须前缀std::了。</p>\n<p><strong>using指示：</strong> 是具有如下形式的声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> NS;</div></pre></td></tr></table></figure>\n<p>上述语句使得命名空间NS的所有名字在using指示所在的作用域以及NS所在的作用域都变得可见。</p>"},{"title":"访问控制与继承","date":"2017-11-23T02:59:00.000Z","update":null,"comments":1,"_content":"\n## 访问控制与继承\n\n每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。\n\n<!--more-->\n\n### 受保护的成员\n\n- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。\n- 和共有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。\n\n此外，protected还有另外一条重要的性质。\n\n- **派生类的成员或友元只能通过派生类对象来访问基类受的保护成员。派生类对于一个基类对象中的受保护的成员没有任何访问权限**。\n\n考虑如下例子：\n\n```C++\nclass Base{\nprotected:\n    int prot_mem;\n};\nclass Sneaky : public Base {\n    friend void clobber(Sneaky&);     //能访问Sneaky::prot_mem\n    friend void clobber(Base&)；   //不能访问Base::prot_mem\n    int j;\n};\n//正确：clobber能访问Sneaky对象的private和protected成员\nvoid clobber(Sneaky &s) {s.j = s.prot_mem = 0;}\n//错误：clobber不能访问Base的protected成员\nvoid clobber(Base &b){ b.prot_mem = 0;}\n```\n\n### 公有、私有和受保护继承  （重点）\n\n某个类对其继承而来的成员的访问权限受到两个因素影响：**一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。**\n\n**派生类访问说明符**（继承的类是公有、私有还是受保护）对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，基类成员的访问权限只与基类中的访问说明符有关（派生类的成员不能访问基类私有成员，可以访问基类公有和受保护成员）。\n\n**派生类访问说明符的目的**是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：\n\n- 如果继承是公有的，对于派生类用户来讲，基类中成员遵循其原有的访问说明符。\n- 如果继承是私有的，对于派生类用户来讲，基类中的成员访问说明符都是私有的。\n- 如果继承是受保护的，对于派生类用户来讲，基类的所有公有成员在新定义的类中都是受保护的，基类中的受保护和私有成员遵循原来的访问说明符。\n\n### 派生类向基类转换的可访问性  （略）\n\n- **只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护或者私有的，则用户代码不能使用该转换。**\n\n\n**关键概念：类的设计与受保护的成员**\n\n不考虑继承的话，我们可以认为一个类有两种不同的用户：**普通用户和类的实现者**。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。\n\n如果进一步考虑继承的话就会出现第三种用户：**即派生类**。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。\n\n和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可以供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。\n\n### 友元与继承\n\n不能继承友元关系；每个类负责控制各自成员的访问权限。\n\n### 改变个别成员的可访问性\n\n有时我们需要改变派生类继承的某个名字的访问级别，通过使用**using声明**可以达到这一目的。\n\n派生类只能为那些它可以访问的名字提供using声明。\n\n### 默认的继承保护级别\n\n使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。\n\n一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。\n","source":"_posts/访问控制与继承.md","raw":"---\ntitle: 访问控制与继承\ndate: 2017-11-23 10:59:00\nupdate: \ntags: [面向对象]\ncategories: C++\ncomments: true\n---\n\n## 访问控制与继承\n\n每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。\n\n<!--more-->\n\n### 受保护的成员\n\n- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。\n- 和共有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。\n\n此外，protected还有另外一条重要的性质。\n\n- **派生类的成员或友元只能通过派生类对象来访问基类受的保护成员。派生类对于一个基类对象中的受保护的成员没有任何访问权限**。\n\n考虑如下例子：\n\n```C++\nclass Base{\nprotected:\n    int prot_mem;\n};\nclass Sneaky : public Base {\n    friend void clobber(Sneaky&);     //能访问Sneaky::prot_mem\n    friend void clobber(Base&)；   //不能访问Base::prot_mem\n    int j;\n};\n//正确：clobber能访问Sneaky对象的private和protected成员\nvoid clobber(Sneaky &s) {s.j = s.prot_mem = 0;}\n//错误：clobber不能访问Base的protected成员\nvoid clobber(Base &b){ b.prot_mem = 0;}\n```\n\n### 公有、私有和受保护继承  （重点）\n\n某个类对其继承而来的成员的访问权限受到两个因素影响：**一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。**\n\n**派生类访问说明符**（继承的类是公有、私有还是受保护）对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，基类成员的访问权限只与基类中的访问说明符有关（派生类的成员不能访问基类私有成员，可以访问基类公有和受保护成员）。\n\n**派生类访问说明符的目的**是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：\n\n- 如果继承是公有的，对于派生类用户来讲，基类中成员遵循其原有的访问说明符。\n- 如果继承是私有的，对于派生类用户来讲，基类中的成员访问说明符都是私有的。\n- 如果继承是受保护的，对于派生类用户来讲，基类的所有公有成员在新定义的类中都是受保护的，基类中的受保护和私有成员遵循原来的访问说明符。\n\n### 派生类向基类转换的可访问性  （略）\n\n- **只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护或者私有的，则用户代码不能使用该转换。**\n\n\n**关键概念：类的设计与受保护的成员**\n\n不考虑继承的话，我们可以认为一个类有两种不同的用户：**普通用户和类的实现者**。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。\n\n如果进一步考虑继承的话就会出现第三种用户：**即派生类**。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。\n\n和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可以供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。\n\n### 友元与继承\n\n不能继承友元关系；每个类负责控制各自成员的访问权限。\n\n### 改变个别成员的可访问性\n\n有时我们需要改变派生类继承的某个名字的访问级别，通过使用**using声明**可以达到这一目的。\n\n派生类只能为那些它可以访问的名字提供using声明。\n\n### 默认的继承保护级别\n\n使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。\n\n一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。\n","slug":"访问控制与继承","published":1,"updated":"2018-02-23T08:13:10.483Z","_id":"cjdzniehz0005h4c9c89q9ope","layout":"post","photos":[],"link":"","content":"<h2 id=\"访问控制与继承\"><a href=\"#访问控制与继承\" class=\"headerlink\" title=\"访问控制与继承\"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。</p>\n<a id=\"more\"></a>\n<h3 id=\"受保护的成员\"><a href=\"#受保护的成员\" class=\"headerlink\" title=\"受保护的成员\"></a>受保护的成员</h3><ul>\n<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>\n<li>和共有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>\n</ul>\n<p>此外，protected还有另外一条重要的性质。</p>\n<ul>\n<li><strong>派生类的成员或友元只能通过派生类对象来访问基类受的保护成员。派生类对于一个基类对象中的受保护的成员没有任何访问权限</strong>。</li>\n</ul>\n<p>考虑如下例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">protected</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sneaky</span> :</span> <span class=\"keyword\">public</span> Base &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky&amp;)</span></span>;     <span class=\"comment\">//能访问Sneaky::prot_mem</span></div><div class=\"line\">    friend void clobber(Base&amp;)；   //不能访问Base::prot_mem</div><div class=\"line\">    <span class=\"keyword\">int</span> j;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//正确：clobber能访问Sneaky对象的private和protected成员</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky &amp;s)</span> </span>&#123;s.j = s.prot_mem = <span class=\"number\">0</span>;&#125;</div><div class=\"line\"><span class=\"comment\">//错误：clobber不能访问Base的protected成员</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Base &amp;b)</span></span>&#123; b.prot_mem = <span class=\"number\">0</span>;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"公有、私有和受保护继承-（重点）\"><a href=\"#公有、私有和受保护继承-（重点）\" class=\"headerlink\" title=\"公有、私有和受保护继承  （重点）\"></a>公有、私有和受保护继承  （重点）</h3><p>某个类对其继承而来的成员的访问权限受到两个因素影响：<strong>一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</strong></p>\n<p><strong>派生类访问说明符</strong>（继承的类是公有、私有还是受保护）对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，基类成员的访问权限只与基类中的访问说明符有关（派生类的成员不能访问基类私有成员，可以访问基类公有和受保护成员）。</p>\n<p><strong>派生类访问说明符的目的</strong>是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：</p>\n<ul>\n<li>如果继承是公有的，对于派生类用户来讲，基类中成员遵循其原有的访问说明符。</li>\n<li>如果继承是私有的，对于派生类用户来讲，基类中的成员访问说明符都是私有的。</li>\n<li>如果继承是受保护的，对于派生类用户来讲，基类的所有公有成员在新定义的类中都是受保护的，基类中的受保护和私有成员遵循原来的访问说明符。</li>\n</ul>\n<h3 id=\"派生类向基类转换的可访问性-（略）\"><a href=\"#派生类向基类转换的可访问性-（略）\" class=\"headerlink\" title=\"派生类向基类转换的可访问性  （略）\"></a>派生类向基类转换的可访问性  （略）</h3><ul>\n<li><strong>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护或者私有的，则用户代码不能使用该转换。</strong></li>\n</ul>\n<p><strong>关键概念：类的设计与受保护的成员</strong></p>\n<p>不考虑继承的话，我们可以认为一个类有两种不同的用户：<strong>普通用户和类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。</p>\n<p>如果进一步考虑继承的话就会出现第三种用户：<strong>即派生类</strong>。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>\n<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可以供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。</p>\n<h3 id=\"友元与继承\"><a href=\"#友元与继承\" class=\"headerlink\" title=\"友元与继承\"></a>友元与继承</h3><p>不能继承友元关系；每个类负责控制各自成员的访问权限。</p>\n<h3 id=\"改变个别成员的可访问性\"><a href=\"#改变个别成员的可访问性\" class=\"headerlink\" title=\"改变个别成员的可访问性\"></a>改变个别成员的可访问性</h3><p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用<strong>using声明</strong>可以达到这一目的。</p>\n<p>派生类只能为那些它可以访问的名字提供using声明。</p>\n<h3 id=\"默认的继承保护级别\"><a href=\"#默认的继承保护级别\" class=\"headerlink\" title=\"默认的继承保护级别\"></a>默认的继承保护级别</h3><p>使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。</p>\n<p>一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"访问控制与继承\"><a href=\"#访问控制与继承\" class=\"headerlink\" title=\"访问控制与继承\"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。</p>","more":"<h3 id=\"受保护的成员\"><a href=\"#受保护的成员\" class=\"headerlink\" title=\"受保护的成员\"></a>受保护的成员</h3><ul>\n<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>\n<li>和共有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>\n</ul>\n<p>此外，protected还有另外一条重要的性质。</p>\n<ul>\n<li><strong>派生类的成员或友元只能通过派生类对象来访问基类受的保护成员。派生类对于一个基类对象中的受保护的成员没有任何访问权限</strong>。</li>\n</ul>\n<p>考虑如下例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">protected</span>:</div><div class=\"line\">    <span class=\"keyword\">int</span> prot_mem;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sneaky</span> :</span> <span class=\"keyword\">public</span> Base &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky&amp;)</span></span>;     <span class=\"comment\">//能访问Sneaky::prot_mem</span></div><div class=\"line\">    friend void clobber(Base&amp;)；   //不能访问Base::prot_mem</div><div class=\"line\">    <span class=\"keyword\">int</span> j;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//正确：clobber能访问Sneaky对象的private和protected成员</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Sneaky &amp;s)</span> </span>&#123;s.j = s.prot_mem = <span class=\"number\">0</span>;&#125;</div><div class=\"line\"><span class=\"comment\">//错误：clobber不能访问Base的protected成员</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clobber</span><span class=\"params\">(Base &amp;b)</span></span>&#123; b.prot_mem = <span class=\"number\">0</span>;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"公有、私有和受保护继承-（重点）\"><a href=\"#公有、私有和受保护继承-（重点）\" class=\"headerlink\" title=\"公有、私有和受保护继承  （重点）\"></a>公有、私有和受保护继承  （重点）</h3><p>某个类对其继承而来的成员的访问权限受到两个因素影响：<strong>一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</strong></p>\n<p><strong>派生类访问说明符</strong>（继承的类是公有、私有还是受保护）对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，基类成员的访问权限只与基类中的访问说明符有关（派生类的成员不能访问基类私有成员，可以访问基类公有和受保护成员）。</p>\n<p><strong>派生类访问说明符的目的</strong>是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：</p>\n<ul>\n<li>如果继承是公有的，对于派生类用户来讲，基类中成员遵循其原有的访问说明符。</li>\n<li>如果继承是私有的，对于派生类用户来讲，基类中的成员访问说明符都是私有的。</li>\n<li>如果继承是受保护的，对于派生类用户来讲，基类的所有公有成员在新定义的类中都是受保护的，基类中的受保护和私有成员遵循原来的访问说明符。</li>\n</ul>\n<h3 id=\"派生类向基类转换的可访问性-（略）\"><a href=\"#派生类向基类转换的可访问性-（略）\" class=\"headerlink\" title=\"派生类向基类转换的可访问性  （略）\"></a>派生类向基类转换的可访问性  （略）</h3><ul>\n<li><strong>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护或者私有的，则用户代码不能使用该转换。</strong></li>\n</ul>\n<p><strong>关键概念：类的设计与受保护的成员</strong></p>\n<p>不考虑继承的话，我们可以认为一个类有两种不同的用户：<strong>普通用户和类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。</p>\n<p>如果进一步考虑继承的话就会出现第三种用户：<strong>即派生类</strong>。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>\n<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可以供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。</p>\n<h3 id=\"友元与继承\"><a href=\"#友元与继承\" class=\"headerlink\" title=\"友元与继承\"></a>友元与继承</h3><p>不能继承友元关系；每个类负责控制各自成员的访问权限。</p>\n<h3 id=\"改变个别成员的可访问性\"><a href=\"#改变个别成员的可访问性\" class=\"headerlink\" title=\"改变个别成员的可访问性\"></a>改变个别成员的可访问性</h3><p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用<strong>using声明</strong>可以达到这一目的。</p>\n<p>派生类只能为那些它可以访问的名字提供using声明。</p>\n<h3 id=\"默认的继承保护级别\"><a href=\"#默认的继承保护级别\" class=\"headerlink\" title=\"默认的继承保护级别\"></a>默认的继承保护级别</h3><p>使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。</p>\n<p>一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>"},{"title":"模板参数与成员模版","date":"2017-12-01T02:49:00.000Z","update":null,"comments":1,"_content":"\n## 模板参数\n\n### 模板参数与作用域\n\n模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：\n\n<!--more-->\n\n```C++\ntypedef double A;\ntemplate <typename A,typename B> \nvoid f(A a, B b){\n    A tmp = a;         //tmp的类型为模板参数A的类型，而非double\n    double B;         //错误：重声明模板参数B\n}\n```\n\n由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：\n\n```C++\n//错误：非法重用模板参数名V\ntemplate <typename V, typename V>   //...\n```\n\n### 模板声明\n\n模版声明必须包含模板参数：\n\n```C++\n//声明但不定义compare和Blob\ntemplate <typename T> int compare(const T&,const T&);\ntemplate <typename T> class Blob;\n```\n\n与函数参数相同，声明中的模板参数的名字不必与定义中相同。\n\n**建议：** 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。\n\n### 使用类的类型成员\n\n例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：\n\n```C++\nT::size_type * p;\n```\n\n它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。\n\n默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：\n\n```C++\ntemplate <typename T>\n//typename T::value_type 使用关键字通过编译器该名字T::value_type表示类型\ntypename T::value_type top (const T &c) {\n    //...\n}\n```\n\n<font color=red>  **note:当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。** </font> \n\n### 默认模板实参\n\n就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。\n\n例如，我们重写compare，默认使用标准库的less函数对象模板：\n\n```C++\ntemplate <typename T,typename F = less<T>>\nint compare(const T &v1,const T &v2, F f = F()){\n    if(f(v1,v2)) return -1;\n    if(f(v2,v1)) return 1;\n    return 0;\n}\n```\n\n### 模板默认实参与类模板\n\n无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：\n\n```C++\ntemplate <class T = int>\nclass Numbers{    //T默认为int\npublic:\n    Numbers(T v=0):val(v) {}\n    //...\nprivate:\n    T val;\n};\n\n\nNumbers<long double> num1;\nNumbers<> num2;        //空<>表示我们希望使用默认类型\n```\n\n\n习题示例：\n\n编写函数，接受一个容器的引用，打印容器中的元素，两种方式，一种使用容器的size_type和size成员来控制打印元素的循环；另一种使用begin和end返回迭代器来控制循环。\n\n```C++\ntemplate<typename Container>\nvoid print1(const Container &container){\n    //typename Container::size_type  表明size_type是一个类型\n    for(typename Container::size_type i = 0;i<container.size();++i){\n        cout<<container[i]<<\" \";\n    }\n    cout<<endl;\n}\n\ntemplate<typename Container>\nvoid print2(const Container &container){\n    for(auto iter = container.begin();iter!=container.end();++iter){\n        cout<<*iter<<\" \";\n    }\n    cout<<endl;\n}\n\n\nvector<int> ivec = {1,2,3,4};\nprint1(ivec);\nlist<string> slist = {\"wang\",\"xin\",\"ri\"};\nprint2(slist);\n```\n\n## 成员模板\n\n一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为**成员模板**（member template）。成员模板不能是虚函数。\n\n### 普通（非模板）类的成员模板\n\n例如，我们定义一个类，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。由于希望delete使用于任何类型，所以我们将调用运算符定义为一个模板：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass DebugDelete{\npublic:\n    DebugDelete(ostream &s = cerr):os(s){}\n    //与任何函数模板相同，T的类型由编译器推断\n    template<typename T>\n    void operator()(T *p) const {    //成员模板，重载函数调用运算符\n        os<<\"deleting unique_ptr\"<<endl;\n        delete p;\n    }\nprivate:\n    ostream &os;\n};\n\nint main()\n{\n    double *p = new double(10);\n    cout<<*p<<endl;\n    DebugDelete d;\n    d(p);     //调用DebugDelete::operator() (double*),释放p\n    int *ip = new int;\n    //在一个临时DebugDelete对象上调用operator()(int*)\n    DebugDelete()(ip);\n    return 0;\n}\n```\n\n### 类模板的成员模板\n\n对于类模板，我们也可以为其定义成员模板。再此情况下，类和成员各自有自己的、独立的模板参数。\n\n与类模板的普通函数成员不同，成员模板是函数模板。**当我们在类模板外定义一个成员模板时**，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：\n\n```C++\n//类模板外定义成员模板\ntemplate <typename T>     //类的类型参数\ntemplate <typename It>      //构造函数的类型参数\nBlob<T>::Blob(It b,It e):data(make_shared<vector<T>>(b,e)) {}\n```\n\n## 控制实例化\n\n当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例。\n\n在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过**显式实例化**来避免这种开销。一个显式实例化有如下形式：\n\n```C++\nextern template declaration;        //实例化声明\ntemplate declaration；              //实例化定义\n```\ndeclaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，\n\n```C++\n//实例化声明与定义\nextern template class Blob<string>;         //声明\ntemplate int compare(const int&,const int&);       //定义\n```\n\n当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。\n\n**警告：** 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。\n\n### 实例化定义会实例化所有成员\n\n一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。\n\n**note:** 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。\n","source":"_posts/模板参数与成员模版.md","raw":"---\ntitle: 模板参数与成员模版\ndate: 2017-12-01 10:49:00\nupdate: \ntags: [模板]\ncategories: C++\ncomments: true\n---\n\n## 模板参数\n\n### 模板参数与作用域\n\n模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：\n\n<!--more-->\n\n```C++\ntypedef double A;\ntemplate <typename A,typename B> \nvoid f(A a, B b){\n    A tmp = a;         //tmp的类型为模板参数A的类型，而非double\n    double B;         //错误：重声明模板参数B\n}\n```\n\n由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：\n\n```C++\n//错误：非法重用模板参数名V\ntemplate <typename V, typename V>   //...\n```\n\n### 模板声明\n\n模版声明必须包含模板参数：\n\n```C++\n//声明但不定义compare和Blob\ntemplate <typename T> int compare(const T&,const T&);\ntemplate <typename T> class Blob;\n```\n\n与函数参数相同，声明中的模板参数的名字不必与定义中相同。\n\n**建议：** 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。\n\n### 使用类的类型成员\n\n例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：\n\n```C++\nT::size_type * p;\n```\n\n它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。\n\n默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：\n\n```C++\ntemplate <typename T>\n//typename T::value_type 使用关键字通过编译器该名字T::value_type表示类型\ntypename T::value_type top (const T &c) {\n    //...\n}\n```\n\n<font color=red>  **note:当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。** </font> \n\n### 默认模板实参\n\n就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。\n\n例如，我们重写compare，默认使用标准库的less函数对象模板：\n\n```C++\ntemplate <typename T,typename F = less<T>>\nint compare(const T &v1,const T &v2, F f = F()){\n    if(f(v1,v2)) return -1;\n    if(f(v2,v1)) return 1;\n    return 0;\n}\n```\n\n### 模板默认实参与类模板\n\n无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：\n\n```C++\ntemplate <class T = int>\nclass Numbers{    //T默认为int\npublic:\n    Numbers(T v=0):val(v) {}\n    //...\nprivate:\n    T val;\n};\n\n\nNumbers<long double> num1;\nNumbers<> num2;        //空<>表示我们希望使用默认类型\n```\n\n\n习题示例：\n\n编写函数，接受一个容器的引用，打印容器中的元素，两种方式，一种使用容器的size_type和size成员来控制打印元素的循环；另一种使用begin和end返回迭代器来控制循环。\n\n```C++\ntemplate<typename Container>\nvoid print1(const Container &container){\n    //typename Container::size_type  表明size_type是一个类型\n    for(typename Container::size_type i = 0;i<container.size();++i){\n        cout<<container[i]<<\" \";\n    }\n    cout<<endl;\n}\n\ntemplate<typename Container>\nvoid print2(const Container &container){\n    for(auto iter = container.begin();iter!=container.end();++iter){\n        cout<<*iter<<\" \";\n    }\n    cout<<endl;\n}\n\n\nvector<int> ivec = {1,2,3,4};\nprint1(ivec);\nlist<string> slist = {\"wang\",\"xin\",\"ri\"};\nprint2(slist);\n```\n\n## 成员模板\n\n一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为**成员模板**（member template）。成员模板不能是虚函数。\n\n### 普通（非模板）类的成员模板\n\n例如，我们定义一个类，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。由于希望delete使用于任何类型，所以我们将调用运算符定义为一个模板：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass DebugDelete{\npublic:\n    DebugDelete(ostream &s = cerr):os(s){}\n    //与任何函数模板相同，T的类型由编译器推断\n    template<typename T>\n    void operator()(T *p) const {    //成员模板，重载函数调用运算符\n        os<<\"deleting unique_ptr\"<<endl;\n        delete p;\n    }\nprivate:\n    ostream &os;\n};\n\nint main()\n{\n    double *p = new double(10);\n    cout<<*p<<endl;\n    DebugDelete d;\n    d(p);     //调用DebugDelete::operator() (double*),释放p\n    int *ip = new int;\n    //在一个临时DebugDelete对象上调用operator()(int*)\n    DebugDelete()(ip);\n    return 0;\n}\n```\n\n### 类模板的成员模板\n\n对于类模板，我们也可以为其定义成员模板。再此情况下，类和成员各自有自己的、独立的模板参数。\n\n与类模板的普通函数成员不同，成员模板是函数模板。**当我们在类模板外定义一个成员模板时**，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：\n\n```C++\n//类模板外定义成员模板\ntemplate <typename T>     //类的类型参数\ntemplate <typename It>      //构造函数的类型参数\nBlob<T>::Blob(It b,It e):data(make_shared<vector<T>>(b,e)) {}\n```\n\n## 控制实例化\n\n当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例。\n\n在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过**显式实例化**来避免这种开销。一个显式实例化有如下形式：\n\n```C++\nextern template declaration;        //实例化声明\ntemplate declaration；              //实例化定义\n```\ndeclaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，\n\n```C++\n//实例化声明与定义\nextern template class Blob<string>;         //声明\ntemplate int compare(const int&,const int&);       //定义\n```\n\n当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。\n\n**警告：** 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。\n\n### 实例化定义会实例化所有成员\n\n一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。\n\n**note:** 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。\n","slug":"模板参数与成员模版","published":1,"updated":"2018-02-23T08:08:23.493Z","_id":"cjdznieir000fh4c990esg3na","layout":"post","photos":[],"link":"","content":"<h2 id=\"模板参数\"><a href=\"#模板参数\" class=\"headerlink\" title=\"模板参数\"></a>模板参数</h2><h3 id=\"模板参数与作用域\"><a href=\"#模板参数与作用域\" class=\"headerlink\" title=\"模板参数与作用域\"></a>模板参数与作用域</h3><p>模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> A;</div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> A,<span class=\"keyword\">typename</span> B&gt; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(A a, B b)</span></span>&#123;</div><div class=\"line\">    A tmp = a;         <span class=\"comment\">//tmp的类型为模板参数A的类型，而非double</span></div><div class=\"line\">    <span class=\"keyword\">double</span> B;         <span class=\"comment\">//错误：重声明模板参数B</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：非法重用模板参数名V</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> V, <span class=\"keyword\">typename</span> V&gt;   <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<h3 id=\"模板声明\"><a href=\"#模板声明\" class=\"headerlink\" title=\"模板声明\"></a>模板声明</h3><p>模版声明必须包含模板参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//声明但不定义compare和Blob</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;,<span class=\"keyword\">const</span> T&amp;)</span></span>;</div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blob</span>;</span></div></pre></td></tr></table></figure>\n<p>与函数参数相同，声明中的模板参数的名字不必与定义中相同。</p>\n<p><strong>建议：</strong> 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>\n<h3 id=\"使用类的类型成员\"><a href=\"#使用类的类型成员\" class=\"headerlink\" title=\"使用类的类型成员\"></a>使用类的类型成员</h3><p>例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T::size_type * p;</div></pre></td></tr></table></figure>\n<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>\n<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"comment\">//typename T::value_type 使用关键字通过编译器该名字T::value_type表示类型</span></div><div class=\"line\"><span class=\"keyword\">typename</span> T::<span class=\"function\">value_type <span class=\"title\">top</span> <span class=\"params\">(<span class=\"keyword\">const</span> T &amp;c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<font color=\"red\">  <strong>note:当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。</strong> </font> \n\n<h3 id=\"默认模板实参\"><a href=\"#默认模板实参\" class=\"headerlink\" title=\"默认模板实参\"></a>默认模板实参</h3><p>就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。</p>\n<p>例如，我们重写compare，默认使用标准库的less函数对象模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T,<span class=\"keyword\">typename</span> F = less&lt;T&gt;&gt;</div><div class=\"line\"><span class=\"keyword\">int</span> compare(<span class=\"keyword\">const</span> T &amp;v1,<span class=\"keyword\">const</span> T &amp;v2, F f = F())&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(f(v1,v2)) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(f(v2,v1)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"模板默认实参与类模板\"><a href=\"#模板默认实参与类模板\" class=\"headerlink\" title=\"模板默认实参与类模板\"></a>模板默认实参与类模板</h3><p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> = <span class=\"title\">int</span>&gt;</span></div><div class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Numbers</span>&#123;</span>    <span class=\"comment\">//T默认为int</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Numbers(T v=<span class=\"number\">0</span>):val(v) &#123;&#125;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    T val;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Numbers&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>&gt; num1;</div><div class=\"line\">Numbers&lt;&gt; num2;        <span class=\"comment\">//空&lt;&gt;表示我们希望使用默认类型</span></div></pre></td></tr></table></figure>\n<p>习题示例：</p>\n<p>编写函数，接受一个容器的引用，打印容器中的元素，两种方式，一种使用容器的size_type和size成员来控制打印元素的循环；另一种使用begin和end返回迭代器来控制循环。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Container&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print1</span><span class=\"params\">(<span class=\"keyword\">const</span> Container &amp;container)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//typename Container::size_type  表明size_type是一个类型</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">typename</span> Container::size_type i = <span class=\"number\">0</span>;i&lt;container.size();++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;container[i]&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Container&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print2</span><span class=\"params\">(<span class=\"keyword\">const</span> Container &amp;container)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> iter = container.begin();iter!=container.end();++iter)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;*iter&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\">print1(ivec);</div><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; slist = &#123;<span class=\"string\">\"wang\"</span>,<span class=\"string\">\"xin\"</span>,<span class=\"string\">\"ri\"</span>&#125;;</div><div class=\"line\">print2(slist);</div></pre></td></tr></table></figure>\n<h2 id=\"成员模板\"><a href=\"#成员模板\" class=\"headerlink\" title=\"成员模板\"></a>成员模板</h2><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（member template）。成员模板不能是虚函数。</p>\n<h3 id=\"普通（非模板）类的成员模板\"><a href=\"#普通（非模板）类的成员模板\" class=\"headerlink\" title=\"普通（非模板）类的成员模板\"></a>普通（非模板）类的成员模板</h3><p>例如，我们定义一个类，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。由于希望delete使用于任何类型，所以我们将调用运算符定义为一个模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugDelete</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    DebugDelete(ostream &amp;s = <span class=\"built_in\">cerr</span>):os(s)&#123;&#125;</div><div class=\"line\">    <span class=\"comment\">//与任何函数模板相同，T的类型由编译器推断</span></div><div class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T *p)</span> <span class=\"keyword\">const</span> </span>&#123;    <span class=\"comment\">//成员模板，重载函数调用运算符</span></div><div class=\"line\">        os&lt;&lt;<span class=\"string\">\"deleting unique_ptr\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">delete</span> p;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    ostream &amp;os;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    DebugDelete d;</div><div class=\"line\">    d(p);     <span class=\"comment\">//调用DebugDelete::operator() (double*),释放p</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *ip = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</div><div class=\"line\">    <span class=\"comment\">//在一个临时DebugDelete对象上调用operator()(int*)</span></div><div class=\"line\">    DebugDelete()(ip);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"类模板的成员模板\"><a href=\"#类模板的成员模板\" class=\"headerlink\" title=\"类模板的成员模板\"></a>类模板的成员模板</h3><p>对于类模板，我们也可以为其定义成员模板。再此情况下，类和成员各自有自己的、独立的模板参数。</p>\n<p>与类模板的普通函数成员不同，成员模板是函数模板。<strong>当我们在类模板外定义一个成员模板时</strong>，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类模板外定义成员模板</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;     <span class=\"comment\">//类的类型参数</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> It&gt;      <span class=\"comment\">//构造函数的类型参数</span></div><div class=\"line\">Blob&lt;T&gt;::Blob(It b,It e):data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt;(b,e)) &#123;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"控制实例化\"><a href=\"#控制实例化\" class=\"headerlink\" title=\"控制实例化\"></a>控制实例化</h2><p>当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例。</p>\n<p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过<strong>显式实例化</strong>来避免这种开销。一个显式实例化有如下形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">template</span> declaration;        <span class=\"comment\">//实例化声明</span></div><div class=\"line\"><span class=\"keyword\">template</span> declaration；              <span class=\"comment\">//实例化定义</span></div></pre></td></tr></table></figure>\n<p>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//实例化声明与定义</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">template</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blob</span>&lt;string&gt;;</span>         <span class=\"comment\">//声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;,<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;)</span></span>;       <span class=\"comment\">//定义</span></div></pre></td></tr></table></figure>\n<p>当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>\n<p><strong>警告：</strong> 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</p>\n<h3 id=\"实例化定义会实例化所有成员\"><a href=\"#实例化定义会实例化所有成员\" class=\"headerlink\" title=\"实例化定义会实例化所有成员\"></a>实例化定义会实例化所有成员</h3><p>一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。</p>\n<p><strong>note:</strong> 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"模板参数\"><a href=\"#模板参数\" class=\"headerlink\" title=\"模板参数\"></a>模板参数</h2><h3 id=\"模板参数与作用域\"><a href=\"#模板参数与作用域\" class=\"headerlink\" title=\"模板参数与作用域\"></a>模板参数与作用域</h3><p>模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> A;</div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> A,<span class=\"keyword\">typename</span> B&gt; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(A a, B b)</span></span>&#123;</div><div class=\"line\">    A tmp = a;         <span class=\"comment\">//tmp的类型为模板参数A的类型，而非double</span></div><div class=\"line\">    <span class=\"keyword\">double</span> B;         <span class=\"comment\">//错误：重声明模板参数B</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//错误：非法重用模板参数名V</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> V, <span class=\"keyword\">typename</span> V&gt;   <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<h3 id=\"模板声明\"><a href=\"#模板声明\" class=\"headerlink\" title=\"模板声明\"></a>模板声明</h3><p>模版声明必须包含模板参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//声明但不定义compare和Blob</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;,<span class=\"keyword\">const</span> T&amp;)</span></span>;</div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blob</span>;</span></div></pre></td></tr></table></figure>\n<p>与函数参数相同，声明中的模板参数的名字不必与定义中相同。</p>\n<p><strong>建议：</strong> 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>\n<h3 id=\"使用类的类型成员\"><a href=\"#使用类的类型成员\" class=\"headerlink\" title=\"使用类的类型成员\"></a>使用类的类型成员</h3><p>例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">T::size_type * p;</div></pre></td></tr></table></figure>\n<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>\n<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"comment\">//typename T::value_type 使用关键字通过编译器该名字T::value_type表示类型</span></div><div class=\"line\"><span class=\"keyword\">typename</span> T::<span class=\"function\">value_type <span class=\"title\">top</span> <span class=\"params\">(<span class=\"keyword\">const</span> T &amp;c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<font color=\"red\">  <strong>note:当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。</strong> </font> \n\n<h3 id=\"默认模板实参\"><a href=\"#默认模板实参\" class=\"headerlink\" title=\"默认模板实参\"></a>默认模板实参</h3><p>就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。</p>\n<p>例如，我们重写compare，默认使用标准库的less函数对象模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T,<span class=\"keyword\">typename</span> F = less&lt;T&gt;&gt;</div><div class=\"line\"><span class=\"keyword\">int</span> compare(<span class=\"keyword\">const</span> T &amp;v1,<span class=\"keyword\">const</span> T &amp;v2, F f = F())&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(f(v1,v2)) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(f(v2,v1)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"模板默认实参与类模板\"><a href=\"#模板默认实参与类模板\" class=\"headerlink\" title=\"模板默认实参与类模板\"></a>模板默认实参与类模板</h3><p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> = <span class=\"title\">int</span>&gt;</span></div><div class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Numbers</span>&#123;</span>    <span class=\"comment\">//T默认为int</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    Numbers(T v=<span class=\"number\">0</span>):val(v) &#123;&#125;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    T val;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Numbers&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>&gt; num1;</div><div class=\"line\">Numbers&lt;&gt; num2;        <span class=\"comment\">//空&lt;&gt;表示我们希望使用默认类型</span></div></pre></td></tr></table></figure>\n<p>习题示例：</p>\n<p>编写函数，接受一个容器的引用，打印容器中的元素，两种方式，一种使用容器的size_type和size成员来控制打印元素的循环；另一种使用begin和end返回迭代器来控制循环。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Container&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print1</span><span class=\"params\">(<span class=\"keyword\">const</span> Container &amp;container)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//typename Container::size_type  表明size_type是一个类型</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">typename</span> Container::size_type i = <span class=\"number\">0</span>;i&lt;container.size();++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;container[i]&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Container&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print2</span><span class=\"params\">(<span class=\"keyword\">const</span> Container &amp;container)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> iter = container.begin();iter!=container.end();++iter)&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;*iter&lt;&lt;<span class=\"string\">\" \"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\">print1(ivec);</div><div class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"built_in\">string</span>&gt; slist = &#123;<span class=\"string\">\"wang\"</span>,<span class=\"string\">\"xin\"</span>,<span class=\"string\">\"ri\"</span>&#125;;</div><div class=\"line\">print2(slist);</div></pre></td></tr></table></figure>\n<h2 id=\"成员模板\"><a href=\"#成员模板\" class=\"headerlink\" title=\"成员模板\"></a>成员模板</h2><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（member template）。成员模板不能是虚函数。</p>\n<h3 id=\"普通（非模板）类的成员模板\"><a href=\"#普通（非模板）类的成员模板\" class=\"headerlink\" title=\"普通（非模板）类的成员模板\"></a>普通（非模板）类的成员模板</h3><p>例如，我们定义一个类，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。由于希望delete使用于任何类型，所以我们将调用运算符定义为一个模板：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugDelete</span>&#123;</span></div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    DebugDelete(ostream &amp;s = <span class=\"built_in\">cerr</span>):os(s)&#123;&#125;</div><div class=\"line\">    <span class=\"comment\">//与任何函数模板相同，T的类型由编译器推断</span></div><div class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T *p)</span> <span class=\"keyword\">const</span> </span>&#123;    <span class=\"comment\">//成员模板，重载函数调用运算符</span></div><div class=\"line\">        os&lt;&lt;<span class=\"string\">\"deleting unique_ptr\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">delete</span> p;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    ostream &amp;os;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    DebugDelete d;</div><div class=\"line\">    d(p);     <span class=\"comment\">//调用DebugDelete::operator() (double*),释放p</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *ip = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</div><div class=\"line\">    <span class=\"comment\">//在一个临时DebugDelete对象上调用operator()(int*)</span></div><div class=\"line\">    DebugDelete()(ip);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"类模板的成员模板\"><a href=\"#类模板的成员模板\" class=\"headerlink\" title=\"类模板的成员模板\"></a>类模板的成员模板</h3><p>对于类模板，我们也可以为其定义成员模板。再此情况下，类和成员各自有自己的、独立的模板参数。</p>\n<p>与类模板的普通函数成员不同，成员模板是函数模板。<strong>当我们在类模板外定义一个成员模板时</strong>，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//类模板外定义成员模板</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;     <span class=\"comment\">//类的类型参数</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> It&gt;      <span class=\"comment\">//构造函数的类型参数</span></div><div class=\"line\">Blob&lt;T&gt;::Blob(It b,It e):data(make_shared&lt;<span class=\"built_in\">vector</span>&lt;T&gt;&gt;(b,e)) &#123;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"控制实例化\"><a href=\"#控制实例化\" class=\"headerlink\" title=\"控制实例化\"></a>控制实例化</h2><p>当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例。</p>\n<p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过<strong>显式实例化</strong>来避免这种开销。一个显式实例化有如下形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">template</span> declaration;        <span class=\"comment\">//实例化声明</span></div><div class=\"line\"><span class=\"keyword\">template</span> declaration；              <span class=\"comment\">//实例化定义</span></div></pre></td></tr></table></figure>\n<p>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//实例化声明与定义</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">template</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blob</span>&lt;string&gt;;</span>         <span class=\"comment\">//声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;,<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;)</span></span>;       <span class=\"comment\">//定义</span></div></pre></td></tr></table></figure>\n<p>当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>\n<p><strong>警告：</strong> 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</p>\n<h3 id=\"实例化定义会实例化所有成员\"><a href=\"#实例化定义会实例化所有成员\" class=\"headerlink\" title=\"实例化定义会实例化所有成员\"></a>实例化定义会实例化所有成员</h3><p>一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。</p>\n<p><strong>note:</strong> 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。</p>"},{"title":"2019华为春招实习机试题","date":"2018-03-29T13:59:00.000Z","update":null,"comments":1,"_content":"\n# 前言\n\n2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。\n\n<!--more-->\n\n\n# 题目\n\n1. Rake接收最大径索引。\n\n在无线通信接收，接收到的信号一般会有RAKE多经。现给出RAKE接收机21径能量；多经索引为0-20；用一个4径的接收窗在21径上进行滑动，滑动窗口判断什么位置接收最大能量。接收窗索引以窗内第一径的索引为准。比如窗最大能量框住径为0,1,2,3；则窗索引为0；如果两个窗的能量一样，则以索引最小为输出。\n\n遍历一边，求出各个能量窗的值，找出最大的的能量窗的索引输出。\n\n```C++\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int num;\n    vector<int> ivec;\n    while(cin>>num){\n        ivec.push_back(num);\n    }\n    vector<int> result = {0};\n    int window_sum = 0;\n    for(int i=0;i<4;++i){\n        window_sum+=ivec[i];\n    }\n    result.push_back(window_sum);\n    for(int i=4; i<ivec.size();++i){\n        window_sum = window_sum-ivec[i-4]+ivec[i];\n        result.push_back(window_sum);\n    }\n    int min_index = 0;\n    int max_value = result[0];\n    for(int i=1; i<result.size(); ++i){\n        if(result[i] > max_value){\n            max_value = result[i];\n            min_index = i;\n        }\n    }\n    cout << min_index-1 << endl;\n    return 0;\n}\n```\n\n2. 输入一个字符串，表示按照标准键盘输入动作，在自然键盘上打字产生的字符串。输出打字人在标准键盘上要打印的实际内容。\n\n比如输入“H kz k xif\"，输出”I am a boy\"。\n\n    标准键盘：\"QWERTYUIOPASDFGHJKLZXCVBNM\"\n    自然键盘：\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n```C++\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main(){\n    char str[256] = {0};\n    string sta = \"QWERTYUIOPASDFGHJKLZXCVBNM\";\n    string nat = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int size = sta.size();\n    for(int i=0;i<size;++i){\n        str[nat[i]] = sta[i];  //大写的转换\n        str[nat[i]+32] = sta[i]+32;  //小写的转换\n    }\n    string input;\n    string output = \"\";\n    getline(cin,input);\n    int length = input.size();\n    for(int i=0;i<length;++i){\n        if((input[i]>='A'&&input[i]<='Z') || (input[i]>='a'&&input[i]<='z')){\n            cout<<str[input[i]];\n        }\n        else{\n            cout<<input[i];\n        }\n    }\n    cout<<endl;\n    return 0;\n}\n```\n\n3. 最大连续字数组的和\n\n输入：2，-3,4,11，-5,8,3，-6\n\n输出：21\n\n不知道为啥只通过了80%，先对字符串拆分出各个数字，然后通过动态规划求出最大连续子串和。\n\n    f(i) = max(f(i)+ivec[i],ivec[i]);\n    res = max(res,f(i));\n\n```C++\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nint main()\n{\n    string s;\n    getline(cin,s);\n    int size = s.size();\n    int flag = true;\n    long long num=0;\n    vector<long long> ivec;\n    for(int i=0;i<size;++i){\n        if(s[i]=='-') flag = false;   //如果是负数\n        else if(s[i]=='+') flag = true;   //如果是正数\n        else if(s[i]>='0'&&s[i]<='9') num = num*10+(s[i]-'0');\n        else if(s[i]==','){  //遇到逗号\n            num = flag?num:-1*num;\n            ivec.push_back(num);\n            flag = true;\n            num = 0;\n        }else if(s[i]==' ') continue;\n        else{   //输入错误\n            cout<<\"输入有误\"<<endl;\n            return 0;\n        }\n    }\n    num = flag?num:(-1)*num;\n    ivec.push_back(num);\n    long long maxsubarray = ivec[0];  //先假设最大值为nums[0] 后面依次更新\n    long long sum = 0;\n    for(int i=0;i<ivec.size();++i){\n        sum += ivec[i];\n        if(sum>maxsubarray) maxsubarray = sum;\n        if(sum<0) sum = 0;\n    }\n    cout<<maxsubarray<<endl;\n    return 0;\n}\n```","source":"_posts/2019华为春招实习机试题.md","raw":"---\ntitle: 2019华为春招实习机试题\ndate: 2018-03-29 21:59:00\nupdate: \ntags: [编程]\ncategories: 春招笔试\ncomments: true\n---\n\n# 前言\n\n2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。\n\n<!--more-->\n\n\n# 题目\n\n1. Rake接收最大径索引。\n\n在无线通信接收，接收到的信号一般会有RAKE多经。现给出RAKE接收机21径能量；多经索引为0-20；用一个4径的接收窗在21径上进行滑动，滑动窗口判断什么位置接收最大能量。接收窗索引以窗内第一径的索引为准。比如窗最大能量框住径为0,1,2,3；则窗索引为0；如果两个窗的能量一样，则以索引最小为输出。\n\n遍历一边，求出各个能量窗的值，找出最大的的能量窗的索引输出。\n\n```C++\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int num;\n    vector<int> ivec;\n    while(cin>>num){\n        ivec.push_back(num);\n    }\n    vector<int> result = {0};\n    int window_sum = 0;\n    for(int i=0;i<4;++i){\n        window_sum+=ivec[i];\n    }\n    result.push_back(window_sum);\n    for(int i=4; i<ivec.size();++i){\n        window_sum = window_sum-ivec[i-4]+ivec[i];\n        result.push_back(window_sum);\n    }\n    int min_index = 0;\n    int max_value = result[0];\n    for(int i=1; i<result.size(); ++i){\n        if(result[i] > max_value){\n            max_value = result[i];\n            min_index = i;\n        }\n    }\n    cout << min_index-1 << endl;\n    return 0;\n}\n```\n\n2. 输入一个字符串，表示按照标准键盘输入动作，在自然键盘上打字产生的字符串。输出打字人在标准键盘上要打印的实际内容。\n\n比如输入“H kz k xif\"，输出”I am a boy\"。\n\n    标准键盘：\"QWERTYUIOPASDFGHJKLZXCVBNM\"\n    自然键盘：\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n```C++\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main(){\n    char str[256] = {0};\n    string sta = \"QWERTYUIOPASDFGHJKLZXCVBNM\";\n    string nat = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int size = sta.size();\n    for(int i=0;i<size;++i){\n        str[nat[i]] = sta[i];  //大写的转换\n        str[nat[i]+32] = sta[i]+32;  //小写的转换\n    }\n    string input;\n    string output = \"\";\n    getline(cin,input);\n    int length = input.size();\n    for(int i=0;i<length;++i){\n        if((input[i]>='A'&&input[i]<='Z') || (input[i]>='a'&&input[i]<='z')){\n            cout<<str[input[i]];\n        }\n        else{\n            cout<<input[i];\n        }\n    }\n    cout<<endl;\n    return 0;\n}\n```\n\n3. 最大连续字数组的和\n\n输入：2，-3,4,11，-5,8,3，-6\n\n输出：21\n\n不知道为啥只通过了80%，先对字符串拆分出各个数字，然后通过动态规划求出最大连续子串和。\n\n    f(i) = max(f(i)+ivec[i],ivec[i]);\n    res = max(res,f(i));\n\n```C++\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nint main()\n{\n    string s;\n    getline(cin,s);\n    int size = s.size();\n    int flag = true;\n    long long num=0;\n    vector<long long> ivec;\n    for(int i=0;i<size;++i){\n        if(s[i]=='-') flag = false;   //如果是负数\n        else if(s[i]=='+') flag = true;   //如果是正数\n        else if(s[i]>='0'&&s[i]<='9') num = num*10+(s[i]-'0');\n        else if(s[i]==','){  //遇到逗号\n            num = flag?num:-1*num;\n            ivec.push_back(num);\n            flag = true;\n            num = 0;\n        }else if(s[i]==' ') continue;\n        else{   //输入错误\n            cout<<\"输入有误\"<<endl;\n            return 0;\n        }\n    }\n    num = flag?num:(-1)*num;\n    ivec.push_back(num);\n    long long maxsubarray = ivec[0];  //先假设最大值为nums[0] 后面依次更新\n    long long sum = 0;\n    for(int i=0;i<ivec.size();++i){\n        sum += ivec[i];\n        if(sum>maxsubarray) maxsubarray = sum;\n        if(sum<0) sum = 0;\n    }\n    cout<<maxsubarray<<endl;\n    return 0;\n}\n```","slug":"2019华为春招实习机试题","published":1,"updated":"2018-03-29T14:01:30.427Z","layout":"post","photos":[],"link":"","_id":"cjfcldds90000u4c9d0smelj7","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><ol>\n<li>Rake接收最大径索引。</li>\n</ol>\n<p>在无线通信接收，接收到的信号一般会有RAKE多经。现给出RAKE接收机21径能量；多经索引为0-20；用一个4径的接收窗在21径上进行滑动，滑动窗口判断什么位置接收最大能量。接收窗索引以窗内第一径的索引为准。比如窗最大能量框住径为0,1,2,3；则窗索引为0；如果两个窗的能量一样，则以索引最小为输出。</p>\n<p>遍历一边，求出各个能量窗的值，找出最大的的能量窗的索引输出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> num;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec;</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;num)&#123;</div><div class=\"line\">        ivec.push_back(num);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result = &#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> window_sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)&#123;</div><div class=\"line\">        window_sum+=ivec[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    result.push_back(window_sum);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">4</span>; i&lt;ivec.size();++i)&#123;</div><div class=\"line\">        window_sum = window_sum-ivec[i<span class=\"number\">-4</span>]+ivec[i];</div><div class=\"line\">        result.push_back(window_sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> min_index = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> max_value = result[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;result.size(); ++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(result[i] &gt; max_value)&#123;</div><div class=\"line\">            max_value = result[i];</div><div class=\"line\">            min_index = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; min_index<span class=\"number\">-1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>输入一个字符串，表示按照标准键盘输入动作，在自然键盘上打字产生的字符串。输出打字人在标准键盘上要打印的实际内容。</li>\n</ol>\n<p>比如输入“H kz k xif”，输出”I am a boy”。</p>\n<pre><code>标准键盘：&quot;QWERTYUIOPASDFGHJKLZXCVBNM&quot;\n自然键盘：&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">string</span> sta = <span class=\"string\">\"QWERTYUIOPASDFGHJKLZXCVBNM\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> nat = <span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> size = sta.size();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i)&#123;</div><div class=\"line\">        str[nat[i]] = sta[i];  <span class=\"comment\">//大写的转换</span></div><div class=\"line\">        str[nat[i]+<span class=\"number\">32</span>] = sta[i]+<span class=\"number\">32</span>;  <span class=\"comment\">//小写的转换</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">string</span> input;</div><div class=\"line\">    <span class=\"built_in\">string</span> output = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    getline(<span class=\"built_in\">cin</span>,input);</div><div class=\"line\">    <span class=\"keyword\">int</span> length = input.size();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>((input[i]&gt;=<span class=\"string\">'A'</span>&amp;&amp;input[i]&lt;=<span class=\"string\">'Z'</span>) || (input[i]&gt;=<span class=\"string\">'a'</span>&amp;&amp;input[i]&lt;=<span class=\"string\">'z'</span>))&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;str[input[i]];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;input[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>最大连续字数组的和</li>\n</ol>\n<p>输入：2，-3,4,11，-5,8,3，-6</p>\n<p>输出：21</p>\n<p>不知道为啥只通过了80%，先对字符串拆分出各个数字，然后通过动态规划求出最大连续子串和。</p>\n<pre><code>f(i) = max(f(i)+ivec[i],ivec[i]);\nres = max(res,f(i));\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> s;</div><div class=\"line\">    getline(<span class=\"built_in\">cin</span>,s);</div><div class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</div><div class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> num=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; ivec;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">'-'</span>) flag = <span class=\"literal\">false</span>;   <span class=\"comment\">//如果是负数</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">'+'</span>) flag = <span class=\"literal\">true</span>;   <span class=\"comment\">//如果是正数</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&gt;=<span class=\"string\">'0'</span>&amp;&amp;s[i]&lt;=<span class=\"string\">'9'</span>) num = num*<span class=\"number\">10</span>+(s[i]-<span class=\"string\">'0'</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">','</span>)&#123;  <span class=\"comment\">//遇到逗号</span></div><div class=\"line\">            num = flag?num:<span class=\"number\">-1</span>*num;</div><div class=\"line\">            ivec.push_back(num);</div><div class=\"line\">            flag = <span class=\"literal\">true</span>;</div><div class=\"line\">            num = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">' '</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//输入错误</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"输入有误\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    num = flag?num:(<span class=\"number\">-1</span>)*num;</div><div class=\"line\">    ivec.push_back(num);</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> maxsubarray = ivec[<span class=\"number\">0</span>];  <span class=\"comment\">//先假设最大值为nums[0] 后面依次更新</span></div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;ivec.size();++i)&#123;</div><div class=\"line\">        sum += ivec[i];</div><div class=\"line\">        <span class=\"keyword\">if</span>(sum&gt;maxsubarray) maxsubarray = sum;</div><div class=\"line\">        <span class=\"keyword\">if</span>(sum&lt;<span class=\"number\">0</span>) sum = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;maxsubarray&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。</p>","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><ol>\n<li>Rake接收最大径索引。</li>\n</ol>\n<p>在无线通信接收，接收到的信号一般会有RAKE多经。现给出RAKE接收机21径能量；多经索引为0-20；用一个4径的接收窗在21径上进行滑动，滑动窗口判断什么位置接收最大能量。接收窗索引以窗内第一径的索引为准。比如窗最大能量框住径为0,1,2,3；则窗索引为0；如果两个窗的能量一样，则以索引最小为输出。</p>\n<p>遍历一边，求出各个能量窗的值，找出最大的的能量窗的索引输出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> num;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivec;</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;num)&#123;</div><div class=\"line\">        ivec.push_back(num);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result = &#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> window_sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;++i)&#123;</div><div class=\"line\">        window_sum+=ivec[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    result.push_back(window_sum);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">4</span>; i&lt;ivec.size();++i)&#123;</div><div class=\"line\">        window_sum = window_sum-ivec[i<span class=\"number\">-4</span>]+ivec[i];</div><div class=\"line\">        result.push_back(window_sum);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> min_index = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> max_value = result[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;result.size(); ++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(result[i] &gt; max_value)&#123;</div><div class=\"line\">            max_value = result[i];</div><div class=\"line\">            min_index = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; min_index<span class=\"number\">-1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>输入一个字符串，表示按照标准键盘输入动作，在自然键盘上打字产生的字符串。输出打字人在标准键盘上要打印的实际内容。</li>\n</ol>\n<p>比如输入“H kz k xif”，输出”I am a boy”。</p>\n<pre><code>标准键盘：&quot;QWERTYUIOPASDFGHJKLZXCVBNM&quot;\n自然键盘：&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">string</span> sta = <span class=\"string\">\"QWERTYUIOPASDFGHJKLZXCVBNM\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> nat = <span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> size = sta.size();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i)&#123;</div><div class=\"line\">        str[nat[i]] = sta[i];  <span class=\"comment\">//大写的转换</span></div><div class=\"line\">        str[nat[i]+<span class=\"number\">32</span>] = sta[i]+<span class=\"number\">32</span>;  <span class=\"comment\">//小写的转换</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">string</span> input;</div><div class=\"line\">    <span class=\"built_in\">string</span> output = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    getline(<span class=\"built_in\">cin</span>,input);</div><div class=\"line\">    <span class=\"keyword\">int</span> length = input.size();</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;length;++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>((input[i]&gt;=<span class=\"string\">'A'</span>&amp;&amp;input[i]&lt;=<span class=\"string\">'Z'</span>) || (input[i]&gt;=<span class=\"string\">'a'</span>&amp;&amp;input[i]&lt;=<span class=\"string\">'z'</span>))&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;str[input[i]];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;input[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>最大连续字数组的和</li>\n</ol>\n<p>输入：2，-3,4,11，-5,8,3，-6</p>\n<p>输出：21</p>\n<p>不知道为啥只通过了80%，先对字符串拆分出各个数字，然后通过动态规划求出最大连续子串和。</p>\n<pre><code>f(i) = max(f(i)+ivec[i],ivec[i]);\nres = max(res,f(i));\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> s;</div><div class=\"line\">    getline(<span class=\"built_in\">cin</span>,s);</div><div class=\"line\">    <span class=\"keyword\">int</span> size = s.size();</div><div class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> num=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; ivec;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;size;++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">'-'</span>) flag = <span class=\"literal\">false</span>;   <span class=\"comment\">//如果是负数</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">'+'</span>) flag = <span class=\"literal\">true</span>;   <span class=\"comment\">//如果是正数</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&gt;=<span class=\"string\">'0'</span>&amp;&amp;s[i]&lt;=<span class=\"string\">'9'</span>) num = num*<span class=\"number\">10</span>+(s[i]-<span class=\"string\">'0'</span>);</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">','</span>)&#123;  <span class=\"comment\">//遇到逗号</span></div><div class=\"line\">            num = flag?num:<span class=\"number\">-1</span>*num;</div><div class=\"line\">            ivec.push_back(num);</div><div class=\"line\">            flag = <span class=\"literal\">true</span>;</div><div class=\"line\">            num = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">' '</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//输入错误</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"输入有误\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    num = flag?num:(<span class=\"number\">-1</span>)*num;</div><div class=\"line\">    ivec.push_back(num);</div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> maxsubarray = ivec[<span class=\"number\">0</span>];  <span class=\"comment\">//先假设最大值为nums[0] 后面依次更新</span></div><div class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;ivec.size();++i)&#123;</div><div class=\"line\">        sum += ivec[i];</div><div class=\"line\">        <span class=\"keyword\">if</span>(sum&gt;maxsubarray) maxsubarray = sum;</div><div class=\"line\">        <span class=\"keyword\">if</span>(sum&lt;<span class=\"number\">0</span>) sum = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;maxsubarray&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjcj3yifq0000jgc9460lm50w","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yigg000ajgc9o7oyv60y"},{"post_id":"cjcj3yigc0006jgc9gbvyvs9n","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yigo000ejgc9ox18k58a"},{"post_id":"cjcj3yifw0001jgc9i9owkvzn","category_id":"cjcj3yigd0007jgc93z1g8zjj","_id":"cjcj3yigq000gjgc9990z4nvg"},{"post_id":"cjcj3yigh000bjgc9jgmv1jid","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yigs000kjgc98xajz7w7"},{"post_id":"cjcj3yig30004jgc9gcpbt36a","category_id":"cjcj3yigd0007jgc93z1g8zjj","_id":"cjcj3yigs000ljgc90m6p3tp2"},{"post_id":"cjcj3yig70005jgc9xewuxbuq","category_id":"cjcj3yigq000ijgc9ukau0xuf","_id":"cjcj3yigu000pjgc9ondxnmcn"},{"post_id":"cjcj3yige0009jgc9ipd8dhvt","category_id":"cjcj3yigt000mjgc9giavsatu","_id":"cjcj3yigw000sjgc97ua9edzp"},{"post_id":"cjcj3yiox001bjgc9pv7zphoe","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yip7001ijgc91gqnebhv"},{"post_id":"cjcj3yip0001djgc9no0t1u7n","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yipe001mjgc9e841ntml"},{"post_id":"cjcj3yip8001jjgc9zx3kj0ut","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yipl001rjgc9yp6hc0wd"},{"post_id":"cjcj3yipf001njgc9tpl4cwbl","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yipp001ujgc91hy6cq8w"},{"post_id":"cjcj3yipi001qjgc97ny0umrf","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjcj3yips001vjgc9qkir4ze4"},{"post_id":"cjcj3yip5001gjgc9dfbhd5jg","category_id":"cjcj3yipe001ljgc9e35us5e9","_id":"cjcj3yipt001xjgc913e90x3c"},{"post_id":"cjdz6yqtr00007wc9ojqyx5x5","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yqu800047wc9kf9rw6l4"},{"post_id":"cjdz6yqtx00017wc9lk269ngh","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yqub00067wc9jsd9lrnb"},{"post_id":"cjdz6yqu600037wc9kzdlh71c","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yquf00097wc96pv27nkw"},{"post_id":"cjdz6yqu900057wc94n6r7759","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yqui000c7wc9c5d21frw"},{"post_id":"cjdz6yquc00077wc9bdc5y44u","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yqum000f7wc9cmpl0ypz"},{"post_id":"cjdz6yqug000b7wc9yfs6tevw","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yqum000h7wc94ioes2z3"},{"post_id":"cjdz6yquj000d7wc9iylm35c2","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yqun000j7wc967808olh"},{"post_id":"cjdz6yqve000w7wc9ynwvhrhc","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdz6yqvx000y7wc9nbjj42fi"},{"post_id":"cjdznieh40000h4c9bzv2pz5e","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdzniehy0004h4c96vzbbfb6"},{"post_id":"cjdzniehg0001h4c98czz6779","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdzniei10007h4c9zeob7lql"},{"post_id":"cjdzniehw0003h4c9mqyoxzxd","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdzniei30009h4c9yku3eevd"},{"post_id":"cjdzniehz0005h4c9c89q9ope","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdzniei4000bh4c9cc9ccura"},{"post_id":"cjdznieir000fh4c990esg3na","category_id":"cjcj3yifz0002jgc9bguctzwf","_id":"cjdznieiu000hh4c95yapc6pu"},{"post_id":"cjfcldds90000u4c9d0smelj7","category_id":"cjfclddsl0001u4c9wf05dtaf","_id":"cjfclddt00003u4c98h9plbdy"}],"PostTag":[{"post_id":"cjcj3yifq0000jgc9460lm50w","tag_id":"cjcj3yig20003jgc917tsbcz5","_id":"cjcj3yigp000fjgc9ije02ucq"},{"post_id":"cjcj3yifq0000jgc9460lm50w","tag_id":"cjcj3yigd0008jgc9152n74ps","_id":"cjcj3yigq000hjgc98t541v3a"},{"post_id":"cjcj3yifw0001jgc9i9owkvzn","tag_id":"cjcj3yign000djgc9l56b0sre","_id":"cjcj3yigu000ojgc94cobj0ns"},{"post_id":"cjcj3yifw0001jgc9i9owkvzn","tag_id":"cjcj3yigr000jjgc9v5lddpn9","_id":"cjcj3yigu000qjgc9086ldiln"},{"post_id":"cjcj3yig30004jgc9gcpbt36a","tag_id":"cjcj3yign000djgc9l56b0sre","_id":"cjcj3yigy000ujgc9elmbsxfl"},{"post_id":"cjcj3yig30004jgc9gcpbt36a","tag_id":"cjcj3yigr000jjgc9v5lddpn9","_id":"cjcj3yigy000vjgc9bqzvd3vo"},{"post_id":"cjcj3yig70005jgc9xewuxbuq","tag_id":"cjcj3yigw000tjgc9eyy4er32","_id":"cjcj3yih0000yjgc9sql51fjt"},{"post_id":"cjcj3yig70005jgc9xewuxbuq","tag_id":"cjcj3yigy000wjgc9xzv7872x","_id":"cjcj3yih0000zjgc98rcp9tha"},{"post_id":"cjcj3yigc0006jgc9gbvyvs9n","tag_id":"cjcj3yigz000xjgc980dcpwb0","_id":"cjcj3yih10011jgc9v0isw9o5"},{"post_id":"cjcj3yige0009jgc9ipd8dhvt","tag_id":"cjcj3yih00010jgc9j61ylg4h","_id":"cjcj3yih20015jgc9nb2r7qt9"},{"post_id":"cjcj3yige0009jgc9ipd8dhvt","tag_id":"cjcj3yih10012jgc9eeaxzzcz","_id":"cjcj3yih30016jgc9llkrzkw7"},{"post_id":"cjcj3yige0009jgc9ipd8dhvt","tag_id":"cjcj3yigy000wjgc9xzv7872x","_id":"cjcj3yih30018jgc9ntz678pu"},{"post_id":"cjcj3yigh000bjgc9jgmv1jid","tag_id":"cjcj3yih20014jgc9qy6io4q7","_id":"cjcj3yih40019jgc9vqn3rxi0"},{"post_id":"cjcj3yigh000bjgc9jgmv1jid","tag_id":"cjcj3yih30017jgc99851lyze","_id":"cjcj3yih4001ajgc9v2i9fhem"},{"post_id":"cjcj3yipi001qjgc97ny0umrf","tag_id":"cjcj3yipg001ojgc9v5tcpn1q","_id":"cjcj3yipo001tjgc98fk6m5a7"},{"post_id":"cjcj3yiox001bjgc9pv7zphoe","tag_id":"cjcj3yip4001fjgc93vebx00b","_id":"cjcj3yipu001yjgc9pbpyhcqs"},{"post_id":"cjcj3yiox001bjgc9pv7zphoe","tag_id":"cjcj3yipg001ojgc9v5tcpn1q","_id":"cjcj3yipu001zjgc9n53o3r0s"},{"post_id":"cjcj3yiox001bjgc9pv7zphoe","tag_id":"cjcj3yipm001sjgc9dk2n76li","_id":"cjcj3yipv0021jgc9wd74o6ah"},{"post_id":"cjcj3yip0001djgc9no0t1u7n","tag_id":"cjcj3yipt001wjgc99jqljbhj","_id":"cjcj3yipv0022jgc97ir3xm8l"},{"post_id":"cjcj3yip5001gjgc9dfbhd5jg","tag_id":"cjcj3yipu0020jgc97iblvo7y","_id":"cjcj3yipx0025jgc9wko3l8ex"},{"post_id":"cjcj3yip5001gjgc9dfbhd5jg","tag_id":"cjcj3yipw0023jgc97tq7vozg","_id":"cjcj3yipx0026jgc9c2vu3ztt"},{"post_id":"cjcj3yip8001jjgc9zx3kj0ut","tag_id":"cjcj3yipw0024jgc9kulyfqro","_id":"cjcj3yipz0029jgc91omhcq3g"},{"post_id":"cjcj3yip8001jjgc9zx3kj0ut","tag_id":"cjcj3yipy0027jgc91txntx8v","_id":"cjcj3yipz002ajgc9cslg5rmu"},{"post_id":"cjcj3yipf001njgc9tpl4cwbl","tag_id":"cjcj3yipy0028jgc992sgujq3","_id":"cjcj3yiq0002bjgc9uvuwqy0n"},{"post_id":"cjdz6yqtr00007wc9ojqyx5x5","tag_id":"cjdz6yqu000027wc916z8hbam","_id":"cjdz6yquf000a7wc9qflllox5"},{"post_id":"cjdz6yqtx00017wc9lk269ngh","tag_id":"cjdz6yque00087wc98cdhxq0a","_id":"cjdz6yqum000g7wc94oceov5j"},{"post_id":"cjdz6yqu600037wc9kzdlh71c","tag_id":"cjdz6yqul000e7wc9nq53lprw","_id":"cjdz6yquo000k7wc9z84wdm5h"},{"post_id":"cjdz6yqu900057wc94n6r7759","tag_id":"cjdz6yqun000i7wc90dwa0yh6","_id":"cjdz6yqup000n7wc9x8flodsf"},{"post_id":"cjdz6yqu900057wc94n6r7759","tag_id":"cjdz6yquo000l7wc9nvfvrsu5","_id":"cjdz6yqup000o7wc9qyvl9prd"},{"post_id":"cjdz6yquc00077wc9bdc5y44u","tag_id":"cjdz6yqup000m7wc9mns1wyw2","_id":"cjdz6yqur000q7wc9gadqi1ci"},{"post_id":"cjdz6yqug000b7wc9yfs6tevw","tag_id":"cjdz6yquq000p7wc9ls4xlvte","_id":"cjdz6yquu000t7wc98u7ecyyt"},{"post_id":"cjdz6yqug000b7wc9yfs6tevw","tag_id":"cjdz6yqus000r7wc9wrrwiy41","_id":"cjdz6yquv000u7wc9naf58cr8"},{"post_id":"cjdz6yquj000d7wc9iylm35c2","tag_id":"cjdz6yqut000s7wc9wstramaz","_id":"cjdz6yquv000v7wc9kpwytfvb"},{"post_id":"cjdz6yqve000w7wc9ynwvhrhc","tag_id":"cjdz6yqvw000x7wc9p8wun2nl","_id":"cjdz6yqvx000z7wc9q4yh3xqo"},{"post_id":"cjdzniehw0003h4c9mqyoxzxd","tag_id":"cjcj3yipy0028jgc992sgujq3","_id":"cjdzniei10006h4c98z7yt1lj"},{"post_id":"cjdznieh40000h4c9bzv2pz5e","tag_id":"cjdzniehk0002h4c9w60eqeri","_id":"cjdzniei4000ah4c9h9n7v6s1"},{"post_id":"cjdzniehg0001h4c98czz6779","tag_id":"cjdzniei20008h4c9yqti02zx","_id":"cjdzniei5000dh4c98cwlmck2"},{"post_id":"cjdzniehz0005h4c9c89q9ope","tag_id":"cjdzniei4000ch4c9ts0o7hd6","_id":"cjdzniei6000eh4c9sft26wnn"},{"post_id":"cjdznieir000fh4c990esg3na","tag_id":"cjdzniehk0002h4c9w60eqeri","_id":"cjdznieiu000gh4c9enki6kof"},{"post_id":"cjfcldds90000u4c9d0smelj7","tag_id":"cjcj3yigy000wjgc9xzv7872x","_id":"cjfclddsx0002u4c9f7lsh7h7"}],"Tag":[{"name":"I/O流","_id":"cjcj3yig20003jgc917tsbcz5"},{"name":"string流","_id":"cjcj3yigd0008jgc9152n74ps"},{"name":"hexo","_id":"cjcj3yign000djgc9l56b0sre"},{"name":"github","_id":"cjcj3yigr000jjgc9v5lddpn9"},{"name":"排序","_id":"cjcj3yigw000tjgc9eyy4er32"},{"name":"编程","_id":"cjcj3yigy000wjgc9xzv7872x"},{"name":"函数","_id":"cjcj3yigz000xjgc980dcpwb0"},{"name":"剑指offer","_id":"cjcj3yih00010jgc9j61ylg4h"},{"name":"刷题","_id":"cjcj3yih10012jgc9eeaxzzcz"},{"name":"C++ Primers","_id":"cjcj3yih20014jgc9qy6io4q7"},{"name":"C++基础知识","_id":"cjcj3yih30017jgc99851lyze"},{"name":"static成员","_id":"cjcj3yip4001fjgc93vebx00b"},{"name":"C++","_id":"cjcj3yipg001ojgc9v5tcpn1q"},{"name":"类定义","_id":"cjcj3yipm001sjgc9dk2n76li"},{"name":"顺序容器","_id":"cjcj3yipt001wjgc99jqljbhj"},{"name":"兄弟","_id":"cjcj3yipu0020jgc97iblvo7y"},{"name":"朋友","_id":"cjcj3yipw0023jgc97tq7vozg"},{"name":"数组","_id":"cjcj3yipw0024jgc9kulyfqro"},{"name":"指针","_id":"cjcj3yipy0027jgc91txntx8v"},{"name":"异常处理","_id":"cjcj3yipy0028jgc992sgujq3"},{"name":"OOP","_id":"cjdz6yqu000027wc916z8hbam"},{"name":"右值引用","_id":"cjdz6yque00087wc98cdhxq0a"},{"name":"关联容器","_id":"cjdz6yqul000e7wc9nq53lprw"},{"name":"智能指针","_id":"cjdz6yqun000i7wc90dwa0yh6"},{"name":"内存分配","_id":"cjdz6yquo000l7wc9nvfvrsu5"},{"name":"虚函数","_id":"cjdz6yqup000m7wc9mns1wyw2"},{"name":"构造函数","_id":"cjdz6yquq000p7wc9ls4xlvte"},{"name":"拷贝控制","_id":"cjdz6yqus000r7wc9wrrwiy41"},{"name":"泛型","_id":"cjdz6yqut000s7wc9wstramaz"},{"name":"运算符重载","_id":"cjdz6yqvw000x7wc9p8wun2nl"},{"name":"模板","_id":"cjdzniehk0002h4c9w60eqeri"},{"name":"虚继承","_id":"cjdzniei20008h4c9yqti02zx"},{"name":"面向对象","_id":"cjdzniei4000ch4c9ts0o7hd6"}]}}