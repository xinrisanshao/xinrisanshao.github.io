---
title: OOP概述（object-oriented programming）
date: 2017-11-19 21:59:00
update: 
tags: [OOP]
categories: C++
comments: true
---

## 前言

面向对象程序设计基于三个基本概念：**数据抽象、继承和动态绑定**。

<!--more-->

**继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。**

## OOP：概述

面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

### 继承

通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。

### 动态绑定

函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为**运行时绑定**。

**note:** **在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定**。


## 定义基类和派生类

**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。**

### 成员函数和继承

派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以**覆盖**（override）从基类继承而来的旧定义。

在C++语言中，基类必须将它的两种成员函数区分开来：**一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数**。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，**该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。**

基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。**任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。**

成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。

### 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，**派生类能访问公用成员，而不能访问私有成员**。不过在某些时候基类中还有这样一种成员，**基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员**。

- private member: base class itself and friend can access
- protected members: base class itself,friend and derived classes can access

## 定义派生类

派生类必须通过使用**派生类列表**明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。

如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。

### 派生类中的虚函数

派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字**override**。


### 派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。

**在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。**

### 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。

```C++
//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分
    Bulk_quote(const string& book,double p,size_t qty,double disc):Quote(book,p),min_qty(qty),discount(disc) {}
```

<font color=red> **首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员** </font>


### 派生类使用基类的成员

**派生类可以访问基类的公有成员和受保护成员**：

其中price是基类中的受保护成员

```C++
//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了
double Bulk_quote::net_price(size_t cnt) const {
    if(cnt >= min_qty) {
        return cnt*(1-discount)*price;
    }else{
        return cnt*price;
    }
}
```

**遵循基类的接口**

必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。

因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。

### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

```C++
class Base{
public:
    static void statmem();
};
class Derived:public Base{
    void f(const Derived&);
};
```

静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它：

```
void Derived::f(const Derived &derived_obj){
    Base::statmem();
    Derived::statmem();
    derived_obj.statmem();
    statmem();         //通过this对象访问
}
```

### 派生类的声明

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。

一个类不能派生它本身。

### 防止继承发生

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，**即在类名后跟一个关键字final**。


## 类型抓换与继承

**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。**

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：**我们可以将基类的指针或引用绑定到派生类对象上**。

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。

### 不存在从基类向派生类的隐式类型转换


因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换：

```C++
Quote base;
Bulk_quote* bulkP = &base;    //错误：不能将基类转换成派生类
Bulk_quote* bulkRef = base;   //错误：不能将基类转换成派生类
```
除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：

```C++
Bulk_quote bulk;
Quote *itemP = &bulk;      //正确：动态类型是Bulk_quote
Bulk_quote *bulkP = itemP;      //错误：不能将基类转换成派生类
```

### 在对象之间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。

```C++
Bulk_quote bulk;      //派生类对象
Quote item(bulk);     //使用Quote::Quote(const Quote&)  构造函数
item = bulk;          //调用Quote::operator=(const Quote&)
```
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

**关键概念：存在继承关系的类型之间的转换规则**

1、从派生类向基类的类型转换只对指针或引用类型有效。

2、基类向派生类不存在隐式类型转换。

3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。



