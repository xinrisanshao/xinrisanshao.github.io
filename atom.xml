<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>新日三少的博客</title>
  <subtitle>Big big pig</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wangxinri.cn/"/>
  <updated>2018-04-10T09:41:42.168Z</updated>
  <id>http://www.wangxinri.cn/</id>
  
  <author>
    <name>新日三少</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bitmap简单实现</title>
    <link href="http://www.wangxinri.cn/2018/04/08/Bitmap/"/>
    <id>http://www.wangxinri.cn/2018/04/08/Bitmap/</id>
    <published>2018-04-08T13:59:00.000Z</published>
    <updated>2018-04-10T09:41:42.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BitMap算法"><a href="#BitMap算法" class="headerlink" title="BitMap算法"></a>BitMap算法</h1><p>Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<a id="more"></a>
<p>我们知道，一般可以直接操控的最小的单位是字节，比如在C/C++中，定义一个类型char，对它进行各种操作。然后很多时候，面对一个很大数据量，且我们仅仅希望知道某个数是否存在，我们不妨可以（<strong>有时候是必须</strong>）使用Bitmap算法来完成相关操作。比如腾讯的下面这道题：</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在40亿个没有排序的无符号整数中，我们如何快速判断某个无符号整数是否在这40亿个数中？</p>
<p>40亿，这是一个很大的数字，就是海量数据的处理，所以我们必须要考虑到内存的问题。我们知道一个无符号整数的大小为4个字节，那么40亿个需要占多少的内存？4<em>40亿是多大量级？咋一看有点难算，不过我们可以估算一下。<br>1KB=1024B<br>1MB=1024KB<br>1GB=1024MB<br>我们近似估计一下，1GB≈1000 </em> 1000 <em> 1000B= 1 000 000 000B = 10亿B，因此40亿</em>4B / 10亿B = 16G。就是说需要占据大概16GB的内存，这显然对于一般的电脑是不行的。</p>
<p>如果我们可以使用位图来存，一整型占4字节32比特位，因此如果用一个bit来存的话，在上面的例子中仅仅需要16G/32=0.5G大概就是500MB的内存。</p>
<p>题目要求我们快速判断，最快的算法当然是O（1）的操作，我们可以开一个无符号整型最大值的空间（保证这42亿个数都在这个范围内），每个数映射一个bit位，如果存在就将该bit位置1，不然就置0。因此想要查找某个数只需要开他映射的那个比特位是0还是1就可以了。</p>
<p>比如我们想要在这些数中查找一个33。</p>
<p>首先我们要开辟一块size_t（无符号整型）的空间，我们不妨使用整形数组arr来存。 其中每个元素都是size_t占4个字节32位.</p>
<p>刚开始每个空格全是0，这时候我们存一个33，arr[0]对应着0-31的比特位，arr[1]对应着32-63的比特位，因此33就在arr[1]第二个比特位。。。我们只需要将这个比特位置1就好了，到时候查找也是这个位是否为1。</p>
<p>bitmap表为：</p>
<p>arr[0] ——&gt; 0 - 31</p>
<p>arr[1] ——&gt; 32 - 63</p>
<p>arr[2] ——&gt; 64 - 95</p>
<p>arr[3] ——&gt; 96 - 127</p>
<p>结论：<strong>对于任意一个数x，x / 32对应着它在vector的第几个位置，x % 32对应它的比特位。</strong></p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;   <span class="comment">//数组容量为100</span></div><div class="line"><span class="keyword">int</span> arr[N] = &#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;   <span class="comment">//设置num所在位标志为1</span></div><div class="line">    <span class="keyword">int</span> index = num/<span class="number">32</span>;  <span class="comment">//所在数组的对应下标</span></div><div class="line">    <span class="keyword">int</span> pos = num%<span class="number">32</span>;    <span class="comment">//对应下标具体的位置</span></div><div class="line">    arr[index] |= (<span class="number">1</span>&lt;&lt;pos);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasExisted</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//checknum是否存在</span></div><div class="line">    <span class="keyword">int</span> index = num/<span class="number">32</span>;</div><div class="line">    <span class="keyword">int</span> pos = num%<span class="number">32</span>;</div><div class="line">    <span class="keyword">if</span>((arr[index]&amp;(<span class="number">1</span>&lt;&lt;pos))!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    setNumber(<span class="number">10</span>);</div><div class="line">    setNumber(<span class="number">50</span>);</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">10</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"10 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">20</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"20 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"20 is not existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">50</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"50 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BitMap算法&quot;&gt;&lt;a href=&quot;#BitMap算法&quot; class=&quot;headerlink&quot; title=&quot;BitMap算法&quot;&gt;&lt;/a&gt;BitMap算法&lt;/h1&gt;&lt;p&gt;Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wangxinri.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://www.wangxinri.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>58同城春招实习机试题</title>
    <link href="http://www.wangxinri.cn/2018/04/01/201958%E5%90%8C%E5%9F%8E%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/04/01/201958同城春招实习机试题/</id>
    <published>2018-04-01T13:59:00.000Z</published>
    <updated>2018-04-02T02:14:03.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>201958同城春招实习机试题，一共两道编程题，解答题热搜top10问题，用topK来实现的，TCP和UDP在直播中的优缺点，简单的介绍了下TCP和UDP的特点和区别，还涉及到SQL和事务，重复读问题。</p>
<a id="more"></a>
<p>应用题是海量数据问题，统计UID出现的次数并排序，用了hashtable来实现的，并用Introspective sort（内省排序）进行排序，总体来说，难度还可以，主要是一个半小时，时间略少，题量略多。</p>
<p>最后记录两道编程题。</p>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="找出符合条件的子字符串"><a href="#找出符合条件的子字符串" class="headerlink" title="找出符合条件的子字符串"></a>找出符合条件的子字符串</h2><p>比如字符串为“aabbbccddddeeffggghh”，给定大小为n，输出所有长度为n的重复子串，比如n=2，输出(0,1,aa)(5,6,cc)(11,12,ee)(13,14,ff)(18,19,hh)。</p>
<p>通过设置两个指针first和last，通过cnt记录每个字符出现的次数，找到满足次数的字符输出即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSubstr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = str.size();</div><div class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> tem = str[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(str[i]==str[i<span class="number">-1</span>])&#123;</div><div class="line">            ++last;</div><div class="line">            ++cnt;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(cnt == n)&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;first&lt;&lt;<span class="string">","</span>&lt;&lt;last&lt;&lt;<span class="string">","</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="built_in">cout</span>&lt;&lt;tem;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</div><div class="line">            &#125;</div><div class="line">            tem = str[i];</div><div class="line">            first = i;</div><div class="line">            last = i;</div><div class="line">            cnt = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(cnt == n)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;first&lt;&lt;<span class="string">","</span>&lt;&lt;last&lt;&lt;<span class="string">","</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="built_in">cout</span>&lt;&lt;tem;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> str = <span class="string">"aabbbccddddeeffggghh"</span>;</div><div class="line">    GetSubstr(str,<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最大连续字数组的和"><a href="#最大连续字数组的和" class="headerlink" title="最大连续字数组的和"></a>最大连续字数组的和</h2><p>比如输入：2,-3,4,11,-5,8,3,-6</p>
<p>则输出：21</p>
<pre><code>f(i) = max(f(i-1)+ivec[i],ivec[i]);
res = max(res,f(i));
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxSubSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = ivec.size();</div><div class="line">    <span class="keyword">int</span> f1 = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> res = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</div><div class="line">        f1 = max(f1+ivec[i],ivec[i]);</div><div class="line">        res = max(f1,res);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxSubSum1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = ivec.size();</div><div class="line">    <span class="keyword">int</span> res = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</div><div class="line">        sum += ivec[i];</div><div class="line">        <span class="keyword">if</span>(sum&gt;res) res = sum;</div><div class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</div><div class="line">            sum = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">-5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">-6</span>&#125;;</div><div class="line">    <span class="keyword">int</span> result = GetMaxSubSum(ivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    result = GetMaxSubSum1(ivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;201958同城春招实习机试题，一共两道编程题，解答题热搜top10问题，用topK来实现的，TCP和UDP在直播中的优缺点，简单的介绍了下TCP和UDP的特点和区别，还涉及到SQL和事务，重复读问题。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2019华为春招实习机试题</title>
    <link href="http://www.wangxinri.cn/2018/03/29/2019%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/03/29/2019华为春招实习机试题/</id>
    <published>2018-03-29T13:59:00.000Z</published>
    <updated>2018-03-30T01:11:18.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Rake接收最大径索引。"><a href="#Rake接收最大径索引。" class="headerlink" title="Rake接收最大径索引。"></a>Rake接收最大径索引。</h2><p>在无线通信接收，接收到的信号一般会有RAKE多经。现给出RAKE接收机21径能量；多经索引为0-20；用一个4径的接收窗在21径上进行滑动，滑动窗口判断什么位置接收最大能量。接收窗索引以窗内第一径的索引为准。比如窗最大能量框住径为0,1,2,3；则窗索引为0；如果两个窗的能量一样，则以索引最小为输出。</p>
<p>遍历一边，求出各个能量窗的值，找出最大的的能量窗的索引输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;num)&#123;</div><div class="line">        ivec.push_back(num);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">int</span> window_sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</div><div class="line">        window_sum+=ivec[i];</div><div class="line">    &#125;</div><div class="line">    result.push_back(window_sum);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;ivec.size();++i)&#123;</div><div class="line">        window_sum = window_sum-ivec[i<span class="number">-4</span>]+ivec[i];</div><div class="line">        result.push_back(window_sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min_index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max_value = result[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;result.size(); ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(result[i] &gt; max_value)&#123;</div><div class="line">            max_value = result[i];</div><div class="line">            min_index = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; min_index<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="标准键盘与自然键盘映射"><a href="#标准键盘与自然键盘映射" class="headerlink" title="标准键盘与自然键盘映射"></a>标准键盘与自然键盘映射</h2><p>输入一个字符串，表示按照标准键盘输入动作，在自然键盘上打字产生的字符串。输出打字人在标准键盘上要打印的实际内容。</p>
<p>比如输入“H kz k xif”，输出”I am a boy”。</p>
<pre><code>标准键盘：&quot;QWERTYUIOPASDFGHJKLZXCVBNM&quot;
自然键盘：&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> str[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">string</span> sta = <span class="string">"QWERTYUIOPASDFGHJKLZXCVBNM"</span>;</div><div class="line">    <span class="built_in">string</span> nat = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</div><div class="line">    <span class="keyword">int</span> size = sta.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</div><div class="line">        str[nat[i]] = sta[i];  <span class="comment">//大写的转换</span></div><div class="line">        str[nat[i]+<span class="number">32</span>] = sta[i]+<span class="number">32</span>;  <span class="comment">//小写的转换</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">string</span> input;</div><div class="line">    <span class="built_in">string</span> output = <span class="string">""</span>;</div><div class="line">    getline(<span class="built_in">cin</span>,input);</div><div class="line">    <span class="keyword">int</span> length = input.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">        <span class="keyword">if</span>((input[i]&gt;=<span class="string">'A'</span>&amp;&amp;input[i]&lt;=<span class="string">'Z'</span>) || (input[i]&gt;=<span class="string">'a'</span>&amp;&amp;input[i]&lt;=<span class="string">'z'</span>))&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;str[input[i]];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;input[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最大连续字数组的和"><a href="#最大连续字数组的和" class="headerlink" title="最大连续字数组的和"></a>最大连续字数组的和</h2><p>输入：2,-3,4,11,-5,8,3,-6</p>
<p>输出：21</p>
<p>不知道为啥只通过了80%，先对字符串拆分出各个数字，然后通过动态规划求出最大连续子串和。</p>
<pre><code>f(i) = max(f(i-1)+ivec[i],ivec[i]);
res = max(res,f(i));
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    getline(<span class="built_in">cin</span>,s);</div><div class="line">    <span class="keyword">int</span> size = s.size();</div><div class="line">    <span class="keyword">int</span> flag = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ivec;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'-'</span>) flag = <span class="literal">false</span>;   <span class="comment">//如果是负数</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'+'</span>) flag = <span class="literal">true</span>;   <span class="comment">//如果是正数</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>) num = num*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">','</span>)&#123;  <span class="comment">//遇到逗号</span></div><div class="line">            num = flag?num:<span class="number">-1</span>*num;</div><div class="line">            ivec.push_back(num);</div><div class="line">            flag = <span class="literal">true</span>;</div><div class="line">            num = <span class="number">0</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">' '</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">else</span>&#123;   <span class="comment">//输入错误</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入有误"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    num = flag?num:(<span class="number">-1</span>)*num;</div><div class="line">    ivec.push_back(num);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxsubarray = ivec[<span class="number">0</span>];  <span class="comment">//先假设最大值为nums[0] 后面依次更新</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ivec.size();++i)&#123;</div><div class="line">        sum += ivec[i];</div><div class="line">        <span class="keyword">if</span>(sum&gt;maxsubarray) maxsubarray = sum;</div><div class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxsubarray&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序算法实现</title>
    <link href="http://www.wangxinri.cn/2018/03/25/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.wangxinri.cn/2018/03/25/各种排序算法实现/</id>
    <published>2018-03-25T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:37.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各种排序算法的实现，这东西，几天不写，就略感手生，需要定期不断温习，各种排序算法的思想都很清晰，写的过程中需要额外注意边界情况，递归结束条件，各种边界判断条件。没事写写，温故而知新。</p>
<a id="more"></a>
<h1 id="手写排序算法"><a href="#手写排序算法" class="headerlink" title="手写排序算法"></a>手写排序算法</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//选择排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Selection</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"select sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">int</span> mindex = i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&lt;a[mindex]) mindex = j;</div><div class="line">            &#125;</div><div class="line">            swap(a[i],a[mindex]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bubble</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bubble sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length-i<span class="number">-1</span>;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>]) swap(a[j],a[j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Insert</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"insert sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="comment">//找到带插入位置</span></div><div class="line">            <span class="keyword">int</span> tem = a[i];</div><div class="line">            <span class="keyword">int</span> j;</div><div class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                    a[j+<span class="number">1</span>] = a[j];</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            a[j+<span class="number">1</span>] = tem;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//希尔排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shell</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"shell sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(h&lt;length/<span class="number">3</span>) h = <span class="number">3</span>*h+<span class="number">1</span>;   <span class="comment">//增量分别为1,4,13,40,...</span></div><div class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;length;++i)&#123;</div><div class="line">                <span class="keyword">int</span> tem = a[i];</div><div class="line">                <span class="keyword">int</span> j;</div><div class="line">                <span class="keyword">for</span>(j=i-h;j&gt;=<span class="number">0</span>;j-=h)&#123;</div><div class="line">                    <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                        a[j+h] = a[j];</div><div class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                a[j+h] = tem;</div><div class="line">            &#125;</div><div class="line">            h = h/<span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol>
<li><p>递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;  <span class="comment">//将[low,high]进行归并</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</div><div class="line">        Merge_sort(a,low,mid,aux);</div><div class="line">        Merge_sort(a,mid+<span class="number">1</span>,high,aux);</div><div class="line">        Merge(a,low,mid,high,aux);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>非递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoRecMergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="title">norecMergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> aux[])</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"norecMergeSort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>;sz&lt;length;sz=sz+sz)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>;lo&lt;length-sz;lo+=sz+sz)&#123;     <span class="comment">//lo = lo + sz + sz</span></div><div class="line">                Merge(a,lo,lo+sz<span class="number">-1</span>,min(lo+sz+sz<span class="number">-1</span>,length<span class="number">-1</span>),aux);  <span class="comment">// lo lo+sz-1  min(lo+sz+sz-1,length-1)</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//快速排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuickSort</span>&#123;</span>   <span class="comment">//不稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;    <span class="comment">//对[low,high]进行快排</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> j = Partition(a,low,high);</div><div class="line">        quicksort(a,low,j<span class="number">-1</span>);</div><div class="line">        quicksort(a,j+<span class="number">1</span>,high);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> v = a[low];</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(a[++i]&lt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(i==high) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(a[--j]&gt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(j==low) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</div><div class="line">            swap(a[i],a[j]);</div><div class="line">        &#125;</div><div class="line">        swap(a[low],a[j]);</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//堆排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapSort</span>&#123;</span>   <span class="comment">//大根堆</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sink</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> index)</span></span>&#123;   <span class="comment">//数组下标为index的元素进行下沉操作</span></div><div class="line">        <span class="keyword">while</span>(<span class="number">2</span>*index+<span class="number">1</span>&lt;length)&#123;  <span class="comment">//有左孩子节点</span></div><div class="line">            <span class="keyword">int</span> big = <span class="number">2</span>*index+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">2</span>&lt;length) &amp;&amp; (a[<span class="number">2</span>*index+<span class="number">2</span>]&gt;a[<span class="number">2</span>*index+<span class="number">1</span>])) &#123; big = <span class="number">2</span>*index+<span class="number">2</span>; &#125;  <span class="comment">//右子节点存在且大于左子节点</span></div><div class="line">            <span class="keyword">if</span>(a[big]&lt;=a[index]) <span class="keyword">break</span>;  <span class="comment">//已经有序，无须交换</span></div><div class="line">            swap(a[index],a[big]);  <span class="comment">//父节点和左右子节点中的较大值进行交换</span></div><div class="line">            index = big;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>;</div><div class="line">        <span class="comment">//构建堆</span></div><div class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</div><div class="line">            Sink(a,length,i);</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length<span class="number">-1</span>;j&gt;<span class="number">0</span>;--j)&#123;</div><div class="line">            swap(a[j],a[<span class="number">0</span>]);</div><div class="line">            Sink(a,j<span class="number">-1</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="完整程序示例"><a href="#完整程序示例" class="headerlink" title="完整程序示例"></a>完整程序示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//选择排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Selection</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"select sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">int</span> mindex = i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&lt;a[mindex]) mindex = j;</div><div class="line">            &#125;</div><div class="line">            swap(a[i],a[mindex]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//冒泡排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bubble</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bubble sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length-i<span class="number">-1</span>;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>]) swap(a[j],a[j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//插入排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Insert</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"insert sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="comment">//找到带插入位置</span></div><div class="line">            <span class="keyword">int</span> tem = a[i];</div><div class="line">            <span class="keyword">int</span> j;</div><div class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                    a[j+<span class="number">1</span>] = a[j];</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            a[j+<span class="number">1</span>] = tem;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//希尔排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shell</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"shell sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(h&lt;length/<span class="number">3</span>) h = <span class="number">3</span>*h+<span class="number">1</span>;   <span class="comment">//增量分别为1,4,13,40,...</span></div><div class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;length;++i)&#123;</div><div class="line">                <span class="keyword">int</span> tem = a[i];</div><div class="line">                <span class="keyword">int</span> j;</div><div class="line">                <span class="keyword">for</span>(j=i-h;j&gt;=<span class="number">0</span>;j-=h)&#123;</div><div class="line">                    <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                        a[j+h] = a[j];</div><div class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                a[j+h] = tem;</div><div class="line">            &#125;</div><div class="line">            h = h/<span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;  <span class="comment">//将[low,high]进行归并</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</div><div class="line">        Merge_sort(a,low,mid,aux);</div><div class="line">        Merge_sort(a,mid+<span class="number">1</span>,high,aux);</div><div class="line">        Merge(a,low,mid,high,aux);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//非递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoRecMergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="title">norecMergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> aux[])</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"norecMergeSort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>;sz&lt;length;sz=sz+sz)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>;lo&lt;length-sz;lo+=sz+sz)&#123;     <span class="comment">//lo = lo + sz + sz</span></div><div class="line">                Merge(a,lo,lo+sz<span class="number">-1</span>,min(lo+sz+sz<span class="number">-1</span>,length<span class="number">-1</span>),aux);  <span class="comment">// lo lo+sz-1  min(lo+sz+sz-1,length-1)</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">//快速排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuickSort</span>&#123;</span>   <span class="comment">//不稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;    <span class="comment">//对[low,high]进行快排</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> j = Partition(a,low,high);</div><div class="line">        quicksort(a,low,j<span class="number">-1</span>);</div><div class="line">        quicksort(a,j+<span class="number">1</span>,high);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> v = a[low];</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(a[++i]&lt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(i==high) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(a[--j]&gt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(j==low) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</div><div class="line">            swap(a[i],a[j]);</div><div class="line">        &#125;</div><div class="line">        swap(a[low],a[j]);</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//堆排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapSort</span>&#123;</span>   <span class="comment">//大根堆</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sink</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> index)</span></span>&#123;   <span class="comment">//数组下标为index的元素进行下沉操作</span></div><div class="line">        <span class="keyword">while</span>(<span class="number">2</span>*index+<span class="number">1</span>&lt;length)&#123;  <span class="comment">//有左孩子节点</span></div><div class="line">            <span class="keyword">int</span> big = <span class="number">2</span>*index+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">2</span>&lt;length) &amp;&amp; (a[<span class="number">2</span>*index+<span class="number">2</span>]&gt;a[<span class="number">2</span>*index+<span class="number">1</span>])) &#123; big = <span class="number">2</span>*index+<span class="number">2</span>; &#125;  <span class="comment">//右子节点存在且大于左子节点</span></div><div class="line">            <span class="keyword">if</span>(a[big]&lt;=a[index]) <span class="keyword">break</span>;  <span class="comment">//已经有序，无须交换</span></div><div class="line">            swap(a[index],a[big]);  <span class="comment">//父节点和左右子节点中的较大值进行交换</span></div><div class="line">            index = big;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>;</div><div class="line">        <span class="comment">//构建堆</span></div><div class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</div><div class="line">            Sink(a,length,i);</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length<span class="number">-1</span>;j&gt;<span class="number">0</span>;--j)&#123;</div><div class="line">            swap(a[j],a[<span class="number">0</span>]);</div><div class="line">            Sink(a,j<span class="number">-1</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</div><div class="line">    <span class="keyword">int</span> aux[<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="comment">//Selection::select(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//Bubble::bubble(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//Insert::insert(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//Shell::shell(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//MergeSort::Merge_sort(a,0,sizeof(a)/sizeof(a[0])-1,aux);</span></div><div class="line">    <span class="comment">//NoRecMergeSort::norecMergeSort(a,sizeof(a)/sizeof(a[0]),aux);</span></div><div class="line">    <span class="comment">//QuickSort::quicksort(a,0,9);</span></div><div class="line">    HeapSort::heapSort(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</div><div class="line">    display(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;各种排序算法的实现，这东西，几天不写，就略感手生，需要定期不断温习，各种排序算法的思想都很清晰，写的过程中需要额外注意边界情况，递归结束条件，各种边界判断条件。没事写写，温故而知新。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wangxinri.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://www.wangxinri.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的各种操作</title>
    <link href="http://www.wangxinri.cn/2018/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.wangxinri.cn/2018/03/22/二叉树各种操作/</id>
    <published>2018-03-22T13:59:00.000Z</published>
    <updated>2018-04-01T03:11:16.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二叉树的各种操作，前中后序的递归与非递归实现，二叉树的构建（序列化和反序列化），二叉树的最大高度与最小高度，打印出从根节点到叶子的节点的所有路径，打印出根节点到特定节点的路径，反转二叉树，判断两个二叉树是否相等等等操作。</p>
<a id="more"></a>
<p>算法这东西，就得多练，几天不写，还是感觉手生，需要定期不断温习，温故而知新啊，好好努力。</p>
<h1 id="二叉树的各种操作"><a href="#二叉树的各种操作" class="headerlink" title="二叉树的各种操作"></a>二叉树的各种操作</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></div><div class="line">    <span class="keyword">char</span> val;   <span class="comment">//节点值</span></div><div class="line">    TreeNode *left;  <span class="comment">//左节点</span></div><div class="line">    TreeNode *right;  <span class="comment">//右节点</span></div><div class="line">    TreeNode(<span class="keyword">char</span> v=<span class="string">'0'</span>):val(v),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*           A</span></div><div class="line"><span class="comment">            / \</span></div><div class="line"><span class="comment">           B   C</span></div><div class="line"><span class="comment">          / \  /</span></div><div class="line"><span class="comment">         D   E F</span></div><div class="line"><span class="comment">        /</span></div><div class="line"><span class="comment">       G</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//前序序列化二叉树  ABDG$$$E$$CF$$$</span></div><div class="line"><span class="function">TreeNode* <span class="title">CreateTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator &amp;iter)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(*iter==<span class="string">'$'</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(*iter);</div><div class="line">    root-&gt;left = CreateTree(++iter);</div><div class="line">    root-&gt;right = CreateTree(++iter);</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取前序序列串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSequence</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;sequence)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) &#123;</div><div class="line">        sequence.push_back(<span class="string">'$'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    sequence.push_back(root-&gt;val);</div><div class="line">    getSequence(root-&gt;left,sequence);</div><div class="line">    getSequence(root-&gt;right,sequence);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;sequence)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ele:sequence)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归先序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">    PreTravel(root-&gt;left);</div><div class="line">    PreTravel(root-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归先序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonCurPreTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    TreeNode *iter = root;</div><div class="line">    <span class="keyword">while</span>(!s.empty()||iter)&#123;</div><div class="line">        <span class="keyword">if</span>(iter)&#123;  <span class="comment">//如果左节点不为空的话，遍历左子树</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">            s.push(iter);</div><div class="line">            iter = iter-&gt;left;  <span class="comment">//左结点依次入栈</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//左节点为空，遍历右子树</span></div><div class="line">            iter = s.top();</div><div class="line">            s.pop();</div><div class="line">            iter = iter-&gt;right;  <span class="comment">//出栈，遍历右子树</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归中序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    InTravel(root-&gt;left);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">    InTravel(root-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归中序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonCurInTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    TreeNode *iter = root;</div><div class="line">    <span class="keyword">while</span>(!s.empty()||iter)&#123;</div><div class="line">        <span class="keyword">if</span>(iter)&#123;  <span class="comment">//如果左节点不为空的话，遍历左子树</span></div><div class="line">            s.push(iter);</div><div class="line">            iter = iter-&gt;left;  <span class="comment">//左结点依次入栈</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//左节点为空，遍历右子树</span></div><div class="line">            iter = s.top();</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">            s.pop();</div><div class="line">            iter = iter-&gt;right;  <span class="comment">//出栈，遍历右子树</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归后序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    PostTravel(root-&gt;left);</div><div class="line">    PostTravel(root-&gt;right);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归后序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonCurPostTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    TreeNode *prenode = <span class="literal">nullptr</span>;</div><div class="line">    TreeNode *curnode = root;</div><div class="line">    <span class="keyword">while</span>(curnode)&#123;</div><div class="line">        s.push(curnode);</div><div class="line">        curnode = curnode-&gt;left;  <span class="comment">//cur先走到左子树最左边结点</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!s.empty())&#123;</div><div class="line">        curnode = s.top();</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">if</span>(curnode-&gt;right==<span class="literal">nullptr</span>||curnode-&gt;right==prenode)&#123; <span class="comment">//右子树为空，或者右子树已经访问过了，此时访问根结点</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;curnode-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">            prenode = curnode;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="comment">//根节点继续入栈，因为此时根节点右子树没有访问，我们需要访问完右子树，还需要继续访问根节点，所以根节点要再此入栈</span></div><div class="line">            s.push(curnode);</div><div class="line">            <span class="comment">//访问右子树</span></div><div class="line">            curnode = curnode-&gt;right;</div><div class="line">            <span class="keyword">while</span>(curnode)&#123;</div><div class="line">                s.push(curnode);</div><div class="line">                curnode = curnode-&gt;left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//层次遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">    q.push(root);</div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;  <span class="comment">//队列非空</span></div><div class="line">        TreeNode *node = q.front();   <span class="comment">//获得队首</span></div><div class="line">        q.pop();   <span class="comment">//移除队列中的第一个元素</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">        <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</div><div class="line">        <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取树的高度(最大高度)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTreeMaxHigh</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//根节点为空</span></div><div class="line">    <span class="keyword">int</span> leftHigh = GetTreeMaxHigh(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> rightHigh = GetTreeMaxHigh(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> leftHigh&gt;rightHigh?leftHigh+<span class="number">1</span>:rightHigh+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取树的最小高度,递归实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTreeMinHigh</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;left)&#123;  <span class="comment">//左子树为空，返回右子树的高度</span></div><div class="line">        <span class="keyword">return</span> GetTreeMinHigh(root-&gt;right)+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;right)&#123;  <span class="comment">//右子树为空，返回左子树的高度</span></div><div class="line">        <span class="keyword">return</span> GetTreeMinHigh(root-&gt;left)+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//左右子树不空，返回左右子树高度的较小值</span></div><div class="line">    <span class="keyword">int</span> leftHigh = GetTreeMinHigh(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> rightHigh = GetTreeMinHigh(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> leftHigh&gt;rightHigh?rightHigh+<span class="number">1</span>:leftHigh+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取树的最小高度，层次遍历实现，也就是找到第一个叶子节点，得到该叶子节点所在的层即可</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTreeMinHighWithLevelTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</div><div class="line">    q.push(root);</div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;</div><div class="line">        <span class="keyword">int</span> length = q.size();</div><div class="line">        ++level;</div><div class="line">        <span class="keyword">while</span>(length--)&#123;</div><div class="line">            TreeNode *node = q.front();</div><div class="line">            q.pop();</div><div class="line">            <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> level;  <span class="comment">//找到第一个叶子节点，返回</span></div><div class="line">            <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</div><div class="line">            <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> level;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取从根节点到所有叶子节点的路径，递归前序遍历思想</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetAllPath</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;allpath,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;path)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    path.push_back(root-&gt;val);</div><div class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;  <span class="comment">//叶子节点，将path存入到allpath中</span></div><div class="line">        allpath.push_back(path);</div><div class="line">    &#125;</div><div class="line">    GetAllPath(root-&gt;left,allpath,path);</div><div class="line">    GetAllPath(root-&gt;right,allpath,path);</div><div class="line">    path.pop_back();  <span class="comment">//在返回到父节点之前，在路径上删除当前节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取根节点到某一固定节点的路径，递归前序遍历的思想</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPathFromRootTOnode</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;allpath,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;path,<span class="keyword">char</span> &amp;ch)</span></span>&#123;  <span class="comment">//allpath,可能有多个相同的节点</span></div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</div><div class="line">    path.push_back(root-&gt;val);</div><div class="line">    <span class="keyword">if</span>(root-&gt;val == ch)&#123;   <span class="comment">//找到该节点，保存路径</span></div><div class="line">        allpath.push_back(path);</div><div class="line">    &#125;</div><div class="line">    GetPathFromRootTOnode(root-&gt;left,allpath,path,ch);</div><div class="line">    GetPathFromRootTOnode(root-&gt;right,allpath,path,ch);</div><div class="line">    path.pop_back();  <span class="comment">//在返回到父节点之前，在路径上删除当前结点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;allpath)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> path : allpath)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : path)&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//判断两棵树是否相同</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSameTree</span><span class="params">(TreeNode *root1,TreeNode *root2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span>(!root1 || !root2) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="comment">//两个节点都不为空</span></div><div class="line">    <span class="keyword">if</span>(root1-&gt;val == root2-&gt;val)&#123;</div><div class="line">        <span class="keyword">return</span> IsSameTree(root1-&gt;left,root2-&gt;left) &amp;&amp; IsSameTree(root1-&gt;right,root2-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不相等</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//反转二叉树，层次遍历实现</span></div><div class="line"><span class="function">TreeNode* <span class="title">invertTree1</span><span class="params">(TreeNode* root)</span> </span>&#123;   <span class="comment">//层次遍历，遍历每一层时，同时翻转该层的左右子树</span></div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;   <span class="comment">//如果根节点为空，返回根节点</span></div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">    q.push(root);     <span class="comment">//根节点入队列</span></div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;  <span class="comment">//队列不为空</span></div><div class="line">        TreeNode *node = q.front();   <span class="comment">//遍历每层时，交换节点的左右节点</span></div><div class="line">        q.pop();     <span class="comment">//出队</span></div><div class="line">        swap(node-&gt;left,node-&gt;right);  <span class="comment">//交换左右节点</span></div><div class="line">        <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);   <span class="comment">//左右结点不为空入队</span></div><div class="line">        <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//反转二叉树，递归实现</span></div><div class="line"><span class="function">TreeNode* <span class="title">invertTree2</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root)&#123;</div><div class="line">        invertTree2(root-&gt;left);</div><div class="line">        invertTree2(root-&gt;right);</div><div class="line">        swap(root-&gt;left,root-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//构建一个二叉树</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; sequence = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'G'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'E'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'C'</span>,<span class="string">'F'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>&#125;;</div><div class="line">    <span class="keyword">auto</span> iter = sequence.begin();</div><div class="line">    TreeNode *root = CreateTree(iter);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"获取前序序列串"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; s;</div><div class="line">    getSequence(root,s);</div><div class="line">    Print(s);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序递归与非递归"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PreTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    NonCurPreTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序递归与非递归"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    InTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    NonCurInTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"后序递归与非递归"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PostTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    NonCurPostTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"层次遍历"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    LevelTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的高度(最大高度)"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">int</span> maxhigh = GetTreeMaxHigh(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxhigh&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的最小高度(根节点到叶子节点的最小距离)"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;GetTreeMinHigh(root)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;GetTreeMinHighWithLevelTravel(root)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输出根节点到叶子节点的所有路径"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; allpath;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; path;</div><div class="line">    GetAllPath(root,allpath,path);</div><div class="line">    Print(allpath);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输出根节点到某一特定节点的路径"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; allivec;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ivec;</div><div class="line">    <span class="keyword">char</span> ch = <span class="string">'E'</span>;</div><div class="line">    GetPathFromRootTOnode(root,allivec,ivec,ch);</div><div class="line">    Print(allivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"判断两棵树是否相同"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(IsSameTree(root,root)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"is the same"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"is not the same"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"反转二叉树"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    root = invertTree2(root);</div><div class="line">    LevelTravel(root);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*           A</span></div><div class="line"><span class="comment">            / \</span></div><div class="line"><span class="comment">           B   C</span></div><div class="line"><span class="comment">          / \  /</span></div><div class="line"><span class="comment">         D   E F</span></div><div class="line"><span class="comment">        /</span></div><div class="line"><span class="comment">       G</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;二叉树的各种操作，前中后序的递归与非递归实现，二叉树的构建（序列化和反序列化），二叉树的最大高度与最小高度，打印出从根节点到叶子的节点的所有路径，打印出根节点到特定节点的路径，反转二叉树，判断两个二叉树是否相等等等操作。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wangxinri.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.wangxinri.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>基本分页存储管理</title>
    <link href="http://www.wangxinri.cn/2018/01/28/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.wangxinri.cn/2018/01/28/基本分页存储管理方式/</id>
    <published>2018-01-28T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:25.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><p>连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。<strong>如果允许将一个进程直接分散地装入到许多不相邻接的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是端，则称为分段存储管理方式</strong>。</p>
<a id="more"></a>
<p><strong>在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，或称为纯分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行</strong>。</p>
<h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><p><strong>1.页面</strong></p>
<p><strong>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页</strong>，并为各页加以编号，从0开始，如第0页、第1页等。相应地，<strong>也把内存空间分成与页面相同的若干个存储块，称为（物理块）或页框（frame）</strong>，也同样为它们加以编号，如0#块、1#块等等。在为进程分配内存时以块为单位将进程中的若干页分别装入到多个可以不相邻的物理块中。<strong>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</strong></p>
<p>在分页系统中的页面其大小应适中。页面若太小，一方面虽然可使内存碎片减小，从<br>而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较<br>多的页面，从而导致进程的页表过长，占用大量内存；此外，还会降低页面换进换出的效<br>率。然而，如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，<br>但却又会使页内碎片增大。因此，<strong>页面的大小应选择适中，且页面大小应是 2 的幂，通常<br>为 512 B～8 KB。</strong></p>
<p><strong>2.地址结构</strong></p>
<p>分页地址中的地址结构（逻辑地址）：</p>
<pre><code>31        12  11         0
    页号P        位移量W
</code></pre><p>它含有两部分：前一部分为页号P，后一部分为位移量W（或称为页内地址）。图中的地址长度为32位，其中0-11位为页内地址，即每页的大小为4kB；12-31位为页号，地址空间最多允许有1M页。</p>
<p>对于某特定机器，其地址结构是一定的。若给定一个逻辑地址空间中的地址为 A，页<br>面的大小为 L，则页号 P 和页内地址 d 可按下式求得：<br>​<br>    P = INT[A/L]<br>    d = [A] MOD L</p>
<p>其中，INT 是整除函数，MOD 是取余函数。例如，其系统的页面大小为 1 KB，设 A = 2170 B，<br>则由上式可以求得 P = 2，d = 122。</p>
<p><strong>3.页表</strong></p>
<p>在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，<strong>即能在内存中找到每个页面所对应的物理块</strong>。为此，<strong>系统又为每个进程建立了一张页面映射表，简称页表。</strong> </p>
<p>在进程地址空间内的所有页(0～n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，见图 4-12 的中间部分。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，<strong>页表的作用是实现从页号到物理块号的地址映射</strong>。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E9%A1%B5%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="image"></p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对<br>地址)分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在<br>执行检索之前，<strong>先将页号与页表长度进行比较</strong>，如果页号大于或等于页表长度，则表示本<br>次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现并产生一地址越界<br>中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，<strong>便得到该表项<br>在页表中的位置，于是可从中得到该页的物理块号</strong>，将之装入物理地址寄存器中。与此同<br>时，<strong>再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完<br>成了从逻辑地址到物理地址的变换</strong>。图 4-13 示出了分页系统的地址变换机构。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="image"></p>
<p><strong>具有快表的地址变换机构</strong></p>
<p>由于页表是存在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次时访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，已形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据（或向此地址中写入数据）。因此，采用这种方式使计算机的处理速度降低近1/2。</p>
<p><strong>具有快表的地址变换过程：</strong></p>
<p>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速<br>缓冲寄存器，又称为“联想寄存器”(Associative Memory)，或称为“<strong>快表</strong>”，在 IBM 系统中<br>又取名为 TLB(Translation Lookaside Buffer)，用以存放当前访问的那些页表项。此时的地址<br>变换过程是：<strong>在 CPU 给出有效地址后，由地址变换机构自动地将页号 P 送入高速缓冲寄存<br>器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示<br>所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到<br>物理地址寄存器中。如在块表中未找到对应的页表项，则还须再访问内存中的页表，找到<br>后，把从页表项中读出的物理块号送地址寄存器；同时，再将此页表项存入快表的一个寄<br>存器单元中，亦即，重新修改快表。但如果联想寄存器已满，则 OS 必须找到一个老的且已<br>被认为不再需要的页表项，将它换出</strong>。图 4-14 示出了具有快表的地址变换机构。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="image"></p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>现代的大多数计算机系统，都支持非常大的逻辑地址空间(232～264)。在这样的环境下，<br>页表就变得非常大，要占用相当大的内存空间。例如，对于一个具有 32 位逻辑地址空间的<br>分页系统，规定页面大小为 4 KB 即 212 B，则在每个进程页表中的页表项可达 1 兆个之多。<br>又因为每个页表项占用一个字节，故每个进程仅仅其页表就要占用 1 MB 的内存空间，而且<br>还要求是连续的。显然这是不现实的，我们可以采用下述两个方法来解决这一问题：</p>
<p>(1) 采用离散分配方式来解决难以找到一块连续的大内存空间的问题；</p>
<p>(2) 只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再<br>调入。</p>
<p>1.两级页表</p>
<p>对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页，并离散地将各个页面分别存放在不同的物理块中的办法来加以解决，同样也要为离散分配的页表再建立一张页表，称为外层页表（Outer Page Table），再每个页表项中记录了页表页面的物理块号。</p>
<p>下面我们仍以前面的 32 位逻辑地址空间为例来说明。当页面大小为 4 KB 时(12 位)，若采<br>用一级页表结构，应具有 20 位的页号，即页表项应有 1 兆个；在采用两级页表结构时，再<br>对页表进行分页，使每页中包含 210 (即 1024)个页表项，最多允许有 210个页表分页；或者<br>说，外层页表中的外层页内地址 P2为 10 位，外层页号 P1也为 10 位。此时的逻辑地址结构<br>可描述如下：</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="image"></p>
<p>由图可以看出，在页表的每个表项中存放的是进程的某页在内存中的物理块号，如第<br>0#页存放在 1#物理块中；1#页存放在 4#物理块中。而在外层页表的每个页表项中，所存放的<br>是某页表分页的首址，如第 0#页表是存放在第 1011#物理块中。我们可以利用外层页表和页<br>表这两级页表，来实现从进程的逻辑地址到内存中物理地址间的变换。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本分页存储管理方式&quot;&gt;&lt;a href=&quot;#基本分页存储管理方式&quot; class=&quot;headerlink&quot; title=&quot;基本分页存储管理方式&quot;&gt;&lt;/a&gt;基本分页存储管理方式&lt;/h2&gt;&lt;p&gt;连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。&lt;strong&gt;如果允许将一个进程直接分散地装入到许多不相邻接的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是端，则称为分段存储管理方式&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="存储管理" scheme="http://www.wangxinri.cn/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>连续分配存储方式</title>
    <link href="http://www.wangxinri.cn/2018/01/24/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.wangxinri.cn/2018/01/24/连续分配存储管理方式/</id>
    <published>2018-01-24T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:30.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常都要经过以下几个步骤：</p>
<a id="more"></a>
<ul>
<li>编译，由编译程序（Compiler）对用户源程序进行编译，形成若干个目标模块（Object Module）。</li>
<li>链接，由链接程序（Linker）将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块（Load Module）</li>
<li>装入，由装入程序（Loader）将装入模块装入内存。</li>
</ul>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>为了能将用户程序装入内存，必须为它分配一定大小的内存空间。<strong>连续分配方式</strong>是最早出现的一种存储器分配方式，<strong>该分配方式为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻</strong>。</p>
<p>连续分配方式可分为四类：<strong>单一连续分配</strong>、<strong>固定分区分配</strong>、<strong>动态分区分配</strong>以及<strong>动态重定位分区分配</strong>算法。</p>
<ul>
<li>单一连续分配：这是最简单的一种存储管理方式，但是<strong>只能用于单用户、单任务的操作系统中</strong>。采用这种存储管理方式时，可把内存分为系统区和用户区两部分。</li>
<li><p>固定分区分配：<strong>固定分区式分配是最简单的一种可运行多道程序的存储管理方式</strong>。这是将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行，当该作业结束时，又可再从后备作业队列中找到另一个作业调入该分区。</p>
<p> 划分分区的方法：</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
<p>内存分配：为了便于内存分配，通常将分区按大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配）。</p>
<p>固定分区分配，是最早的多道程序的存储管理方式，<strong>由于每个分区的大小固定，必然会造成存储空间的浪费，因而现在已很少将它用于通用计算机中</strong>。</p>
</li>
</ul>
<h3 id="动态分区分配（重点）"><a href="#动态分区分配（重点）" class="headerlink" title="动态分区分配（重点）"></a>动态分区分配（重点）</h3><p>动态分区分配是根据进程的实际需要，动态地为之分配内存空间。在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作这样三个问题。</p>
<h4 id="分区分配中的数据结构"><a href="#分区分配中的数据结构" class="headerlink" title="分区分配中的数据结构"></a>分区分配中的数据结构</h4><ul>
<li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。</li>
<li>空闲分区链。</li>
</ul>
<h4 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h4><p>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。目前常用的一下所述的五种分配算法。</p>
<p><strong>1.首次适应算法（first fit）</strong></p>
<p>我们以空闲分区链为例来说明采用 FF 算法时的分配情况。<strong>FF 算法要求空闲分区链以<br>地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要<br>求的空闲分区为止</strong>；然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，<br>余下的空闲分区仍留在空闲链中。若从链首直至链尾都不能找到一个能满足要求的分区，<br>则此次内存分配失败，返回。 <strong>该算法倾向于优先利用内存中低址部分的空闲分区，从而保<br>留了高址部分的大空闲区。这给为以后到达的大作业分配大的内存空间创造了条件。其缺<br>点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是<br>从低址部分开始，这无疑会增加查找可用空闲分区时的开销</strong> 。</p>
<p><strong>2.循环首次适应算法（next fit）</strong></p>
<p>该算法是由首次适应算法演变而成的。<strong>在为进程分配内存空间时，不再是每次都从链<br>首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满<br>足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业</strong>。为实现该算法，<br>应设置一起始查寻指针，用于指示下一次起始查寻的空闲分区，并采用循环查找方式，即<br>如果最后一个(链尾)空闲分区的大小仍不能满足要求，则应返回到第一个空闲分区，比较其<br>大小是否满足要求。找到后，应调整起始查寻指针。<strong>该算法能使内存中的空闲分区分布得<br>更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区</strong>。</p>
<p><strong>3.最佳适应算法（best fit）</strong></p>
<p>所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区<br>分配给作业，避免“大材小用”。为了加速寻找，<strong>该算法要求将所有的空闲分区按其容量以<br>从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区，必然是最<br>佳的</strong>。孤立地看，<strong>最佳适应算法似乎是最佳的，然而在宏观上却不一定。因为每次分配后<br>所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区</strong>。</p>
<p><strong>4.最坏适应算法（worst fit）</strong></p>
<p>最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给<br>作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业<br>有利，同时最坏适应分配算法查找效率很高。<strong>该算法要求将所有的空闲分区按其容量以从<br>大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。但是该算<br>法的缺点也是明显的，它会使存储器中缺乏大的空闲分区</strong>。<font color="red"> <strong>最坏适应算法与前面所述的首<br>次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法</strong>。 </font></p>
<p><strong>5.快速适应算法（quick fit）</strong></p>
<p><font color="red"> <strong>该算法又称为分类搜索法</strong> </font>，是将空闲分区根据其容量大小进行分类，对于每一类具有<br>相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区<br>链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，<br>并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进<br>行划分，如 2 KB、4 KB、8 KB 等，对于其它大小的分区，如 7 KB 这样的空闲区，既可以<br>放在 8 KB 的链表中，也可以放在一个特殊的空闲区链表中。</p>
<p>该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区<br>链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区<br>产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。</p>
<p>该算法的缺点是在分区归还主存时算法复杂，系统开销较大。此外，该算法在分配空<br>闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，<br>或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存<br>储空间浪费，这是典型的以空间换时间的作法。</p>
<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><p>在动态分区存储管理方式中，主要的操作是分配内存和回收内存。</p>
<p><strong>1）分配内存</strong></p>
<p>系统应利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。设请求的分区大<br>小为 u.size，表中每个空闲分区的大小可表示为 m.size。若 m.size-u.size≤size(size 是事先规定的不再切割的剩余分区的大小)，说明多余部分太小，可不再切割，将整个分区分配给请求者；否则(即多余部分超过size)，从该分区中按请求的大小划分出一块内存空间分配出去， 余下的部分仍留在空闲分区链(表)中。然后，将分配区的首址返回给调用者。图 4-7 示出了<br>分配流程。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<p><strong>2）回收内存</strong></p>
<p>当进程运行完毕是释放内存时，<strong>系统根据回收区的首址</strong>，从空闲区链（表）中找到响应的插入点，此时可能出现以下四种情况之一：</p>
<p>(1) 回收区与插入点的前一个空闲分区 F1相邻接，见图 4-8(a)。此时应将回收区与插入<br>点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区 F1的大小。</p>
<p>(2) 回收分区与插入点的后一空闲分区 F2相邻接，见图 4-8(b)。此时也可将两分区合并，<br>形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。</p>
<p>(3) 回收区同时与插入点的前、后两个分区邻接，见图 4-8(c)。此时将三个分区合并，<br>使用 F1的表项和 F1的首址，取消 F2的表项，大小为三者之和。</p>
<p>(4) 回收区既不与 F1邻接，又不与 F2邻接。这时应为回收区单独建立一新表项，填写<br>回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5.png" alt="image"></p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p><strong>固定分区和动态分区方式都有不足之处。固定分区方式限制了活动进程的数目，当进<br>程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空<br>闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对以上两种内存方式的一<br>种折衷方案</strong>。</p>
<p>伙伴系统规定，无论已分配分区或空闲分区，其大小均为 2 的 k 次幂，k 为整数，<br>l≤k≤m，其中：21 表示分配的最小分区的大小，2m 表示分配的最大分区的大小，通常 2m<br>是整个可分配内存的大小。</p>
<p>假设系统的可利用空间容量为 2m个字，则系统开始运行时，整个内存区是一个大小为 2m<br>的空闲分区。在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区，<br>将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独<br>设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了 k(0≤k≤m)个空闲分区链表。</p>
<p>当需要为进程分配一个长度为 n 的存储空间时，首先计算一个 i 值，使 2i－1&lt;n≤2i，然<br>后在空闲分区大小为 2i 的空闲分区链表中查找。若找到，即把该空闲分区分配给进程。否<br>则，表明长度为 2i 的空闲分区已经耗尽，则在分区大小为 2i＋1 的空闲分区链表中寻找。若<br>存在 2i＋1 的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙<br>伴，其中的一个分区用于分配，而把另一个加入分区大小为 2i 的空闲分区链表中。若大小<br>为 2i＋1的空闲分区也不存在，则需要查找大小为 2i＋2的空闲分区，若找到则对其进行两次分<br>割：第一次，将其分割为大小为 2i＋1 的两个分区，一个用于分配，一个加入到大小为 2i＋1<br>的空闲分区链表中；第二次，将第一次用于分配的空闲区分割为 2i 的两个分区，一个用于<br>分配，一个加入到大小为 2i 的空闲分区链表中。若仍然找不到，则继续查找大小为 2i＋3 的<br>空闲分区，以此类推。由此可见，在最坏的情况下，可能需要对 2k的空闲分区进行 k 次分<br>割才能得到所需分区。</p>
<p>与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，如回收大小<br>为 2i的空闲分区时，若事先已存在 2i的空闲分区时，则应将其与伙伴分区合并为大小为<br>2i＋1的空闲分区，若事先已存在 2i＋1的空闲分区时，又应继续与其伙伴分区合并为大小为<br>2i＋2的空闲分区，依此类推。</p>
<p>在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空<br>闲分区所花费的时间。与前面所述的多种方法相比较，由于该算法在回收空闲分区时，需<br>要对空闲分区进行合并，所以其时间性能比前面所述的分类搜索算法差，但比顺序搜索算<br>法好，而其空间性能则远优于前面所述的分类搜索法，比顺序搜索法略差。</p>
<p>需要指出的是，<strong>在当前的操作系统中，普遍采用的是下面将要讲述的基于分页和分段<br>机制的虚拟内存机制</strong>，该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系<br>统仍不失为一种有效的内存分配和释放的方法，得到了大量的应用。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>在上述的分类搜索算法（快速适应算法（quick fit））和伙伴系统中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在一张管理索引表中查找所需空间大小所对应的表项，从中得到对应的空闲分区链表表头指针，从而通过查找得到一个空闲分区。如果对空闲愤怒分类较细，则相应的空闲分区链表也较多，因此选择合适的空闲链表的开销也相应增加，且时间性能降低。</p>
<p><strong>哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</strong></p>
<p>当进行空闲分区分配时，<strong>根据所需空间分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略</strong>。</p>
<h3 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h3><ol>
<li>动态重定位的引入</li>
</ol>
<p><strong>在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间</strong>。如果在系统中只有若干个小的区块，即使它们的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。这些不能被利用的小分区称为“零头”或“碎片”。</p>
<p>若想把作业装入，可采用的一种方法是：将内存中的所有作业进行移动，使它们全都相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时就可把作业装入该区。这种通过移动内存中作业的位置，以把原来多个分散的小分区拼接成一个大分区的方法，称为“拼接”或“紧凑”，见下图，由于经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，<strong>在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。</strong></p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E7%B4%A7%E5%87%91%E7%9A%84%E7%A4%BA%E6%84%8F.png" alt="image"></p>
<ol>
<li>动态重定位的实现</li>
</ol>
<p>在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，<strong>即须在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址</strong>。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p>
<p>图 4-10 示出了动态重定位的实现原理。<br><strong>地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态<br>重定位</strong>。当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时，不需对<br>程序做任何修改，只要用该程序在内存的新起始地址，去置换原来的起始地址即可</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p>
<ol>
<li>动态重定位分区分配算法</li>
</ol>
<p>动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：这种分配算法中，增加了紧凑的功能，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。如下图：</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p>
<h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><p>1.对换的引入</p>
<p>在多道程序环境下，一方面，在内存中某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降。为了解决这一问题，在系统中又增设了对换（也称交换）设施。<strong>所谓“对换”，是指把内存中暂时不能运行的内存或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施</strong>。</p>
<p><strong>如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”</strong>。这种对换被<br>广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用<br>率。<strong>而如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段<br>对换”，又统称为“部分对换”</strong>。这种对换方法是实现后面要讲到的请求分页和请求分段式<br>存储管理的基础，其目的是为了支持虚拟存储系统。在此，我们只介绍进程对换，而分页<br>或分段对换将放在虚拟存储器中介绍。<strong>为了实现进程对换，系统必须能实现三方面的功能：<br>对换空间的管理、进程的换出，以及进程的换入</strong></p>
<p>2．对换空间的管理</p>
<p><strong>在具有对换功能的 OS 中，通常把外存分为文件区和对换区。前者用于存放文件，后者<br>用于存放从内存换出的进程</strong>。由于通常的文件都是较长久地驻留在外存上，故对文件区管理<br>的主要目标，是提高文件存储空间的利用率，为此，<strong>对文件区采取离散分配方式</strong>。然而，进<br>程在对换区中驻留的时间是短暂的，对换操作又较频繁，故对对换空间管理的主要目标，<br>是提高进程换入和换出的速度。为此，<strong>对换区采取的是连续分配方式</strong>，较少考虑外存中的碎片问题。</p>
<p>为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外<br>存的使用情况。<strong>其形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空<br>闲分区表或空闲分区链</strong>。在空闲分区表中的每个表目中应包含两项，即对换区的首址及其<br>大小，分别用盘块号和盘块数表示。</p>
<p><strong>由于对换分区的分配是采用连续分配方式，因而对换空间的分配与回收，与动态分区<br>方式时的内存分配与回收方法雷</strong>同。其分配算法可以是首次适应算法、循环首次适应算法<br>或最佳适应算法。具体的分配操作，也与图 4-7 中内存的分配过程相同，这里不再赘述。</p>
<ol>
<li>进程的换出和换入</li>
</ol>
<p>（1）进程的换出。每当一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。其过程是：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。若传送过程未出现错误，便可回收进程所占用的内存空间，并对该进程和进程控制块做相应的修改。</p>
<p>（2）进程的换入。系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间最久（换出到磁盘上）的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序的装入和链接&quot;&gt;&lt;a href=&quot;#程序的装入和链接&quot; class=&quot;headerlink&quot; title=&quot;程序的装入和链接&quot;&gt;&lt;/a&gt;程序的装入和链接&lt;/h2&gt;&lt;p&gt;用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常都要经过以下几个步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="存储管理" scheme="http://www.wangxinri.cn/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>调度算法</title>
    <link href="http://www.wangxinri.cn/2018/01/22/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <id>http://www.wangxinri.cn/2018/01/22/处理机调度/</id>
    <published>2018-01-22T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:32.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>在多道程序环境下，内存中存在着多个进程，其数目往往多于处理机数目。这就要求系统能按某种算法，动态地将处理机分配给处于就绪状态的一个进程、使之执行。分配处理机的任务是由处理机调度程序完成的。对于大型系统运行时的性能，如系统吞吐量、资源利用率、作业周转时间或响应的及时性等，在很大程度上都取决于处理机调度性能的好坏。因而，处理机调度便成为OS中至关重要的部分。</p>
<a id="more"></a>
<h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><p><strong>1.先来先服务(FCFS)调度算法</strong></p>
<p>该算法即可用于作业调度，也可用于进程调度</p>
<p><strong>2.短作业优先(short job first SJF)的调度算法</strong></p>
<p>可以分别作用于作业调度和进程调度，作业的长度是以作业所要求的运行时间来衡量的（预估时间）。</p>
<p><strong>3.优先级调度算法（PSA）</strong></p>
<p>可以作为作业调度算法，也可作为进程调度算法。根据优先级进行调度。</p>
<p><strong>4.高响应比优先调度算法（HRRN)</strong></p>
<p>为每个作业引入一个动态优先级，即优先级可以改变，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。</p>
<p><strong>优先权 = (等待时间+要求服务时间)/要求服务时间</strong></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>早期所采用的非抢占方式存在着很大的局限性，很难满足交互性作业和实时任务的需求。为此，在进程调度中又引入了抢占方式。</p>
<ul>
<li>非抢占方式</li>
<li><p>抢占方式</p>
<p> 1.优先权原则<br> 2.短进程优先原则<br> 3.时间片原则</p>
</li>
</ul>
<h4 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h4><p>基于时间片的的轮转（RR）调度算法。系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并设置每隔一定时间间隔（如30ms）即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程（或新到达的紧迫进程）。由此，可保证就绪队列中的所有进程在一个确定的时间段内，都能够获得一次CPU执行。</p>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p>1、设有N个队列（Q1,Q2….QN），其中各个队列对于处理机的优先级是不一样的，也就是说位于各个队列中的作业(进程)的优先级也是不一样的。一般来说，优先级Priority(Q1) &gt; Priority(Q2) &gt; … &gt; Priority(QN)。怎么讲，位于Q1中的任何一个作业(进程)都要比Q2中的任何一个作业(进程)相对于CPU的优先级要高（也就是说，Q1中的作业一定要比Q2中的作业先被处理机调度），依次类推其它的队列。</p>
<p>2、对于某个特定的队列来说，里面是遵循时间片轮转法。也就是说，位于队列Q2中有N个作业，它们的运行时间是通过Q2这个队列所设定的时间片来确定的（为了便于理解，我们也可以认为特定队列中的作业的优先级是按照FCFS来调度的）。</p>
<p>3、各个队列的时间片是一样的吗？不一样，这就是该算法设计的精妙之处。各个队列的时间片是随着优先级的增加而减少的，也就是说，优先级越高的队列中它的时间片就越短。同时，为了便于那些超大作业的完成，最后一个队列QN(优先级最低的队列)的时间片一般很大(不需要考虑这个问题)。</p>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><h4 id="最早截止时间优先EDF算法"><a href="#最早截止时间优先EDF算法" class="headerlink" title="最早截止时间优先EDF算法"></a>最早截止时间优先EDF算法</h4><p><strong>该算法是根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机</strong>。最早截止时间优先算法即可用于抢占式调度，也可用于非抢占式调度方式。</p>
<h4 id="最低松弛度优先LLF算法"><a href="#最低松弛度优先LLF算法" class="headerlink" title="最低松弛度优先LLF算法"></a>最低松弛度优先LLF算法</h4><p>该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。例如，一个任务在200ms时必须完成，而它本身所需的运行时间是100ms，因此调度程序必须在100ms之前调度执行，该任务的紧急程度（松弛程度）为100ms。<strong>在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在最前面，调度程序选择队列中的队首任务执行</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;处理机调度&quot;&gt;&lt;a href=&quot;#处理机调度&quot; class=&quot;headerlink&quot; title=&quot;处理机调度&quot;&gt;&lt;/a&gt;处理机调度&lt;/h2&gt;&lt;p&gt;在多道程序环境下，内存中存在着多个进程，其数目往往多于处理机数目。这就要求系统能按某种算法，动态地将处理机分配给处于就绪状态的一个进程、使之执行。分配处理机的任务是由处理机调度程序完成的。对于大型系统运行时的性能，如系统吞吐量、资源利用率、作业周转时间或响应的及时性等，在很大程度上都取决于处理机调度性能的好坏。因而，处理机调度便成为OS中至关重要的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="调度" scheme="http://www.wangxinri.cn/tags/%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://www.wangxinri.cn/2018/01/20/%E6%AD%BB%E9%94%81/"/>
    <id>http://www.wangxinri.cn/2018/01/20/死锁/</id>
    <published>2018-01-20T13:59:00.000Z</published>
    <updated>2018-04-06T13:40:41.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁：指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都讲无法向前推进。</strong></p>
<p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的（Deadlock)。</p>
<a id="more"></a>
<h3 id="计算机系统中的死锁"><a href="#计算机系统中的死锁" class="headerlink" title="计算机系统中的死锁"></a>计算机系统中的死锁</h3><ul>
<li>竞争不可抢占性资源引发死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ul>
<p><strong>产生死锁的必要条件</strong></p>
<ul>
<li><strong>互斥条件</strong>。即在一段时间内，某资源只能被一个进程占用。</li>
<li><strong>请求和保持条件</strong>。进程已经保持了至少一个资源，但又提出了新的资源请求，该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li><strong>不可抢占条件</strong>。</li>
<li><strong>循环等待条件</strong>。在发生死锁时，必然存在一个进程-资源的循环链，即进程集合{p0,p1,…,pn}中的p0正在等待一个p1占用的资源，p1正在等待p2占用的资源，…pn正在等待已被p0占用的资源。</li>
</ul>
<p><strong>处理死锁的方法</strong></p>
<p>目前处理死锁的方法可归结为四种。</p>
<p><strong>预防死锁</strong> ：实现预防方法，该方法通过设置某些限制条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。</p>
<ul>
<li><strong>避免死锁</strong>：同样属于事先预防策略，在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免发生死锁。</li>
<li><strong>检测死锁</strong>：允许运行过程中发生死锁。但可通过检测机构及时的检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。</li>
<li><strong>解除死锁</strong>：当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。常用的方法是撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其能继续运行。</li>
</ul>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏产生死锁的后三个条件。</p>
<ul>
<li><strong>破坏请求和保持</strong></li>
</ul>
<p>第一种协议：一次性申请其在整个运行过程中的全部资源。</p>
<p>第二种协议：允许一个进程只获得运行初期所需的资源后，便开始运行，进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。</p>
<ul>
<li><strong>破坏不可抢占条件</strong></li>
</ul>
<p>当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。</p>
<ul>
<li><strong>破坏循环等待条件</strong></li>
</ul>
<p>一个能保证“循环等待”条件不成立的方法是，对系统的所有资源类型进行线性排序，并赋予不同的序号，这样不可能再出现环路，因而破坏了“循环等待”条件。</p>
<h3 id="避免死锁-（银行家算法）"><a href="#避免死锁-（银行家算法）" class="headerlink" title="避免死锁 （银行家算法）"></a>避免死锁 （银行家算法）</h3><p><strong>避免死锁的基本思想：</strong> 确保系统始终处于安全状态，一个系统开始是处于安全状态的。当有进程请求一个可用资源时，系统需对该进程的请求进行计算，若将资源分配给进程后系统仍处于安全状态，才将该资源分配给进程。</p>
<p><strong>利用银行家算法来避免死锁</strong> </p>
<p>当前序列是安全的，即当前状态不会发生死锁。此时如果某个进程请求资源，当前资源如果小于等于它需要的值，执行下一步，否则，返回异常；</p>
<p>继续判断需求的资源值是否小于等于系统中尚有的可用资源数，如果大于，则需等待其它进程释放资源，否则，系统试探性的将资源分配给该进程，并修改相应的资源数</p>
<p>接着系统调用安全判定算法，如果安全，也就是存在一个安全系列，资源分配成功；如果不安全，恢复原来的资源分配状态，让该进程继续等待。</p>
<p><strong>银行家算法</strong>：</p>
<p>我们将第i个进程请求的资源数记为Requests[i]。</p>
<p>1.如果Requests[i]&lt;=Need[i]，则转到第二步。否则，返回异常。这一步是控制进程申请的资源不得大于需要的资源。</p>
<p>2.如果Requests[i]&lt;=Available，则转到第三步，否则表示尚无足够资源，pi需等待。</p>
<p>3.如果满足前两步，那么做如下操作：</p>
<p>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Available = Available -Requests[i]   </div><div class="line">Allocation = Allocation[i]+Requests[i]</div><div class="line">Need[i]=Need[i]-Requests[i]</div></pre></td></tr></table></figure>
<p>4.调用安全判定算法，检查是否安全<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(安全)</div><div class="line">&#123;</div><div class="line">    申请成功，资源分配</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    申请失败，资源撤回。第三步前几个操作进行逆操作</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.cnblogs.com/chuxiuhong/p/6103928.html" target="_blank" rel="external">参考链接：银行家算法学习笔记</a></p>
<h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p>如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能会发生死锁。在这种情况下，系统应当提供两个算法：<br>​                              </p>
<ul>
<li>死锁检测算法。该方法用于检测系统状态，以确定系统中是否发生了死锁。</li>
<li>死锁解除算法。当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>
</ul>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>系统死锁，可利用<strong>资源分配图</strong>来描述。如图所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</p>
<p>所示的资源分配图中，进程P1已经分得了两个R1资源，并又请求一个R2资源；进程P2分得了一个R1和一个R2资源，并又请求一个R1资源。</p>
<p><strong>死锁定理</strong><br><strong>可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态</strong>。简化方法如下：</p>
<p>1) 在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图2-18(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到图248(b)所示的情况。</p>
<p>2) 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图2-17中，进程P2就满足这样的条件。根据第1)条中的方法进行一系列简化后,<strong>若能消去图中所有的边，则称该图是可完全简化</strong>的，如图2-18(c)所示。</p>
<p><strong>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理</strong>。 </p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="image"></p>
<h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>常采用解除死锁的两种方法：</p>
<ul>
<li><strong>抢占资源</strong>。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</li>
<li><strong>终止（或撤销）进程</strong>。终止（或撤销）系统中的一个或多个死锁进程，直到打破循环环路，使系统从死锁状态解脱出来。</li>
</ul>
<ol>
<li>终止进程的方法</li>
</ol>
<ul>
<li><strong>终止所有死锁进程</strong></li>
<li><strong>逐个终止进程</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;死锁：指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都讲无法向前推进。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的（Deadlock)。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="http://www.wangxinri.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>经典进程同步问题</title>
    <link href="http://www.wangxinri.cn/2018/01/15/%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/01/15/经典进程同步问题/</id>
    <published>2018-01-15T13:59:00.000Z</published>
    <updated>2018-04-06T13:37:14.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经典进程同步问题：生产者-消费者问题、哲学家进餐问题、读者-写者问题，通过信号量来实现进程之间的同步。</p>
<a id="more"></a>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p><strong>1.利用记录型信号量解决生产者-消费者问题</strong></p>
<p>假定在生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可利用互斥信号mutex实现诸进程对缓冲池的互斥使用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> in = <span class="number">0</span>,out = <span class="number">0</span>;</div><div class="line">item buffer[n];</div><div class="line">semaphore mutex = <span class="number">1</span>,empty = n,full=<span class="number">0</span>;</div><div class="line"><span class="keyword">void</span> producer&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        producer an item nextp;</div><div class="line">        ...</div><div class="line">        wait(empty);</div><div class="line">        wait(mutex);</div><div class="line">        buffer[in] = nextp;</div><div class="line">        in = (in+<span class="number">1</span>)%n;</div><div class="line">        signal(mutex);</div><div class="line">        signal(full);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        wait(full);</div><div class="line">        wait(mutex);</div><div class="line">        nextc = buffer[out];</div><div class="line">        out = (out+<span class="number">1</span>)%n;</div><div class="line">        signal(mutex);</div><div class="line">        signal(empty);</div><div class="line">        consumer the item in nextc;</div><div class="line">        ...</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    cobegin</div><div class="line">        producer(); consumer();</div><div class="line">    coend</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2.利用And信号量解决生产者-消费者问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> in = <span class="number">0</span>,out = <span class="number">0</span>;</div><div class="line">item buffer[n];</div><div class="line">semaphore mutex = <span class="number">1</span>,empty = n,full=<span class="number">0</span>;</div><div class="line"><span class="keyword">void</span> producer&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        producer an item nextp;</div><div class="line">        ...</div><div class="line">        Swait(empty,mutex);</div><div class="line">        buffer[in] = nextp;</div><div class="line">        in = (in+<span class="number">1</span>)%n;</div><div class="line">        Ssignal(mutex,full);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        Swait(full,mutex);</div><div class="line">        nextc = buffer[out];</div><div class="line">        out = (out+<span class="number">1</span>)%n;</div><div class="line">        Ssignal(mutex,empty);</div><div class="line">        consumer the item in nextc;</div><div class="line">        ...</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    cobegin</div><div class="line">        producer(); consumer();</div><div class="line">    coend</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>五个哲学家共用一张圆桌，分别坐在周围的五个椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替的进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。</p>
<p><strong>1.利用记录型信号量解决哲学家进餐问题</strong></p>
<p>经分析，放在桌子上的筷子时临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</div></pre></td></tr></table></figure>
<p>所有信号量均被初始化为1，第i为哲学家的活动可描述为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    wait(chopstick[i]);</div><div class="line">    wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">    ...</div><div class="line">    <span class="comment">//eat</span></div><div class="line">    ...</div><div class="line">    signal(chopstick[i]);</div><div class="line">    signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">    ...</div><div class="line">    <span class="comment">//think</span></div><div class="line">    ...</div><div class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>假如五位哲学家同时各自拿起左边的筷子时，就会使五个信号量chopstick为0，当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。对于这种死锁问题，可采取一下几种解决方法。</p>
<p><strong>首先给出两个断言：</strong></p>
<p>（1）系统中有N个并发进程。若规定每个进程需要申请2个某类资源，则当系统提供N+1个同类资源时，无论采用何种方式申请资源， 一定不会发生死锁。分析：N+1个资源被N 个进程竞争， 由抽屉原理可知， 则至少存在一个进程获2个以上的同类资源。这就是前面提到的哲学家就餐问题中5个哲学家提供6支筷子时一定不会发生死锁的原因。</p>
<p>（2）系统中有N个并发进程。若规定每个进程需要申请R个某类资源，则当系统提供K＝N*（R-1）+1个同类资源时，无论采用何种方式申请使用，一定不会发生死锁。分析：在最坏的情况下，每个进程都申请到R-1个同类资源， 此时它们均阻塞。 试想若系统再追加一个同类资源， 则 N 个进程中必有一个进程获得R个资源，死锁解除。 </p>
<p><strong>(1)破坏请求保持条件</strong></p>
<p>利用原子思想完成。即只有拿起两支筷子的哲学家才可以进餐，否则，一支筷子也不拿。</p>
<p><strong>解法一：利用AND机制实现第i位哲学家的活动描述为：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> i)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        think;</div><div class="line">        swait(chopstick[(i+<span class="number">1</span>)]%<span class="number">5</span>，chopstick[i])；</div><div class="line">        eat;</div><div class="line">        Ssignal(chopstick[i]，chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解法二：利用记录型信号量机制实现在初始化中增加一个信号量定义：semaphore mutex=1：<br>该方法将拿两只筷子的过程作为临界资源，一次只允许一个哲学家进入。</strong></p>
<p>第I位哲学家的活动描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> I)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        思考;</div><div class="line">        wait(mutex)；</div><div class="line">        wait(stiCk[I]);</div><div class="line">        wait(Stick[(I+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">        signal(mutex)；</div><div class="line">        进餐；</div><div class="line">        signal(stick[I]);</div><div class="line">        Signal(Stick[(I+<span class="number">1</span>)%<span class="number">5</span>])；</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>(2)破坏环路等待条件</strong></p>
<p><strong>解法一</strong>：奇数号哲学家先拿他左边的筷子，偶数号哲学家先拿他右边的筷子。这样破坏了同方向环路，一个哲学家拿到一只筷子后，就阻止了他邻座的一个哲学家吃饭。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。算法描述如下：</p>
<p>1)第i个哲学家的活动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> I)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        思考;</div><div class="line">        If I%<span class="number">2</span>==<span class="number">1</span> then</div><div class="line">            wait(Stick[I]);</div><div class="line">            wait(stick[(I+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">            进餐;</div><div class="line">            signal(stick[I])；</div><div class="line">            signal(stick[(I+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            wait(stick[(I+<span class="number">1</span>)%<span class="number">5</span>])；</div><div class="line">            wait(stick[I]);</div><div class="line">            进餐；</div><div class="line">            signal(stick[(I+<span class="number">1</span>)%<span class="number">5</span>])；</div><div class="line">            signal(stick[I]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解法二</strong>：至多允许四位哲学家进餐，将最后一个哲学家停止申请资源，断开环路。最终能保证有一位哲学家能进餐，用完释放两只筷子，从而使更多的哲学家能够进餐。增加一个信号量定义semaphore count=4：算法描述第1个哲学家的活动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> I)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">        思考；</div><div class="line">        wait(count)；</div><div class="line">        wait(chopstiok[I])；</div><div class="line">        wait(chopstick[I+<span class="number">1</span>]%<span class="number">5</span>)；</div><div class="line">        进餐;</div><div class="line">        signal(chopstick[I])；</div><div class="line">        signal(chopstick[I+<span class="number">1</span>]%<span class="number">5</span>)</div><div class="line">        signal(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>允许多个进程同时读一个共享对象，但不允许一个write进程和其他reader进程或writer进程同时访问共享对象。所谓读者-写者问题是指：<strong>保证一个writer进程必须与其他进程互斥地访问共享对象的同步问题。</strong></p>
<p><strong>1.记录型信号量解决读者-写者问题</strong></p>
<p>为实现reader和writer之间的互斥而设置一个互斥信号量wmutex。同时，增加一个count计数器，用来记录reader进程的个数，reader进程执行时，并且count==0时，此时wait(wmutex)，禁止写进程去写，然后++count；reader进程执行完毕后，–count，如果count ==0时，此时表示无reader进程，则signal(wmutex)，允许writer去写。同时由于reader进程互斥的共享count，所以我们设置一个rmutex来互斥访问count。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">seamphore rmutex=<span class="number">1</span>,wmutex=<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        wait(rmutex);</div><div class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) wait(wmutex)</div><div class="line">        ++count;</div><div class="line">        signal(rmutex);</div><div class="line">        ...</div><div class="line">        reader</div><div class="line">        ...</div><div class="line">        wait(rmutex);</div><div class="line">        --count;</div><div class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) signal(wmutex);</div><div class="line">        signal(rmutex);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        wait(wmutex);</div><div class="line">        ...</div><div class="line">        writer</div><div class="line">        ...</div><div class="line">        signal(wmutex);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    cobegin</div><div class="line">        reader(); writer();</div><div class="line">    coend</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2.利用信号量集机制解决读者-写者问题</strong></p>
<p>Swait((S,1,0)：是一种很特殊且很有用的信号量操作。当S&gt;=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个开关。</p>
<p>这里我们增加一个限制，即最多允许RN个读者同时读。为此我们引入一个信号量L，并赋予其初值为RN，通过执行Swait(L,1,1)来控制读者的数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> RN;   <span class="comment">//最多允许RN个读者同时读</span></div><div class="line">semaphore L = RN,mx = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        Swait(L,<span class="number">1</span>,<span class="number">1</span>);   <span class="comment">//L个资源（读进程），每次分配1个，当L&lt;1时，无法分配资源，阻塞</span></div><div class="line">        SWait(mx,<span class="number">1</span>,<span class="number">0</span>);  <span class="comment">//mx&gt;=1,允许多个读进程进程进入</span></div><div class="line">        ...</div><div class="line">        read</div><div class="line">        ...</div><div class="line">        Ssignal(L,<span class="number">1</span>);     <span class="comment">//释放L资源（读者数被释放+1）</span></div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        Swait(mx,<span class="number">1</span>,<span class="number">1</span>;L,RN,<span class="number">0</span>);  <span class="comment">//表示仅当既无writer进程在写操作（mx=1)、又无reader进程在读操作（L=RN)时，writer进程才能进入临界区</span></div><div class="line">        ...</div><div class="line">        writer</div><div class="line">        ...</div><div class="line">        signal(mx,<span class="number">1</span>);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经典进程同步问题：生产者-消费者问题、哲学家进餐问题、读者-写者问题，通过信号量来实现进程之间的同步。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多重继承与虚继承</title>
    <link href="http://www.wangxinri.cn/2017/12/04/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.wangxinri.cn/2017/12/04/多重继承与虚继承/</id>
    <published>2017-12-04T02:59:00.000Z</published>
    <updated>2018-02-23T08:00:41.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p><strong>多重继承</strong>（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</p>
<a id="more"></a>
<h3 id="多重派生"><a href="#多重派生" class="headerlink" title="多重派生"></a>多重派生</h3><p>在派生类的派生列表中可以包含多个基类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Bear : public ZooAnimal &#123; /* ... */ &#125;;</div><div class="line">class Panda : public Bear,public Endangered &#123; /* ... */ &#125;;</div></pre></td></tr></table></figure>
<p><strong>和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的</strong>。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。</p>
<h4 id="多重继承的派生类从每个基类中继承状态"><a href="#多重继承的派生类从每个基类中继承状态" class="headerlink" title="多重继承的派生类从每个基类中继承状态"></a>多重继承的派生类从每个基类中继承状态</h4><p>在多重继承关系中，派生类的对象包含有每个基类的子对象。在panda对象中含有Bear部分（其中又含有ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/201712041506.png" alt="image"></p>
<h4 id="派生类构造函数初始化所有基类"><a href="#派生类构造函数初始化所有基类" class="headerlink" title="派生类构造函数初始化所有基类"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象。但只能初始化它的直接基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//显式地初始化所有基类</span></div><div class="line">Panda::Panda(<span class="built_in">string</span> name,<span class="keyword">bool</span> onExhibit):Bear(name,onExhibit,<span class="string">"Panda"</span>),Endangered(Endangered::critical) &#123;&#125;</div><div class="line"><span class="comment">//隐式地使用Bear的默认构造函数初始化Bear子对象</span></div><div class="line">Panda::Panda():Endangered(Endangered::critical) &#123;&#125;</div></pre></td></tr></table></figure>
<p>派生类的构造函数初始化列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类出现顺序一致，而与派生类构造函数初始值列表中基类的顺序无关。</p>
<p>一个Panda对象按照如下词序进行初始化：</p>
<ul>
<li>ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。</li>
<li>接下来初始化Panda的第一个直接基类Bear。</li>
<li>然后初始化Panda的第二个直接基类Endangered。</li>
<li>最后初始化Panda。</li>
</ul>
<h4 id="继承的构造函数与多重继承"><a href="#继承的构造函数与多重继承" class="headerlink" title="继承的构造函数与多重继承"></a>继承的构造函数与多重继承</h4><p>在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span>&#123;</span></div><div class="line">    Base1() <span class="keyword">default</span>;</div><div class="line">    Base1(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div><div class="line">    Base1(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span></div><div class="line">    Base2() = <span class="keyword">default</span>;</div><div class="line">    Base2(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div><div class="line">    Base2(<span class="keyword">int</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//错误：D1试图从两个基类中都继承D1::D1(const string&amp;)</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2 &#123;</div><div class="line">    <span class="keyword">using</span> Base1::Base1;      <span class="comment">//从Base1继承构造函数</span></div><div class="line">    <span class="keyword">using</span> Base2::Base2;      <span class="comment">//从Base2继承构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2 &#123;</div><div class="line">    <span class="keyword">using</span> Base1::Base1;      <span class="comment">//从Base1继承构造函数</span></div><div class="line">    <span class="keyword">using</span> Base2::Base2;      <span class="comment">//从Base2继承构造函数</span></div><div class="line">    <span class="comment">//D2必须自定义一个接受string的构造函数</span></div><div class="line">    D2(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s):Base1(s),Base2(s) &#123;&#125;</div><div class="line">    D2() = <span class="keyword">default</span>;  <span class="comment">//一旦定义了自己的构造函数，系统不提供默认构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="析构函数与多重继承"><a href="#析构函数与多重继承" class="headerlink" title="析构函数与多重继承"></a>析构函数与多重继承</h4><p>和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</p>
<p>析构函数的调用顺序正好与构造函数相反。</p>
<h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。</p>
<p>与只有一个基类的继承一样，<strong>对象、指针或引用的静态类型决定了我们能够使用哪些成员。</strong><br>如果我们使用一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered特有的部分都不可见。</p>
<h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>在只有一个基类的情况下，派生类的作用域嵌套在直接和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。</p>
<p>在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。</p>
<p>在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。</p>
<p>为避免产生多个子对象，在C++语言中我们通过<strong>虚继承</strong>（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为<strong>虚基类</strong>（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</p>
<p><strong>note: 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</strong></p>
<h3 id="使用虚基类"><a href="#使用虚基类" class="headerlink" title="使用虚基类"></a>使用虚基类</h3><p>我们指定虚基类的方式是在派生列表中添加关键字virtual：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关键字public和virtual的顺序随意</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccoon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; <span class="comment">/* ... */</span>&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal &#123; <span class="comment">/* ... */</span>&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类</p>
<p>virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。</p>
<p>如果某个类指定了虚基类，则该类的派生仍按常规方式进行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> :</span> <span class="keyword">public</span> Bear,<span class="keyword">public</span> Raccoon,<span class="keyword">public</span> Endangered&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Panda中只有一个ZooAnimal基类部分</p>
<h3 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h3><p>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。</p>
<p>与非虚的多重继承体系一样，<strong>解决这种二义性问题最好的方法是在派生类中为成员自定义新的示例。</strong></p>
<h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p><strong>在虚派生中，虚基类是由最底层的派生类（也就是最最后面的派生类）初始化的。</strong>，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。</p>
<p>为了理解这一规则，我们不妨假设当以普通规则处理初始任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。</p>
<p>当创建一个Bear（或Raccoon）的对象时，将直接初始化其ZooAnimal基类部分。</p>
<p>当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Panda::Panda(<span class="built_in">string</span> name,<span class="keyword">bool</span> onExhibit):ZooAnimal(name,onExhibit,<span class="string">"Panda"</span>),</div><div class="line">                Bear(name,onExhibit),Raccoon(name,onExhibit),</div><div class="line">                Endangered(Endangered::critical),sleeping_flag(<span class="literal">false</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="虚继承的对象的构造方式"><a href="#虚继承的对象的构造方式" class="headerlink" title="虚继承的对象的构造方式"></a>虚继承的对象的构造方式</h3><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。</p>
<p>例如：当我们创建一个Panda对象时：</p>
<ul>
<li>首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</li>
<li>接下来构造Bear部分</li>
<li>然后构造Raccoon部分</li>
<li>然后构造第三个直接基类Endangered</li>
<li>最后构造Panda部分</li>
</ul>
<p>如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。</p>
<p><strong>note: 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</strong></p>
<h3 id="构造函数与析构函数的次序"><a href="#构造函数与析构函数的次序" class="headerlink" title="构造函数与析构函数的次序"></a>构造函数与析构函数的次序</h3><p>一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> &#123;</span> ...&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character &#123; ...&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span> &#123;</span> ...&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BookCharacter,<span class="keyword">public</span> Bear,<span class="keyword">public</span> <span class="keyword">virtual</span> ToyAnimal &#123;...&#125;;</div></pre></td></tr></table></figure>
<p>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，创建一个TeddyBear对象，需要按照如下次序调用这些构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ZooAnimal();      //Bear的虚基类</div><div class="line">ToyAnimal();      //直接虚基类</div><div class="line">Character();      //第一个非虚基类的间接基类</div><div class="line">BookCharacter();     //第一个直接非虚基类</div><div class="line">Bear();           //第二个直接非虚基类</div><div class="line">TeddyBear();      //最低层的派生类</div></pre></td></tr></table></figure>
<p>合成的拷贝和移动构造函数按照完成相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后ZooAnimal部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多重继承与虚继承&quot;&gt;&lt;a href=&quot;#多重继承与虚继承&quot; class=&quot;headerlink&quot; title=&quot;多重继承与虚继承&quot;&gt;&lt;/a&gt;多重继承与虚继承&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;多重继承&lt;/strong&gt;（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="虚继承" scheme="http://www.wangxinri.cn/tags/%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>异常处理与命令空间</title>
    <link href="http://www.wangxinri.cn/2017/12/03/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4/"/>
    <id>http://www.wangxinri.cn/2017/12/03/异常处理与命令空间/</id>
    <published>2017-12-03T02:59:00.000Z</published>
    <updated>2018-02-23T08:03:17.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>异常处理</strong>（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。</p>
<a id="more"></a>
<p>当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。</p>
<p>因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。</p>
<h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><p>当抛出一个异常时，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch字句。当throw出现在一个<strong>try语句块</strong>内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。</p>
<p>上述过程被称为<strong>栈展开</strong>（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。</p>
<p>假设找到了一个匹配的catch字句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。</p>
<p>如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数<strong>terminate</strong>，顾名思义，terminate负责终止程序的执行过程。</p>
<p><strong>note:</strong> 一个异常如果没有被捕获，则它将终止当前的程序。</p>
<h3 id="栈展开过程中对象被自动销毁"><a href="#栈展开过程中对象被自动销毁" class="headerlink" title="栈展开过程中对象被自动销毁"></a>栈展开过程中对象被自动销毁</h3><p>块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。</p>
<p>如果异常发生在构造函数中，则当前的对象可能只构造了一部分。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。数组或标准库容器的元素初始化过程中，也是一样的。</p>
<h3 id="析构函数与异常"><a href="#析构函数与异常" class="headerlink" title="析构函数与异常"></a>析构函数与异常</h3><p>在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。</p>
<h3 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h3><p>异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。</p>
<p>异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。</p>
<p>当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>catch子句中的<strong>异常声明</strong>（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>
<p>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。</p>
<h4 id="查找匹配的处理代码"><a href="#查找匹配的处理代码" class="headerlink" title="查找匹配的处理代码"></a>查找匹配的处理代码</h4><p>在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。</p>
<p>因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，<strong>使得派生类异常的处理代码出现在基类异常的处理代码之前。</strong></p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会在某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发<strong>命名空间污染</strong>。</p>
<p><strong>命名空间</strong>（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命令空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>一个命令空间的定义包含两个部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。</p>
<p><strong>using声明：</strong> 是一种将命名空间中的某个名字注入当前作用域的机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div></pre></td></tr></table></figure>
<p>上述语句使得命令空间std中的名字cout在当前作用域可见。之后，我们将可以直接使用cout而无须前缀std::了。</p>
<p><strong>using指示：</strong> 是具有如下形式的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> NS;</div></pre></td></tr></table></figure>
<p>上述语句使得命名空间NS的所有名字在using指示所在的作用域以及NS所在的作用域都变得可见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;异常处理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;异常处理&lt;/strong&gt;（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="异常处理" scheme="http://www.wangxinri.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>函数模版和类模板</title>
    <link href="http://www.wangxinri.cn/2017/12/01/%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    <id>http://www.wangxinri.cn/2017/12/01/函数模版和类模板/</id>
    <published>2017-12-01T02:59:00.000Z</published>
    <updated>2018-02-23T07:21:59.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p>
<a id="more"></a>
<p>本书第Ⅱ部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。</p>
<p>例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。</p>
<p>模版是泛型编程的基础。我们不必了解模版是如何定义的就能使用它们，实际上我们已经这样用了。</p>
<p><strong>模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。</strong> </p>
<h2 id="定义模版"><a href="#定义模版" class="headerlink" title="定义模版"></a>定义模版</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v1&lt;v2) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(v2&lt;v1) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模版定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p>
<p><strong>note: 在模板定义中，模板参数列表不能为空。</strong></p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。</p>
<p>T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。</p>
<h4 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h4><p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用参数的类型来确定绑定到模板参数T的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//T为int</span></div></pre></td></tr></table></figure>
<p>实参类型是int。编译器会推断出模板参数为int，并将它绑定到模板参数T。</p>
<p>编译器用推断出的模板参数来为我们<strong>实例化</strong>（instantiate）一个特定版本的函数。</p>
<p>如上调用将实例化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化出 int compare(const int&amp;, const int&amp;) &#123; ...; &#125;</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//T为int</span></div></pre></td></tr></table></figure>
<h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>一般来说，我们可以将模板类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确：返回类型和参数类型相同</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="function">T <span class="title">foo</span><span class="params">(T *p)</span></span>&#123;</div><div class="line">    T tem = *p;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类型参数前必须使用关键字typename 或 class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误：U之前必须加上class或typename</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,U&gt;</div><div class="line"><span class="comment">//正确：在模板参数列表中，typename和class没有什么不同</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></div></pre></td></tr></table></figure>
<p>typename是在模板已经广泛使用之后才引入C++语言的，推荐使用。</p>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。</p>
<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>
<p>例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char 的数组。由于我们不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N,<span class="keyword">unsigned</span> M&gt;</div><div class="line">int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们调用这个版本的compare时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compare(<span class="string">"hi"</span>,<span class="string">"mom"</span>)</div></pre></td></tr></table></figure>
<p>编译器会实例化出如下版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</div></pre></td></tr></table></figure>
<p>在模板定义内，模板非类型参数时一个常量值。在需要常量表达式的地方，可以使用非类型参数。</p>
<p><strong>note: 非类型模板参数的模板实参必须是常量表达式。</strong></p>
<h4 id="inline-和-constexpr的函数模板"><a href="#inline-和-constexpr的函数模板" class="headerlink" title="inline 和 constexpr的函数模板"></a>inline 和 constexpr的函数模板</h4><p>函数模板可以声明为inline或constexpr的，如同非模板函数一样。<strong>inline或constexpr说明符放在模板参数之后，返回类型之前。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确：inline说明符跟在模板参数列表之后</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="编写类型无关的代码"><a href="#编写类型无关的代码" class="headerlink" title="编写类型无关的代码"></a>编写类型无关的代码</h4><p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：</p>
<ul>
<li>模板中的函数参数是const的引用。</li>
<li>函数体中的条件判断仅使用&lt;比较运算。</li>
</ul>
<p>大多数类型都允许拷贝，但是，不允许拷贝的类类型也是存在的。通过设置为引用，保证这写类型可以处理。而且，当处理大对象时，这种设计策略还能使函数运行得更快。</p>
<p><strong>注意： 模板程序应该尽量减少对实参类型的要求。</strong></p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。</p>
<p><strong>note: 函数模板和雷模板成员函数的定义通常放在头文件中</strong>。</p>
<font color="red"> <strong>警告：保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。</strong> </font>

<p>示例：定义自己版本的begin和end，同时编写一个constexpr模板，返回给定数组的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// the same as std::begin</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> size&gt;</div><div class="line">T* begin_def(T(&amp;arr)[size])&#123;   //arr数组的引用</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">// the same as std::end</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> size&gt;</div><div class="line">T* end_def(T(&amp;arr)[size])&#123;</div><div class="line">    <span class="comment">//We usually don't use a function name which is the same as the function of standard libary</span></div><div class="line">    <span class="comment">//This should not be const</span></div><div class="line">    <span class="keyword">return</span> arr + size;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> size&gt;</div><div class="line">constexpr unsigned getSize(const T(&amp;arr)[size])&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s[] = &#123; <span class="string">"sssss"</span>,<span class="string">"ss"</span>,<span class="string">"ss"</span>,<span class="string">"ssssszzzz"</span> &#125;;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(begin_def(s)) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(end_def(s) - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">string</span> s1[] = &#123; <span class="string">"sss"</span> &#125;;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; getSize(s1) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//1</span></div><div class="line">    <span class="keyword">char</span> c[] = <span class="string">"s"</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; getSize(c) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//2</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p><strong>类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息—-用来代替模板参数的模板实参列表。</strong></p>
<h4 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h4><p>类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。</p>
<h4 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h4><p>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。</string></p>
<h4 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h4><p>类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，<strong>定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</strong></p>
<p>对应的Blob的成员应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>)</div></pre></td></tr></table></figure>
<h4 id="类模板成员函数的实例化"><a href="#类模板成员函数的实例化" class="headerlink" title="类模板成员函数的实例化"></a>类模板成员函数的实例化</h4><p>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p>
<h4 id="在类代码内简化模板类名的使用"><a href="#在类代码内简化模板类名的使用" class="headerlink" title="在类代码内简化模板类名的使用"></a>在类代码内简化模板类名的使用</h4><p>当我们使用一个类模板类型时必须提供模板参数，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参</p>
<h4 id="在类模板外使用类模板名"><a href="#在类模板外使用类模板名" class="headerlink" title="在类模板外使用类模板名"></a>在类模板外使用类模板名</h4><p>当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重载BlobPtr&lt;T&gt;模板类的后置递增运算符</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   <span class="comment">//类外，返回类型BlobPtr&lt;T&gt;</span></div><div class="line">    <span class="comment">//类内，BlobPtr无须提供模板参数，写成 BlobPtr 等价 BlobPtr&lt;T&gt; ret = *this;</span></div><div class="line">    BlobPtr ret = *<span class="keyword">this</span>;   </div><div class="line">    ++*<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> ret;     <span class="comment">//返回保存的类型</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类模板完整示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span>    <span class="comment">//typedef int size;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::size_type size_type;</div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    Blob();</div><div class="line">    Blob(<span class="built_in">initializer_list</span>&lt;T&gt; i1);</div><div class="line">    <span class="comment">//Blob中的元素数目</span></div><div class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;size(); &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</div><div class="line">    <span class="comment">//添加和删除元素</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class="line">    <span class="comment">//移动版本</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; data-&gt;push_back(move(t)); &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//元素访问</span></div><div class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</div><div class="line">    T&amp; <span class="keyword">operator</span>[] (size_type i);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;T&gt;&gt; data;</div><div class="line">    <span class="comment">//若data[i]无效，则抛出msg</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i,<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T&amp; Blob&lt;T&gt;::back()&#123;</div><div class="line">    check(<span class="number">0</span>,<span class="string">"subscript out of range"</span>);</div><div class="line">    <span class="keyword">return</span> data-&gt;back();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i) &#123;</div><div class="line">    check(i,<span class="string">"subscript out of range"</span>);</div><div class="line">    (*data)[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> Blob&lt;T&gt;::pop_back()&#123;</div><div class="line">    check(<span class="number">0</span>,<span class="string">"pop_back on empty Blob"</span>);</div><div class="line">    data-&gt;pop_back();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Blob&lt;T&gt;::Blob():data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Blob&lt;T&gt;::Blob(<span class="built_in">initializer_list</span>&lt;T&gt; i1): data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;(i1)) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i,<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span>&#123;</div><div class="line">    <span class="keyword">if</span>(i&gt;=data-&gt;size()) <span class="keyword">throw</span> out_of_range(msg);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Blob&lt;<span class="keyword">int</span>&gt; ib = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</div><div class="line">    <span class="keyword">int</span> back = ib.back();</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;back&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;ib.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数。</strong></p>
<h4 id="类模板和友元（暂时不看）"><a href="#类模板和友元（暂时不看）" class="headerlink" title="类模板和友元（暂时不看）"></a>类模板和友元（暂时不看）</h4><h4 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h4><p>与任何其他类相同，类模板可以声明static成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</div><div class="line">    <span class="comment">//其他接口成员</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr;</div><div class="line">    <span class="comment">//其他实现成员</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个Foo的实例都有其自己的static成员实例。即，对于任意给定类型X，都有一个Foo<x>::ctr和一个Foo<x>::count成员。所有Foo<x>类型的对象共享相同的ctr对象和count对象。</x></x></x></p>
<p>我们将static数据成员也定义为模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;  <span class="comment">//定义并初始化ctr</span></div></pre></td></tr></table></figure>
<p>访问类模板的static成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;     <span class="comment">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></div><div class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt;:count();       <span class="comment">//实例化Foo&lt;int&gt;::count</span></div><div class="line">ct = fi.count();        <span class="comment">//使用Foo&lt;int&gt;::count</span></div><div class="line">ct = Foo::count();       <span class="comment">//错误：使用哪个模板实例的count?</span></div></pre></td></tr></table></figure>
<p>类似于任何其他成员函数，一个static成员函数只有在使用时才会实例化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="模板" scheme="http://www.wangxinri.cn/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>模板参数与成员模版</title>
    <link href="http://www.wangxinri.cn/2017/12/01/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E6%A8%A1%E7%89%88/"/>
    <id>http://www.wangxinri.cn/2017/12/01/模板参数与成员模版/</id>
    <published>2017-12-01T02:49:00.000Z</published>
    <updated>2018-02-23T08:08:23.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><h3 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h3><p>模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span>&#123;</div><div class="line">    A tmp = a;         <span class="comment">//tmp的类型为模板参数A的类型，而非double</span></div><div class="line">    <span class="keyword">double</span> B;         <span class="comment">//错误：重声明模板参数B</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误：非法重用模板参数名V</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> V&gt;   <span class="comment">//...</span></div></pre></td></tr></table></figure>
<h3 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h3><p>模版声明必须包含模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明但不定义compare和Blob</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></div></pre></td></tr></table></figure>
<p>与函数参数相同，声明中的模板参数的名字不必与定义中相同。</p>
<p><strong>建议：</strong> 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>
<h3 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h3><p>例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T::size_type * p;</div></pre></td></tr></table></figure>
<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>
<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="comment">//typename T::value_type 使用关键字通过编译器该名字T::value_type表示类型</span></div><div class="line"><span class="keyword">typename</span> T::<span class="function">value_type <span class="title">top</span> <span class="params">(<span class="keyword">const</span> T &amp;c)</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="red">  <strong>note:当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。</strong> </font> 

<h3 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h3><p>就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。</p>
<p>例如，我们重写compare，默认使用标准库的less函数对象模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> F = less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2, F f = F())&#123;</div><div class="line">    <span class="keyword">if</span>(f(v1,v2)) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(f(v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h3><p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt;</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">Numbers</span>&#123;</span>    <span class="comment">//T默认为int</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Numbers(T v=<span class="number">0</span>):val(v) &#123;&#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; num1;</div><div class="line">Numbers&lt;&gt; num2;        <span class="comment">//空&lt;&gt;表示我们希望使用默认类型</span></div></pre></td></tr></table></figure>
<p>习题示例：</p>
<p>编写函数，接受一个容器的引用，打印容器中的元素，两种方式，一种使用容器的size_type和size成员来控制打印元素的循环；另一种使用begin和end返回迭代器来控制循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">(<span class="keyword">const</span> Container &amp;container)</span></span>&#123;</div><div class="line">    <span class="comment">//typename Container::size_type  表明size_type是一个类型</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> Container::size_type i = <span class="number">0</span>;i&lt;container.size();++i)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;container[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="keyword">const</span> Container &amp;container)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = container.begin();iter!=container.end();++iter)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</div><div class="line">print1(ivec);</div><div class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist = &#123;<span class="string">"wang"</span>,<span class="string">"xin"</span>,<span class="string">"ri"</span>&#125;;</div><div class="line">print2(slist);</div></pre></td></tr></table></figure>
<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（member template）。成员模板不能是虚函数。</p>
<h3 id="普通（非模板）类的成员模板"><a href="#普通（非模板）类的成员模板" class="headerlink" title="普通（非模板）类的成员模板"></a>普通（非模板）类的成员模板</h3><p>例如，我们定义一个类，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。由于希望delete使用于任何类型，所以我们将调用运算符定义为一个模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DebugDelete(ostream &amp;s = <span class="built_in">cerr</span>):os(s)&#123;&#125;</div><div class="line">    <span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span> </span>&#123;    <span class="comment">//成员模板，重载函数调用运算符</span></div><div class="line">        os&lt;&lt;<span class="string">"deleting unique_ptr"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">delete</span> p;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    ostream &amp;os;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">double</span> *p = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    DebugDelete d;</div><div class="line">    d(p);     <span class="comment">//调用DebugDelete::operator() (double*),释放p</span></div><div class="line">    <span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>;</div><div class="line">    <span class="comment">//在一个临时DebugDelete对象上调用operator()(int*)</span></div><div class="line">    DebugDelete()(ip);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h3><p>对于类模板，我们也可以为其定义成员模板。再此情况下，类和成员各自有自己的、独立的模板参数。</p>
<p>与类模板的普通函数成员不同，成员模板是函数模板。<strong>当我们在类模板外定义一个成员模板时</strong>，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类模板外定义成员模板</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">//类的类型参数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;      <span class="comment">//构造函数的类型参数</span></div><div class="line">Blob&lt;T&gt;::Blob(It b,It e):data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;(b,e)) &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h2><p>当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例。</p>
<p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过<strong>显式实例化</strong>来避免这种开销。一个显式实例化有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;        <span class="comment">//实例化声明</span></div><div class="line"><span class="keyword">template</span> declaration；              <span class="comment">//实例化定义</span></div></pre></td></tr></table></figure>
<p>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化声明与定义</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>         <span class="comment">//声明</span></div><div class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;       <span class="comment">//定义</span></div></pre></td></tr></table></figure>
<p>当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<p><strong>警告：</strong> 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</p>
<h3 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h3><p>一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。</p>
<p><strong>note:</strong> 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模板参数&quot;&gt;&lt;a href=&quot;#模板参数&quot; class=&quot;headerlink&quot; title=&quot;模板参数&quot;&gt;&lt;/a&gt;模板参数&lt;/h2&gt;&lt;h3 id=&quot;模板参数与作用域&quot;&gt;&lt;a href=&quot;#模板参数与作用域&quot; class=&quot;headerlink&quot; title=&quot;模板参数与作用域&quot;&gt;&lt;/a&gt;模板参数与作用域&lt;/h3&gt;&lt;p&gt;模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="模板" scheme="http://www.wangxinri.cn/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>虚函数与抽象基类</title>
    <link href="http://www.wangxinri.cn/2017/11/23/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
    <id>http://www.wangxinri.cn/2017/11/23/虚函数与抽象基类/</id>
    <published>2017-11-23T13:59:00.000Z</published>
    <updated>2018-02-23T00:58:41.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，<strong>所以所有的虚函数都必须有定义</strong>。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。</p>
<a id="more"></a>
<h3 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h3><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。</p>
<p>必须要搞清楚一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">base = derived;     <span class="comment">//把derived的Quote部分拷贝给base</span></div><div class="line">base.net_price(<span class="number">20</span>);     <span class="comment">//调用Quote::net_price</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</p>
<h3 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>当我们在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p><strong>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</strong></p>
<p>同样，派生类中虚函数的返回类型也必须与基类匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。</p>
<h3 id="final和override说明符"><a href="#final和override说明符" class="headerlink" title="final和override说明符"></a>final和override说明符</h3><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>在类的设计中常常会用到虚函数。但是存在一个问题，在派生类中本来是要重写基类中的虚函数的时候，由于写错参数类型，写错函数名等问题，造成重新定义了一个函数，这往往会造成意想不到的错误。想要调试并发现这样的错误显然非常困难，c++11引入关键字<strong>override</strong>。在派生类中重写了虚函数以后，可以使用override来修饰重写的虚函数，这个时候如果基类中没有这个虚函数，此时编译器将报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span>B&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> override</span>;    <span class="comment">//正确：f1与基类中的f1匹配</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> override</span>;         <span class="comment">//错误：B没有形如f2(int)的函数</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> override</span>;         <span class="comment">//错误：f3不是虚函数</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> override</span>;           <span class="comment">//错误：B没有名为f4的函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>在设计基类的时候，有时候我们不想后续的的派生类覆盖某个方法，这个时候，我们可以将这个方法修饰为 final 。派生类中任何试图覆盖该函数的行为都将导致错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span>:</span>B&#123;</div><div class="line">    <span class="comment">//从B继承f2()和f3(),覆盖f1(int)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;        <span class="comment">//不允许后续的其他类覆盖f1(int)</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span>:</span>D2 &#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">//正确：覆盖从间接基类B继承而来的f2</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;      <span class="comment">//错误：D2已经将f2声明成final</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h3><p><strong>虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</strong></p>
<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p><strong>建议：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>
<h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。<strong>使用作用域运算符可以实现这一目的</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></div><div class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</div></pre></td></tr></table></figure>
<p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p><strong>和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。</strong></p>
<p>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能再类的内部为一个=0的函数提供函数体。</p>
<h3 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h3><p>含有（或者未经覆盖直接继承）纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。<strong>我们不能（直接）创建一个抽象基类的对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></div><div class="line">Disc_quote discounted;        <span class="comment">//错误：不能定义Disc_quote的对象</span></div><div class="line">Bulk_quote bulk;              <span class="comment">//正确：Bulk_quote中没有纯虚函数</span></div></pre></td></tr></table></figure>
<p><strong>note:</strong> <font color="red"> <strong>我们不能创建抽象基类的对象。</strong> </font></p>
<h3 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h3><p>先初始化基类的构造函数、再初始化自己的构造函数，最后执行构造函数体部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h2&gt;&lt;p&gt;在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，&lt;strong&gt;所以所有的虚函数都必须有定义&lt;/strong&gt;。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="虚函数" scheme="http://www.wangxinri.cn/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>访问控制与继承</title>
    <link href="http://www.wangxinri.cn/2017/11/23/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.wangxinri.cn/2017/11/23/访问控制与继承/</id>
    <published>2017-11-23T02:59:00.000Z</published>
    <updated>2018-02-23T08:13:10.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。</p>
<a id="more"></a>
<h3 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h3><ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>
<li>和共有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
</ul>
<p>此外，protected还有另外一条重要的性质。</p>
<ul>
<li><strong>派生类的成员或友元只能通过派生类对象来访问基类受的保护成员。派生类对于一个基类对象中的受保护的成员没有任何访问权限</strong>。</li>
</ul>
<p>考虑如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> prot_mem;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;     <span class="comment">//能访问Sneaky::prot_mem</span></div><div class="line">    friend void clobber(Base&amp;)；   //不能访问Base::prot_mem</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//正确：clobber能访问Sneaky对象的private和protected成员</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123;s.j = s.prot_mem = <span class="number">0</span>;&#125;</div><div class="line"><span class="comment">//错误：clobber不能访问Base的protected成员</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123; b.prot_mem = <span class="number">0</span>;&#125;</div></pre></td></tr></table></figure>
<h3 id="公有、私有和受保护继承-（重点）"><a href="#公有、私有和受保护继承-（重点）" class="headerlink" title="公有、私有和受保护继承  （重点）"></a>公有、私有和受保护继承  （重点）</h3><p>某个类对其继承而来的成员的访问权限受到两个因素影响：<strong>一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</strong></p>
<p><strong>派生类访问说明符</strong>（继承的类是公有、私有还是受保护）对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，基类成员的访问权限只与基类中的访问说明符有关（派生类的成员不能访问基类私有成员，可以访问基类公有和受保护成员）。</p>
<p><strong>派生类访问说明符的目的</strong>是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：</p>
<ul>
<li>如果继承是公有的，对于派生类用户来讲，基类中成员遵循其原有的访问说明符。</li>
<li>如果继承是私有的，对于派生类用户来讲，基类中的成员访问说明符都是私有的。</li>
<li>如果继承是受保护的，对于派生类用户来讲，基类的所有公有成员在新定义的类中都是受保护的，基类中的受保护和私有成员遵循原来的访问说明符。</li>
</ul>
<h3 id="派生类向基类转换的可访问性-（略）"><a href="#派生类向基类转换的可访问性-（略）" class="headerlink" title="派生类向基类转换的可访问性  （略）"></a>派生类向基类转换的可访问性  （略）</h3><ul>
<li><strong>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护或者私有的，则用户代码不能使用该转换。</strong></li>
</ul>
<p><strong>关键概念：类的设计与受保护的成员</strong></p>
<p>不考虑继承的话，我们可以认为一个类有两种不同的用户：<strong>普通用户和类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。</p>
<p>如果进一步考虑继承的话就会出现第三种用户：<strong>即派生类</strong>。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可以供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。</p>
<h3 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h3><p>不能继承友元关系；每个类负责控制各自成员的访问权限。</p>
<h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用<strong>using声明</strong>可以达到这一目的。</p>
<p>派生类只能为那些它可以访问的名字提供using声明。</p>
<h3 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h3><p>使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。</p>
<p>一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;访问控制与继承&quot;&gt;&lt;a href=&quot;#访问控制与继承&quot; class=&quot;headerlink&quot; title=&quot;访问控制与继承&quot;&gt;&lt;/a&gt;访问控制与继承&lt;/h2&gt;&lt;p&gt;每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.wangxinri.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>OOP概述（object-oriented programming）</title>
    <link href="http://www.wangxinri.cn/2017/11/19/OOP%E6%A6%82%E8%BF%B0%EF%BC%88object-oriented-programming%EF%BC%89/"/>
    <id>http://www.wangxinri.cn/2017/11/19/OOP概述（object-oriented-programming）/</id>
    <published>2017-11-19T13:59:00.000Z</published>
    <updated>2018-02-22T13:23:07.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面向对象程序设计基于三个基本概念：<strong>数据抽象、继承和动态绑定</strong>。</p>
<a id="more"></a>
<p><strong>继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。</strong></p>
<h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p>面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为<strong>派生类</strong>。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为<strong>运行时绑定</strong>。</p>
<p><strong>note:</strong> <strong>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong>。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p><strong>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</strong></p>
<h3 id="成员函数和继承"><a href="#成员函数和继承" class="headerlink" title="成员函数和继承"></a>成员函数和继承</h3><p>派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以<strong>覆盖</strong>（override）从基类继承而来的旧定义。</p>
<p>在C++语言中，基类必须将它的两种成员函数区分开来：<strong>一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数</strong>。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，<strong>该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</strong></p>
<p>基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。<strong>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</strong></p>
<p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>
<h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，<strong>派生类能访问公用成员，而不能访问私有成员</strong>。不过在某些时候基类中还有这样一种成员，<strong>基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员</strong>。</p>
<ul>
<li>private member: base class itself and friend can access</li>
<li>protected members: base class itself,friend and derived classes can access</li>
</ul>
<h2 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h2><p>派生类必须通过使用<strong>派生类列表</strong>明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。</p>
<p>如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。</p>
<h3 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字<strong>override</strong>。</p>
<h3 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h3><p>一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>
<p><strong>在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。</strong></p>
<h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分</span></div><div class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">string</span>&amp; book,<span class="keyword">double</span> p,<span class="keyword">size_t</span> qty,<span class="keyword">double</span> disc):Quote(book,p),min_qty(qty),discount(disc) &#123;&#125;</div></pre></td></tr></table></figure>
<font color="red"> <strong>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</strong> </font>


<h3 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h3><p><strong>派生类可以访问基类的公有成员和受保护成员</strong>：</p>
<p>其中price是基类中的受保护成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></div><div class="line"><span class="keyword">double</span> Bulk_quote::net_price(<span class="keyword">size_t</span> cnt) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">if</span>(cnt &gt;= min_qty) &#123;</div><div class="line">        <span class="keyword">return</span> cnt*(<span class="number">1</span>-discount)*price;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> cnt*price;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>遵循基类的接口</strong></p>
<p>必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。</p>
<p>因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void Derived::f(const Derived &amp;derived_obj)&#123;</div><div class="line">    Base::statmem();</div><div class="line">    Derived::statmem();</div><div class="line">    derived_obj.statmem();</div><div class="line">    statmem();         //通过this对象访问</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h3><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p>
<p>一个类不能派生它本身。</p>
<h3 id="防止继承发生"><a href="#防止继承发生" class="headerlink" title="防止继承发生"></a>防止继承发生</h3><p>有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，<strong>即在类名后跟一个关键字final</strong>。</p>
<h2 id="类型抓换与继承"><a href="#类型抓换与继承" class="headerlink" title="类型抓换与继承"></a>类型抓换与继承</h2><p><strong>理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。</strong></p>
<p>通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：<strong>我们可以将基类的指针或引用绑定到派生类对象上</strong>。</p>
<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>
<h3 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h3><p>因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Quote base;</div><div class="line">Bulk_quote* bulkP = &amp;base;    <span class="comment">//错误：不能将基类转换成派生类</span></div><div class="line">Bulk_quote* bulkRef = base;   <span class="comment">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>
<p>除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bulk_quote bulk;</div><div class="line">Quote *itemP = &amp;bulk;      <span class="comment">//正确：动态类型是Bulk_quote</span></div><div class="line">Bulk_quote *bulkP = itemP;      <span class="comment">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>
<h3 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h3><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bulk_quote bulk;      <span class="comment">//派生类对象</span></div><div class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;     <span class="comment">//使用Quote::Quote(const Quote&amp;)  构造函数</span></div><div class="line">item = bulk;          <span class="comment">//调用Quote::operator=(const Quote&amp;)</span></div></pre></td></tr></table></figure>
<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
<p><strong>关键概念：存在继承关系的类型之间的转换规则</strong></p>
<p>1、从派生类向基类的类型转换只对指针或引用类型有效。</p>
<p>2、基类向派生类不存在隐式类型转换。</p>
<p>3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。</p>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;面向对象程序设计基于三个基本概念：&lt;strong&gt;数据抽象、继承和动态绑定&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="OOP" scheme="http://www.wangxinri.cn/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>常用运算符重载</title>
    <link href="http://www.wangxinri.cn/2017/11/18/%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://www.wangxinri.cn/2017/11/18/常用运算符重载/</id>
    <published>2017-11-18T13:59:00.000Z</published>
    <updated>2018-02-22T12:27:58.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。</p>
<p><strong>如果一个运算符函数是成员函数，这他的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。</strong></p>
<p>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误：不能为int重定义内置的运算符</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">int</span>,<span class="keyword">int</span>);</div></pre></td></tr></table></figure>
<p>这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</p>
<h3 id="直接调用一个重载的运算符函数"><a href="#直接调用一个重载的运算符函数" class="headerlink" title="直接调用一个重载的运算符函数"></a>直接调用一个重载的运算符函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个非成员运算符函数的等价调用</span></div><div class="line">data1 + data2;          <span class="comment">//普通的表达式</span></div><div class="line"><span class="keyword">operator</span>+(data1,data2);       <span class="comment">//等价的函数调用</span></div></pre></td></tr></table></figure>
<p>这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个成员运算符函数的等价调用</span></div><div class="line">data1 += data2;        <span class="comment">//基于“调用”的表达式</span></div><div class="line">data1.<span class="keyword">operator</span>+=(data2);         <span class="comment">//对成员运算符</span></div></pre></td></tr></table></figure>
<p>这两天语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。</p>
<h3 id="某些运算符不应该被重载"><a href="#某些运算符不应该被重载" class="headerlink" title="某些运算符不应该被重载"></a>某些运算符不应该被重载</h3><p>某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。</p>
<p>比如：&amp;&amp; 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，这两个运算对象总是会被求值。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。</p>
<p><strong>通常情况下：不应该重载逗号、取地址、逻辑与和逻辑或运算符。</strong></p>
<h3 id="赋值和复合赋值运算符"><a href="#赋值和复合赋值运算符" class="headerlink" title="赋值和复合赋值运算符"></a>赋值和复合赋值运算符</h3><p>赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧的运算对象的一个引用。重载的赋值运算符应该继承而非违背其内置版本的含义。</p>
<p>如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。+=运算符的行为显然与其内置版本一致，即先执行+，再执行=。</p>
<h3 id="选择作为成员或者非成员-（重点）"><a href="#选择作为成员或者非成员-（重点）" class="headerlink" title="选择作为成员或者非成员 （重点）"></a>选择作为成员或者非成员 （重点）</h3><p>当我们定义重载的运算符必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。</p>
<p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：</p>
<ul>
<li>赋值（=）、下标（[])、调用（（））和成员访问箭头（-&gt;）运算符必须是成员</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li>
<li>具有对称性的运算符可以转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ul>
<p>例如，我们能求一个int和一个double的和，因为它们中任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。<strong>如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。</strong></p>
<p>当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s = <span class="string">"world"</span>;</div><div class="line"><span class="built_in">string</span> t = s + <span class="string">"!"</span>;    <span class="comment">//正确：我们能把一个const char*加到一个string对象中</span></div><div class="line"><span class="built_in">string</span> u = <span class="string">"hi"</span> + s;     <span class="comment">//如果 + 是string的成员，则产生错误</span></div></pre></td></tr></table></figure>
<p>如果operator+是string类的成员，则上面的第一个加法等价于s.operator+(“!”)。同样的，”hi”+s等价于”hi”.operator+(s)。显然”hi”的类型是const char*,这是一种内置类型，根本就没有成员函数。</p>
<p>因为string将+定义成了普通的非成员函数，所以”hi”+s等价于operator+(“hi”,s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准备无误地转换成string。</p>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。</p>
<h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用时因为我们无法直接赋值一个ostream对象。</p>
<p>第二个形参一般来说是一个常量的引用，因为打印对象不会改变对象的内容，为了与其他输出运算符保持一致，operator&lt;&lt;一般要返回它的ostream形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="keyword">const</span> Sales_data &amp;item)&#123;</div><div class="line">    os&lt;&lt;item.isbn()&lt;&lt;item.avg_price();</div><div class="line">    <span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>输入输出运算符必须是非成员函数</strong>，通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is,Sales_data &amp;item)&#123;</div><div class="line">    <span class="keyword">double</span> price ;</div><div class="line">    is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price;  </div><div class="line">    <span class="keyword">if</span>(is)&#123;    <span class="comment">//检查输入是否成功</span></div><div class="line">        item.revenue = item.units_sold*price;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        item = Sales_data();       <span class="comment">//输入失败：对象被赋予默认的状态</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>note:</strong> 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>如果类同时定义了算符运算符和相关的复合赋值运算符（+=），则通常情况下应该使用复合赋值来实现算术运算符。</p>
<h3 id="相等运算符-（-）"><a href="#相等运算符-（-）" class="headerlink" title="相等运算符  （==）"></a>相等运算符  （==）</h3><p>如果某个类在逻辑上有相等性的含义，则该类应该定义operator == ，这样做可以使得用户更容易使用标准库算法来处理这个类。</p>
<h3 id="关系运算符-（-lt-）"><a href="#关系运算符-（-lt-）" class="headerlink" title="关系运算符 （&lt;）"></a>关系运算符 （&lt;）</h3><p>定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较有用。</p>
<p>通常情况下关系运算符应该</p>
<ul>
<li>定义顺序关系，令其与关联容器中对关键字的要求一致。</li>
<li>如果类同时也包含==运算符的话，则定义一种关系令其与 ==保持一致。特别是，如果两个对象是!=的，那么一个对象应该&lt;另外一个。</li>
</ul>
<p><strong>注意：</strong> 如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和 ==产生的结果一致时才定义 &lt;运算符。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数</p>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p><strong>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作为成员的二元运算符：左侧运算对象绑定到隐式的this指针</span></div><div class="line"><span class="comment">//假定两个对象表示的是同一本书</span></div><div class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+= (<span class="keyword">const</span> Sales_data &amp;rhs)&#123;</div><div class="line">    <span class="keyword">this</span>.units_sole += rhs.units_sole;</div><div class="line">    <span class="keyword">this</span>.revenue += rhs.revenue;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p>
<p><strong>note: 下标运算符必须是成员函数。</strong></p>
<p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。<strong>进一步，我们最好定义下标运算符的常量版本和非常量版本，当作用与一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值</strong>。</p>
<p>定义StrVec的下标运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) &#123;<span class="keyword">return</span> elements[n];&#125;</div><div class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;<span class="keyword">return</span> elements[n];&#125;</div><div class="line">    <span class="comment">//其他成员定义</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> *element;         <span class="comment">//指向数组首元素的指针</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设svec是一个StrVec对象</span></div><div class="line"><span class="keyword">const</span> StrVec cvec = svec;      <span class="comment">//把svec的元素拷贝到cvec中</span></div><div class="line"><span class="comment">//如果svec中含有元素，对第一个元素运行string的empty函数</span></div><div class="line"><span class="keyword">if</span>(svec.size() &amp;&amp; svec[<span class="number">0</span>].empty()) &#123;</div><div class="line">    svec[<span class="number">0</span>] = <span class="string">"zero"</span>;      <span class="comment">//正确:下标运算符返回string的引用</span></div><div class="line">    cvec[<span class="number">0</span>] = <span class="string">"zip"</span>;       <span class="comment">//错误：对cvec取下标返回的是常量引用，不能再赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="递增和递减运算符-（重点）"><a href="#递增和递减运算符-（重点）" class="headerlink" title="递增和递减运算符 （重点）"></a>递增和递减运算符 （重点）</h2><p>C++语言并不要求递增和递减运算符必须是类的成员，<strong>但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。</strong></p>
<p><strong>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类成员。</strong></p>
<h3 id="定义前置递增-递减运算符"><a href="#定义前置递增-递减运算符" class="headerlink" title="定义前置递增/递减运算符"></a>定义前置递增/递减运算符</h3><p>与内置版本保持一致，<strong>前置运算符应该返回递增或递减后对象的引用。 </strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer&amp; <span class="keyword">operator</span>++()&#123; ++value; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;    <span class="comment">//前置运算符</span></div></pre></td></tr></table></figure>
<h3 id="后置运算符"><a href="#后置运算符" class="headerlink" title="后置运算符"></a>后置运算符</h3><p>后置版本接受一个额外的（不被使用）int类型的形参，因为我们不会用到int形参，所以无须为其命令。</p>
<p>为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   <span class="comment">//后置运算符</span></div><div class="line">    Integer ret = *<span class="keyword">this</span>; </div><div class="line">    ++value; </div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="显示调用后置运算符"><a href="#显示调用后置运算符" class="headerlink" title="显示调用后置运算符"></a>显示调用后置运算符</h3><p>通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer INT;</div><div class="line">INT.<span class="keyword">operator</span>++(<span class="number">0</span>);   <span class="comment">//调用后置版本的operator++</span></div><div class="line">INT.<span class="keyword">operator</span>++();    <span class="comment">//调用前置版本的operator++</span></div></pre></td></tr></table></figure>
<p>完整代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Integer(<span class="keyword">int</span> a = <span class="number">0</span>):value(a)&#123;&#125;    <span class="comment">//默认值参数，如果不提供参数，调用默认构造函数，提供参数则调用构造函数</span></div><div class="line">    Integer(<span class="keyword">const</span> Integer&amp; Int):value(Int.value)&#123;&#125;   <span class="comment">//拷贝构造函数</span></div><div class="line">    Integer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Integer &amp;Int) &#123; value = Int.value; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;  <span class="comment">//拷贝赋值运算符</span></div><div class="line">    Integer&amp; <span class="keyword">operator</span>++()&#123; ++value; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;    <span class="comment">//前置运算符</span></div><div class="line">    Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; Integer ret = *<span class="keyword">this</span>; ++value; <span class="keyword">return</span> ret;&#125;  <span class="comment">//后置运算符</span></div><div class="line">    <span class="keyword">int</span> value;   <span class="comment">//含有一个数据类型</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Integer a;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;a.value&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    a.value = <span class="number">10</span>;</div><div class="line">    <span class="function">Integer <span class="title">b</span><span class="params">(a)</span></span>;   <span class="comment">//调用拷贝构造函数</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;b.value&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    Integer c;</div><div class="line">    c = a;    <span class="comment">//调用拷贝赋值运算符</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;c.value&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    ++c;   <span class="comment">//调用重载前置运算符</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;c.value&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;(c++).value&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//调用重载后置运算符</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;c.value&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="运算符重载" scheme="http://www.wangxinri.cn/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>对象移动</title>
    <link href="http://www.wangxinri.cn/2017/11/15/%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8/"/>
    <id>http://www.wangxinri.cn/2017/11/15/对象移动/</id>
    <published>2017-11-15T13:59:00.000Z</published>
    <updated>2018-02-22T12:23:17.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。</p>
<a id="more"></a>
<p><strong>noet:</strong> 标准库容器、string和shared_ptr类及支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作，新标准引入了一种新的引用类型——<strong>右值引用</strong>，就是必须绑定到右值的引用。<strong>我们通过&amp;&amp;而不是&amp;来获得右值引用</strong>。右值引用一个重要的特性就是<strong>只能绑定到将要销毁的对象。</strong></p>
<p>左值和右值是表达式的属性，一些表达式生成或要求左值，而另一些则生成或要求右值。<strong>一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的是对象的值。</strong>（<strong>可以取地址的、有名字的就是左值；不能取地址的、没有名字的就是右值</strong>。）<strong>两者明显的区别就是左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</strong>。</p>
<p>类似于常规引用（左值引用），一个右值引用也不过是某个对象的另一个名字而已。我们不能将左值引用绑定到要求转换的表达式、字面常量或是返回值的表达式，也不能把右值应用直接绑定到一个左值上。但是，<strong>常量左值引用可以绑定到非常量左值、常量左值、右值，是一个万能引用类型</strong>。不过相比右值引用所引用的右值，常量左值引用所引用的右值在它的“余生”中只能是只读的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> &amp;r = i;     <span class="comment">//r引用i</span></div><div class="line"><span class="keyword">int</span> &amp;r2 = i*<span class="number">2</span>;    <span class="comment">//错误，i*2是一个右值</span></div><div class="line"><span class="keyword">int</span> &amp;&amp;rr = i；    <span class="comment">//错误，不能将一个右值引用绑定到一个左值上</span></div><div class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i*<span class="number">2</span>;   <span class="comment">//正确，将rr2绑定到一个乘法结果上</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i*<span class="number">2</span>; <span class="comment">//正确，将一个常量引用绑定到一个右值上</span></div></pre></td></tr></table></figure>
<h3 id="左值持久；右值短暂"><a href="#左值持久；右值短暂" class="headerlink" title="左值持久；右值短暂"></a>左值持久；右值短暂</h3><p>考虑左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>
<p>由于右值引用只能绑定到临时对象，我们得知</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<p><strong>注意：</strong> 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态</p>
<h3 id="变量时左值"><a href="#变量时左值" class="headerlink" title="变量时左值"></a>变量时左值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;   <span class="comment">//正确：字面值常量是右值</span></div><div class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1;   <span class="comment">//错误：表达式rr1是左值</span></div></pre></td></tr></table></figure>
<p>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p>
<h3 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h3><p>我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为<strong>move</strong>的新标准库函数来<strong>获得绑定到左值上的右值引用</strong>，此函数定义在<strong>头文件utility</strong>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int &amp;&amp;rr3 = std::move(rr1);     //ok</div></pre></td></tr></table></figure>
<p><strong>note:</strong> 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p>
<p><strong>warning:</strong> 使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。</p>
<h2 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></div><div class="line">    <span class="built_in">string</span> i;       <span class="comment">//内置类型可以移动</span></div><div class="line">    <span class="built_in">string</span> s;     <span class="comment">//string定义了自己的移动操作</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    X x;</div><div class="line">    x.i = <span class="string">"cqu"</span>;</div><div class="line">    x.s = <span class="string">"wangxinri"</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;x.i&lt;&lt;<span class="string">" "</span>&lt;&lt;x.s&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//cqu wangxinri</span></div><div class="line">    <span class="comment">//使用合成的移动构造函数</span></div><div class="line">    X x2 = <span class="built_in">std</span>::move(x);   <span class="comment">//移后源对象x必须保持有效的、可析构的状态</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;x2.i&lt;&lt;<span class="string">" "</span>&lt;&lt;x2.s&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//cqu wangxinri</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"---------"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;x.i&lt;&lt;<span class="string">" "</span>&lt;&lt;x.s&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//输出空字符，说明x的值已经被x2接管了，x是一个可析构的状态</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"---------"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    x.i = <span class="string">"aaa"</span>;</div><div class="line">    x.s = <span class="string">"bbb"</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;x.i&lt;&lt;<span class="string">" "</span>&lt;&lt;x.s&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//  aaa  bbb</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。</p>
<p>move用来将一个右值引用绑定到一个左值的标准库函数。调用move隐含地承诺我们将不会再使用移后源对象，除了销毁它或赋予它一个新值之外。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象移动&quot;&gt;&lt;a href=&quot;#对象移动&quot; class=&quot;headerlink&quot; title=&quot;对象移动&quot;&gt;&lt;/a&gt;对象移动&lt;/h2&gt;&lt;p&gt;新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="右值引用" scheme="http://www.wangxinri.cn/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>动态内存与智能指针</title>
    <link href="http://www.wangxinri.cn/2017/11/10/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://www.wangxinri.cn/2017/11/10/动态内存与智能指针/</id>
    <published>2017-11-10T13:59:00.000Z</published>
    <updated>2018-02-22T12:18:17.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>到目前为止，我们编写的程序中所使用的对象都有着严格定义的生命期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。</p>
<a id="more"></a>
<p>除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。</p>
<p>动态对象的正确释放被证明是编程中极其容器出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p>
<h3 id="静态内存、栈内存、堆"><a href="#静态内存、栈内存、堆" class="headerlink" title="静态内存、栈内存、堆"></a>静态内存、栈内存、堆</h3><p><strong>静态内存</strong>：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</p>
<p><strong>栈内存</strong>：用来保存定义在函数内的非static对象。</p>
<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间（free store）</strong>或<strong>堆（heap）</strong>。程序用堆来存储<strong>动态分配</strong>（dynamically allocate）的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。</p>
<p><strong>warning</strong>：虽然使用动态内存有时是必要的，但众所周知，正确管理动态内存是非常棘手的。</p>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p><strong>在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针。我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</strong></p>
<p>动态内存的使用很容易出问题，因为确保在正确的时间释放内存是及其困难的。有时我们会忘记释放内存，在这种情况下就会产生<strong>内存泄漏</strong>；有时在尚有指针引用内存的情况下我们就释放它了，在这种情况下就会产生<strong>引用非法内存的指针</strong>。</p>
<p>为了更容易（同时也安全）地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。只能指针的行为类似常规指针，重要的区别是<strong>它负责自动释放所指向的对象</strong>。新标准库提供的这两种只能指针的区别在于管理底层指针的方式：<strong>shared_ptr允许多个指针指向同一对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</strong></p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>类似vector，只能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种指针的名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1 ; <span class="comment">//shared_ptr,可以指向string</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; p2;  <span class="comment">//shared_ptr,可以指向int的list</span></div></pre></td></tr></table></figure>
<p>默认初始化的智能指针中保存着一个空指针。</p>
<p>只能指针的使用方式与普通指针类似。解引用一个智能指针返回它所指的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果p1不为空，检查它是否指向一个空string</span></div><div class="line"><span class="keyword">if</span>(p1&amp;&amp;p1-&gt;empty())</div><div class="line">　　*p1=<span class="string">"hi"</span>;</div></pre></td></tr></table></figure>
<p>下表列出了shared_ptr和unique_ptr都支持的操作。只适用shared_ptr的操作列入下面。</p>
<p> <strong>shared_ptr和unique_ptr都支持的操作</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; sp     空智能指针，可以指向类型为T的对象</div><div class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; up    </div><div class="line">p　　　　　　将p用作一个条件判断，若p指向一个对象，则为<span class="literal">true</span></div><div class="line">*p　　　　　　解引用p，获得它指向的对象</div><div class="line">p-&gt;mem　　　　　等价于(*p).mem</div><div class="line">p.get()　　　　　　返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</div><div class="line">swap(p,q) 　　　　交换p和q中的指针</div><div class="line">p.swap(q)</div></pre></td></tr></table></figure>
<p> <strong>shared_ptr独有的操作</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">make_shared&lt;T&gt;(args)　　　　　返回一个<span class="built_in">shared_ptr</span>，指向一个动态分配的类型为T的对象，使用args初始化此对象</div><div class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q)　　　　　　　p是<span class="built_in">shared_ptr</span> q的一个拷贝，此操作会递增q中的计数器。q中的指针必须都能转换为T*</div><div class="line">p=q　　　　　　　　　　　　　　p和q都是<span class="built_in">shared_ptr</span>，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为<span class="number">0</span>，则将其管理　　　　　　　　　　　　　　　　的原内存释放</div><div class="line">p.unique()  　　　　　　　　　　  若p.use_count()为<span class="number">1</span>，返回<span class="literal">true</span>，否则返回<span class="literal">false</span></div><div class="line">p.use_count() 　　　　　　　　　返回与p共享对象的智能指针的数量；可能很慢，主要用于调试</div></pre></td></tr></table></figure>
<h3 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h3><p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。<strong>此函数在动态内存中分配一个对象并初始化它，返回指向对象的shared_ptr</strong>。与智能指针一样，make_shared也定义在头文件memory中。</p>
<p>当要使用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指向一个值为42的int的shared_ptr</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3=make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>);</div><div class="line"><span class="comment">//p4指向一个值为"99999"的string</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p4=make_shared&lt;<span class="built_in">string</span>&gt; (<span class="number">5</span>,<span class="string">'9'</span>);</div><div class="line"><span class="comment">//p5指向一个值初始化的int，即，值为0</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p5=make_shared&lt;<span class="keyword">int</span>&gt; ();</div></pre></td></tr></table></figure>
<p>类似顺序容器的emplace成员，<strong>make_shared用其参数来构造给定类型的对象</strong>。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int> 时传递的参数必须能用来初始化一个int，依次类推。如果我们不传递任何参数，对象就会进行值初始化。</int></string></p>
<p>当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式较简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//p6指向一个动态分配的空vector&lt;string&gt;</span></div><div class="line"><span class="keyword">auto</span> p6=make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ();</div></pre></td></tr></table></figure>
<h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>当进行拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> p=make_shard&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">//p指向的对象只有p一个引用者</span></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;  <span class="comment">//p和q指向相同的对象，此对象有两个引用者</span></div></pre></td></tr></table></figure>
<p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器都会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域时，计数器就会递减）</p>
<p>一旦一个shared_ptr的计算器变为0，它就会自动释放自己所管理的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto r=make_shared&lt;int&gt;(42);  //r指向的int只有一个引用者</div><div class="line">r=q;   //给r赋值，令它指向另一个地址，递增q指向的对象的引用计数，递减r原来指向的对象的引用计数，r原来指向的对象已没有引用者，会自动释放</div></pre></td></tr></table></figure>
<p>此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一执行此int的shared_ptr，在把q赋给r的过程中，此int被自动释放。</p>
<h3 id="shared-ptr自动销毁所管理的对象"><a href="#shared-ptr自动销毁所管理的对象" class="headerlink" title="shared_ptr自动销毁所管理的对象"></a>shared_ptr自动销毁所管理的对象</h3><p><strong>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象</strong>。它是通过另一个特殊的成员函数——析构函数完成销毁工作的。类似与构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。</p>
<p><strong>析构函数一般用来释放对象分配的资源</strong>。例如，string的构造函数（以及其他string成员）会分配内存来保存构成string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。</p>
<p><strong>shared_ptr的析构函数会递减它所指对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存</strong>。</p>
<h3 id="shared-ptr还会自动释放相关联的内存"><a href="#shared-ptr还会自动释放相关联的内存" class="headerlink" title="shared_ptr还会自动释放相关联的内存"></a>shared_ptr还会自动释放相关联的内存</h3><p>当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如，我们可能有一个函数，它返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//factory返回一个shared_ptr，指向一个动态分配的对象</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; factory(T arg)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//恰当地处理arg</span></div><div class="line">    <span class="comment">//shared_ptr负责释放内存</span></div><div class="line">    <span class="keyword">return</span> make_shared&lt;Foo&gt;(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时刻被释放。例如，下面的函数将factory返回的shared_ptr保存在局部变量中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</div><div class="line">    <span class="comment">//使用p</span></div><div class="line">    <span class="comment">//p离开了作用域，它指向的内存会被自动释放掉</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于p是use_factory的局部变量，在use_factory结束时它将被销毁。当p被销毁时，将递减其引用计数并检查它是否为0。在此例中，p是唯一引用factory返回的内存的对象。由于p将要销毁，p指向的这个对象也会被销毁，所占用的内存会被释放。</p>
<p>但如果有其他的shared_ptr也指向这块内存，它就不会被释放掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p=factory(arg);</div><div class="line">    <span class="comment">//使用p</span></div><div class="line">    <span class="keyword">return</span> p; <span class="comment">//当我们返回p时，引用计数进行了递增操作</span></div><div class="line">&#125; <span class="comment">//p离开了作用域，但它指向的内存不会被释放</span></div></pre></td></tr></table></figure>
<p>在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。</p>
<p>由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。shared_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某种元素。在这种情况西下，你应该确保erase删除哪些不再需要的shared_ptr元素。</p>
<p><strong>注意：如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</strong></p>
<h3 id="使用了动态生存期的资源的类"><a href="#使用了动态生存期的资源的类" class="headerlink" title="使用了动态生存期的资源的类"></a>使用了动态生存期的资源的类</h3><p>程序使用动态内存处于以下三种原因之一：</p>
<p>1 程序不知道自己需要使用多少个对象；</p>
<p>2 程序不知到所需的准确类型</p>
<p>3 程序需要在多个对象间共享数据</p>
<p>容器类是处于第一种原因而使用动态内存的典型例子。</p>
<p>使用动态内存的一个常见原因是运行多个对象共享相同的状态。</p>
<h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2><p>C++语言定义了两个运算符来分配和释放动态内存。<strong>运算符new分配内存，delete释放new分配的内存。</strong></p>
<p>相对于智能指针，使用这两个运算符管理内存非常容易出错，随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。</p>
<h3 id="使用new动态分配和初始化对象"><a href="#使用new动态分配和初始化对象" class="headerlink" title="使用new动态分配和初始化对象"></a>使用new动态分配和初始化对象</h3><p>在自由空间分配的内存是无名的。因此，new无法为其分配的对象命名，而是返回一个执行对象的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="keyword">int</span> ;   <span class="comment">// pi指向一个动态分配的、未初始化的无名对象</span></div></pre></td></tr></table></figure>
<p>此new表达式在自由空间构造一个int型对象，并返回指向该对象的指针。</p>
<p><strong>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> *ps=<span class="keyword">new</span> <span class="built_in">string</span>; <span class="comment">//初始化为空string</span></div><div class="line"><span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="keyword">int</span> ; <span class="comment">// pi指向一个未初始化的int</span></div></pre></td></tr></table></figure>
<p>我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>)  ;<span class="comment">//pi的对象的值为1024</span></div><div class="line"><span class="built_in">string</span> *ps=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'9'</span>) ; <span class="comment">//vector有10个元素，值依次从0到9</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv=<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div></pre></td></tr></table></figure>
<p>也可以<strong>对动态的对象进行值初始化，只需在类型名之后跟一对空括号即可</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> *ps1=<span class="keyword">new</span> <span class="built_in">string</span>;   <span class="comment">//默认初始化为空string</span></div><div class="line"><span class="built_in">string</span> *ps=<span class="keyword">new</span> <span class="built_in">string</span>();  <span class="comment">//值初始化为空string</span></div><div class="line"><span class="keyword">int</span> *pi1=<span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//默认初始化：*pi1的值未定义</span></div><div class="line"><span class="keyword">int</span> *pi2=<span class="keyword">new</span> <span class="keyword">int</span>();   <span class="comment">// 值初始化为0 *pi2为0</span></div></pre></td></tr></table></figure>
<p>对于定义与自己的构造函数的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。</p>
<p>如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> p1=<span class="keyword">new</span> <span class="keyword">auto</span>(obj) ; <span class="comment">//p指向一个与obj类型相同的对象</span></div><div class="line"><span class="keyword">auto</span> p2=<span class="keyword">new</span> <span class="keyword">auto</span>(a,b,c) ;  <span class="comment">//错误：括号中只能有单个初始化器</span></div></pre></td></tr></table></figure>
<p>p1的类型是一个指针，执行从obj自动推断的类型。若obj是一个int，那么p1就算int<em>；若obj是一个string，那么p1是一个string</em>；依次类推。新分配的对象用obj的值进行初始化。</p>
<h3 id="动态分配的const对象"><a href="#动态分配的const对象" class="headerlink" title="动态分配的const对象"></a>动态分配的const对象</h3><p>用new分配const对象是合法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//分配并初始化一个const int</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci=<span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</div><div class="line"><span class="comment">//分配并默认初始化一个const的空string</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs=<span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</div></pre></td></tr></table></figure>
<p>类似其他任何const对象，<strong>一个动态分配的const对象必须进行初始化</strong>。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，<strong>new 返回的指针是一个指向const的指针</strong>。</p>
<h3 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h3><p>虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败，默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果分配失败，new返回一个空指针</span></div><div class="line"><span class="keyword">int</span> *p1=<span class="keyword">new</span> <span class="keyword">int</span> ; <span class="comment">//如果分配失败，new抛出std::bad_alloc</span></div><div class="line"><span class="keyword">int</span> *p2=<span class="keyword">new</span> (nothrow) <span class="keyword">int</span> ; <span class="comment">//如果分配失败，new返回一个空指针</span></div></pre></td></tr></table></figure>
<p>我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数，在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。</p>
<h3 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h3><p>为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式来将动态内存归还给系统。<strong>delete表达式接受一个指针，指向我们想要释放的对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></div></pre></td></tr></table></figure>
<p>与new 类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。</p>
<h3 id="指针值和delete"><a href="#指针值和delete" class="headerlink" title="指针值和delete"></a>指针值和delete</h3><p>我们传递给delete的指针必须指向动态分配的内存，或是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i,*pi1=&amp;i,*pi2=<span class="literal">nullptr</span>;</div><div class="line"><span class="keyword">double</span> *pd=<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">33</span>),*pd2=pd;</div><div class="line"><span class="keyword">delete</span> i;  <span class="comment">//错误，i不是一个指针</span></div><div class="line"><span class="keyword">delete</span> pi1; <span class="comment">//未定义：pi1执行一个局部变量</span></div><div class="line"><span class="keyword">delete</span> pd; <span class="comment">//正确</span></div><div class="line"><span class="keyword">delete</span> pd2;  <span class="comment">//未定义，pd2指向的内存已经被释放了</span></div><div class="line"><span class="keyword">delete</span> pi2;  <span class="comment">//正确：释放一个空指针总是没有错误的</span></div></pre></td></tr></table></figure>
<p>对于delete i的请求，编译器会生成一个错误信息，因为它知道i不是一个指针。执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些delete表达式，大多数编译器会编译通过，尽管它们是错误的。</p>
<p>虽然一个const对象的值不能被改变，但它本身是可以被销毁的，如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci=<span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>); </div><div class="line"><span class="keyword">delete</span> pci; <span class="comment">//正确：释放一个从const对象</span></div></pre></td></tr></table></figure>
<h3 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h3><p>由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。<strong>对于一个由内置指针管理的动态对象，直到被显示释放之前它都是存在的。</strong></p>
<p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//factory返回一个指针，指向一个动态分配的对象</span></div><div class="line"><span class="function">Foo* <span class="title">factory</span><span class="params">(T arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">　　<span class="comment">//视情况处理arg</span></div><div class="line">　　<span class="keyword">return</span> <span class="keyword">new</span> Foo(arg); <span class="comment">//调用者负责释放此内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似我们之前定义的factory函数，这个版本的factory分配一个对象，但并不delete它。factory的调用者负责在不需要此对象时释放它。不幸的是，调用者经常忘记释放对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">　　Foo *p=factory(arg);</div><div class="line">　　<span class="comment">//使用p但不delete它</span></div><div class="line">&#125; <span class="comment">//p离开了它的作用域，但它所指向的内存没有被释放</span></div></pre></td></tr></table></figure>
<p>此外，use_factory函数调用factory，后者分配一个类型为Foo的新对象。当use_factory返回时，局部变量p被销毁，此变量是一个内置指针，而不是一个智能指针。</p>
<p>与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。</p>
<p><strong>注意</strong>：<strong>由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在</strong>。</p>
<p>在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，程序就没有办法释放这块内存了。根据整个程序的逻辑，修正这个错误的正确方法是在use_factory中记得要释放内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></div><div class="line"><span class="function"></span>&#123; </div><div class="line">　　Foo *p=factory(arg);</div><div class="line">　　<span class="comment">//使用p</span></div><div class="line">　　<span class="keyword">delete</span> p ;  <span class="comment">//现在记得释放内存，我们已经不需要它了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种可能，我们的系统中的其他代码要使用use_factory所分配的对象，我们就应该修改此函数，让他返回一个指针，指向它分配的内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">Foo* <span class="title">use_factory</span><span class="params">(T arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">　　Foo *p=factory(arg);</div><div class="line">　　<span class="comment">//使用p</span></div><div class="line">　　<span class="keyword">return</span> p; <span class="comment">//调用者必须释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>小心：动态内存的管理非常容易出错</strong> </p>
<p>使用new和delete管理动态内存存在三个常见问题：</p>
<ul>
<li><p>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。</p>
</li>
<li><p>使用以及释放掉的对象，通过在释放内存后将指针置为空，有时可以检测出这种错误。</p>
</li>
<li><p>同一块内存被释放两次，当有来年刚给指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了，如果我们随后又delete第一个指针，自由空间就可能会被破坏。</p>
</li>
</ul>
<p>相对于查找和修正这种错误来源，制造出这些错误要简单很多。</p>
<p><strong>坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何只能智能指针指向它的情况下，智能指针才会自动释放它</strong>。</p>
<h3 id="delete之后重置指针值。。。。"><a href="#delete之后重置指针值。。。。" class="headerlink" title="delete之后重置指针值。。。。"></a>delete之后重置指针值。。。。</h3><p>当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的<strong>空悬指针</strong>，即，指向一块层级保存数据对象但现在以及无效的内存的指针。</p>
<p>为初始化指针的所有确定空悬指针也都有，有一种方法可以避免空悬指针的问题；在指针即将要离开其作用域之前释放掉它所关联的内存。这样在指针关联的内存被释放掉之后，就没有机会继续使用指针了。<strong>如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。</strong></p>
<h3 id="这只是提供了有限的保护"><a href="#这只是提供了有限的保护" class="headerlink" title="这只是提供了有限的保护"></a>这只是提供了有限的保护</h3><p>动态内存的一个基本问题是可能有多个指针指向相同的内存，在delete内存之后重置指针的方法只对这个指针有效，对其他任何指向（已释放的）内存的指针是没有作用的。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int *p(new int (42));  //p指向动态内存</div><div class="line"><span class="keyword">auto</span> q=p;  <span class="comment">//p和q指向相同的内存</span></div><div class="line"><span class="keyword">delete</span> p; <span class="comment">//p和q均变为无效</span></div><div class="line">p=<span class="literal">nullptr</span>;  <span class="comment">//指出p不再绑定到任何对象</span></div></pre></td></tr></table></figure>
<p>本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr指出它不再指向任何对象，但是，重置p对q没有任何作用，在我们释放p所指向的（同时也是q所指向的）内存时，q也变为无效了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;到目前为止，我们编写的程序中所使用的对象都有着严格定义的生命期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="智能指针" scheme="http://www.wangxinri.cn/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="内存分配" scheme="http://www.wangxinri.cn/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
</feed>
