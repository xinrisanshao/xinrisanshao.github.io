<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>新日三少的博客</title>
  <subtitle>Big big pig</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wangxinri.cn/"/>
  <updated>2018-05-19T03:30:08.968Z</updated>
  <id>http://www.wangxinri.cn/</id>
  
  <author>
    <name>新日三少</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程同步之互斥量</title>
    <link href="http://www.wangxinri.cn/2018/05/19/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F/"/>
    <id>http://www.wangxinri.cn/2018/05/19/线程同步之互斥量/</id>
    <published>2018-05-19T13:59:00.000Z</published>
    <updated>2018-05-19T03:30:08.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图，如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。</p>
<a id="more"></a>
<p>同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性，但是，<strong>当一个线程可以修改的变量，其他线程也可以读取和修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容是不会访问到无效值的</strong>。</p>
<p>为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量（互斥访问）。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p><strong>可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量（mutex）从本质上来说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量</strong>。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种情况下，每次只有一个线程可以向前执行。</p>
<p>互斥变量是用pthread_mutex_t数据类型表示的。在使用互斥变量之前，必须首先对它进行初始化，可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于静态分配的互斥量），也可以调用pthread_mutex_init函数进行初始化。如果动态分配互斥量（例如，通过调用malloc函数），在释放内存前需要调用pthread_mutex_destroy。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line">    				返回值：成功返回<span class="number">0</span>，失败返回错误编号；</div></pre></td></tr></table></figure>
<p>如果使用默认初始化互斥量，只需把attr设置为NULL；<br>对互斥量进行加锁，需要调用pthread_mutex_lock,如果互斥量已经上锁，调用线程将会阻塞到互斥量被解锁。对互斥量解锁，需要调用pthread_mutex_unlock。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line">              返回值：成功返回<span class="number">0</span>，错误返回错误编号；</div></pre></td></tr></table></figure>
<p><strong>如果线程不希望被阻塞，它可以使用pthread_mutex_trylock尝试对互斥量进行加锁（如果互斥量被加锁，函数返回EBUSY，线程不会被阻塞）</strong>。如果调用pthread_mutex_trylock时互斥量处于未锁住状态，那么pthread_mutex_trylock将锁住互斥量，不会出现阻塞并返回0，否则失败不能锁住互斥量，而返回EBUSY；使用pthread_mutex_trylock()接口可以避免死锁。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用互斥量来实现三个线程分别打印出ABC，循环五次。 主要思路如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mutex1 = 1 </div><div class="line">mutex2 = 0</div><div class="line">mutex3 = 0</div><div class="line">thread1     p(mutex1)  v(mutex2)</div><div class="line">thread2     p(mutex2)  v(mutex3)</div><div class="line">thread3     p(mutex3)  v(mutex1)</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex1;</div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex2;</div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex3;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;     <span class="comment">//initialization</span></div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	err = pthread_mutex_init(&amp;mutex1,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"init mutex1 error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_mutex_init(&amp;mutex2,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"init mutex2 error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_mutex_init(&amp;mutex3,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"init mutex3 error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_mutex_lock(&amp;mutex2);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"mutex2 lock error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_mutex_lock(&amp;mutex3);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"mutex3 lock error\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</div><div class="line">		err = pthread_mutex_lock(&amp;mutex1);</div><div class="line">		<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"mutex1 lock error\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"thread1: A\n"</span>);</div><div class="line">		err = pthread_mutex_unlock(&amp;mutex2);</div><div class="line">		<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"mutex2 unlock error\n"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">int</span> err;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</div><div class="line">                err = pthread_mutex_lock(&amp;mutex2);</div><div class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">"mutex2 lock error\n"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"thread2: B\n"</span>);</div><div class="line">                err = pthread_mutex_unlock(&amp;mutex3);    </div><div class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">"mutex3 unlock error\n"</span>);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn3</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">int</span> err;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</div><div class="line">                err = pthread_mutex_lock(&amp;mutex3);</div><div class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">"mutex3 lock error\n"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"thread3: C\n"</span>);</div><div class="line">                err = pthread_mutex_unlock(&amp;mutex1);    </div><div class="line">                <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">"mutex1 unlock error\n"</span>);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destory</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	err = pthread_mutex_unlock(&amp;mutex2);</div><div class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"mutex2 unlock error\n"</span>);</div><div class="line">        &#125;</div><div class="line">	err = pthread_mutex_unlock(&amp;mutex3);</div><div class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"mutex3 unlock error\n"</span>);</div><div class="line">        &#125;</div><div class="line">	err = pthread_mutex_destroy(&amp;mutex1);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"mutex1 destory error\n"</span>);</div><div class="line">	&#125;	</div><div class="line">	err = pthread_mutex_destroy(&amp;mutex2);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"mutex2 destory error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_mutex_destroy(&amp;mutex3);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"mutex3 destory error\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">pthread_t</span> tid1,tid2,tid3;</div><div class="line">	Init();</div><div class="line">	err = pthread_create(&amp;tid1,<span class="literal">NULL</span>,thr_fn1,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_create(&amp;tid2,<span class="literal">NULL</span>,thr_fn2,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;	</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_create(&amp;tid3,<span class="literal">NULL</span>,thr_fn3,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_join(tid1,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_join(tid2,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_join(tid3,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread3\n"</span>);</div><div class="line">	&#125;</div><div class="line">	Destory();</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadMutex.c -lpthread -o pthreadMutex.o </div><div class="line">[vrlive@iZ23chs2r19Z eleven]$ ./pthreadMutex.o </div><div class="line">thread1: A</div><div class="line">thread2: B</div><div class="line">thread3: C</div><div class="line">thread1: A</div><div class="line">thread2: B</div><div class="line">thread3: C</div><div class="line">thread1: A</div><div class="line">thread2: B</div><div class="line">thread3: C</div><div class="line">thread1: A</div><div class="line">thread2: B</div><div class="line">thread3: C</div><div class="line">thread1: A</div><div class="line">thread2: B</div><div class="line">thread3: C</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：pthread_mutex_lock和pthread_mutex_unlock必须成对出现，不然pthread_mutex_destory函数调用出错。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>1.线程A试图对用一个互斥量mutexA加锁两次，那么它自身就会陷入死锁状态，</p>
<p>用伪代码表示就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_lock(&amp;mutexA)  </div><div class="line">pthread_mutex_lock(&amp;mutexA) <span class="comment">/* 这里死锁 */</span></div></pre></td></tr></table></figure>
<p>2.程序中使用多个互斥量时，如果允许一个线程一直占有第一个互斥量，并且试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥量的线程也在试图锁住第一个互斥量，这时就发生死锁。<strong>因为两个线程都在互相请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是产生死锁</strong>。</p>
<p>用伪代码表示就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pthreadA:</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;mutexA)  </div><div class="line">    pthread_mutex_lock(&amp;mutexB) <span class="comment">/* 这里死锁 */</span>  </div><div class="line"></div><div class="line">pthreadB:</div><div class="line"></div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;mutexB)  </div><div class="line">    pthread_mutex_lock(&amp;mutexA) <span class="comment">/* 这里死锁 */</span></div></pre></td></tr></table></figure>
<p>有时候，应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构，可用的函数并不能把它转换成简单的层次，那么就需要采用另外的方法。在这种情况下，<strong>可以先释放占有的锁，然后过段时间再试</strong>。这种情况可以使用pthread_mutex_trylock接口避免死锁。如果已经占有某些锁而且pthread_mutex_trylock接口返回成功，那么就可以前进。但是，如果不能获取锁，可以先释放已经占有的锁，做好清理工作，然后过一段时间再重新试。</p>
<h3 id="函数pthread-mutex-timedlock"><a href="#函数pthread-mutex-timedlock" class="headerlink" title="函数pthread_mutex_timedlock"></a>函数pthread_mutex_timedlock</h3><p>当线程试图获取一个已加锁的互斥量时，pthread_mutex_timedlock互斥量原语允许绑定线程阻塞时间。pthread_mutex_timedlock函数与pthread_mutex_lock是基本等价的，但是<strong>在达到超时时间值时，pthread_mutex_timelock不会对互斥量进行加锁，而是返回错误码ETIMEDOUT</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></div><div class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line">                        <span class="comment">//返回值：若成功，返回0；否则，返回错误编码</span></div></pre></td></tr></table></figure>
<p><strong>超时指定愿意等待的绝对时间（某个具体的时间）</strong>（与相对时间对比而言，指定在时间X之前可以阻塞等待，而不是说愿意阻塞Y秒）。这个超时时间是用timespec结构来表示，它用秒和纳秒来描述时间。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>下面示例给出了如何用pthread_mutex_timedlock避免永久阻塞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></div><div class="line">	<span class="keyword">char</span> buf[<span class="number">64</span>];</div><div class="line">	<span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</div><div class="line">	</div><div class="line">	pthread_mutex_lock(&amp;lock);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"mutex is locked\n"</span>);</div><div class="line">	clock_gettime(CLOCK_REALTIME,&amp;tout);</div><div class="line">	tmp = localtime(&amp;tout.tv_sec);</div><div class="line">	strftime(buf,<span class="keyword">sizeof</span>(buf),<span class="string">"%r"</span>,tmp);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"current time is %s\n"</span>,buf);</div><div class="line">	tout.tv_sec += <span class="number">10</span>;    <span class="comment">//10 seconds from new</span></div><div class="line"></div><div class="line">	<span class="comment">//caution: this could lead to deadlock</span></div><div class="line">	err = pthread_mutex_timedlock(&amp;lock,&amp;tout);</div><div class="line">	clock_gettime(CLOCK_REALTIME,&amp;tout);</div><div class="line">	tmp = localtime(&amp;tout.tv_sec);</div><div class="line">	strftime(buf,<span class="keyword">sizeof</span>(buf),<span class="string">"%r"</span>,tmp);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"the time is now %s\n"</span>,buf);	</div><div class="line">	<span class="keyword">if</span>(err == <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"mutex locked again\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't lock mutex again:%s\n"</span>,strerror(err));</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadMutexTimelock.c -lpthread -o pthreadMutexTimelock.o</div><div class="line">[vrlive@iZ23chs2r19Z eleven]$ ./pthreadMutexTimelock.o </div><div class="line">mutex is locked</div><div class="line">current time is 06:38:24 PM</div><div class="line">the time is now 06:38:34 PM</div><div class="line">can't lock mutex again:Connection timed out</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程同步&quot;&gt;&lt;a href=&quot;#线程同步&quot; class=&quot;headerlink&quot; title=&quot;线程同步&quot;&gt;&lt;/a&gt;线程同步&lt;/h2&gt;&lt;p&gt;当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图，如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="http://www.wangxinri.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程分离和结合</title>
    <link href="http://www.wangxinri.cn/2018/05/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BB%E4%B8%8E%E7%BB%93%E5%90%88/"/>
    <id>http://www.wangxinri.cn/2018/05/19/线程的分离与结合/</id>
    <published>2018-05-19T03:59:00.000Z</published>
    <updated>2018-05-19T03:29:04.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的分离与结合"><a href="#线程的分离与结合" class="headerlink" title="线程的分离与结合"></a>线程的分离与结合</h2><p><strong>在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）</strong>。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。</p>
<a id="more"></a>
<p><strong>线程的分离状态决定一个线程以什么样的方式来终止自己</strong>。在上面的例子中，我们采用了线程的默认属性，即为非分离状态（即可结合的，joinable，需要回收），这种情况下，原有的线程等待创建的线程结束；只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。</p>
<p>设置线程分离状态的函数为pthread_attr_setdetachstate（pthread_attr_t *attr, int detachstate）。第二个参数可选为PTHREAD_CREATE_DETACHED（分离线程）和 PTHREAD _CREATE_JOINABLE（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<p>另外一个可能常用的属性是线程的优先级，它存放在结构sched_param中。用函数pthread_attr_getschedparam和函数pthread_attr_setschedparam进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。</p>
<h3 id="线程等待——正确处理线程终止"><a href="#线程等待——正确处理线程终止" class="headerlink" title="线程等待——正确处理线程终止"></a>线程等待——正确处理线程终止</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> th,<span class="keyword">void</span> *thread_return)</span></span>;<span class="comment">//挂起等待th结束,*thread_return=retval;</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> th)</span></span>;</div></pre></td></tr></table></figure>
<p>如果线程处于joinable状态，则只能只能被创建他的线程等待终止。</p>
<p>在Linux平台默认情况下，虽然各个线程之间是相互独立的，一个线程的终止不会去通知或影响其他的线程。但是已经终止的线程的资源并不会随着线程的终止而得到释放，我们需要调用 pthread_join() 来获得另一个线程的终止状态并且释放该线程所占的资源。（说明：线程处于joinable状态下）</p>
<p>调用该函数的线程将挂起，等待 th 所表示的线程的结束。 thread_return 是指向线程 th 返回值的指针。需要注意的是 th 所表示的线程必须是 joinable 的，即处于非 detached（游离）状态；并且只可以有唯一的一个线程对 th 调用 pthread_join() 。如果 th 处于 detached 状态，那么对 th 的 pthread_join() 调用将返回错误。</p>
<p>如果不关心一个线程的结束状态，那么也可以将一个线程设置为 detached 状态，从而让操作系统在该线程结束时来回收它所占的资源。将一个线程设置为detached 状态可以通过两种方式来实现。一种是调用 pthread_detach() 函数，可以将线程 th 设置为 detached 状态。另一种方法是在创建线程时就将它设置为 detached 状态，首先初始化一个线程属性变量，然后将其设置为 detached 状态，最后将它作为参数传入线程创建函数 pthread_create()，这样所创建出来的线程就直接处于 detached 状态。</p>
<p>创建 detach 线程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_t</span>       tid;</div><div class="line"><span class="keyword">pthread_attr_t</span>  attr;</div><div class="line">pthread_attr_init(&amp;attr);</div><div class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</div><div class="line">pthread_create(&amp;tid, &amp;attr, THREAD_FUNCTION, arg);</div></pre></td></tr></table></figure>
<p><strong>总之为了在使用 pthread时避免线程的资源在线程结束时不能得到正确释放，从而避免产生潜在的内存泄漏问题，在对待线程结束时，要确保该线程处于 detached 状态，否着就需要调用 pthread_join() 函数来对其进行资源回收</strong>。 </p>
<p><a href="https://blog.csdn.net/jobbofhe/article/details/52252736" target="_blank" rel="external">参考：线程分离状态的理解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程的分离与结合&quot;&gt;&lt;a href=&quot;#线程的分离与结合&quot; class=&quot;headerlink&quot; title=&quot;线程的分离与结合&quot;&gt;&lt;/a&gt;线程的分离与结合&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）&lt;/strong&gt;。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="http://www.wangxinri.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>信号集</title>
    <link href="http://www.wangxinri.cn/2018/05/18/%E4%BF%A1%E5%8F%B7%E9%9B%86/"/>
    <id>http://www.wangxinri.cn/2018/05/18/信号集/</id>
    <published>2018-05-18T13:59:00.000Z</published>
    <updated>2018-05-19T03:26:51.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>我们需要有一个能表示多个信号—信号集（signal set）的数据类型。我们将在sigprocmask类函数中使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。</p>
<a id="more"></a>
<p>如前所述，不同的信号的编号可能超过一个整型变量所包含的位数，所有一般而言，不能用整型量中的一位代表一种信号，也就是不能用一个整型量表示信号集。POSIX.1定义数据类型sigset_t以包含一个信号集，并且定义了下列5个处理信号集的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signo)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signo)</span></span>;     <span class="comment">//4个函数返回值：若成功，返回0，若出错，返回-1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signo)</span></span>;     <span class="comment">//返回值，若真，返回1，若假，返回0</span></div></pre></td></tr></table></figure>
<p>函数sigemptyset初始化由set指向的信号集，清除其中所有信号。函数sigfillset初始化由set指向的信号集，使其包括所有信号。所有应用程序在使用信号集前，要对该信号集调用sigemptyset或sigfillset一次。这是因为C编译器将不赋初值的外部变量和静态变量都初始化为0，而这是否与给定系统上信号集的视线相对应并不清楚。</p>
<p>一旦已经初始化了一个信号集，以后就可在该信号集中增、删特定的信号。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>如果实现的信号数目少于一个整型量所包含的位数，则可用一位代表一个信号的方法实现信号集，例如，假定一种实现有31种信号和32位整型。sigemptyset函数将整型设置为0，sigfillset函数则将整型中的各位设置为1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sigemptyset(ptr) (*(ptr) = 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sigfillset(ptr) (*(ptr) = ~(sigset_t)0,0)</span></div></pre></td></tr></table></figure>
<p>注意，除了设置信号集中各位为1外，sigfillset必须返回0，所以使用c语言的逗号运算符，它将逗号运算符后的值作为表达式的值返回。</p>
<p>其他关闭某一位、开启某一位、检查某一位的操作类似bitmap算法操作。</p>
<h2 id="函数sigprocmask"><a href="#函数sigprocmask" class="headerlink" title="函数sigprocmask"></a>函数sigprocmask</h2><p>一个进程的信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集。调用函数sigprocmask可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>,<span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;</div><div class="line">        <span class="comment">//返回值：若成功，返回0，若出错，返回-1</span></div></pre></td></tr></table></figure>
<p>首选，若oset是非空指针，那么进程的当前信号屏蔽字通过oset返回。</p>
<p>其次，若set是一个非空指针，则参数how指示如何修改当前信号量屏蔽字。下图说明了how可选的值。SIG_BLOCK是或操作，而SIG_SETMASK则是赋值操作。注意，不能阻塞SIGKILL和SIGSTOP信号。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E6%9B%B4%E6%94%B9%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97.png" alt="image"></p>
<p>如果set是个空指针，则不改变该进程的信号屏蔽字，how的值也无意义。</p>
<p>在调用sigprocmask后如果由任何未决的、不在阻塞的信号，则在sigprocmask返回前，至少将其中之一递送给该进程。</p>
<h2 id="函数sigpending"><a href="#函数sigpending" class="headerlink" title="函数sigpending"></a>函数sigpending</h2><p>sigpending 函数返回一个信号集，对于调用进程而言。其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过set参数返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;        <span class="comment">//返回值：若成功，返回0，若出错，返回-1</span></div></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>展示了前面的大部分函数和信号功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">sigset_t</span> newmask,oldmask,pendmask;</div><div class="line">	<span class="keyword">if</span>(signal(SIGQUIT,sig_quit) == SIG_ERR)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't catch SIGQUIT\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// block SIGQUIT and save current signal mask</span></div><div class="line">	sigemptyset(&amp;newmask);</div><div class="line">	sigaddset(&amp;newmask,SIGQUIT);</div><div class="line">	<span class="keyword">if</span>(sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"SIG_BLOCK error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	sleep(<span class="number">5</span>);     <span class="comment">//SIGQUIT here will remain pending</span></div><div class="line">	<span class="keyword">if</span>(sigpending(&amp;pendmask) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"sigpending error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(sigismember(&amp;pendmask,SIGQUIT))&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nSIGQUIT pending\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Restore signal mask which unblocks SIGQUIT</span></div><div class="line">	<span class="keyword">if</span>(sigprocmask(SIG_SETMASK,&amp;oldmask,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"SIG_SETMASK error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"SIGQUIT unblocked\n"</span>);</div><div class="line">	sleep(<span class="number">5</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"caught SIGQUIT\n"</span>);</div><div class="line">	<span class="keyword">if</span>(signal(SIGQUIT,SIG_DFL) == SIG_ERR)&#123;    <span class="comment">//restablished new handler</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't reset SIGQUIT\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进程阻塞SIGQUIT信号，同时保存了当前信号屏蔽字（以便后面恢复），然后休眠5秒。在此期间，发送若干退出信号SIGQUIT，这些信号都被阻塞，不递送至该进程，休眠结束后，将SIGQUIT设置为不再阻塞，在sigprocmask设置为之前未阻塞的信号集返回前，之前阻塞的SIGQUIT被递送到进程，并执行相应的信号处理函数，这是我们发现，之前发送的多个SIGQUIT只执行了一次，说明信号在该系统中没有进行排队，然后重新注册新的SIGQUIT信号处理函数为默认，也就是终止进程，此时，进程调用sleep再此休眠5秒，再此期间，如果接收到SIGQUIT信号，则执行默认处理，终止进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z ten]$ ./sigprocmask.o </div><div class="line">^\^\^\^\SIGQUIT pending</div><div class="line">caught SIGQUIT</div><div class="line">SIGQUIT unblocked</div><div class="line">^\Quit</div><div class="line">[vrlive@iZ23chs2r19Z ten]$ ./sigprocmask.o </div><div class="line">^\SIGQUIT pending</div><div class="line">caught SIGQUIT</div><div class="line">SIGQUIT unblocked</div><div class="line">^\Quit</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信号集&quot;&gt;&lt;a href=&quot;#信号集&quot; class=&quot;headerlink&quot; title=&quot;信号集&quot;&gt;&lt;/a&gt;信号集&lt;/h2&gt;&lt;p&gt;我们需要有一个能表示多个信号—信号集（signal set）的数据类型。我们将在sigprocmask类函数中使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="信号" scheme="http://www.wangxinri.cn/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>alarm与pause</title>
    <link href="http://www.wangxinri.cn/2018/05/18/%E5%87%BD%E6%95%B0alarm%E5%92%8Cpause/"/>
    <id>http://www.wangxinri.cn/2018/05/18/函数alarm和pause/</id>
    <published>2018-05-18T13:59:00.000Z</published>
    <updated>2018-05-19T03:25:41.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h2><p><strong>使用alarm函数可以设置一个定时器（闹钟时间），在将来的某个时刻该定时器会超时。当定时器超时时，产生SIGALRM信号。如果忽略或不捕获此信号，则其默认动作是终止调用该alarm函数的进程</strong>。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;   <span class="comment">//返回值：0或以前设置的闹钟时间的余留秒数</span></div></pre></td></tr></table></figure>
<p>参数seconds的值是产生信号SIGALRM需要经过的时钟秒数。当这一时刻到达时，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一个时间间隔。</p>
<p>每个进程只能有一个闹钟时间。如果在调用alarm时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次alarm函数调用的值返回。已经注册的闹钟时间则被新值取代。</p>
<p>如果由以前注册的尚未超过的闹钟时间，而且本次调用的second值是0，则取消以前的闹钟时间，其余留值仍作为为alarm函数的返回值。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alarm</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"receivec %d signal\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signal(SIGALRM,sig_alarm) == SIG_ERR)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"signal error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	alarm(<span class="number">10</span>);</div><div class="line">	sleep(<span class="number">5</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"sleep over\n"</span>);</div><div class="line">	<span class="keyword">int</span> ret = alarm(<span class="number">2</span>);    <span class="comment">//restablished new alarm</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"last alarm last second = %d\n"</span>,ret);</div><div class="line">    pause();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z ten]$ ./alarm.o </div><div class="line">sleep over</div><div class="line">last alarm last second = 5</div><div class="line">receivec 14 signal</div></pre></td></tr></table></figure>
<h2 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h2><p><strong>pause函数使调用进程挂起直至捕捉到一个信号</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">//返回值-1，errno设置为EINTR</span></div></pre></td></tr></table></figure>
<p><strong>只有执行了一个信号处理程序并从其中返回时，pause才返回</strong>。这种情况下，pause返回-1，errno设置为EINTR。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"wangxinri\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR1,sig_usr) == SIG_ERR)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"signal error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"begin the pause function\n"</span>);</div><div class="line">	pause();</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"end the main function\n"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z ten]$ ps -auf</div><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">vrlive    5263  0.0  0.0 115512  2148 pts/0    Ss   19:50   0:00 -bash</div><div class="line">vrlive    5291  0.0  0.0   4168   356 pts/0    S+   19:51   0:00  \_ ./sleep.o</div><div class="line">vrlive    5226  0.0  0.0 115512  2144 pts/1    Ss   19:45   0:00 -bash</div><div class="line">vrlive    5293  0.0  0.0 139496  1612 pts/1    R+   19:52   0:00  \_ ps -auf</div><div class="line">root       473  0.0  0.0 110036   844 tty1     Ss+   2017   0:00 /sbin/agetty --noclear tty1 linux</div><div class="line">[vrlive@iZ23chs2r19Z ten]$ kill -USR1 5291</div><div class="line"></div><div class="line"></div><div class="line">[vrlive@iZ23chs2r19Z ten]$ ./sleep.o </div><div class="line">begin the pause function</div><div class="line">wangxinri</div><div class="line">end the main function</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;alarm&quot;&gt;&lt;a href=&quot;#alarm&quot; class=&quot;headerlink&quot; title=&quot;alarm&quot;&gt;&lt;/a&gt;alarm&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;使用alarm函数可以设置一个定时器（闹钟时间），在将来的某个时刻该定时器会超时。当定时器超时时，产生SIGALRM信号。如果忽略或不捕获此信号，则其默认动作是终止调用该alarm函数的进程&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="信号" scheme="http://www.wangxinri.cn/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://www.wangxinri.cn/2018/05/18/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.wangxinri.cn/2018/05/18/线程/</id>
    <published>2018-05-18T03:59:00.000Z</published>
    <updated>2018-05-19T03:28:12.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>使用多个控制线程（或者简单地说就是线程）在单进程环境中执行多个任务</strong>。一个进程中的所有线程都可以访问该进程的组成部分，如文件描述符和内存。</p>
<a id="more"></a>
<p>不管什么情况下，<strong>只要单个资源需要在多个用户间共享，就必须处理一致性问题</strong>。本章的最后将讨论目前可用的<strong>同步机制</strong>，防止多个线程在共享资源时出现不一致的问题。</p>
<h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>典型的UNIX进程可以看成只有一个控制线程，一个进程在某一时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处。</p>
<ul>
<li>通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。</li>
<li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，<strong>而多个线程自动地可以访问相同的存储地址空间和文件描述符</strong>。</li>
<li>有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下，一个单线程进程要完成多个任务，只需要把这些任务串行化。但有多个控制线程时，相互独立的任务的处理就可以交叉进行，此时只需要为每个任务分配一个单独的线程。<strong>当然只有在两个任务的处理过程互不依赖的情况下，两个任务才可以交叉执行</strong>。</li>
<li>交互的程序同样可以通过使用多线程来改善响应时间，多线程可以把程序中处理用户输入输出的部分与其他部分分开。</li>
</ul>
<p>即使多线程程序在串行化任务时不得不阻塞，由于某些线程在阻塞的时候还有另外一些线程可以运行，所以多线程程序在单处理器上运行还是可以改善响应时间和吞吐量。</p>
<p><strong>每个线程都包含有表示执行环境所必需的信息，其中包含进程中标识线程的线程ID，一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符</strong>。</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程ID一样，每个线程也有一个线程ID，进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义。</p>
<p>线程ID是用pthread_t数据类型来表示，必须使用一个函数来对两个线程ID进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1,<span class="keyword">pthread_t</span> tid2)</span></span>;</div><div class="line">            <span class="comment">//若相等，返回非0数值；否则，返回0</span></div></pre></td></tr></table></figure>
<p>线程可以通过调用pthread_self函数获得自身的线程ID。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);       <span class="comment">//返回值：调用线程的线程ID</span></div></pre></td></tr></table></figure>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>在传统的UNIX进程模型中，每个进程只有一个控制线程。从概念上来讲，这与基于线程的模型中每个进程只包含一个线程是相同的。在POSIX线程（pthread）的情况下，程序开始运行时，他也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用pthread_create函数创建。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,</span></span></div><div class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></div><div class="line">                    void *(*start_rtn)(void *),</div><div class="line">                    <span class="keyword">void</span> *<span class="keyword">restrict</span> arg);</div><div class="line">        <span class="comment">//返回值：若成功，返回0；否则，返回错误编码。</span></div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>tidp：新创建的线程ID会被设置成tidp指向的内存单元。</li>
<li>attr：用于定制各种不同的线程属性，如果设置为NULL，则创建一个具有默认属性的线程。</li>
<li>start_rtn：新创建的线程从start_rtn函数的地址开始运行，该函数只有一个void类型的指针参数arg，如果start_rtn需要多个参数，可以将参数放入一个结构中，然后将结构的地址作为arg传入。</li>
</ul>
<p><strong>线程创建时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除</strong>。</p>
<p>注意：pthread函数在调用失败后通常会返回错误码，它们并不像其他的POSIX函数一样设置errno。每个线程都提供errno的副本，这只是为了与使用errno的现有函数兼容。在线程中，从函数中返回错误码更为清晰整洁，不需要依赖那些随着函数执行不断变化的全局状态。这样可以把错误的范围限制在引起出错的函数中。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建一个线程，打印进程ID、新线程的线程ID以及初始化线程的线程ID。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> ntid;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printids</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">pthread_t</span> tid;</div><div class="line">	pid = getpid();</div><div class="line">	tid = pthread_self();</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s pid %lu,tid %lu (0x%lx)\n"</span>,s,pid,tid,tid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	printids(<span class="string">"new thread: "</span>);</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	err = pthread_create(&amp;ntid,<span class="literal">NULL</span>,thr_fn,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>( err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	printids(<span class="string">"main thread: "</span>);</div><div class="line">	sleep(<span class="number">1</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadCreate.c -o pthreadCreate.o -lpthread</div><div class="line">[vrlive@iZ23chs2r19Z eleven]$ ./pthreadCreate.o </div><div class="line">main thread:  pid 7229,tid 140149555926848 (0x7f771c7f1740)</div><div class="line">new thread:  pid 7229,tid 140149547579136 (0x7f771bffb700)</div></pre></td></tr></table></figure>
<p>在编译中要加 -lpthread参数，因为pthread库不是linux默认的库。</p>
<p>这个示例有两个特别之处。</p>
<p>第一个特别之处在于，主线程需要休眠，如果主线程不休眠，它就可能会退出，这样新线程还没有机会运行，整个进程就可能已经终止了。这种行为依赖于操作系统中的线程实现和调度算法。</p>
<p>第二个特别之处在于新线程是通过调用pthread_self函数获取自己的线程ID的，而不是从共享内存中读出的，或者从线程的启动例程中以参数的形式接收到的。在这个例子中，主线程把新线程ID存放在ntid中，但是新建的线程并不能安全地使用它，如果新线程在主线程调用pthread_create返回之前就运行了，那么新线程有可能看到的是未经初始化的ntid的内容。这个内容并不是正确的线程ID。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、_Exit、_exit，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。</p>
<p>单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回，返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用pthread_exit。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p>rval_ptr参数是一个无类型的指针，与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用pthread_join函数访问到这个指针上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span> **rval_ptr)</span></span>;  <span class="comment">//若成功，返回0；否则，返回错误编码</span></div></pre></td></tr></table></figure>
<p>调用线程将一直阻塞，直到指定的线程调用pthread_exit、从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，rval_ptr就包含返回码。如果线程被取消，由rval_ptr指定的内存单元被设置为PTHREAD_CANCELED。</p>
<p><strong>可以通过调用pthread_join自动把线程置于分离状态，这样资源就可以恢复</strong>。如果线程已经处于分离状态，pthread_join调用就会失败，返回EINVAL，尽管这种行为是与具体实现相关的。</p>
<p>如果对线程的返回值并不敢兴趣，那么可以把rval_ptr设置为NULL。在这种情况下，调用pthread_join函数可以等待指定的线程终止，但并不获取线程的终止状态。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>获取已终止线程的退出码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 returning\n"</span>);</div><div class="line">	<span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2 exiting\n"</span>);</div><div class="line">	pthread_exit((<span class="keyword">void</span>*)<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">pthread_t</span> tid1,tid2;</div><div class="line">	<span class="keyword">void</span> *tret;</div><div class="line">	err = pthread_create(&amp;tid1,<span class="literal">NULL</span>,thr_fn1,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_create(&amp;tid2,<span class="literal">NULL</span>,thr_fn2,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_join(tid1,&amp;tret);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread 1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread1 exit code %ld\n"</span>,(<span class="keyword">long</span>)tret);</div><div class="line">	err = pthread_join(tid2,&amp;tret);	</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread2 exit code %ld\n"</span>,(<span class="keyword">long</span>)tret);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadJoin.c -o pthreadJoin.o -lpthread</div><div class="line">[vrlive@iZ23chs2r19Z eleven]$ ./pthreadJoin.o </div><div class="line">thread 1 returning</div><div class="line">thread1 exit code 1</div><div class="line">thread 2 exiting</div><div class="line">thread2 exit code 2</div></pre></td></tr></table></figure>
<p>可以看出，当一个线程通过调用pthread_exit退出或简单地从启动例程中返回时，<strong>进程中的其他线程可以通过调用pthread_join函数获得该进程的退出状态</strong>。</p>
<p>pthread_create和pthread_exit函数的无类型指针参数可以传递的值不止一个，这个指针可以传递包含复杂信息的结构的地址，但是注意，<strong>这个结构体所使用的内存在调用者完成调用以后必须仍然是有效的</strong>。</p>
<p>示例：</p>
<p>程序给出了用自动变量（分配在栈上）作为pthread_exit的参数时出现的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> a,b,c,d;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfoo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">const</span> struct foo *fp)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">" structure at 0x%lx\n"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)fp);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">" foo.a = %d\n"</span>,fp-&gt;a);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">" foo.b = %d\n"</span>,fp-&gt;b);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">" foo.c = %d\n"</span>,fp-&gt;c);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">" foo.d = %d\n"</span>,fp-&gt;d);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">f</span> = &#123;</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;   <span class="comment">//initinal	</span></div><div class="line">	printfoo(<span class="string">"thread1 :\n"</span>,&amp;f);</div><div class="line">	pthread_exit((<span class="keyword">void</span>*)&amp;f);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread 2: ID is %lu\n"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)pthread_self());</div><div class="line">	pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">pthread_t</span> tid1,tid2;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></div><div class="line">	err = pthread_create(&amp;tid1,<span class="literal">NULL</span>,thr_fn1,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_join(tid1,(<span class="keyword">void</span>*)&amp;fp);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	sleep(<span class="number">1</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"parent starting second thread\n"</span>);</div><div class="line">	err = pthread_create(&amp;tid2,<span class="literal">NULL</span>,thr_fn2,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_join(tid2,<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	sleep(<span class="number">1</span>);</div><div class="line">	printfoo(<span class="string">"parent:\n"</span>,fp);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadExit.c -o pthreadExit.o -lpthread</div><div class="line">[vrlive@iZ23chs2r19Z eleven]$ ./pthreadExit.o </div><div class="line">thread1 :</div><div class="line"> structure at 0x7ff5ec397f00</div><div class="line"> foo.a = 1</div><div class="line"> foo.b = 2</div><div class="line"> foo.c = 3</div><div class="line"> foo.d = 4</div><div class="line">parent starting second thread</div><div class="line">thread 2: ID is 140694206908160</div><div class="line">parent:</div><div class="line"> structure at 0x7ff5ec397f00</div><div class="line"> foo.a = 0</div><div class="line"> foo.b = 0</div><div class="line"> foo.c = 1</div><div class="line"> foo.d = 0</div></pre></td></tr></table></figure>
<p>解决办法，可以使用全局结构（全局变量，static修饰），或者用malloc函数分配结构。</p>
<h2 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h2><p>线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;   <span class="comment">//返回值，若成功，返回0，否则，返回错误编码</span></div></pre></td></tr></table></figure>
<p>在默认情况下，pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数，但是，线程可以选择忽略取消或者控制如何被取消。注意，pthread_cancel并不等待线程终止，它仅仅提出请求。</p>
<p><strong>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用atexit函数安排退出是类似的。这样的函数称为线程清理处理程序</strong>（thread cleanup handler）。一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们的注册时相反。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line">void pthread_cleanup_push(void (*rtn)(void *)，void *arg);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</div></pre></td></tr></table></figure>
<p><strong>当线程执行以下动作时，清理函数rtn是由pthread_cleanup_push函数调度的</strong>，调用时只有一个参数arg：</p>
<ul>
<li>调用pthread_exit时；</li>
<li>响应取消请求时；</li>
<li>用非零execute参数调用pthread_cleanup_pop时。</li>
</ul>
<p>如果execute参数设置为0，清理函数将不被调用。不管发生上述哪种情况，pthread_cleanup_pop都将删除上次pthread_cleanup_push调用建立的清理处理程序。</p>
<p><strong>这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用</strong>。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"cleanup: %s\n"</span>,(<span class="keyword">char</span>*)arg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread1 start\n"</span>);</div><div class="line">	pthread_cleanup_push(cleanup,<span class="string">"thread1 first handler"</span>);</div><div class="line">	pthread_cleanup_push(cleanup,<span class="string">"thread1 second handler"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread1 push complete\n"</span>);</div><div class="line">	<span class="keyword">if</span>(arg)&#123;    <span class="comment">//  (void*)1</span></div><div class="line">		<span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pthread1 pthread_cleanup_pop start\n"</span>);</div><div class="line">	pthread_cleanup_pop(<span class="number">0</span>);</div><div class="line">	pthread_cleanup_pop(<span class="number">0</span>);</div><div class="line">	<span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread2 start\n"</span>);</div><div class="line">	pthread_cleanup_push(cleanup,<span class="string">"thread2 first handler"</span>);</div><div class="line">	pthread_cleanup_push(cleanup,<span class="string">"thread2 second handler"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread2 push complete\n"</span>);</div><div class="line">	<span class="keyword">if</span>(arg)&#123;</div><div class="line">		pthread_exit((<span class="keyword">void</span>*)<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pthread2 pthread_cleanup_pop start\n"</span>);</div><div class="line">	pthread_cleanup_pop(<span class="number">0</span>);</div><div class="line">	pthread_cleanup_pop(<span class="number">0</span>);</div><div class="line">	pthread_exit((<span class="keyword">void</span>*)<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">pthread_t</span> tid1,tid2;</div><div class="line">	<span class="keyword">void</span> *tret;</div><div class="line">	err = pthread_create(&amp;tid1,<span class="literal">NULL</span>,thr_fn1,(<span class="keyword">void</span>*)<span class="number">1</span>);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_create(&amp;tid2,<span class="literal">NULL</span>,thr_fn2,(<span class="keyword">void</span>*)<span class="number">1</span>);</div><div class="line">	<span class="keyword">if</span>(err !=<span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't create thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	err = pthread_join(tid1,&amp;tret);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread1 exit code %ld\n"</span>,(<span class="keyword">long</span>)tret);</div><div class="line">	err = pthread_join(tid2,&amp;tret);</div><div class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't join with thread2\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"thread2 exit code %ld\n"</span>,(<span class="keyword">long</span>)tret);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eleven]$ ./pthreadCleanup.o </div><div class="line">thread1 start</div><div class="line">thread1 push complete</div><div class="line">thread1 exit code 1</div><div class="line">thread2 start</div><div class="line">thread2 push complete</div><div class="line">cleanup: thread2 second handler</div><div class="line">cleanup: thread2 first handler</div><div class="line">thread2 exit code 2</div></pre></td></tr></table></figure>
<p>从输入结果可以看到，两个线程都正确地启动和退出了，但是只有第二个线程的清理处理程序被调用了。因此，如果线程是通过从它的启动例程中返回而终止的话，它的清理处理程序就不会被调用，还要注意清理处理程序是按照与它们安装时相反的顺序被调用的。</p>
<p>现在，让我们了解一下线程函数和进程函数之间的相似之处，下图总结了这些相似的函数。</p>
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>pthread_create</td>
<td>创建新的控制流</td>
</tr>
<tr>
<td>exit</td>
<td>pthread_exit</td>
<td>从现在的控制流中退出</td>
</tr>
<tr>
<td>waitpid</td>
<td>pthread_join</td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td>atexit</td>
<td>pthread_cancel_push</td>
<td>注册在调用控制流时调用的函数</td>
</tr>
<tr>
<td>getpid</td>
<td>pthread_self</td>
<td>获取控制流ID</td>
</tr>
<tr>
<td>abort</td>
<td>pthread_cancel</td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody>
</table>
<p>在默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。在线程分离后，我们不能用pthread_join函数等待它的终止状态，因为对分离状态的线程调用pthread_join会产生未定义行为。可以调用pthread_detach分离线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;     <span class="comment">//若成功，返回0；否则，返回错误编码</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;使用多个控制线程（或者简单地说就是线程）在单进程环境中执行多个任务&lt;/strong&gt;。一个进程中的所有线程都可以访问该进程的组成部分，如文件描述符和内存。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="http://www.wangxinri.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>kill和raise</title>
    <link href="http://www.wangxinri.cn/2018/05/17/%E5%87%BD%E6%95%B0kill%E5%92%8Craise/"/>
    <id>http://www.wangxinri.cn/2018/05/17/函数kill和raise/</id>
    <published>2018-05-17T11:59:00.000Z</published>
    <updated>2018-05-19T03:24:35.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kill和raise"><a href="#kill和raise" class="headerlink" title="kill和raise"></a>kill和raise</h2><p>kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> signo)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</div><div class="line">        <span class="comment">//若成功，返回0；若出错，返回-1</span></div></pre></td></tr></table></figure>
<p>调用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">raise(signo);</div><div class="line"><span class="comment">//等价于调用</span></div><div class="line">kill(getpid(),signo);</div></pre></td></tr></table></figure></p>
<p>kill的pid参数有以下4中不同的情况。</p>
<ul>
<li>pid&gt;0 将该信号发送给进程ID为pid的进程。</li>
<li>pid == 0 将该信号发送给与发送进程属于同一进程组的所有进程。</li>
<li>pid &lt; 0 将该信号发送给其他进程组ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程。</li>
<li>pid == -1 该信号发送给发送进程有权限向它们发送信号的所有进程。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signal(SIG_USR1,sig_usr1) == SIG_ERR)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"signal error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	kill(getpid(),SIG_USR1);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"send a SIG_USR1\n"</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr1</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"received a %d signal\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z ten]$ ./kill.o </div><div class="line">received a 897804016 signal</div><div class="line">send a SIGUSR1</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kill和raise&quot;&gt;&lt;a href=&quot;#kill和raise&quot; class=&quot;headerlink&quot; title=&quot;kill和raise&quot;&gt;&lt;/a&gt;kill和raise&lt;/h2&gt;&lt;p&gt;kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="信号" scheme="http://www.wangxinri.cn/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>信号</title>
    <link href="http://www.wangxinri.cn/2018/05/16/%E4%BF%A1%E5%8F%B7/"/>
    <id>http://www.wangxinri.cn/2018/05/16/信号/</id>
    <published>2018-05-16T13:59:00.000Z</published>
    <updated>2018-05-19T03:23:05.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>信号是软件中断。很多比较重要的应用程序都需要处理信号，信号提供了一种处理异步事件的方法</strong>，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。</p>
<a id="more"></a>
<h3 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h3><p>首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，SIGABRT是夭折信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，由alarm函数设置的定时器超时后将产生此信号。</p>
<p>在头文件<signal.h>中，信号名都被定义为正整数常量（信号编号）。</signal.h></p>
<p>不存在编号为0的信号。kill函数对信号编号0有特殊的应用。POSIX.1将此种信号编号值称为空信号。</p>
<p>很多条件可以产生信号：</p>
<ul>
<li>当用户按某些终端键时，引发终端产生的信号。在终端上按Delete键（或者很多系统中的Ctrl+C键）通常产生中断信号（SIGINT）。这是停止一个已失去控制程序的方法。</li>
<li>硬件异常产生信号：除数为0、无效的内存引用等。这些条件通常由硬件检测到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无效内存引用的进程产生SIGSEGV信号。</li>
<li>进程调用kill函数可将任意信号发送给另一个进程或进程组。自然，对此有所限制，接受信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。</li>
<li>用户可用kill命令将信号发送给其他进程。此命令只是kill函数的接口。常用此命令终止一个失控的后台进程。</li>
<li>当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是硬件产生条件（如除以0），而是软件条件。例如SIGURG（在网络连接上传来带外的数据）、SIGPIPE（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM（进程所设置的定时器已经超时）。</li>
</ul>
<p>信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单的测试一个变量（如errno）来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。</p>
<p>在某个信号出现时，可以告诉内核按下列3中方式之一进行处理，我们称之为信号的处理或与信号相关的动作。</p>
<ol>
<li>忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却绝不能忽略，它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号（如非法内存引用或除以0），则进程的运行行为是未定义的。</li>
<li>捕获信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。比如，如果捕获到SIGCHLD信号，则表示一个子进程已经终止，所以此信号的捕获函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。注意：<strong>不能捕获SIGKILL和SIGSTOP信号</strong>。</li>
<li>执行系统默认动作，对大多数系统默认动作是终止该进程。</li>
</ol>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/UNIX%E7%B3%BB%E7%BB%9F%E4%BF%A1%E5%8F%B7.png" alt="image"></p>
<p>下面较详细地逐一说明这些信号：</p>
<p>参考UNIX环境高级编程。</p>
<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><p>UNIX系统信号机制最简单的接口是signal函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo ,<span class="keyword">void</span> (*func)(<span class="keyword">int</span>))) (<span class="keyword">int</span>);</div><div class="line">    <span class="comment">//若成功，返回以前的信号处理配置；若出错，返回SIG_ERR</span></div></pre></td></tr></table></figure>
<p>通过typedef可以转换成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function">Sigfunc *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>,Sigfunc *)</span></span>;</div></pre></td></tr></table></figure>
<p>也就是说，signal有两个参数，一个是int,一个是Sigfunc ,返回值也是Sigfunc ，该指针指向一个参数为int，无返回值的函数。</p>
<p>signo参数是上图中的信号名。func的值是常量SIG_IGN、常量SIGDFL或当接到此信号后要调用的函数的地址。</p>
<ul>
<li>SIG_IGN，则向内核表示忽略此信号（记住有两个信号SIGKILL和SIGSTOP不能忽略）。</li>
<li>SIG_DFL，则表示接到此信号后的动作是系统默认动作。</li>
<li>当指定函数地址时，则在信号发生时，调用该信号，我们称这种处理为捕获该信号，称此函数为信号处理程序（signal handler）或信号捕获函数（signal-catching function）。</li>
</ul>
<p><strong>当调用signal设置处理程序时，第二个参数是指向该函数（也就是信号处理程序）的指针。signal的返回值则是指向在此之前的信号处理程序的指针</strong>。</p>
<p>signal 的第1个参数signum表示要捕捉的信号，第2个参数是个函数指针，表示要对该信号进行捕捉的函数，该参数也可以是SIG_DEF(表示交由系统缺省处理，相当于白注册了)或SIG_IGN(表示忽略掉该信号而不做任何处理)。signal如果调用成功，返回以前该信号的处理函数的地址，否则返回 SIG_ERR。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_ERR (void(*)())-1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL (void(*)())0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN (void(*)())1</span></div></pre></td></tr></table></figure>
<p>这些常量可用于表示“指向函数的指针，该函数要求一个整形参数，并且无返回值”。signal的第二个参数及其返回值就可用它们表示。这些常量所使用的3个值不一定是-1、0和1，但它们必须是3个值而绝不能是任一函数的地址。</p>
<p><strong>注：</strong></p>
<p>为什么不是这样定义的呢？？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define SIG_ERR (void (*)(int))-1</div><div class="line">#define SIG_DEL (void (*)(int))0</div><div class="line">#define SIG_IGN (void (*)(int))1</div></pre></td></tr></table></figure>
<p>在网上搜索之后找到答案，C语言中是可以这样定义的，<strong>C语言中前向声明是可以省略参数的，意味着可以有任意多个参数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">       fun(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i+j);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>只是将-1强制转换为一个指针</strong>，通过编译。就像</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL (void *)0</span></div></pre></td></tr></table></figure>
<p>可以将SIG_ERR跟其他的信号理解的一样，是一个整数。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面给出了一个简单的信号处理程序，它捕获两个用户定义的信号并打印信号编号，pause函数，它使调用进程在接到一信号前挂起。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">//one handler for both signals</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR1,sig_usr) == SIG_ERR)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't catch error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR2,sig_usr) == SIG_ERR)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't catch error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"we come here,catch no signal\n"</span>);</div><div class="line">	<span class="keyword">for</span>(;;)&#123;</div><div class="line">		pause();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;     <span class="comment">//argument is signal number</span></div><div class="line">	<span class="keyword">if</span>(signo == SIGUSR1)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR1\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGUSR2)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR2\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"received signal %d\n"</span>,signo);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使程序在后台运行，并且用kill命令将信号发送给它。</p>
<p>注意，在UNIX系统中，杀死（kill）这个术语是不恰当的。kill命令和kill函数只是将一个信号发送给一个进程或进程组。该信号是否终止进程取决于该信号的类型，以及进程是否安排了捕获该信号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z ten]$ ./signal.o &amp;     <span class="comment">//后台启动进程</span></div><div class="line">[<span class="number">4</span>] <span class="number">3243</span>                   <span class="comment">//进程ID</span></div><div class="line">[vrlive@iZ23chs2r19Z ten]$ kill -USR1 <span class="number">3243</span></div><div class="line">received SIGUSR1</div><div class="line">[vrlive@iZ23chs2r19Z ten]$ kill -USR2 <span class="number">3243</span></div><div class="line">received SIGUSR2</div><div class="line">[vrlive@iZ23chs2r19Z ten]$ kill <span class="number">3243</span>       <span class="comment">//默认向该进程发送SIGTERM</span></div><div class="line">[<span class="number">4</span>]+  Terminated              ./signal.o</div></pre></td></tr></table></figure>
<h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p><strong>当执行一个程序时，所有信号的状态都是系统默认或者忽略</strong>。通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。确切地讲，<strong>exec函数将原先设置为要捕获的信号都更改为默认状态，其他信号的状态不变</strong>（一个进程原先要捕获的信号，当其执行一个新程序后，就不再捕获了，因为信号捕获函数的地址很可能在所执行的新程序文件中已无意义）。</p>
<p>很多捕获这两个信号的交互程序具有下列形式的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">if</span>(signal(SIGINT,SIG_IGN) != SIG_IGN)</div><div class="line">    signal(SIGINT,sig_int);</div><div class="line"><span class="keyword">if</span>(signal(SIGQUIT,SIG_IGN) != SIG_IGN)</div><div class="line">    signal(SIGQUIT,sig_quit);</div></pre></td></tr></table></figure>
<p>这样处理后，仅当SIGINT和SIGQUIT当前未被忽略时，进程才会捕获它们。</p>
<p>从signal的这两个调用中也可以看到这种函数的限制：不改变信号的处理方式就不能确定信号的当前处理方式。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>当一个进程调用fork时，<strong>其子进程继承父进程的信号处理方式</strong>，因为子进程在开始时复制了父进程的内存映像，所以信号捕获函数的地址在子进程中时有意义的。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>首先注册一个信号处理函数，发送信号后，注册信号处理函数更新新的注册信号函数，代替之前的信号处理函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(signal(SIGUSR1,sig_usr) == SIG_ERR)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"can't catch SIGUSR1\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(;;)&#123;</div><div class="line">		pause();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</div><div class="line">	signal(SIGUSR1,sig_usr1);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"now we reestablish handler for next time\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr1</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"this handler is new handler\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z ten]$ ps -auf</div><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">vrlive    4420  0.0  0.0 115512  2136 pts/1    Ss   10:18   0:00 -bash</div><div class="line">vrlive    4444  0.0  0.0 139496  1616 pts/1    R+   10:18   0:00  \_ ps -auf</div><div class="line">vrlive    4378  0.0  0.0 115516  2140 pts/0    Ss   10:03   0:00 -bash</div><div class="line">vrlive    4415  0.0  0.0   4164   352 pts/0    S+   10:17   0:00  \_ ./changesignal.o</div><div class="line">root       473  0.0  0.0 110036   844 tty1     Ss+   2017   0:00 /sbin/agetty --noclear tty1 linux</div><div class="line">[vrlive@iZ23chs2r19Z ten]$ kill -USR1 4415</div><div class="line">[vrlive@iZ23chs2r19Z ten]$ kill -USR1 4415</div><div class="line">[vrlive@iZ23chs2r19Z ten]$ kill -USR1 4415</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z ten]$ ./changesignal.o </div><div class="line"></div><div class="line">now we reestablish handler for next time</div><div class="line">this handler is new handler</div><div class="line">this handler is new handler</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;信号是软件中断。很多比较重要的应用程序都需要处理信号，信号提供了一种处理异步事件的方法&lt;/strong&gt;，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="信号" scheme="http://www.wangxinri.cn/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>进程组</title>
    <link href="http://www.wangxinri.cn/2018/05/16/%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D/"/>
    <id>http://www.wangxinri.cn/2018/05/16/进程组和会话/</id>
    <published>2018-05-16T03:59:00.000Z</published>
    <updated>2018-05-19T03:22:06.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p><strong>每个进程除了有一进程ID外，还属于一个进程组</strong>。</p>
<a id="more"></a>
<p>进程组是一个或多个进程的集合。通常，他们是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID—它是一个正整数，并可存放在pid_t数据类型中。函数getpgrp返回调用进程的进程组ID。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);     <span class="comment">//调用进程的进程组ID</span></div></pre></td></tr></table></figure>
<p>Single UNiX Specification定义了getpgid函数模仿此种运行行为。该函数的参数时pid，返回该进程的进程组ID。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);</div></pre></td></tr></table></figure>
<p><strong>若pid是0，返回调用进程的进程组ID</strong>，于是，getpgid(0);  等价于 getpgrp();</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %d,ppid = %d\n"</span>,getpid(),getppid());   <span class="comment">//主进程的父进程是bash</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pgrp = %d\n"</span>,getpgrp());</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pgrp = %d\n"</span>,getpgid(<span class="number">0</span>));</div><div class="line">	system(<span class="string">"ps -O pgid"</span>);    <span class="comment">//打印进程状态</span></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z nine]$ ./getppid.o </div><div class="line">pid = 1174,ppid = 1103     //1103为bash</div><div class="line">pgrp = 1174</div><div class="line">pgrp = 1174</div><div class="line">  PID  PGID S TTY          TIME COMMAND</div><div class="line"> 1103  1103 S pts/1    00:00:00 -bash</div><div class="line"> 1174  1174 S pts/1    00:00:00 ./getppid.o</div><div class="line"> 1175  1174 R pts/1    00:00:00 ps -O pgid</div></pre></td></tr></table></figure>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。</p>
<p>进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。</p>
<p>进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">pid_t</span> pgid)</span></span>;    <span class="comment">//若成功，返回0；若出错，返回-1</span></div></pre></td></tr></table></figure>
<p>setpgid 函数将pid进程的进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。如果pid是0，则使用调用者的进程ID。另外，如果pgid是0，则由pid指定的进程ID用作进程组ID。</p>
<p><strong>一个进程只能为它自己或它的子进程设置进程组ID</strong>。在它的子进程调用了exec后，它就不再更改该子进程的进程组ID。</p>
<p><strong>在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID</strong>。在这来两个调用中有一个是冗余的，但让父进程和子进程都这样做可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如果不这样做，在fork之后，由于父进程和子进程运行的先后次序不确定，会因为子进程的组员身份取决于哪个进程首先执行而产生竞争条件。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话（session）是一个或多个进程组的集合。</p>
<p>进程调用setsid函数建立一个新会话。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);    <span class="comment">//若成功，返回进程组ID，若出错，返回-1</span></div></pre></td></tr></table></figure>
<p><strong>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话</strong>。具体会发生以下3件事。</p>
<ol>
<li>该进程变成新会话的会话首进程。此时，该进程是新会话中的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断。</li>
</ol>
<p><strong>如果该调用进程已经是一个进程组的组长，则此函数返回出错</strong>。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。</p>
<p>getsid函数返回会话首进程的进程组ID。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid);   <span class="comment">//若成功，返回会话首进程的进程组ID；若出错，返回-1</span></div></pre></td></tr></table></figure>
<p>如若pid是0，getsid返回调用进程的会话首进程的进程ID。处于安全方面的考虑，一些实现有如下限制：如若pid并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组ID。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</div><div class="line">		<span class="keyword">pid_t</span> sid;</div><div class="line">		sid = getsid(<span class="number">0</span>);  </div><div class="line">		<span class="built_in">printf</span>(<span class="string">"in child(before setsid) sid = %d\n"</span>,sid);</div><div class="line">		sid = setsid();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"in child(after setsid) sid = %d\n"</span>,sid);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"in child sid = %d,pgrpid = %d,pid = %d\n"</span>,sid,getpgrp(),getpid());</div><div class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">pid_t</span> sid;</div><div class="line">	sid = setsid();   <span class="comment">//error  -1</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"in parent sid = %d,pgrpid = %d,pid = %d\n"</span>,sid,getpgrp(),getpid());</div><div class="line">	sid = getsid(<span class="number">0</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"in parent sid = %d\n"</span>,sid);	</div><div class="line">	sid = getsid(pid);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"in parent get child sid = %d\n"</span>,sid);</div><div class="line">	sid = getsid(<span class="number">1</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"in parent get init sid = %d\n"</span>,sid);</div><div class="line">	waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z nine]$ ./session.o </div><div class="line">in parent sid = -1,pgrpid = 1469,pid = 1469</div><div class="line">in parent sid = 1329</div><div class="line">in parent get child sid = 1329</div><div class="line">in parent get init sid = 1</div><div class="line">in child(before setsid) sid = 1329</div><div class="line">in child(after setsid) sid = 1470</div><div class="line">in child sid = 1470,pgrpid = 1470,pid = 1470</div></pre></td></tr></table></figure>
<p>在父进程中，调用setsid，因为该进程是进程组组长（pid和pgrpid都是1469），所以返回-1。</p>
<p>获取父进程sid是1329。</p>
<p>在父进程中获取子进程sid也是1329。</p>
<p>在父进程中获取init的sid是1。（好像能获取任何进程的sid）</p>
<p>在子进程中获取sid是1329（此时和父进程子在同一个会话中）</p>
<p>在子进程中setsid后，子进程处在新的会话中，新会话的ID是1470，</p>
<p>在子进程中获取sid是1470，进程组ID和进程ID都是1470，说明该子进程是会话中的第一个进程，而且是进程组的组长。</p>
<p>参考：<a href="https://blog.csdn.net/todd911/article/details/16965971" target="_blank" rel="external">https://blog.csdn.net/todd911/article/details/16965971</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程组&quot;&gt;&lt;a href=&quot;#进程组&quot; class=&quot;headerlink&quot; title=&quot;进程组&quot;&gt;&lt;/a&gt;进程组&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;每个进程除了有一进程ID外，还属于一个进程组&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>exit与wait函数系列</title>
    <link href="http://www.wangxinri.cn/2018/05/15/exit%E5%92%8Cwait%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97/"/>
    <id>http://www.wangxinri.cn/2018/05/15/exit和wait函数系列/</id>
    <published>2018-05-15T13:59:00.000Z</published>
    <updated>2018-05-19T03:19:19.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程有5中正常终止和3中异常终止方式。<strong>5中正常终止方式具体如下</strong>：</p>
<a id="more"></a>
<ol>
<li>在main函数内执行return语句。这等效于调用exit。</li>
<li>调用exit函数，此函数由ISO C定义，其操作包括调用各终止处理程序（终止处理程序在调用atexit函数时登记），然后关闭所有标准I/O流等。</li>
<li>调用_exit或者 _Exit函数。ISOC定义 _Exit，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗，这取决于实现。在UNIX系统中， _Exit和 _exit是同义的，并不冲洗标准I/O流。 _exit函数由exit函数调用（在大多数UNIX系统实现中，exit是标准C库中的一个函数，而 _exit则是一个系统调用）。</li>
<li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。</li>
<li>进程的最后一个线程调用pthread_exit函数，如同前面一样，在这种情况中，进程终止状态总是0，这与传送给pthread_exit的参数无关。</li>
</ol>
<p><strong>3中异常终止具体如下</strong>：</p>
<ol>
<li>调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例。</li>
<li>当进程接收到某些信号时。信号可由进程自身（如调用abort函数）、其他进程或内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生响应的信号。</li>
<li>最后一个线程对“取消”（cancellation）请求作出响应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止。</li>
</ol>
<p><strong>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure>
<p>对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数（exit、_exit和 _Exit），实现这一点的方法是，将其退出状态（exit status）作为参数传递给函数。在异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态（termination status）。<strong>在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态</strong>。</p>
<p>子进程在父进程调用fork后产生，子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，将如何呢？</p>
<p><strong>对于父进程已经终止的所有进程，它们的父进程都改变为init进程。我们称这些进程由init进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就改为1（init进程ID）。这种处理办法保证了每个进程有一个父进程</strong>。</p>
<p><strong>内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或者waitpid时，可以得到这些信息</strong>。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。</p>
<p>在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程称为<strong>僵死进程</strong>（Zombie）</p>
<p>一个由init进程收养的进程终止时会发生什么？它会不会变成一个僵死进程？对此问题的回答是“否”，因为<strong>init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了系统中塞满僵死进程</strong>。</p>
<h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号，因为子进程终止是个异步时间（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。对于这种信号的系统默认动作是忽略它，现在需要知道的是调用wait或waitpid的进程可能会发生什么。</p>
<ul>
<li>如果其所有子进程都还在运行，则阻塞。</li>
<li>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，则立即出错返回。</li>
</ul>
<p>如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在调用wait，则进程可能会阻塞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *statloc,<span class="keyword">int</span> options);</div><div class="line"><span class="comment">//两个函数返回值：若成功，返回进程ID；若出错，返回0或-1</span></div></pre></td></tr></table></figure>
<p><strong>两个函数的区别</strong></p>
<ul>
<li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞。</li>
<li>waitpid并不等待在其调用之后的第一个终止进程，它有若干个选项，可以控制它所等待的进程。</li>
</ul>
<p>如果子进程已经终止，并且是一个僵死进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。如调用者阻塞而且它有多个子进程，则在其某一子进程终止时，wait就立即返回。<strong>因为wait返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了</strong>。</p>
<p>这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。</p>
<p>依据传统，这两个函数返回的整型状态字是由实现定义的。其中某些位表示退出状态（正常返回），其他位则指示信号编号（异常返回），有一位指示是否产生了core文件等。POSIX.1规定，终止状态用定义在<sys wait.h="">中的各个宏来查看。有4个互斥的宏可用来取得进程终止的原因，它们的名字都以WIF开始。基于这4个宏中哪一个值为真，就可选用其他宏来取得退出状态、信号编号等，这4个互斥的宏如下图：</sys></p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/wait%E5%92%8Cwaitpid%E6%89%80%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%8F.png" alt="image"></p>
<p>函数pr_exit使用上图中中的宏以打印进程终止状态的说明。</p>
<p>head.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAGS O_RDWR | O_CREAT</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE S_IRUSR | S_IWUSR | S_IXUSR</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(WIFEXITED(status))&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"normal termination,exit status = %d\n"</span>,WEXITSTATUS(status));</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"abnormal termination,signal number = %d %s\n"</span>,WTERMSIG(status),</div><div class="line">	#ifdef WCOREDUMP</div><div class="line">		WCOREDUMP(status) ? <span class="string">" (core file generated)"</span> : <span class="string">" "</span>);</div><div class="line">	<span class="meta">#<span class="meta-keyword">else</span>  </span></div><div class="line">		<span class="string">" "</span>);</div><div class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"child stopped,signal number = %d\n"</span>,WSTOPSIG(status));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>wait.c</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">int</span> status;</div><div class="line">	<span class="keyword">if</span>((pid=fork()) &lt;<span class="number">0</span> )&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid ==<span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">exit</span>(<span class="number">7</span>);   <span class="comment">//child</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(wait(&amp;status) != pid)&#123;    <span class="comment">//wait for child</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"wait error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	pr_exit(status);    <span class="comment">//print child status</span></div><div class="line">	</div><div class="line">	<span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;    <span class="comment">//child</span></div><div class="line">		<span class="built_in">abort</span>();   <span class="comment">//generates SIGABRT</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(wait(&amp;status) != pid)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"wait error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	pr_exit(status);</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</div><div class="line">		status /= <span class="number">0</span>;    <span class="comment">//divide by 0 generates SIGFPE</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(wait(&amp;status) != pid)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"wait error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	pr_exit(status);</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./wait.o </div><div class="line">normal termination,exit status = 7</div><div class="line">abnormal termination,signal number = 6     //SIGABRT的值为6</div><div class="line">abnormal termination,signal number = 8     //SIGFPE的值为8</div></pre></td></tr></table></figure>
<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *statloc,<span class="keyword">int</span> options);</div><div class="line"><span class="comment">//若成功，返回进程ID；若出错，返回0或-1</span></div></pre></td></tr></table></figure>
<p>等待一个指定的进程终止，POSIX定义了waitpid函数以提供这种功能（以及其他一些功能）。</p>
<p>对于waitpid函数中pid参数的作用解释如下：</p>
<ul>
<li>pid == -1 等待任一子进程。此种情况下，waitpid与wait等效。</li>
<li>pid&gt;0  等待进程ID与pid相等的子进程。</li>
<li>pid == 0  等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1  等待组ID等于pid绝对值的任一子进程。</li>
</ul>
<p>waitpid函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由statloc指向的存储单元中。对于wait，其唯一的出错是调用进程没有子进程（函数调用被另一个信号中断时，也可能返回另一种出错）。但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错。</p>
<p>options参数使我们能进一步控制waitpid的操作。此参数或者是0，或者是下图中常量按位或运算的结果。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/waitpid%E7%9A%84options%E5%B8%B8%E9%87%8F.png" alt="image"></p>
<p><strong>waitpid函数提供了wait函数没有提供的3个功能</strong>：</p>
<ul>
<li>waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。</li>
<li>waitpid提供了一个wait的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。</li>
<li>waitpid通过WUNTRACED和WCONTINUED选项支持作业控制。</li>
</ul>
<p>示例：如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止，实现这一要求的诀窍是调用fork两次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;    <span class="comment">//first child</span></div><div class="line">		<span class="keyword">if</span>((pid=fork()) &lt;<span class="number">0</span>)&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;   <span class="comment">//first child,second parent</span></div><div class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//parent from second fork == first child</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// second child</span></div><div class="line">		sleep(<span class="number">2</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"second child,parent pid = %d\n"</span>,getppid());</div><div class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// first child parent</span></div><div class="line">	<span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>) != pid)&#123;   <span class="comment">//wait for first child</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"waitpid error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"parent process end\n"</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二个子进程调用sleep以保证在打印父进程ID时第一个子进程已终止。在fork之后，父进程和子进程都可继续执行，并且我们无法预知哪一个会先执行。在fork之后，如果不使第二个子进程休眠，那么它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程，而不是init进程（进程ID为1）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./forktwice.o </div><div class="line">parent process end</div><div class="line">[vrlive@iZ23chs2r19Z eight]$ second child,parent pid = 1</div></pre></td></tr></table></figure>
<font color="red"> <strong>1.为何要fork()两次来避免产生僵尸进程？</strong> </font>

<p>当我们只fork()一次后，存在父进程和子进程。这时有两种方法来避免产生僵尸进程：</p>
<ul>
<li>父进程调用waitpid()等函数来接收子进程退出状态。</li>
<li>父进程先结束，子进程则自动托管到Init进程（pid = 1）。</li>
</ul>
<p>目前先考虑子进程先于父进程结束的情况：     </p>
<p>若父进程未处理子进程退出状态，在父进程退出前，子进程一直处于僵尸进程状态。<br>若父进程调用waitpid()（这里使用阻塞调用确保子进程先于父进程结束 ）来等待子进程结束，将会使父进程在调用waitpid()后进入睡眠状态，只有子进程结束父进程的waitpid()才会返回。 如果存在子进程结束，但父进程还未执行到waitpid()的情况，那么这段时期子进程也将处于僵尸进程状态。</p>
<p>由此，可以看出父进程与子进程有父子关系，<strong>除非保证父进程先于子进程结束或者保证父进程在子进程结束前执行waitpid()，子进程均有机会成为僵尸进程</strong>。那么如何使父进程更方便地创建不会成为僵尸进程的子进程呢？这就要用两次fork()了。</p>
<p>父进程一次fork()后产生一个子进程随后立即执行waitpid(子进程pid, NULL, 0)来等待子进程结束，然后子进程fork()后产生孙子进程随后立即exit(0)。这样子进程顺利终止（父进程仅仅给子进程收尸，并不需要子进程的返回值），然后父进程继续执行。这时的孙子进程由于失去了它的父进程（即是父进程的子进程），将被转交给Init进程托管。于是父进程与孙子进程无继承关系了，它们的父进程均为Init，Init进程在其子进程结束时会自动收尸，这样也就不会产生僵尸进程了。</p>
<p><strong>示例2</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;     <span class="comment">//parent</span></div><div class="line">		sleep(<span class="number">2</span>);</div><div class="line">		<span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>)!=pid)&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"waitpid error\n"</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"waitpid first child  success\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//first child</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %d,ppid = %d\n"</span>,getpid(),getppid());</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>((pid=fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;</div><div class="line">		sleep(<span class="number">4</span>);</div><div class="line">		<span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>)!=pid)&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"waitpid error\n"</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"waitpid second child success\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">abort</span>();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//  seond child</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"second child\n"</span>);</div><div class="line">	</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./account.o </div><div class="line">pid = 676,ppid = 675</div><div class="line">second child</div><div class="line">waitpid second child success</div><div class="line">waitpid first child  success</div></pre></td></tr></table></figure>
<h3 id="waitid"><a href="#waitid" class="headerlink" title="waitid"></a>waitid</h3><p>waitid：取得进程终止状态的函数，此函数类似于waitpid，但提供了更多的灵活性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype,<span class="keyword">id_t</span> id,<span class="keyword">siginfo_t</span> *infop,<span class="keyword">int</span> options)</span></span>;</div><div class="line"><span class="comment">//若成功，返回0；失败，返回-1</span></div></pre></td></tr></table></figure>
<p>具体介绍参考APUE</p>
<h3 id="wait3和wait4"><a href="#wait3和wait4" class="headerlink" title="wait3和wait4"></a>wait3和wait4</h3><p>wait3和wait4提供的功能比wait、waitpid和waitid所提供功能要多一个，这与附加参数有关，该参数允许内核返回由终止进程及其所有子进程使用的资源概况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *statloc,<span class="keyword">int</span> options,struct rusage *rusage);</div><div class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *statloc,<span class="keyword">int</span> options,struct rusage *rusage);</div><div class="line"><span class="comment">//若成功，返回进程ID；若出错，返回-1</span></div></pre></td></tr></table></figure>
<p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。</p>
<p><strong>相比较于waitid，wait3，wait4，wait和waitpid已经可以满足大多数应用，waitid使用方法与waitpid相似，可以看做是waitpid的增强版。wait3和wait4相比较于wait，waitpid，waitid，增加了获取进程所使用资源的功能</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数exit&quot;&gt;&lt;a href=&quot;#函数exit&quot; class=&quot;headerlink&quot; title=&quot;函数exit&quot;&gt;&lt;/a&gt;函数exit&lt;/h2&gt;&lt;p&gt;进程有5中正常终止和3中异常终止方式。&lt;strong&gt;5中正常终止方式具体如下&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="系统函数" scheme="http://www.wangxinri.cn/tags/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>解释器文件</title>
    <link href="http://www.wangxinri.cn/2018/05/14/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%87%E4%BB%B6/"/>
    <id>http://www.wangxinri.cn/2018/05/14/解释器文件/</id>
    <published>2018-05-14T14:59:00.000Z</published>
    <updated>2018-05-19T03:44:17.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>所有现今的UNIX系统都支持解释器文件（interpreter file）。这种文件是文本文件，其起始行的形式是：</p>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>! pathname[optional-argument]</div></pre></td></tr></table></figure>
<p>在感叹号和pathname之间的空格是可选的。最常见的解释器文件以下列行开始:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>! /bin/sh</div></pre></td></tr></table></figure>
<p>pathname通常是绝对路径名，对它不进行什么特殊的处理（不使用PATH进行路径搜索）。<strong>对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程实际执行的并不是该解释器文件，而是在该解释器文件第一行中pathname所指定的文件</strong>。一定要将解释器文件（文本文件，它以#!开头）和解释器（由该解释器文件第一行中的pathname指定）区分开来。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>execl执行的文件是一个解释器文件时，内核如何处理execl参数及该解释器文件第一行的可选参数。</p>
<p>execinterp.c </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;	<span class="comment">//child</span></div><div class="line">		<span class="keyword">if</span>( execl(<span class="string">"/home/vrlive/linuxProgram/apueProgram/eight/testinterp"</span>,<span class="string">"testinterp"</span>,<span class="string">"myarg1"</span>,<span class="string">"MY ARG2"</span>,(<span class="keyword">char</span>*)<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"execl error\n"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;    <span class="comment">//parent</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"waitpid error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中testinterp为解释器文件，之前运行老出错，是因为testinterp文件没有可执行权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ll | grep testinterp </div><div class="line">-rwxrwxr-x 1 vrlive vrlive   61 May 14 16:51 testinterp</div><div class="line">[vrlive@iZ23chs2r19Z eight]$ cat testinterp </div><div class="line"><span class="meta">#</span>! /home/vrlive/linuxProgram/apueProgram/eight/echoarg.o foo</div></pre></td></tr></table></figure>
<p>echoarg.o是echoarg.c的可执行文件，回显每一个命令行参数。</p>
<p>echoarg.c</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;argc;++i)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"argv[%d]: %s\n"</span>,i,argv[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./execinterp.o </div><div class="line">argv[0]: /home/vrlive/linuxProgram/apueProgram/eight/echoarg.o</div><div class="line">argv[1]: foo</div><div class="line">argv[2]: /home/vrlive/linuxProgram/apueProgram/eight/testinterp</div><div class="line">argv[3]: myarg1</div><div class="line">argv[4]: MY ARG2</div></pre></td></tr></table></figure>
<p>当内核exec解释器时（/home/vrlive/linuxProgram/apueProgram/eight/echoarg.o）时，argv[0]是该解释器的pathname，argv[1]是解释器文件中的可选参数，其余参数是pathname（excel函数pathname参数值/home/vrlive/linuxProgram/apueProgram/eight/testinterp）以及execl的第2个和第3个参数（myarg1、MY ARG2）。调用execl时的argv[1]和argv[2]已右移了两个位置。</p>
<p><strong>注意</strong>，内核取execl调用中的pathname而非第一个参数（testinterp），因为一般而言，pathname包含了比第一个参数更多的信息。</p>
<p><strong>后续待补充</strong>…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;解释器文件&quot;&gt;&lt;a href=&quot;#解释器文件&quot; class=&quot;headerlink&quot; title=&quot;解释器文件&quot;&gt;&lt;/a&gt;解释器文件&lt;/h2&gt;&lt;p&gt;所有现今的UNIX系统都支持解释器文件（interpreter file）。这种文件是文本文件，其起始行的形式是：&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>exec系列</title>
    <link href="http://www.wangxinri.cn/2018/05/14/exec%E7%B3%BB%E5%88%97/"/>
    <id>http://www.wangxinri.cn/2018/05/14/exec系列/</id>
    <published>2018-05-14T13:59:00.000Z</published>
    <updated>2018-05-19T03:13:47.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>用fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序，<strong>当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文短、数据段、堆段和栈段</strong>。</p>
<a id="more"></a>
<p>有7中不同的exec函数可供使用，它们常常被统称为exec函数，我们可以使用这7个函数中的任一个。这些exec函数使得UNIX系统进程控制原语更加完善。用fork可以创建新进程，用exec可以初始执行新的程序。exit函数和wait函数处理终止和等待终止。这些是我们需要的基本的进程控制原语。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char*)0  */</span> )</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...  <span class="comment">/* (char*)0,char *const envp[] */</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">char</span> *<span class="keyword">const</span> argv[],<span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,<span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...   <span class="comment">/* (char*)0  */</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,<span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *<span class="keyword">const</span> argv[],<span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</div><div class="line">            <span class="comment">//若出错，返回-1；若成功，不返回</span></div></pre></td></tr></table></figure>
<p>这些函数之间的<strong>第一个区别</strong>是前4个函数去路径名作为参数，后两个函数则取文件名作为参数，最后一个取文件描述符作为参数。当指定filename作为参数时：</p>
<ul>
<li>如果filename中包含/，则就将其视为路径名。</li>
<li><strong>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件</strong>。</li>
</ul>
<p>PATH变量包含了一张目录表（称为路径前缀），目录之间用冒号（:）分隔。</p>
<p><strong>查看PATH环境变量</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ env | grep PATH</div><div class="line">PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/vrlive/.local/bin:/home/vrlive/bin</div></pre></td></tr></table></figure>
<p>如果execlp或者execvp使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器长生的机器可执行文件，则就认为该文件是一个shell脚本，于是试着调用/bin/sh，并以该filename作为shell的输入。</p>
<p><strong>第二个区别</strong>与参数表的传递有关（l表示list，v表示矢量vector）。函数execl、execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数以空指针结尾（(char*)0）。对于另外4个函数（execv、execvp、execve和fexecve），则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数。</p>
<p><strong>最后一个区别</strong>与向新程序传递的环境表相关。以e结尾的3个函数（execle、execve和fexecve）可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有环境。</p>
<p>这7个exec函数的参数很难记忆。函数名中的字符串会给我们一些帮助。字母p表示该函数取filename作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，它与字母v互斥。v表示该函数取一个argv[]矢量。最后，字母e表示该函数取envp[]数组，而不使用当前环境。下图显式了这7个函数之间的区别。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/7%E4%B8%AAexec%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="image"></p>
<p>在很多UNIX实现中，这7个函数中只有execve时内核的系统调用。另外6个只是库函数，他们最终都要调用该系统调用。这7个函数之间的关系如下：</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/7%E4%B8%AAexec%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image"></p>
<p>在这种安排下，库函数execlp和execvp使用PATH环境变量，查找查找第一个包含名为filename的可执行文件的路径名前缀。fexecve库函数使用/proc把文件描述符参数转换成路径名，execve用该路径名去执行程序。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>演示execle和execlp的用法</p>
<p>exec.c</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *env_init[] = &#123;<span class="string">"USER = unknown"</span>,<span class="string">"PATH=/tmp"</span>,<span class="literal">NULL</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;     <span class="comment">//child   specify pathname,specify environment</span></div><div class="line">		<span class="keyword">if</span>(execle(<span class="string">"/home/vrlive/linuxProgram/apueProgram/eight/echoall.o"</span>,<span class="string">"echoall.o"</span>,<span class="string">"myarg1"</span>,<span class="string">"MY ARG2"</span>,(<span class="keyword">char</span>*)<span class="number">0</span>,env_init) &lt; <span class="number">0</span>) </div><div class="line">			<span class="built_in">printf</span>(<span class="string">"execle error\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"waitpid error\n"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(execlp(<span class="string">"echoall.o"</span>,<span class="string">"echoall.o"</span>,<span class="string">"only 1 arg"</span>,(<span class="keyword">char</span>*)<span class="number">0</span>) &lt; <span class="number">0</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"execlp error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"waitpid error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序要执行两次的echoall程序如下echoall.c所示。这是一个很普通的程序，它回显所有命令行参数及全部环境表。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>我们将第一个参数（新程序中的argv[0]）设置为路径名的文件名分量（”echoall.o”）。某些shell将此参数设置为完全的路径名。这只是一个惯例。我们可将argv[0]设置为任何字符串。当login命令执行shell时就是这样做的。在执行shell之前，login在argv[0]之前加一个/作为前缀，这向shell指明它是作为登录shell被调用的。登录shell将执行启动配置文件（start-up profile）命令，而非登录shell则不会执行这些命令。</li>
<li>execle要求路径名和一个特定的环境。而execlp，它用一个文件名，所以其PATH环境变量所指向的各目录中搜寻可执行文件，我们的echoall.o在/home/vrlive/bin也有一份。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ env | grep PATH</div><div class="line">PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/vrlive/.local/bin:/home/vrlive/bin</div></pre></td></tr></table></figure>
<p>echoall.c</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">char</span> **ptr;</div><div class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> **environ;    <span class="comment">//extern the environ</span></div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;argc;++i)&#123;    <span class="comment">//echo all command-line args</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"argv[%d]: %s\n"</span>,i,argv[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(ptr = environ;*ptr!=<span class="number">0</span>;++ptr)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,*ptr);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./exec.o </div><div class="line">argv[0]: echoall.o</div><div class="line">argv[1]: myarg1</div><div class="line">argv[2]: MY ARG2</div><div class="line">USER = unknown</div><div class="line">PATH=/tmp                          //first child  end</div><div class="line">argv[0]: echoall.o              </div><div class="line">argv[1]: only 1 arg</div><div class="line">XDG_SESSION_ID=25503</div><div class="line">HOSTNAME=iZ23chs2r19Z</div><div class="line">TERM=xterm</div><div class="line">SHELL=/bin/bash</div><div class="line">HISTSIZE=1000</div><div class="line">SSH_CLIENT=14.108.30.83 34140 22</div><div class="line">SSH_TTY=/dev/pts/2</div><div class="line">USER=vrlive</div><div class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:</div><div class="line">MAIL=/var/spool/mail/vrlive</div><div class="line">PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/vrlive/.local/bin:/home/vrlive/bin</div><div class="line">PWD=/home/vrlive/linuxProgram/apueProgram/eight</div><div class="line">LANG=en_US.UTF-8</div><div class="line">HISTCONTROL=ignoredups</div><div class="line">SHLVL=1</div><div class="line">HOME=/home/vrlive</div><div class="line">LOGNAME=vrlive</div><div class="line">SSH_CONNECTION=14.108.30.83 34140 172.16.0.1 22</div><div class="line">LESSOPEN=||/usr/bin/lesspipe.sh %s</div><div class="line">XDG_RUNTIME_DIR=/run/user/1000</div><div class="line">_=./exec.o</div><div class="line">OLDPWD=/home/vrlive/linuxProgram/apueProgram</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;exec&quot;&gt;&lt;a href=&quot;#exec&quot; class=&quot;headerlink&quot; title=&quot;exec&quot;&gt;&lt;/a&gt;exec&lt;/h2&gt;&lt;p&gt;用fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序，&lt;strong&gt;当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文短、数据段、堆段和栈段&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>竞争条件</title>
    <link href="http://www.wangxinri.cn/2018/05/14/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
    <id>http://www.wangxinri.cn/2018/05/14/竞争条件/</id>
    <published>2018-05-14T13:59:00.000Z</published>
    <updated>2018-05-19T03:44:44.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件（race condition）。</p>
<a id="more"></a>
<p>如果再fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行，那么fork函数就会是竞争条件活跃的滋生地。通常，我们不能预料哪一个进程先运行。即使我们知道哪一个进程先运行，在该进程开始运行后所发生的事情也依赖于系统负载以及内核的调度算法。</p>
<p>如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个（子进程终止前，父进程被阻塞了）。如果一个进程要等待其父进程终止，则可使用下列形式的循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)&#123;</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种形式的循环称为轮询（polling），它的问题是浪费了CPU时间，因为调用者每隔一秒都被唤醒，然后进行条件测试。</p>
<p><strong>为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收方法，在UNIX中可以使用信号机制，各种形式的进程间通信（IPC）也可使用</strong>。</p>
<p><strong>示例</strong>：程序输出两个字符串：一个由子进程输出，另一个由父进程输出。因为输出依赖于内核使这两个进程的运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞争条件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">if</span>((pid = fork()) &lt;<span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;   <span class="comment">//child</span></div><div class="line">		charatatime(<span class="string">"output for child\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;    <span class="comment">//parent</span></div><div class="line">		charatatime(<span class="string">"output for parent\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</div><div class="line">	<span class="keyword">char</span> *ptr;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line">	setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);     <span class="comment">//set unbuffered</span></div><div class="line">	<span class="keyword">for</span>(ptr = str; (c=*str++) != <span class="string">'\0'</span>;)&#123;</div><div class="line">		putc(c,<span class="built_in">stdout</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序中将标准输出设置为不带缓冲的，于是每个字符输出都需调用一次write（内核系统调用）。本例的目的是使内核能尽可能多次地在两个进程之间进行切换，以便演示竞争条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./race.o </div><div class="line">ouotputpuut for child</div><div class="line">t for parent</div><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./race.o </div><div class="line">output for parent</div><div class="line">output for[vrlive@iZ23chs2r19Z eight]$  child</div><div class="line">./race.o </div><div class="line">ououtputtput for child</div><div class="line"> for parent</div><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./race.o </div><div class="line">output for parent</div><div class="line">output for child</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;竞争条件&quot;&gt;&lt;a href=&quot;#竞争条件&quot; class=&quot;headerlink&quot; title=&quot;竞争条件&quot;&gt;&lt;/a&gt;竞争条件&lt;/h2&gt;&lt;p&gt;当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件（race condition）。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>system函数</title>
    <link href="http://www.wangxinri.cn/2018/05/14/%E5%87%BD%E6%95%B0system/"/>
    <id>http://www.wangxinri.cn/2018/05/14/函数system/</id>
    <published>2018-05-14T12:59:00.000Z</published>
    <updated>2018-05-19T03:16:41.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>在程序中执行一个命令字符串很方便，例如，假定要将时间和日期放在某个文件中：通过调用time得到当前日历时间，接着调用localtime将日历时间变换为年、月、日、时、分、秒的分解形式，然后调用strftime对上面的结果进行格式化处理，最后将结果写入到文件中。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">time_t</span> t;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></div><div class="line">	<span class="keyword">char</span> buf1[<span class="number">16</span>];</div><div class="line">	<span class="keyword">char</span> buf2[<span class="number">64</span>];</div><div class="line">	time(&amp;t);</div><div class="line">	tmp = localtime(&amp;t);</div><div class="line">	<span class="keyword">if</span>(strftime(buf1,<span class="number">16</span>,<span class="string">"time and date:%r,%a %b %d,%Y"</span>,tmp) == <span class="number">0</span>)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"buffer length 16 is too small\n"</span>);</div><div class="line">	<span class="keyword">else</span> </div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf1);</div><div class="line">	<span class="keyword">if</span>(strftime(buf2,<span class="number">64</span>,<span class="string">"time and date:%r,%a %b %d,%Y"</span>,tmp) == <span class="number">0</span>)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"buffer length 64 is too small\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf2);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z six]$ ./strftime.o </div><div class="line">buffer length 16 is too small</div><div class="line">time and date:07:31:31 PM,Mon May 14,2018</div></pre></td></tr></table></figure>
<p>但是用下面的system函数则更容易做到这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//system("date&gt;file");</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	system(<span class="string">"date&gt;file"</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</div></pre></td></tr></table></figure>
<p>如果cmdstring是一个空指针，则仅当命令处理程序可用时，system返回非0值，这一特征可以确定在一个给定的操作系统上是否支持system函数。在UNIX中，system总是可用的。</p>
<p><strong>因为system在其实现中调用了fork、exec和waitpid，因此有3种返回值</strong>。</p>
<ol>
<li>fork失败或者waitpid返回除EINTR之外的出错，则system返回-1，并且设置errno以指示错误类型。</li>
<li>如果exec失败（表示不能执行shell），则其返回值如果shell执行了exit(127)一样。</li>
<li>否则所有3个函数（fork、exec和waitpid）都成功，那么system的返回值是shell的终止状态，其格式已在waitpid中说明。</li>
</ol>
<p>如下给出了system函数的一种实现。它对信号没有进行处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ cat head.h </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAGS O_RDWR | O_CREAT</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE S_IRUSR | S_IWUSR | S_IXUSR</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(WIFEXITED(status))&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"normal termination,exit status = %d\n"</span>,WEXITSTATUS(status));</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"abnormal termination,signal number = %d %s\n"</span>,WTERMSIG(status),</div><div class="line">	#ifdef WCOREDUMP</div><div class="line">		WCOREDUMP(status) ? <span class="string">" (core file generated)"</span> : <span class="string">" "</span>);</div><div class="line">	<span class="meta">#<span class="meta-keyword">else</span>  </span></div><div class="line">		<span class="string">" "</span>);</div><div class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"child stopped,signal number = %d\n"</span>,WSTOPSIG(status));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>&#123;    <span class="comment">//version without signal handling</span></div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">int</span> status;</div><div class="line">	<span class="keyword">if</span>(cmdstring == <span class="literal">NULL</span>)&#123;</div><div class="line">		<span class="keyword">return</span>(<span class="number">1</span>);   <span class="comment">//always a command processor with UNIX</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>( (pid=fork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		status = <span class="number">-1</span>;     <span class="comment">//probably out of processes</span></div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</div><div class="line">		execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="string">"-c"</span>,cmdstring,(<span class="keyword">char</span>*)<span class="number">0</span>);</div><div class="line">		_exit(<span class="number">127</span>);    <span class="comment">//execl error</span></div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">while</span>(waitpid(pid,&amp;status,<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">if</span>(errno != EINTR)&#123;</div><div class="line">				status = <span class="number">-1</span>;    <span class="comment">//error other than EINTR form waitpid()</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span>(status);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>shell的-c选项告诉shell程序取下一个命令行参数（在这里是cmdstring）作为命令输入（而不是从标准输入或从一个给定的文件中读命令）。shell对以null字节终止的字符串进行语法分析，将它们分成命令行参数。传递给shell的命令字符串可以包含任一有效的shell命令。例如，可以用&lt;和&gt;对输入和输出重定向。</p>
<p>注意，我们调用_exit而不是exit。这是为了防止任一标准I/O缓冲（这些缓冲会在fork中由父进程复制到子进程）在子进程中被冲洗。</p>
<p>以下代码对system函数进行测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> status;</div><div class="line">	<span class="keyword">if</span>((status = system(<span class="string">"date"</span>)) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"system() error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	pr_exit(status);</div><div class="line">	<span class="keyword">if</span>((status = system(<span class="string">"nosuchcommand"</span>)) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"system() error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	pr_exit(status);</div><div class="line">	<span class="keyword">if</span>((status = system(<span class="string">"who; exit 44"</span>)) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"system() error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	pr_exit(status);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./runsystem.o </div><div class="line">Mon May 14 21:00:03 CST 2018</div><div class="line">normal termination,exit status = 0     //date</div><div class="line">sh: nosuchcommand: command not found</div><div class="line">normal termination,exit status = 127     //nosuchcommand</div><div class="line">vrlive   pts/0        2018-05-14 19:23 (14.108.28.90)</div><div class="line">vrlive   pts/1        2018-05-14 19:23 (14.108.28.90)</div><div class="line">vrlive   pts/2        2018-05-14 19:23 (14.108.28.90)</div><div class="line">vrlive   pts/3        2018-05-14 20:32 (119.86.103.135)</div><div class="line">vrlive   pts/4        2018-05-14 20:40 (119.86.103.135)</div><div class="line">normal termination,exit status = 44     //exit 44</div></pre></td></tr></table></figure>
<p><strong>使用system而不是直接使用fork和exec的优点是：system进行了所需要的各种出错处理以及各种信号处理</strong>。</p>
<p>下面这一块不太懂，以后再看看：</p>
<p>注：如果一个进程正以特殊的权限（设置用户ID或设置组ID）运行，它又想生成另一个进程执行另一个程序，则它应当直接使用fork和exec，而且在fork之后、exec之前要更改会普通权限，<strong>设置用户ID或者设置组ID程序绝不应调用system函数</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数system&quot;&gt;&lt;a href=&quot;#函数system&quot; class=&quot;headerlink&quot; title=&quot;函数system&quot;&gt;&lt;/a&gt;函数system&lt;/h2&gt;&lt;p&gt;在程序中执行一个命令字符串很方便，例如，假定要将时间和日期放在某个文件中：通过调用time得到当前日历时间，接着调用localtime将日历时间变换为年、月、日、时、分、秒的分解形式，然后调用strftime对上面的结果进行格式化处理，最后将结果写入到文件中。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="系统函数" scheme="http://www.wangxinri.cn/tags/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>进程与fork</title>
    <link href="http://www.wangxinri.cn/2018/05/10/%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E5%92%8Cfork/"/>
    <id>http://www.wangxinri.cn/2018/05/10/进程标识和fork/</id>
    <published>2018-05-10T13:59:00.000Z</published>
    <updated>2018-05-19T03:07:43.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>介绍UNIX系统的进程控制，包括创建新进程、执行程序和进程终止。还将说明进程属性的各种ID—实际、有效和保存的用户ID和组ID，以及它们如何受到进程控制原语的影响。</p>
<a id="more"></a>
<h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><p>每个进程都有一个非负整形表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。例如，应用程序有时就把进程ID作为名字的一部分来创建一个唯一的文件名。</p>
<p>虽然是唯一的，但是进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<ul>
<li>ID为0的进程通常是调度进程，常常被称为交换进程，也被成为系统进程。</li>
<li>ID为1的进程通常是init进程。init进程绝不会终止，他是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。</li>
<li>ID为2的进程是页守护进程，此进程负责支持虚拟存储器系统的分页操作。</li>
</ul>
<h4 id="进程标志函数"><a href="#进程标志函数" class="headerlink" title="进程标志函数"></a>进程标志函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">pid_t</span> pid = getpid();   <span class="comment">//获取进程id    </span></div><div class="line">	<span class="keyword">pid_t</span> ppid = getppid();   <span class="comment">//获取进程的父id  </span></div><div class="line">	<span class="keyword">uid_t</span> uid = getuid();     <span class="comment">//获取进程的实际用户id</span></div><div class="line">	<span class="keyword">uid_t</span> euid = geteuid();   <span class="comment">//获取进程的有效用户id</span></div><div class="line">	<span class="keyword">gid_t</span> gid = getgid();     <span class="comment">//获取进程的实际组id</span></div><div class="line">	<span class="keyword">gid_t</span> egid = getegid();     <span class="comment">//获取进程的有效组id</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pid=%d,ppid=%d,uid=%d,euid=%d,gid=%d,egid=%d\n"</span>,pid,ppid,uid,euid,gid,egid);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际用户Id 和实际组id 是 用户的性质。他是当前登录用户的信息。 </p>
<p>有效用户id 和 有效组 id是进程拥有的性质。放该进程访问一些资源时，他们是内核用来测试该进程是否具有权限的依据。通常情况下他们和用户实际id 和实际组id 一样。</p>
<h3 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h3><p>一个现有的进程可以调用fork函数创建一个新进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);   <span class="comment">//返回值：子进程返回0，父进程返回子进程ID,若出错，返回-1</span></div></pre></td></tr></table></figure>
<p>由fork创建的新进程被称为子进程。fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID，将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数可以获得其所有子进程的进程ID。fork使子进程得到返回值0的理由是：一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID（进程ID 0总是由内核交换进程使用，<strong>所以一个子进程的进程ID不可能为0</strong>，这样就可以区别哪个是父进程哪个是子进程了）。</p>
<p>当创建了子进程后，子进程和父进程继续执行fork调用之后的命令，包括都执行fork()调用后的返回值。</p>
<p><strong>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。</strong> </p>
<p>如下演示了fork函数，从中可以看到子进程对变量所做的改变并不影响父进程中该变量的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="keyword">int</span> globvar = <span class="number">6</span>;</div><div class="line"><span class="keyword">char</span> buf[] = <span class="string">"a write to stdout\n"</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> var = <span class="number">88</span>;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	<span class="keyword">if</span>(write(STDOUT_FILENO,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>) != <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"write error\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</div><div class="line">	<span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid ==<span class="number">0</span>)&#123;   <span class="comment">//child</span></div><div class="line">		++globvar;</div><div class="line">		++var;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;     <span class="comment">//parent</span></div><div class="line">		sleep(<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %d,glob = %d,var= %d\n"</span>,getpid(),globvar,var);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./fork.o </div><div class="line">a write to stdout</div><div class="line">before fork</div><div class="line">pid = 29103,glob = 7,var= 89</div><div class="line">pid = 29102,glob = 6,var= 88</div><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./fork.o &gt; temp.out</div><div class="line">[vrlive@iZ23chs2r19Z eight]$ cat temp.out </div><div class="line">a write to stdout</div><div class="line">before fork</div><div class="line">pid = 29105,glob = 7,var= 89</div><div class="line">before fork</div><div class="line">pid = 29104,glob = 6,var= 88</div></pre></td></tr></table></figure>
<p>fork之后，父进程先执行还是子进程先执行是不确定的，则取决于内核所用的调度算法，该程序中，父进程使自己休眠2s，以此使子进程先执行。但不保证2s已经足够。</p>
<p>当写标准输出时，我们将buf长度减去1作为输出字节数，这是为了避免将终止null字节输出。</p>
<p>标准I/O库是带缓冲的，如果标准输出（printf）连到终端设备，则它是行缓冲的；否则它是全缓冲的，当以交互方式运行该程序时，只得到该printf输出的行一次，其原因是标准输出缓冲区由换行符冲洗。但是当将标准输出重定向到一个文件时，却得到printf输出行两次。其原因是，在fork之前调用了printf一次，但当调用fork时，该行数据仍在缓冲区中，然后在将父进程数据空间赋值到子进程中时，该缓冲区数据也被复制到子进程中，此时父进程和子进程各自有了带该行内容的缓冲区。在exit之前的第二个printf将其数据追加到已有的缓冲区中。当每个进程终止时，其缓冲区中的内容都被写到相应文件中。</p>
<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p><strong>fork的一个特性时父进程的所有打开文件描述符都被复制到子进程中</strong>。我们说“复制”是因为对每个文件描述符来说，就好像执行了dup函数。父进程和子进程每个相同的打开描述符共享一个文件表项（文件表项含有文件的偏移量），也就是说，<strong>父进程和子进程共享同一个文件偏移量</strong>。</p>
<p>假设父子进程都向标准输出进行写操作。如果父进程的标准输出已重定向，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。当父进程等待子进程时，子进程写到标准输出；而在子进程终止时，父进程也写到标准输出上，并且知道其输出会追加到子进程所写数据之后。如果父进程和子进程不共享同一文件偏移量，要实现这种形式的交互就要困难得多，可能需要父进程显式地动作。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/fork%E4%B9%8B%E5%90%8E%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%AF%B9%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B1%E4%BA%AB.png" alt="image"></p>
<p>如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步（如使父进程等待子进程），那么它们的输出就会相互混合（假定所用的描述符是在fork之前打开的）。</p>
<p>在fork之后处理文件描述符有以下两种常见情况。</p>
<ol>
<li><strong>父进程等待子进程完成</strong>。在这种情况下，父进程无须对其描述符做任何处理。当子进程终止后，它曾进行过读写操作的任一共享描述符的文件偏移量已做了相应更新。</li>
<li><strong>父进程和子进程各自执行不同的程序段</strong>。在这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件描述符，这样就不会干扰到对方使用的文件描述符。这种方法是网络服务进程经常使用的。</li>
</ol>
<p>除了打开文件之外，<strong>父进程的很多其他属性也由子进程继承</strong>，包括：</p>
<ul>
<li>实际用户id、实际组id、有效用户id、有效组id</li>
<li>附属组id</li>
<li>进程组id</li>
<li>会话id</li>
<li>控制终端</li>
<li>设置用户id标志和设置组id标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭（close-on-exec）标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<p><strong>父进程和子进程之间的区别具体</strong>如下</p>
<ul>
<li>fork的返回值不同。</li>
<li>进程ID不同。</li>
<li>这两个进程的父进程ID不同。</li>
<li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0。</li>
<li>子进程不继承父进程设置的文件锁。</li>
<li>子进程的未处理闹钟被清除。</li>
<li>子进程的未处理信号集设置为空集。</li>
</ul>
<p><strong>fork失败的两个主要原因</strong></p>
<ul>
<li>系统中已经有太多的进程。</li>
<li>该实际用户ID的进程总数超过了系统限制。</li>
</ul>
<p><strong>fork有以下两种用法</strong></p>
<ul>
<li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是最常见的—父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。</li>
<li>一个进程要执行一个不同的程序。这对shell是常见的情况，在这种情况下，子进程从fork返回后立即调用exec。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;介绍UNIX系统的进程控制，包括创建新进程、执行程序和进程终止。还将说明进程属性的各种ID—实际、有效和保存的用户ID和组ID，以及它们如何受到进程控制原语的影响。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="fork" scheme="http://www.wangxinri.cn/tags/fork/"/>
    
  </entry>
  
  <entry>
    <title>vfork</title>
    <link href="http://www.wangxinri.cn/2018/04/20/vfork/"/>
    <id>http://www.wangxinri.cn/2018/04/20/vfork/</id>
    <published>2018-04-20T14:59:00.000Z</published>
    <updated>2018-05-19T03:44:56.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h2><p>vfork函数的调用序列和返回值与fork相同，但两者的语义不同。</p>
<a id="more"></a>
<p>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都会创建一个子进程，<strong>但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec(或exit)，于是它并不会引用该地址空间</strong>。不过在子进程调用exec或exit之前，它在父进程的空间中运行。这种优化工作方式在某些UNIX系统的实现中提高了效率，但如果子进程修改了数据（除了用于存放vfork返回值的变量）、进行函数调用、或者没有调用exec或exit就返回都可能带来未知的结果（就像上一节fork中提及的，实现采用写时复制技术以提高fork之后跟随exec操作的效率，但是不复制比部分赋值还是更快一些）。</p>
<p>vfork和fork之间的另一个区别是：<strong>vfork保证子进程先运行，再它调用exec或者exit之后父进程才可能被调度运行（子进程调用exec或exit之前，内核会使父进程处于休眠状态），当子进程调用这两个函数中的任意一个时，父进程会恢复运行。（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁）</strong>。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></div><div class="line"><span class="keyword">int</span> globvar = <span class="number">6</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> var;</div><div class="line">	<span class="keyword">pid_t</span> pid;</div><div class="line">	var = <span class="number">88</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"before vfork\n"</span>);</div><div class="line">	<span class="keyword">if</span>( (pid=vfork()) &lt; <span class="number">0</span>)&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"vfork error\n"</span>);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  </div><div class="line">		++globvar;     <span class="comment">//child;</span></div><div class="line">		++var;</div><div class="line">		_exit(<span class="number">0</span>);    <span class="comment">//child terminates</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//parent continues here</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %d,glob = %d,var = %d\n"</span>,getpid(),globvar,var);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[vrlive@iZ23chs2r19Z eight]$ ./vfork.o </div><div class="line">before vfork</div><div class="line">pid = 29440,glob = 7,var = 89</div></pre></td></tr></table></figure>
<p>子进程对变量做增1的操作，结果改变了父进程中的变量值。因为子进程子进程在父进程的地址空间中运行，所以这并不令人惊讶。但是其作用的确与fork不同。</p>
<h3 id="fork与vfork的区别："><a href="#fork与vfork的区别：" class="headerlink" title="fork与vfork的区别："></a>fork与vfork的区别：</h3><p>1）fork()： 父子进程的执行次序不确定。</p>
<p>vfork()：保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。</p>
<p>2）fork()： 子进程拷贝父进程的地址空间，子进程是父进程的一个复制品。</p>
<p>vfork()：子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的）</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/vfork.png" alt="image"></p>
<p><strong>用 vfork() 创建进程，子进程里一定要调用 exec（进程替换） 或 exit（退出进程 _exit(0) ），否则，程序会出问题，没有意义。</strong></p>
<p><a href="https://blog.csdn.net/tennysonsky/article/details/45847107" target="_blank" rel="external">参考：vfork() 函数详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vfork&quot;&gt;&lt;a href=&quot;#vfork&quot; class=&quot;headerlink&quot; title=&quot;vfork&quot;&gt;&lt;/a&gt;vfork&lt;/h2&gt;&lt;p&gt;vfork函数的调用序列和返回值与fork相同，但两者的语义不同。&lt;/p&gt;
    
    </summary>
    
      <category term="UNIX环境高级编程" scheme="http://www.wangxinri.cn/categories/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>8皇后问题</title>
    <link href="http://www.wangxinri.cn/2018/04/20/8queen/"/>
    <id>http://www.wangxinri.cn/2018/04/20/8queen/</id>
    <published>2018-04-20T13:59:00.000Z</published>
    <updated>2018-04-20T03:02:49.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><p>在8*8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一条对角线上。请问总共有多少种符合条件的摆法？ </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>剑指offer上的方法，通过排列组合求出所有不在同一行、同一列的组合，然后剔除在同一对角线的组合，即为最终结果</p>
<p>定义一个数组ivec[8]，数组中第i个数字表示位于第i行的皇后的列号，先把数组ivec中的8个数字分别用0-7初始化，然后对数组ivec进行全排列，因为我们用不同的数字初始化数组，所以任意两个皇后肯定不同列。接下来只需要判断每一个排列对应的8个皇后是不是在同一条对角线上，也就是对于数组的两个下标i,j，如果存在 (abs(i-j)) == (abs(ivec[i]-ivec[j]))，则剔除。否则为其中一种摆法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">/*问题描述:在8*8的国际象棋上排放8个皇后，使其不能相互攻击，</span></div><div class="line"><span class="comment">即任意两个皇后不得处在同一行、同一列或者同一条对角线上。*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec,<span class="keyword">int</span> start,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;allVec)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == (ivec.size()<span class="number">-1</span>)) allVec.push_back(ivec);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;ivec.size();++i)&#123;</div><div class="line">        swap(ivec[i],ivec[start]);</div><div class="line">        helper(ivec,start+<span class="number">1</span>,allVec);</div><div class="line">        swap(ivec[i],ivec[start]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;allVec)</span></span>&#123;</div><div class="line">    helper(ivec,<span class="number">0</span>,allVec);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</div><div class="line">    <span class="comment">//先求所有皇后可能出现的列的组合，排列组合问题</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allVec;</div><div class="line">    Permutation(ivec,allVec);</div><div class="line">    <span class="comment">//此时保证皇后都是不同行，不同列的情况，接着剔除同一对角线的</span></div><div class="line">    <span class="comment">// abs(i-j) == abs(vec[i]-vec[j])，处于同一对角线，删除</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; resVec;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter=allVec.begin();iter!=allVec.end();++iter)&#123;</div><div class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</div><div class="line">            <span class="keyword">bool</span> flag2 = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(i!=j)&#123;</div><div class="line">                    <span class="keyword">if</span>( (<span class="built_in">abs</span>(i-j)) == ( <span class="built_in">abs</span>((*iter)[i]-(*iter)[j]) ) )&#123;  <span class="comment">//剔除</span></div><div class="line">                        flag = <span class="literal">false</span>;</div><div class="line">                        flag2 = <span class="literal">false</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!flag2) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(flag) resVec.push_back(*iter);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"解法共有："</span>&lt;&lt;resVec.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> vec : resVec)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"解法"</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : vec) <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        ++i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>解法共有92种，时间复杂度为 8！<em>  ((8 </em> 7)/2)。8！为排列组合需要的时间复杂度，(8 * 7)/2 为剔除每一个排列组合需要的时间复杂度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;八皇后问题&quot;&gt;&lt;a href=&quot;#八皇后问题&quot; class=&quot;headerlink&quot; title=&quot;八皇后问题&quot;&gt;&lt;/a&gt;八皇后问题&lt;/h1&gt;&lt;p&gt;在8*8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一条对角线上。请问总共有多少种符合条件的摆法？ &lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wangxinri.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>笔试编程题0414</title>
    <link href="http://www.wangxinri.cn/2018/04/14/2019%E6%90%9C%E7%8B%90%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/04/14/2019搜狐春招笔试题/</id>
    <published>2018-04-14T13:59:00.000Z</published>
    <updated>2018-04-14T13:39:31.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019搜狐春招笔试题，两道都ac了，还是挺开心的。</p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>会员成长值 = 每天成长值 + 任务成长值。</p>
<p>大体意思是：给定多行，每行第一个值为1给出了某个时间范围每天的成长值，每行第一个值为2给出了某天做任务的任务值。每行中每天的成长值的时间范围可能有重复的，选择成长值最大的来作为当天最大成长值。求出总的会员成长值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">3 </div><div class="line">1 1 5 10</div><div class="line">2 3 4</div><div class="line">1 4 6 -5</div><div class="line">输出49</div></pre></td></tr></table></figure>
<p>思路：遍历找出每天成长值的时间范围，然后依次比较每天的成长值，得到最大的成长值作为当天的成长值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> N;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;N;</div><div class="line">    <span class="keyword">int</span> len = N;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; growVec;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tastVec;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">while</span>(len--)&#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;num;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;   <span class="comment">//成长</span></div><div class="line">            <span class="keyword">int</span> tem;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</div><div class="line">                <span class="built_in">cin</span>&gt;&gt;tem;</div><div class="line">                ivec.push_back(tem);</div><div class="line">            &#125;</div><div class="line">            growVec.push_back(ivec);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//任务</span></div><div class="line">            <span class="keyword">int</span> tem;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</div><div class="line">                <span class="built_in">cin</span>&gt;&gt;tem;</div><div class="line">                ivec.push_back(tem);</div><div class="line">            &#125;</div><div class="line">            tastVec.push_back(ivec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    for(auto ivec : growVec)&#123;</span></div><div class="line"><span class="comment">        for(auto ele : ivec) cout&lt;&lt;ele&lt;&lt;" ";</span></div><div class="line"><span class="comment">        cout&lt;&lt;endl;</span></div><div class="line"><span class="comment">    &#125;</span></div><div class="line"><span class="comment">    for(auto ivec : tastVec)&#123;</span></div><div class="line"><span class="comment">        for(auto ele : ivec) cout&lt;&lt;ele&lt;&lt;" ";</span></div><div class="line"><span class="comment">        cout&lt;&lt;endl;</span></div><div class="line"><span class="comment">    &#125;</span></div><div class="line"><span class="comment">    cout&lt;&lt;"-------------------"&lt;&lt;endl;</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">int</span> mintime = <span class="number">1000000</span>;</div><div class="line">    <span class="keyword">int</span> maxtime = <span class="number">-1000000</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = growVec.begin();iter!=growVec.end();++iter)&#123;</div><div class="line">        <span class="keyword">if</span>((*iter)[<span class="number">0</span>] &lt; mintime) mintime = (*iter)[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span>((*iter)[<span class="number">1</span>] &gt; maxtime) maxtime = (*iter)[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//cout&lt;&lt;mintime&lt;&lt;" "&lt;&lt;maxtime&lt;&lt;endl;   //时间范围</span></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mintime;i&lt;=maxtime;++i)&#123;</div><div class="line">        <span class="keyword">int</span> MaxValue = <span class="number">-1000000</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = growVec.begin();iter!=growVec.end();++iter)&#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;=(*iter)[<span class="number">0</span>]&amp;&amp;i&lt;=(*iter)[<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">if</span>(MaxValue&lt;(*iter)[<span class="number">2</span>]) MaxValue = (*iter)[<span class="number">2</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//cout&lt;&lt;MaxValue&lt;&lt;endl;</span></div><div class="line">        res += MaxValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//cout&lt;&lt;"here"&lt;&lt;endl;</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = tastVec.begin();iter!=tastVec.end();++iter)&#123;</div><div class="line">        res += (*iter)[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h3><p>找出某个序列中第K小的数。</p>
<p>思路：维护一个K大的大根堆，堆顶元素是最大的值，遍历数组序列，如果存在比堆顶元素小的数，将堆顶元素删除，将新值添加进堆。</p>
<p>注：<strong>默认所有make_heap操作都是大根堆，也就是所有的第三个参数时less(),如果需要生成小根堆，操作也是一样的，第三个参数全为greater()</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetSmallKNum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">    <span class="keyword">if</span>(k&gt;input.size() || k&lt;<span class="number">1</span>) <span class="keyword">return</span> ivec;</div><div class="line">    <span class="keyword">auto</span> iter = input.begin();  <span class="comment">//从第一个元素开始遍历</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</div><div class="line">        ivec.push_back(*iter);</div><div class="line">        ++iter;</div><div class="line">    &#125;</div><div class="line">    make_heap(ivec.begin(),ivec.end());</div><div class="line">    <span class="keyword">auto</span> end = input.end();</div><div class="line">    <span class="keyword">for</span>(;iter!=end;++iter)&#123;</div><div class="line">        <span class="keyword">if</span>(*iter&lt;ivec[<span class="number">0</span>])&#123;  <span class="comment">//小于最大值</span></div><div class="line">            pop_heap(ivec.begin(),ivec.end());  <span class="comment">//删除堆顶元素</span></div><div class="line">            ivec.pop_back();</div><div class="line">            ivec.push_back(*iter);</div><div class="line">            push_heap(ivec.begin(),ivec.end());  <span class="comment">//插入新的元素</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//对大根堆进行排序</span></div><div class="line">    sort_heap(ivec.begin(),ivec.end());</div><div class="line">    <span class="keyword">return</span> ivec;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len,k;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;len&gt;&gt;k;</div><div class="line">    <span class="keyword">int</span> size = len;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">while</span>(len--)&#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;num;</div><div class="line">        input.push_back(num);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = GetSmallKNum(input,k);</div><div class="line">    <span class="keyword">int</span> length = res.size();</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;++i) <span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="string">","</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019搜狐春招笔试题，两道都ac了，还是挺开心的。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap简单实现</title>
    <link href="http://www.wangxinri.cn/2018/04/08/Bitmap/"/>
    <id>http://www.wangxinri.cn/2018/04/08/Bitmap/</id>
    <published>2018-04-08T13:59:00.000Z</published>
    <updated>2018-04-10T09:41:42.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BitMap算法"><a href="#BitMap算法" class="headerlink" title="BitMap算法"></a>BitMap算法</h1><p>Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<a id="more"></a>
<p>我们知道，一般可以直接操控的最小的单位是字节，比如在C/C++中，定义一个类型char，对它进行各种操作。然后很多时候，面对一个很大数据量，且我们仅仅希望知道某个数是否存在，我们不妨可以（<strong>有时候是必须</strong>）使用Bitmap算法来完成相关操作。比如腾讯的下面这道题：</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在40亿个没有排序的无符号整数中，我们如何快速判断某个无符号整数是否在这40亿个数中？</p>
<p>40亿，这是一个很大的数字，就是海量数据的处理，所以我们必须要考虑到内存的问题。我们知道一个无符号整数的大小为4个字节，那么40亿个需要占多少的内存？4<em>40亿是多大量级？咋一看有点难算，不过我们可以估算一下。<br>1KB=1024B<br>1MB=1024KB<br>1GB=1024MB<br>我们近似估计一下，1GB≈1000 </em> 1000 <em> 1000B= 1 000 000 000B = 10亿B，因此40亿</em>4B / 10亿B = 16G。就是说需要占据大概16GB的内存，这显然对于一般的电脑是不行的。</p>
<p>如果我们可以使用位图来存，一整型占4字节32比特位，因此如果用一个bit来存的话，在上面的例子中仅仅需要16G/32=0.5G大概就是500MB的内存。</p>
<p>题目要求我们快速判断，最快的算法当然是O（1）的操作，我们可以开一个无符号整型最大值的空间（保证这42亿个数都在这个范围内），每个数映射一个bit位，如果存在就将该bit位置1，不然就置0。因此想要查找某个数只需要开他映射的那个比特位是0还是1就可以了。</p>
<p>比如我们想要在这些数中查找一个33。</p>
<p>首先我们要开辟一块size_t（无符号整型）的空间，我们不妨使用整形数组arr来存。 其中每个元素都是size_t占4个字节32位.</p>
<p>刚开始每个空格全是0，这时候我们存一个33，arr[0]对应着0-31的比特位，arr[1]对应着32-63的比特位，因此33就在arr[1]第二个比特位。。。我们只需要将这个比特位置1就好了，到时候查找也是这个位是否为1。</p>
<p>bitmap表为：</p>
<p>arr[0] ——&gt; 0 - 31</p>
<p>arr[1] ——&gt; 32 - 63</p>
<p>arr[2] ——&gt; 64 - 95</p>
<p>arr[3] ——&gt; 96 - 127</p>
<p>结论：<strong>对于任意一个数x，x / 32对应着它在vector的第几个位置，x % 32对应它的比特位。</strong></p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;   <span class="comment">//数组容量为100</span></div><div class="line"><span class="keyword">int</span> arr[N] = &#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;   <span class="comment">//设置num所在位标志为1</span></div><div class="line">    <span class="keyword">int</span> index = num/<span class="number">32</span>;  <span class="comment">//所在数组的对应下标</span></div><div class="line">    <span class="keyword">int</span> pos = num%<span class="number">32</span>;    <span class="comment">//对应下标具体的位置</span></div><div class="line">    arr[index] |= (<span class="number">1</span>&lt;&lt;pos);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasExisted</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//checknum是否存在</span></div><div class="line">    <span class="keyword">int</span> index = num/<span class="number">32</span>;</div><div class="line">    <span class="keyword">int</span> pos = num%<span class="number">32</span>;</div><div class="line">    <span class="keyword">if</span>((arr[index]&amp;(<span class="number">1</span>&lt;&lt;pos))!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    setNumber(<span class="number">10</span>);</div><div class="line">    setNumber(<span class="number">50</span>);</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">10</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"10 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">20</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"20 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"20 is not existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">50</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"50 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BitMap算法&quot;&gt;&lt;a href=&quot;#BitMap算法&quot; class=&quot;headerlink&quot; title=&quot;BitMap算法&quot;&gt;&lt;/a&gt;BitMap算法&lt;/h1&gt;&lt;p&gt;Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wangxinri.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://www.wangxinri.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>笔试编程题0403</title>
    <link href="http://www.wangxinri.cn/2018/04/03/2019%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/04/03/2019去哪儿网春招笔试编程题/</id>
    <published>2018-04-03T13:59:00.000Z</published>
    <updated>2018-04-14T13:39:13.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019去哪儿网春招笔试编程题，去哪儿网的春招笔试编程题还是挺难的，再做一遍，总结总结。</p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="找最短的转换序列"><a href="#找最短的转换序列" class="headerlink" title="找最短的转换序列"></a>找最短的转换序列</h2><p>题目记不太清，大致是给一个初始单词和一个最终单词，同时给定一个单词列表，初始单词每次可以更改一个字母，找出最短的序列使得初始单词经过若干步转化为最终单词，并且转换的单词必须出现在单词列表中，存在的话，返回序列长度，否则返回0。</p>
<p>比如：<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>最短转换序列为： <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>返回 <code>5</code>.</p>
<p>注意：单词长度都是固定的，并且都是小写字母。</p>
<p><strong>思路</strong> ：用广度优先搜索～先将beginWord放入队列中，然后将队列中的每一个单词从头到尾换26个字母一遍～如果换后的单词在字典中能找到～而且没有被访问过～（如果每次都找访问过的就死循环啦，不停的变来变去变同一个咋办～）那就将这个单词放入队列中继续变换～直到有一次发现在字典中找到单词的时候，这个单词恰好是endWord为止～</p>
<p>很像二叉树的层次遍历，找到endword后，直接返回所在的层数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = wordList.begin();iter!=wordList.end();++iter)&#123;</div><div class="line">            wordSet.insert(*iter);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; sq;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visitSet;</div><div class="line">        sq.push(beginWord);</div><div class="line">        <span class="keyword">while</span>(!sq.empty())&#123;   <span class="comment">//队列不为空</span></div><div class="line">            <span class="keyword">int</span> size = sq.size();</div><div class="line">            ++length;</div><div class="line">            <span class="keyword">while</span>(size--)&#123;</div><div class="line">                <span class="built_in">string</span> word = sq.front();</div><div class="line">                sq.pop();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.size();++i)&#123;</div><div class="line">                    <span class="built_in">string</span> newword = word;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)&#123;</div><div class="line">                        newword[i] = <span class="string">'a'</span> + j;</div><div class="line">                        <span class="keyword">if</span>(wordSet.find(newword)!=wordSet.end() &amp;&amp; visitSet.find(newword) == visitSet.end())&#123;  <span class="comment">//存在且未被访问</span></div><div class="line">                            <span class="keyword">if</span>(newword == endWord) <span class="keyword">return</span> length;</div><div class="line">                            visitSet.insert(newword);</div><div class="line">                            <span class="comment">//加入到队列中</span></div><div class="line">                            sq.push(newword);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>题意：从给定数组中找到一组数字，要求这组数字之和等于target。另外，数组中的数字不允许被使用多次，但如果一开始就存在多个的话，可以使用多次。</p>
<p>比如给一个集合：[10,1,2,7,6,1,5] 和目标值8，输出</p>
<p>[1, 7] </p>
<p>[1, 2, 5] </p>
<p>[2, 6] </p>
<p>[1, 1, 6] </p>
<p>解题思路：显然先排序，然后dfs。其中有一点要注意的是：因为不能重复，所以要跳过一样的数字。以上面为例，如果不跳过重复的1的话，会出现多个：[1,7]。</p>
<p>递归流程图：以1,1,1,2为例，target = 3，输出[1,1,1]、[1,2];</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result,<span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = candidates.size();</div><div class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</div><div class="line">        result.push_back(path);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;len;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>])&#123;  <span class="comment">//避免再同一层中出现，去除重复</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span>;   <span class="comment">//剪枝，目标值小于待遍历值时，不用继续往下搜寻了</span></div><div class="line">        path.push_back(candidates[i]);</div><div class="line">        helper(candidates,target-candidates[i],path,result,i+<span class="number">1</span>);</div><div class="line">        path.pop_back();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="keyword">int</span> target)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">    sort(candidates.begin(),candidates.end());   <span class="comment">//排序</span></div><div class="line">    <span class="comment">//递归</span></div><div class="line">    helper(candidates,target,path,result,<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//所有的数都是正整数</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates = &#123;<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</div><div class="line">    <span class="keyword">int</span> target = <span class="number">8</span>;</div><div class="line">    sort(candidates.begin(),candidates.end());</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result = combinationSum(candidates,target);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ivec : result)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : ivec) <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019去哪儿网春招笔试编程题，去哪儿网的春招笔试编程题还是挺难的，再做一遍，总结总结。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>笔试编程题0401</title>
    <link href="http://www.wangxinri.cn/2018/04/01/201958%E5%90%8C%E5%9F%8E%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/04/01/201958同城春招实习机试题/</id>
    <published>2018-04-01T13:59:00.000Z</published>
    <updated>2018-04-14T13:40:20.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>201958同城春招实习机试题，一共两道编程题，解答题热搜top10问题，用topK来实现的，TCP和UDP在直播中的优缺点，简单的介绍了下TCP和UDP的特点和区别，还涉及到SQL和事务，重复读问题。</p>
<a id="more"></a>
<p>应用题是海量数据问题，统计UID出现的次数并排序，用了hashtable来实现的，并用Introspective sort（内省排序）进行排序，总体来说，难度还可以，主要是一个半小时，时间略少，题量略多。</p>
<p>最后记录两道编程题。</p>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="找出符合条件的子字符串"><a href="#找出符合条件的子字符串" class="headerlink" title="找出符合条件的子字符串"></a>找出符合条件的子字符串</h2><p>比如字符串为“aabbbccddddeeffggghh”，给定大小为n，输出所有长度为n的重复子串，比如n=2，输出(0,1,aa)(5,6,cc)(11,12,ee)(13,14,ff)(18,19,hh)。</p>
<p>通过设置两个指针first和last，通过cnt记录每个字符出现的次数，找到满足次数的字符输出即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSubstr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = str.size();</div><div class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> tem = str[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(str[i]==str[i<span class="number">-1</span>])&#123;</div><div class="line">            ++last;</div><div class="line">            ++cnt;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(cnt == n)&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;first&lt;&lt;<span class="string">","</span>&lt;&lt;last&lt;&lt;<span class="string">","</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="built_in">cout</span>&lt;&lt;tem;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</div><div class="line">            &#125;</div><div class="line">            tem = str[i];</div><div class="line">            first = i;</div><div class="line">            last = i;</div><div class="line">            cnt = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(cnt == n)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;first&lt;&lt;<span class="string">","</span>&lt;&lt;last&lt;&lt;<span class="string">","</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="built_in">cout</span>&lt;&lt;tem;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> str = <span class="string">"aabbbccddddeeffggghh"</span>;</div><div class="line">    GetSubstr(str,<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最大连续字数组的和"><a href="#最大连续字数组的和" class="headerlink" title="最大连续字数组的和"></a>最大连续字数组的和</h2><p>比如输入：2,-3,4,11,-5,8,3,-6</p>
<p>则输出：21</p>
<pre><code>f(i) = max(f(i-1)+ivec[i],ivec[i]);
res = max(res,f(i));
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxSubSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = ivec.size();</div><div class="line">    <span class="keyword">int</span> f1 = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> res = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</div><div class="line">        f1 = max(f1+ivec[i],ivec[i]);</div><div class="line">        res = max(f1,res);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxSubSum1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = ivec.size();</div><div class="line">    <span class="keyword">int</span> res = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</div><div class="line">        sum += ivec[i];</div><div class="line">        <span class="keyword">if</span>(sum&gt;res) res = sum;</div><div class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</div><div class="line">            sum = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">-5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">-6</span>&#125;;</div><div class="line">    <span class="keyword">int</span> result = GetMaxSubSum(ivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    result = GetMaxSubSum1(ivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;201958同城春招实习机试题，一共两道编程题，解答题热搜top10问题，用topK来实现的，TCP和UDP在直播中的优缺点，简单的介绍了下TCP和UDP的特点和区别，还涉及到SQL和事务，重复读问题。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
