<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>新日三少的博客</title>
  <subtitle>Big big pig</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wangxinri.cn/"/>
  <updated>2018-04-20T03:02:49.953Z</updated>
  <id>http://www.wangxinri.cn/</id>
  
  <author>
    <name>新日三少</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>8皇后问题</title>
    <link href="http://www.wangxinri.cn/2018/04/20/8queen/"/>
    <id>http://www.wangxinri.cn/2018/04/20/8queen/</id>
    <published>2018-04-20T13:59:00.000Z</published>
    <updated>2018-04-20T03:02:49.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><p>在8*8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一条对角线上。请问总共有多少种符合条件的摆法？ </p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>剑指offer上的方法，通过排列组合求出所有不在同一行、同一列的组合，然后剔除在同一对角线的组合，即为最终结果</p>
<p>定义一个数组ivec[8]，数组中第i个数字表示位于第i行的皇后的列号，先把数组ivec中的8个数字分别用0-7初始化，然后对数组ivec进行全排列，因为我们用不同的数字初始化数组，所以任意两个皇后肯定不同列。接下来只需要判断每一个排列对应的8个皇后是不是在同一条对角线上，也就是对于数组的两个下标i,j，如果存在 (abs(i-j)) == (abs(ivec[i]-ivec[j]))，则剔除。否则为其中一种摆法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">/*问题描述:在8*8的国际象棋上排放8个皇后，使其不能相互攻击，</span></div><div class="line"><span class="comment">即任意两个皇后不得处在同一行、同一列或者同一条对角线上。*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec,<span class="keyword">int</span> start,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;allVec)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start == (ivec.size()<span class="number">-1</span>)) allVec.push_back(ivec);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;ivec.size();++i)&#123;</div><div class="line">        swap(ivec[i],ivec[start]);</div><div class="line">        helper(ivec,start+<span class="number">1</span>,allVec);</div><div class="line">        swap(ivec[i],ivec[start]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;allVec)</span></span>&#123;</div><div class="line">    helper(ivec,<span class="number">0</span>,allVec);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</div><div class="line">    <span class="comment">//先求所有皇后可能出现的列的组合，排列组合问题</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allVec;</div><div class="line">    Permutation(ivec,allVec);</div><div class="line">    <span class="comment">//此时保证皇后都是不同行，不同列的情况，接着剔除同一对角线的</span></div><div class="line">    <span class="comment">// abs(i-j) == abs(vec[i]-vec[j])，处于同一对角线，删除</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; resVec;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter=allVec.begin();iter!=allVec.end();++iter)&#123;</div><div class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</div><div class="line">            <span class="keyword">bool</span> flag2 = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(i!=j)&#123;</div><div class="line">                    <span class="keyword">if</span>( (<span class="built_in">abs</span>(i-j)) == ( <span class="built_in">abs</span>((*iter)[i]-(*iter)[j]) ) )&#123;  <span class="comment">//剔除</span></div><div class="line">                        flag = <span class="literal">false</span>;</div><div class="line">                        flag2 = <span class="literal">false</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!flag2) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(flag) resVec.push_back(*iter);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"解法共有："</span>&lt;&lt;resVec.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> vec : resVec)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"解法"</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : vec) <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        ++i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>解法共有92种，时间复杂度为 8！<em>  ((8 </em> 7)/2)。8！为排列组合需要的时间复杂度，(8 * 7)/2 为剔除每一个排列组合需要的时间复杂度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;八皇后问题&quot;&gt;&lt;a href=&quot;#八皇后问题&quot; class=&quot;headerlink&quot; title=&quot;八皇后问题&quot;&gt;&lt;/a&gt;八皇后问题&lt;/h1&gt;&lt;p&gt;在8*8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一条对角线上。请问总共有多少种符合条件的摆法？ &lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wangxinri.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>笔试编程题0414</title>
    <link href="http://www.wangxinri.cn/2018/04/14/2019%E6%90%9C%E7%8B%90%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/04/14/2019搜狐春招笔试题/</id>
    <published>2018-04-14T13:59:00.000Z</published>
    <updated>2018-04-14T13:39:31.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019搜狐春招笔试题，两道都ac了，还是挺开心的。</p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>会员成长值 = 每天成长值 + 任务成长值。</p>
<p>大体意思是：给定多行，每行第一个值为1给出了某个时间范围每天的成长值，每行第一个值为2给出了某天做任务的任务值。每行中每天的成长值的时间范围可能有重复的，选择成长值最大的来作为当天最大成长值。求出总的会员成长值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">3 </div><div class="line">1 1 5 10</div><div class="line">2 3 4</div><div class="line">1 4 6 -5</div><div class="line">输出49</div></pre></td></tr></table></figure>
<p>思路：遍历找出每天成长值的时间范围，然后依次比较每天的成长值，得到最大的成长值作为当天的成长值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> N;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;N;</div><div class="line">    <span class="keyword">int</span> len = N;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; growVec;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tastVec;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">while</span>(len--)&#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;num;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;   <span class="comment">//成长</span></div><div class="line">            <span class="keyword">int</span> tem;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</div><div class="line">                <span class="built_in">cin</span>&gt;&gt;tem;</div><div class="line">                ivec.push_back(tem);</div><div class="line">            &#125;</div><div class="line">            growVec.push_back(ivec);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//任务</span></div><div class="line">            <span class="keyword">int</span> tem;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</div><div class="line">                <span class="built_in">cin</span>&gt;&gt;tem;</div><div class="line">                ivec.push_back(tem);</div><div class="line">            &#125;</div><div class="line">            tastVec.push_back(ivec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    for(auto ivec : growVec)&#123;</span></div><div class="line"><span class="comment">        for(auto ele : ivec) cout&lt;&lt;ele&lt;&lt;" ";</span></div><div class="line"><span class="comment">        cout&lt;&lt;endl;</span></div><div class="line"><span class="comment">    &#125;</span></div><div class="line"><span class="comment">    for(auto ivec : tastVec)&#123;</span></div><div class="line"><span class="comment">        for(auto ele : ivec) cout&lt;&lt;ele&lt;&lt;" ";</span></div><div class="line"><span class="comment">        cout&lt;&lt;endl;</span></div><div class="line"><span class="comment">    &#125;</span></div><div class="line"><span class="comment">    cout&lt;&lt;"-------------------"&lt;&lt;endl;</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">int</span> mintime = <span class="number">1000000</span>;</div><div class="line">    <span class="keyword">int</span> maxtime = <span class="number">-1000000</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = growVec.begin();iter!=growVec.end();++iter)&#123;</div><div class="line">        <span class="keyword">if</span>((*iter)[<span class="number">0</span>] &lt; mintime) mintime = (*iter)[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span>((*iter)[<span class="number">1</span>] &gt; maxtime) maxtime = (*iter)[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//cout&lt;&lt;mintime&lt;&lt;" "&lt;&lt;maxtime&lt;&lt;endl;   //时间范围</span></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mintime;i&lt;=maxtime;++i)&#123;</div><div class="line">        <span class="keyword">int</span> MaxValue = <span class="number">-1000000</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = growVec.begin();iter!=growVec.end();++iter)&#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;=(*iter)[<span class="number">0</span>]&amp;&amp;i&lt;=(*iter)[<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">if</span>(MaxValue&lt;(*iter)[<span class="number">2</span>]) MaxValue = (*iter)[<span class="number">2</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//cout&lt;&lt;MaxValue&lt;&lt;endl;</span></div><div class="line">        res += MaxValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//cout&lt;&lt;"here"&lt;&lt;endl;</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = tastVec.begin();iter!=tastVec.end();++iter)&#123;</div><div class="line">        res += (*iter)[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h3><p>找出某个序列中第K小的数。</p>
<p>思路：维护一个K大的大根堆，堆顶元素是最大的值，遍历数组序列，如果存在比堆顶元素小的数，将堆顶元素删除，将新值添加进堆。</p>
<p>注：<strong>默认所有make_heap操作都是大根堆，也就是所有的第三个参数时less(),如果需要生成小根堆，操作也是一样的，第三个参数全为greater()</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetSmallKNum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">    <span class="keyword">if</span>(k&gt;input.size() || k&lt;<span class="number">1</span>) <span class="keyword">return</span> ivec;</div><div class="line">    <span class="keyword">auto</span> iter = input.begin();  <span class="comment">//从第一个元素开始遍历</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</div><div class="line">        ivec.push_back(*iter);</div><div class="line">        ++iter;</div><div class="line">    &#125;</div><div class="line">    make_heap(ivec.begin(),ivec.end());</div><div class="line">    <span class="keyword">auto</span> end = input.end();</div><div class="line">    <span class="keyword">for</span>(;iter!=end;++iter)&#123;</div><div class="line">        <span class="keyword">if</span>(*iter&lt;ivec[<span class="number">0</span>])&#123;  <span class="comment">//小于最大值</span></div><div class="line">            pop_heap(ivec.begin(),ivec.end());  <span class="comment">//删除堆顶元素</span></div><div class="line">            ivec.pop_back();</div><div class="line">            ivec.push_back(*iter);</div><div class="line">            push_heap(ivec.begin(),ivec.end());  <span class="comment">//插入新的元素</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//对大根堆进行排序</span></div><div class="line">    sort_heap(ivec.begin(),ivec.end());</div><div class="line">    <span class="keyword">return</span> ivec;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len,k;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;len&gt;&gt;k;</div><div class="line">    <span class="keyword">int</span> size = len;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">while</span>(len--)&#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;num;</div><div class="line">        input.push_back(num);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = GetSmallKNum(input,k);</div><div class="line">    <span class="keyword">int</span> length = res.size();</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;++i) <span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="string">","</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019搜狐春招笔试题，两道都ac了，还是挺开心的。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap简单实现</title>
    <link href="http://www.wangxinri.cn/2018/04/08/Bitmap/"/>
    <id>http://www.wangxinri.cn/2018/04/08/Bitmap/</id>
    <published>2018-04-08T13:59:00.000Z</published>
    <updated>2018-04-10T09:41:42.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BitMap算法"><a href="#BitMap算法" class="headerlink" title="BitMap算法"></a>BitMap算法</h1><p>Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<a id="more"></a>
<p>我们知道，一般可以直接操控的最小的单位是字节，比如在C/C++中，定义一个类型char，对它进行各种操作。然后很多时候，面对一个很大数据量，且我们仅仅希望知道某个数是否存在，我们不妨可以（<strong>有时候是必须</strong>）使用Bitmap算法来完成相关操作。比如腾讯的下面这道题：</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在40亿个没有排序的无符号整数中，我们如何快速判断某个无符号整数是否在这40亿个数中？</p>
<p>40亿，这是一个很大的数字，就是海量数据的处理，所以我们必须要考虑到内存的问题。我们知道一个无符号整数的大小为4个字节，那么40亿个需要占多少的内存？4<em>40亿是多大量级？咋一看有点难算，不过我们可以估算一下。<br>1KB=1024B<br>1MB=1024KB<br>1GB=1024MB<br>我们近似估计一下，1GB≈1000 </em> 1000 <em> 1000B= 1 000 000 000B = 10亿B，因此40亿</em>4B / 10亿B = 16G。就是说需要占据大概16GB的内存，这显然对于一般的电脑是不行的。</p>
<p>如果我们可以使用位图来存，一整型占4字节32比特位，因此如果用一个bit来存的话，在上面的例子中仅仅需要16G/32=0.5G大概就是500MB的内存。</p>
<p>题目要求我们快速判断，最快的算法当然是O（1）的操作，我们可以开一个无符号整型最大值的空间（保证这42亿个数都在这个范围内），每个数映射一个bit位，如果存在就将该bit位置1，不然就置0。因此想要查找某个数只需要开他映射的那个比特位是0还是1就可以了。</p>
<p>比如我们想要在这些数中查找一个33。</p>
<p>首先我们要开辟一块size_t（无符号整型）的空间，我们不妨使用整形数组arr来存。 其中每个元素都是size_t占4个字节32位.</p>
<p>刚开始每个空格全是0，这时候我们存一个33，arr[0]对应着0-31的比特位，arr[1]对应着32-63的比特位，因此33就在arr[1]第二个比特位。。。我们只需要将这个比特位置1就好了，到时候查找也是这个位是否为1。</p>
<p>bitmap表为：</p>
<p>arr[0] ——&gt; 0 - 31</p>
<p>arr[1] ——&gt; 32 - 63</p>
<p>arr[2] ——&gt; 64 - 95</p>
<p>arr[3] ——&gt; 96 - 127</p>
<p>结论：<strong>对于任意一个数x，x / 32对应着它在vector的第几个位置，x % 32对应它的比特位。</strong></p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;   <span class="comment">//数组容量为100</span></div><div class="line"><span class="keyword">int</span> arr[N] = &#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;   <span class="comment">//设置num所在位标志为1</span></div><div class="line">    <span class="keyword">int</span> index = num/<span class="number">32</span>;  <span class="comment">//所在数组的对应下标</span></div><div class="line">    <span class="keyword">int</span> pos = num%<span class="number">32</span>;    <span class="comment">//对应下标具体的位置</span></div><div class="line">    arr[index] |= (<span class="number">1</span>&lt;&lt;pos);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasExisted</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//checknum是否存在</span></div><div class="line">    <span class="keyword">int</span> index = num/<span class="number">32</span>;</div><div class="line">    <span class="keyword">int</span> pos = num%<span class="number">32</span>;</div><div class="line">    <span class="keyword">if</span>((arr[index]&amp;(<span class="number">1</span>&lt;&lt;pos))!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    setNumber(<span class="number">10</span>);</div><div class="line">    setNumber(<span class="number">50</span>);</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">10</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"10 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">20</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"20 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"20 is not existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(hasExisted(<span class="number">50</span>)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"50 is existed"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BitMap算法&quot;&gt;&lt;a href=&quot;#BitMap算法&quot; class=&quot;headerlink&quot; title=&quot;BitMap算法&quot;&gt;&lt;/a&gt;BitMap算法&lt;/h1&gt;&lt;p&gt;Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://www.wangxinri.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://www.wangxinri.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>笔试编程题0403</title>
    <link href="http://www.wangxinri.cn/2018/04/03/2019%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/04/03/2019去哪儿网春招笔试编程题/</id>
    <published>2018-04-03T13:59:00.000Z</published>
    <updated>2018-04-14T13:39:13.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019去哪儿网春招笔试编程题，去哪儿网的春招笔试编程题还是挺难的，再做一遍，总结总结。</p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="找最短的转换序列"><a href="#找最短的转换序列" class="headerlink" title="找最短的转换序列"></a>找最短的转换序列</h2><p>题目记不太清，大致是给一个初始单词和一个最终单词，同时给定一个单词列表，初始单词每次可以更改一个字母，找出最短的序列使得初始单词经过若干步转化为最终单词，并且转换的单词必须出现在单词列表中，存在的话，返回序列长度，否则返回0。</p>
<p>比如：<br><em>beginWord</em> = <code>&quot;hit&quot;</code><br><em>endWord</em> = <code>&quot;cog&quot;</code><br><em>wordList</em> = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p>
<p>最短转换序列为： <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>返回 <code>5</code>.</p>
<p>注意：单词长度都是固定的，并且都是小写字母。</p>
<p><strong>思路</strong> ：用广度优先搜索～先将beginWord放入队列中，然后将队列中的每一个单词从头到尾换26个字母一遍～如果换后的单词在字典中能找到～而且没有被访问过～（如果每次都找访问过的就死循环啦，不停的变来变去变同一个咋办～）那就将这个单词放入队列中继续变换～直到有一次发现在字典中找到单词的时候，这个单词恰好是endWord为止～</p>
<p>很像二叉树的层次遍历，找到endword后，直接返回所在的层数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = wordList.begin();iter!=wordList.end();++iter)&#123;</div><div class="line">            wordSet.insert(*iter);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; sq;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visitSet;</div><div class="line">        sq.push(beginWord);</div><div class="line">        <span class="keyword">while</span>(!sq.empty())&#123;   <span class="comment">//队列不为空</span></div><div class="line">            <span class="keyword">int</span> size = sq.size();</div><div class="line">            ++length;</div><div class="line">            <span class="keyword">while</span>(size--)&#123;</div><div class="line">                <span class="built_in">string</span> word = sq.front();</div><div class="line">                sq.pop();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.size();++i)&#123;</div><div class="line">                    <span class="built_in">string</span> newword = word;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)&#123;</div><div class="line">                        newword[i] = <span class="string">'a'</span> + j;</div><div class="line">                        <span class="keyword">if</span>(wordSet.find(newword)!=wordSet.end() &amp;&amp; visitSet.find(newword) == visitSet.end())&#123;  <span class="comment">//存在且未被访问</span></div><div class="line">                            <span class="keyword">if</span>(newword == endWord) <span class="keyword">return</span> length;</div><div class="line">                            visitSet.insert(newword);</div><div class="line">                            <span class="comment">//加入到队列中</span></div><div class="line">                            sq.push(newword);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>题意：从给定数组中找到一组数字，要求这组数字之和等于target。另外，数组中的数字不允许被使用多次，但如果一开始就存在多个的话，可以使用多次。</p>
<p>比如给一个集合：[10,1,2,7,6,1,5] 和目标值8，输出</p>
<p>[1, 7] </p>
<p>[1, 2, 5] </p>
<p>[2, 6] </p>
<p>[1, 1, 6] </p>
<p>解题思路：显然先排序，然后dfs。其中有一点要注意的是：因为不能重复，所以要跳过一样的数字。以上面为例，如果不跳过重复的1的话，会出现多个：[1,7]。</p>
<p>递归流程图：以1,1,1,2为例，target = 3，输出[1,1,1]、[1,2];</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result,<span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = candidates.size();</div><div class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</div><div class="line">        result.push_back(path);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;len;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>])&#123;  <span class="comment">//避免再同一层中出现，去除重复</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span>;   <span class="comment">//剪枝，目标值小于待遍历值时，不用继续往下搜寻了</span></div><div class="line">        path.push_back(candidates[i]);</div><div class="line">        helper(candidates,target-candidates[i],path,result,i+<span class="number">1</span>);</div><div class="line">        path.pop_back();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="keyword">int</span> target)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">    sort(candidates.begin(),candidates.end());   <span class="comment">//排序</span></div><div class="line">    <span class="comment">//递归</span></div><div class="line">    helper(candidates,target,path,result,<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//所有的数都是正整数</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates = &#123;<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</div><div class="line">    <span class="keyword">int</span> target = <span class="number">8</span>;</div><div class="line">    sort(candidates.begin(),candidates.end());</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result = combinationSum(candidates,target);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ivec : result)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : ivec) <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019去哪儿网春招笔试编程题，去哪儿网的春招笔试编程题还是挺难的，再做一遍，总结总结。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>笔试编程题0401</title>
    <link href="http://www.wangxinri.cn/2018/04/01/201958%E5%90%8C%E5%9F%8E%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/04/01/201958同城春招实习机试题/</id>
    <published>2018-04-01T13:59:00.000Z</published>
    <updated>2018-04-14T13:40:20.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>201958同城春招实习机试题，一共两道编程题，解答题热搜top10问题，用topK来实现的，TCP和UDP在直播中的优缺点，简单的介绍了下TCP和UDP的特点和区别，还涉及到SQL和事务，重复读问题。</p>
<a id="more"></a>
<p>应用题是海量数据问题，统计UID出现的次数并排序，用了hashtable来实现的，并用Introspective sort（内省排序）进行排序，总体来说，难度还可以，主要是一个半小时，时间略少，题量略多。</p>
<p>最后记录两道编程题。</p>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="找出符合条件的子字符串"><a href="#找出符合条件的子字符串" class="headerlink" title="找出符合条件的子字符串"></a>找出符合条件的子字符串</h2><p>比如字符串为“aabbbccddddeeffggghh”，给定大小为n，输出所有长度为n的重复子串，比如n=2，输出(0,1,aa)(5,6,cc)(11,12,ee)(13,14,ff)(18,19,hh)。</p>
<p>通过设置两个指针first和last，通过cnt记录每个字符出现的次数，找到满足次数的字符输出即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSubstr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = str.size();</div><div class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> tem = str[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(str[i]==str[i<span class="number">-1</span>])&#123;</div><div class="line">            ++last;</div><div class="line">            ++cnt;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(cnt == n)&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;first&lt;&lt;<span class="string">","</span>&lt;&lt;last&lt;&lt;<span class="string">","</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="built_in">cout</span>&lt;&lt;tem;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</div><div class="line">            &#125;</div><div class="line">            tem = str[i];</div><div class="line">            first = i;</div><div class="line">            last = i;</div><div class="line">            cnt = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(cnt == n)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;first&lt;&lt;<span class="string">","</span>&lt;&lt;last&lt;&lt;<span class="string">","</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j) <span class="built_in">cout</span>&lt;&lt;tem;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> str = <span class="string">"aabbbccddddeeffggghh"</span>;</div><div class="line">    GetSubstr(str,<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最大连续字数组的和"><a href="#最大连续字数组的和" class="headerlink" title="最大连续字数组的和"></a>最大连续字数组的和</h2><p>比如输入：2,-3,4,11,-5,8,3,-6</p>
<p>则输出：21</p>
<pre><code>f(i) = max(f(i-1)+ivec[i],ivec[i]);
res = max(res,f(i));
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxSubSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = ivec.size();</div><div class="line">    <span class="keyword">int</span> f1 = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> res = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</div><div class="line">        f1 = max(f1+ivec[i],ivec[i]);</div><div class="line">        res = max(f1,res);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxSubSum1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = ivec.size();</div><div class="line">    <span class="keyword">int</span> res = ivec[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</div><div class="line">        sum += ivec[i];</div><div class="line">        <span class="keyword">if</span>(sum&gt;res) res = sum;</div><div class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</div><div class="line">            sum = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">-5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">-6</span>&#125;;</div><div class="line">    <span class="keyword">int</span> result = GetMaxSubSum(ivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    result = GetMaxSubSum1(ivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;201958同城春招实习机试题，一共两道编程题，解答题热搜top10问题，用topK来实现的，TCP和UDP在直播中的优缺点，简单的介绍了下TCP和UDP的特点和区别，还涉及到SQL和事务，重复读问题。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>笔试编程题0329</title>
    <link href="http://www.wangxinri.cn/2018/03/29/2019%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/03/29/2019华为春招实习机试题/</id>
    <published>2018-03-29T13:59:00.000Z</published>
    <updated>2018-04-14T13:40:02.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Rake接收最大径索引。"><a href="#Rake接收最大径索引。" class="headerlink" title="Rake接收最大径索引。"></a>Rake接收最大径索引。</h2><p>在无线通信接收，接收到的信号一般会有RAKE多经。现给出RAKE接收机21径能量；多经索引为0-20；用一个4径的接收窗在21径上进行滑动，滑动窗口判断什么位置接收最大能量。接收窗索引以窗内第一径的索引为准。比如窗最大能量框住径为0,1,2,3；则窗索引为0；如果两个窗的能量一样，则以索引最小为输出。</p>
<p>遍历一边，求出各个能量窗的值，找出最大的的能量窗的索引输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;num)&#123;</div><div class="line">        ivec.push_back(num);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">int</span> window_sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</div><div class="line">        window_sum+=ivec[i];</div><div class="line">    &#125;</div><div class="line">    result.push_back(window_sum);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;ivec.size();++i)&#123;</div><div class="line">        window_sum = window_sum-ivec[i<span class="number">-4</span>]+ivec[i];</div><div class="line">        result.push_back(window_sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min_index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> max_value = result[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;result.size(); ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(result[i] &gt; max_value)&#123;</div><div class="line">            max_value = result[i];</div><div class="line">            min_index = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; min_index<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="标准键盘与自然键盘映射"><a href="#标准键盘与自然键盘映射" class="headerlink" title="标准键盘与自然键盘映射"></a>标准键盘与自然键盘映射</h2><p>输入一个字符串，表示按照标准键盘输入动作，在自然键盘上打字产生的字符串。输出打字人在标准键盘上要打印的实际内容。</p>
<p>比如输入“H kz k xif”，输出”I am a boy”。</p>
<pre><code>标准键盘：&quot;QWERTYUIOPASDFGHJKLZXCVBNM&quot;
自然键盘：&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> str[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">string</span> sta = <span class="string">"QWERTYUIOPASDFGHJKLZXCVBNM"</span>;</div><div class="line">    <span class="built_in">string</span> nat = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</div><div class="line">    <span class="keyword">int</span> size = sta.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</div><div class="line">        str[nat[i]] = sta[i];  <span class="comment">//大写的转换</span></div><div class="line">        str[nat[i]+<span class="number">32</span>] = sta[i]+<span class="number">32</span>;  <span class="comment">//小写的转换</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">string</span> input;</div><div class="line">    <span class="built_in">string</span> output = <span class="string">""</span>;</div><div class="line">    getline(<span class="built_in">cin</span>,input);</div><div class="line">    <span class="keyword">int</span> length = input.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">        <span class="keyword">if</span>((input[i]&gt;=<span class="string">'A'</span>&amp;&amp;input[i]&lt;=<span class="string">'Z'</span>) || (input[i]&gt;=<span class="string">'a'</span>&amp;&amp;input[i]&lt;=<span class="string">'z'</span>))&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;str[input[i]];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;input[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最大连续字数组的和"><a href="#最大连续字数组的和" class="headerlink" title="最大连续字数组的和"></a>最大连续字数组的和</h2><p>输入：2,-3,4,11,-5,8,3,-6</p>
<p>输出：21</p>
<p>不知道为啥只通过了80%，先对字符串拆分出各个数字，然后通过动态规划求出最大连续子串和。</p>
<pre><code>f(i) = max(f(i-1)+ivec[i],ivec[i]);
res = max(res,f(i));
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    getline(<span class="built_in">cin</span>,s);</div><div class="line">    <span class="keyword">int</span> size = s.size();</div><div class="line">    <span class="keyword">int</span> flag = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ivec;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'-'</span>) flag = <span class="literal">false</span>;   <span class="comment">//如果是负数</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'+'</span>) flag = <span class="literal">true</span>;   <span class="comment">//如果是正数</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>) num = num*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">','</span>)&#123;  <span class="comment">//遇到逗号</span></div><div class="line">            num = flag?num:<span class="number">-1</span>*num;</div><div class="line">            ivec.push_back(num);</div><div class="line">            flag = <span class="literal">true</span>;</div><div class="line">            num = <span class="number">0</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">' '</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">else</span>&#123;   <span class="comment">//输入错误</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入有误"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    num = flag?num:(<span class="number">-1</span>)*num;</div><div class="line">    ivec.push_back(num);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxsubarray = ivec[<span class="number">0</span>];  <span class="comment">//先假设最大值为nums[0] 后面依次更新</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ivec.size();++i)&#123;</div><div class="line">        sum += ivec[i];</div><div class="line">        <span class="keyword">if</span>(sum&gt;maxsubarray) maxsubarray = sum;</div><div class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxsubarray&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。&lt;/p&gt;
    
    </summary>
    
      <category term="春招笔试" scheme="http://www.wangxinri.cn/categories/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://www.wangxinri.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序算法实现</title>
    <link href="http://www.wangxinri.cn/2018/03/25/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.wangxinri.cn/2018/03/25/各种排序算法实现/</id>
    <published>2018-03-25T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:37.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各种排序算法的实现，这东西，几天不写，就略感手生，需要定期不断温习，各种排序算法的思想都很清晰，写的过程中需要额外注意边界情况，递归结束条件，各种边界判断条件。没事写写，温故而知新。</p>
<a id="more"></a>
<h1 id="手写排序算法"><a href="#手写排序算法" class="headerlink" title="手写排序算法"></a>手写排序算法</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//选择排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Selection</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"select sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">int</span> mindex = i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&lt;a[mindex]) mindex = j;</div><div class="line">            &#125;</div><div class="line">            swap(a[i],a[mindex]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bubble</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bubble sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length-i<span class="number">-1</span>;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>]) swap(a[j],a[j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Insert</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"insert sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="comment">//找到带插入位置</span></div><div class="line">            <span class="keyword">int</span> tem = a[i];</div><div class="line">            <span class="keyword">int</span> j;</div><div class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                    a[j+<span class="number">1</span>] = a[j];</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            a[j+<span class="number">1</span>] = tem;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//希尔排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shell</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"shell sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(h&lt;length/<span class="number">3</span>) h = <span class="number">3</span>*h+<span class="number">1</span>;   <span class="comment">//增量分别为1,4,13,40,...</span></div><div class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;length;++i)&#123;</div><div class="line">                <span class="keyword">int</span> tem = a[i];</div><div class="line">                <span class="keyword">int</span> j;</div><div class="line">                <span class="keyword">for</span>(j=i-h;j&gt;=<span class="number">0</span>;j-=h)&#123;</div><div class="line">                    <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                        a[j+h] = a[j];</div><div class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                a[j+h] = tem;</div><div class="line">            &#125;</div><div class="line">            h = h/<span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol>
<li><p>递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;  <span class="comment">//将[low,high]进行归并</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</div><div class="line">        Merge_sort(a,low,mid,aux);</div><div class="line">        Merge_sort(a,mid+<span class="number">1</span>,high,aux);</div><div class="line">        Merge(a,low,mid,high,aux);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>非递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoRecMergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="title">norecMergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> aux[])</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"norecMergeSort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>;sz&lt;length;sz=sz+sz)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>;lo&lt;length-sz;lo+=sz+sz)&#123;     <span class="comment">//lo = lo + sz + sz</span></div><div class="line">                Merge(a,lo,lo+sz<span class="number">-1</span>,min(lo+sz+sz<span class="number">-1</span>,length<span class="number">-1</span>),aux);  <span class="comment">// lo lo+sz-1  min(lo+sz+sz-1,length-1)</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//快速排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuickSort</span>&#123;</span>   <span class="comment">//不稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;    <span class="comment">//对[low,high]进行快排</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> j = Partition(a,low,high);</div><div class="line">        quicksort(a,low,j<span class="number">-1</span>);</div><div class="line">        quicksort(a,j+<span class="number">1</span>,high);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> v = a[low];</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(a[++i]&lt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(i==high) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(a[--j]&gt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(j==low) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</div><div class="line">            swap(a[i],a[j]);</div><div class="line">        &#125;</div><div class="line">        swap(a[low],a[j]);</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//堆排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapSort</span>&#123;</span>   <span class="comment">//大根堆</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sink</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> index)</span></span>&#123;   <span class="comment">//数组下标为index的元素进行下沉操作</span></div><div class="line">        <span class="keyword">while</span>(<span class="number">2</span>*index+<span class="number">1</span>&lt;length)&#123;  <span class="comment">//有左孩子节点</span></div><div class="line">            <span class="keyword">int</span> big = <span class="number">2</span>*index+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">2</span>&lt;length) &amp;&amp; (a[<span class="number">2</span>*index+<span class="number">2</span>]&gt;a[<span class="number">2</span>*index+<span class="number">1</span>])) &#123; big = <span class="number">2</span>*index+<span class="number">2</span>; &#125;  <span class="comment">//右子节点存在且大于左子节点</span></div><div class="line">            <span class="keyword">if</span>(a[big]&lt;=a[index]) <span class="keyword">break</span>;  <span class="comment">//已经有序，无须交换</span></div><div class="line">            swap(a[index],a[big]);  <span class="comment">//父节点和左右子节点中的较大值进行交换</span></div><div class="line">            index = big;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>;</div><div class="line">        <span class="comment">//构建堆</span></div><div class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</div><div class="line">            Sink(a,length,i);</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length<span class="number">-1</span>;j&gt;<span class="number">0</span>;--j)&#123;</div><div class="line">            swap(a[j],a[<span class="number">0</span>]);</div><div class="line">            Sink(a,j<span class="number">-1</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="完整程序示例"><a href="#完整程序示例" class="headerlink" title="完整程序示例"></a>完整程序示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//选择排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Selection</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"select sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">int</span> mindex = i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&lt;a[mindex]) mindex = j;</div><div class="line">            &#125;</div><div class="line">            swap(a[i],a[mindex]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//冒泡排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bubble</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;  <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"bubble sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length-i<span class="number">-1</span>;++j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>]) swap(a[j],a[j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//插入排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Insert</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"insert sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</div><div class="line">            <span class="comment">//找到带插入位置</span></div><div class="line">            <span class="keyword">int</span> tem = a[i];</div><div class="line">            <span class="keyword">int</span> j;</div><div class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</div><div class="line">                <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                    a[j+<span class="number">1</span>] = a[j];</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            a[j+<span class="number">1</span>] = tem;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//希尔排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shell</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;   <span class="comment">//不稳定</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"shell sort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(h&lt;length/<span class="number">3</span>) h = <span class="number">3</span>*h+<span class="number">1</span>;   <span class="comment">//增量分别为1,4,13,40,...</span></div><div class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;length;++i)&#123;</div><div class="line">                <span class="keyword">int</span> tem = a[i];</div><div class="line">                <span class="keyword">int</span> j;</div><div class="line">                <span class="keyword">for</span>(j=i-h;j&gt;=<span class="number">0</span>;j-=h)&#123;</div><div class="line">                    <span class="keyword">if</span>(a[j]&gt;tem)&#123;</div><div class="line">                        a[j+h] = a[j];</div><div class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                a[j+h] = tem;</div><div class="line">            &#125;</div><div class="line">            h = h/<span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;  <span class="comment">//将[low,high]进行归并</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</div><div class="line">        Merge_sort(a,low,mid,aux);</div><div class="line">        Merge_sort(a,mid+<span class="number">1</span>,high,aux);</div><div class="line">        Merge(a,low,mid,high,aux);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//非递归归并排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoRecMergeSort</span>&#123;</span>   <span class="comment">//稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="title">norecMergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> aux[])</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"norecMergeSort"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>;sz&lt;length;sz=sz+sz)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>;lo&lt;length-sz;lo+=sz+sz)&#123;     <span class="comment">//lo = lo + sz + sz</span></div><div class="line">                Merge(a,lo,lo+sz<span class="number">-1</span>,min(lo+sz+sz<span class="number">-1</span>,length<span class="number">-1</span>),aux);  <span class="comment">// lo lo+sz-1  min(lo+sz+sz-1,length-1)</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> aux[])</span></span>&#123;   <span class="comment">//将[low,mid] 与 [mid+1,high]进行归并</span></div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> index = low;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&lt;a[j]) aux[index++] = a[i++];</div><div class="line">            <span class="keyword">else</span> aux[index++] = a[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid) aux[index++] = a[i++];</div><div class="line">        <span class="keyword">while</span>(j&lt;=high) aux[index++] = a[j++];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;++k)&#123;</div><div class="line">            a[k] = aux[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="comment">//快速排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuickSort</span>&#123;</span>   <span class="comment">//不稳定</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;    <span class="comment">//对[low,high]进行快排</span></div><div class="line">        <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> j = Partition(a,low,high);</div><div class="line">        quicksort(a,low,j<span class="number">-1</span>);</div><div class="line">        quicksort(a,j+<span class="number">1</span>,high);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = low;</div><div class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> v = a[low];</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">            <span class="keyword">while</span>(a[++i]&lt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(i==high) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(a[--j]&gt;=v) &#123;</div><div class="line">                <span class="keyword">if</span>(j==low) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</div><div class="line">            swap(a[i],a[j]);</div><div class="line">        &#125;</div><div class="line">        swap(a[low],a[j]);</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//堆排序</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapSort</span>&#123;</span>   <span class="comment">//大根堆</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sink</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length,<span class="keyword">int</span> index)</span></span>&#123;   <span class="comment">//数组下标为index的元素进行下沉操作</span></div><div class="line">        <span class="keyword">while</span>(<span class="number">2</span>*index+<span class="number">1</span>&lt;length)&#123;  <span class="comment">//有左孩子节点</span></div><div class="line">            <span class="keyword">int</span> big = <span class="number">2</span>*index+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">2</span>&lt;length) &amp;&amp; (a[<span class="number">2</span>*index+<span class="number">2</span>]&gt;a[<span class="number">2</span>*index+<span class="number">1</span>])) &#123; big = <span class="number">2</span>*index+<span class="number">2</span>; &#125;  <span class="comment">//右子节点存在且大于左子节点</span></div><div class="line">            <span class="keyword">if</span>(a[big]&lt;=a[index]) <span class="keyword">break</span>;  <span class="comment">//已经有序，无须交换</span></div><div class="line">            swap(a[index],a[big]);  <span class="comment">//父节点和左右子节点中的较大值进行交换</span></div><div class="line">            index = big;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>;</div><div class="line">        <span class="comment">//构建堆</span></div><div class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</div><div class="line">            Sink(a,length,i);</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length<span class="number">-1</span>;j&gt;<span class="number">0</span>;--j)&#123;</div><div class="line">            swap(a[j],a[<span class="number">0</span>]);</div><div class="line">            Sink(a,j<span class="number">-1</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</div><div class="line">    <span class="keyword">int</span> aux[<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="comment">//Selection::select(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//Bubble::bubble(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//Insert::insert(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//Shell::shell(a,sizeof(a)/sizeof(a[0]));</span></div><div class="line">    <span class="comment">//MergeSort::Merge_sort(a,0,sizeof(a)/sizeof(a[0])-1,aux);</span></div><div class="line">    <span class="comment">//NoRecMergeSort::norecMergeSort(a,sizeof(a)/sizeof(a[0]),aux);</span></div><div class="line">    <span class="comment">//QuickSort::quicksort(a,0,9);</span></div><div class="line">    HeapSort::heapSort(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</div><div class="line">    display(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;各种排序算法的实现，这东西，几天不写，就略感手生，需要定期不断温习，各种排序算法的思想都很清晰，写的过程中需要额外注意边界情况，递归结束条件，各种边界判断条件。没事写写，温故而知新。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wangxinri.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://www.wangxinri.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的各种操作</title>
    <link href="http://www.wangxinri.cn/2018/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.wangxinri.cn/2018/03/22/二叉树各种操作/</id>
    <published>2018-03-22T13:59:00.000Z</published>
    <updated>2018-04-01T03:11:16.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二叉树的各种操作，前中后序的递归与非递归实现，二叉树的构建（序列化和反序列化），二叉树的最大高度与最小高度，打印出从根节点到叶子的节点的所有路径，打印出根节点到特定节点的路径，反转二叉树，判断两个二叉树是否相等等等操作。</p>
<a id="more"></a>
<p>算法这东西，就得多练，几天不写，还是感觉手生，需要定期不断温习，温故而知新啊，好好努力。</p>
<h1 id="二叉树的各种操作"><a href="#二叉树的各种操作" class="headerlink" title="二叉树的各种操作"></a>二叉树的各种操作</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></div><div class="line">    <span class="keyword">char</span> val;   <span class="comment">//节点值</span></div><div class="line">    TreeNode *left;  <span class="comment">//左节点</span></div><div class="line">    TreeNode *right;  <span class="comment">//右节点</span></div><div class="line">    TreeNode(<span class="keyword">char</span> v=<span class="string">'0'</span>):val(v),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*           A</span></div><div class="line"><span class="comment">            / \</span></div><div class="line"><span class="comment">           B   C</span></div><div class="line"><span class="comment">          / \  /</span></div><div class="line"><span class="comment">         D   E F</span></div><div class="line"><span class="comment">        /</span></div><div class="line"><span class="comment">       G</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//前序序列化二叉树  ABDG$$$E$$CF$$$</span></div><div class="line"><span class="function">TreeNode* <span class="title">CreateTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator &amp;iter)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(*iter==<span class="string">'$'</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(*iter);</div><div class="line">    root-&gt;left = CreateTree(++iter);</div><div class="line">    root-&gt;right = CreateTree(++iter);</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取前序序列串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSequence</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;sequence)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) &#123;</div><div class="line">        sequence.push_back(<span class="string">'$'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    sequence.push_back(root-&gt;val);</div><div class="line">    getSequence(root-&gt;left,sequence);</div><div class="line">    getSequence(root-&gt;right,sequence);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;sequence)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ele:sequence)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归先序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">    PreTravel(root-&gt;left);</div><div class="line">    PreTravel(root-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归先序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonCurPreTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    TreeNode *iter = root;</div><div class="line">    <span class="keyword">while</span>(!s.empty()||iter)&#123;</div><div class="line">        <span class="keyword">if</span>(iter)&#123;  <span class="comment">//如果左节点不为空的话，遍历左子树</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">            s.push(iter);</div><div class="line">            iter = iter-&gt;left;  <span class="comment">//左结点依次入栈</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//左节点为空，遍历右子树</span></div><div class="line">            iter = s.top();</div><div class="line">            s.pop();</div><div class="line">            iter = iter-&gt;right;  <span class="comment">//出栈，遍历右子树</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归中序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    InTravel(root-&gt;left);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">    InTravel(root-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归中序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonCurInTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    TreeNode *iter = root;</div><div class="line">    <span class="keyword">while</span>(!s.empty()||iter)&#123;</div><div class="line">        <span class="keyword">if</span>(iter)&#123;  <span class="comment">//如果左节点不为空的话，遍历左子树</span></div><div class="line">            s.push(iter);</div><div class="line">            iter = iter-&gt;left;  <span class="comment">//左结点依次入栈</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//左节点为空，遍历右子树</span></div><div class="line">            iter = s.top();</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">            s.pop();</div><div class="line">            iter = iter-&gt;right;  <span class="comment">//出栈，遍历右子树</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归后序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    PostTravel(root-&gt;left);</div><div class="line">    PostTravel(root-&gt;right);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归后序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonCurPostTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    TreeNode *prenode = <span class="literal">nullptr</span>;</div><div class="line">    TreeNode *curnode = root;</div><div class="line">    <span class="keyword">while</span>(curnode)&#123;</div><div class="line">        s.push(curnode);</div><div class="line">        curnode = curnode-&gt;left;  <span class="comment">//cur先走到左子树最左边结点</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!s.empty())&#123;</div><div class="line">        curnode = s.top();</div><div class="line">        s.pop();</div><div class="line">        <span class="keyword">if</span>(curnode-&gt;right==<span class="literal">nullptr</span>||curnode-&gt;right==prenode)&#123; <span class="comment">//右子树为空，或者右子树已经访问过了，此时访问根结点</span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;curnode-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">            prenode = curnode;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="comment">//根节点继续入栈，因为此时根节点右子树没有访问，我们需要访问完右子树，还需要继续访问根节点，所以根节点要再此入栈</span></div><div class="line">            s.push(curnode);</div><div class="line">            <span class="comment">//访问右子树</span></div><div class="line">            curnode = curnode-&gt;right;</div><div class="line">            <span class="keyword">while</span>(curnode)&#123;</div><div class="line">                s.push(curnode);</div><div class="line">                curnode = curnode-&gt;left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//层次遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">    q.push(root);</div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;  <span class="comment">//队列非空</span></div><div class="line">        TreeNode *node = q.front();   <span class="comment">//获得队首</span></div><div class="line">        q.pop();   <span class="comment">//移除队列中的第一个元素</span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;</div><div class="line">        <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</div><div class="line">        <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取树的高度(最大高度)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTreeMaxHigh</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//根节点为空</span></div><div class="line">    <span class="keyword">int</span> leftHigh = GetTreeMaxHigh(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> rightHigh = GetTreeMaxHigh(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> leftHigh&gt;rightHigh?leftHigh+<span class="number">1</span>:rightHigh+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取树的最小高度,递归实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTreeMinHigh</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;left)&#123;  <span class="comment">//左子树为空，返回右子树的高度</span></div><div class="line">        <span class="keyword">return</span> GetTreeMinHigh(root-&gt;right)+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;right)&#123;  <span class="comment">//右子树为空，返回左子树的高度</span></div><div class="line">        <span class="keyword">return</span> GetTreeMinHigh(root-&gt;left)+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//左右子树不空，返回左右子树高度的较小值</span></div><div class="line">    <span class="keyword">int</span> leftHigh = GetTreeMinHigh(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> rightHigh = GetTreeMinHigh(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> leftHigh&gt;rightHigh?rightHigh+<span class="number">1</span>:leftHigh+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取树的最小高度，层次遍历实现，也就是找到第一个叶子节点，得到该叶子节点所在的层即可</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTreeMinHighWithLevelTravel</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</div><div class="line">    q.push(root);</div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;</div><div class="line">        <span class="keyword">int</span> length = q.size();</div><div class="line">        ++level;</div><div class="line">        <span class="keyword">while</span>(length--)&#123;</div><div class="line">            TreeNode *node = q.front();</div><div class="line">            q.pop();</div><div class="line">            <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> level;  <span class="comment">//找到第一个叶子节点，返回</span></div><div class="line">            <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</div><div class="line">            <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> level;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取从根节点到所有叶子节点的路径，递归前序遍历思想</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetAllPath</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;allpath,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;path)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</div><div class="line">    path.push_back(root-&gt;val);</div><div class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;  <span class="comment">//叶子节点，将path存入到allpath中</span></div><div class="line">        allpath.push_back(path);</div><div class="line">    &#125;</div><div class="line">    GetAllPath(root-&gt;left,allpath,path);</div><div class="line">    GetAllPath(root-&gt;right,allpath,path);</div><div class="line">    path.pop_back();  <span class="comment">//在返回到父节点之前，在路径上删除当前节点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取根节点到某一固定节点的路径，递归前序遍历的思想</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPathFromRootTOnode</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;allpath,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;path,<span class="keyword">char</span> &amp;ch)</span></span>&#123;  <span class="comment">//allpath,可能有多个相同的节点</span></div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</div><div class="line">    path.push_back(root-&gt;val);</div><div class="line">    <span class="keyword">if</span>(root-&gt;val == ch)&#123;   <span class="comment">//找到该节点，保存路径</span></div><div class="line">        allpath.push_back(path);</div><div class="line">    &#125;</div><div class="line">    GetPathFromRootTOnode(root-&gt;left,allpath,path,ch);</div><div class="line">    GetPathFromRootTOnode(root-&gt;right,allpath,path,ch);</div><div class="line">    path.pop_back();  <span class="comment">//在返回到父节点之前，在路径上删除当前结点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;allpath)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> path : allpath)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : path)&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">" "</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//判断两棵树是否相同</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSameTree</span><span class="params">(TreeNode *root1,TreeNode *root2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span>(!root1 || !root2) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="comment">//两个节点都不为空</span></div><div class="line">    <span class="keyword">if</span>(root1-&gt;val == root2-&gt;val)&#123;</div><div class="line">        <span class="keyword">return</span> IsSameTree(root1-&gt;left,root2-&gt;left) &amp;&amp; IsSameTree(root1-&gt;right,root2-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不相等</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//反转二叉树，层次遍历实现</span></div><div class="line"><span class="function">TreeNode* <span class="title">invertTree1</span><span class="params">(TreeNode* root)</span> </span>&#123;   <span class="comment">//层次遍历，遍历每一层时，同时翻转该层的左右子树</span></div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;   <span class="comment">//如果根节点为空，返回根节点</span></div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</div><div class="line">    q.push(root);     <span class="comment">//根节点入队列</span></div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;  <span class="comment">//队列不为空</span></div><div class="line">        TreeNode *node = q.front();   <span class="comment">//遍历每层时，交换节点的左右节点</span></div><div class="line">        q.pop();     <span class="comment">//出队</span></div><div class="line">        swap(node-&gt;left,node-&gt;right);  <span class="comment">//交换左右节点</span></div><div class="line">        <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);   <span class="comment">//左右结点不为空入队</span></div><div class="line">        <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//反转二叉树，递归实现</span></div><div class="line"><span class="function">TreeNode* <span class="title">invertTree2</span><span class="params">(TreeNode *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root)&#123;</div><div class="line">        invertTree2(root-&gt;left);</div><div class="line">        invertTree2(root-&gt;right);</div><div class="line">        swap(root-&gt;left,root-&gt;right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//构建一个二叉树</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; sequence = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'G'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'E'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'C'</span>,<span class="string">'F'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>,<span class="string">'$'</span>&#125;;</div><div class="line">    <span class="keyword">auto</span> iter = sequence.begin();</div><div class="line">    TreeNode *root = CreateTree(iter);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"获取前序序列串"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; s;</div><div class="line">    getSequence(root,s);</div><div class="line">    Print(s);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序递归与非递归"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PreTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    NonCurPreTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序递归与非递归"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    InTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    NonCurInTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"后序递归与非递归"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    PostTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    NonCurPostTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"层次遍历"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    LevelTravel(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的高度(最大高度)"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">int</span> maxhigh = GetTreeMaxHigh(root);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxhigh&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的最小高度(根节点到叶子节点的最小距离)"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;GetTreeMinHigh(root)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;GetTreeMinHighWithLevelTravel(root)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输出根节点到叶子节点的所有路径"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; allpath;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; path;</div><div class="line">    GetAllPath(root,allpath,path);</div><div class="line">    Print(allpath);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输出根节点到某一特定节点的路径"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; allivec;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ivec;</div><div class="line">    <span class="keyword">char</span> ch = <span class="string">'E'</span>;</div><div class="line">    GetPathFromRootTOnode(root,allivec,ivec,ch);</div><div class="line">    Print(allivec);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"判断两棵树是否相同"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">if</span>(IsSameTree(root,root)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"is the same"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"is not the same"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"反转二叉树"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    root = invertTree2(root);</div><div class="line">    LevelTravel(root);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*           A</span></div><div class="line"><span class="comment">            / \</span></div><div class="line"><span class="comment">           B   C</span></div><div class="line"><span class="comment">          / \  /</span></div><div class="line"><span class="comment">         D   E F</span></div><div class="line"><span class="comment">        /</span></div><div class="line"><span class="comment">       G</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;二叉树的各种操作，前中后序的递归与非递归实现，二叉树的构建（序列化和反序列化），二叉树的最大高度与最小高度，打印出从根节点到叶子的节点的所有路径，打印出根节点到特定节点的路径，反转二叉树，判断两个二叉树是否相等等等操作。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wangxinri.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.wangxinri.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>基本分页存储管理</title>
    <link href="http://www.wangxinri.cn/2018/01/28/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.wangxinri.cn/2018/01/28/基本分页存储管理方式/</id>
    <published>2018-01-28T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:25.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><p>连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。<strong>如果允许将一个进程直接分散地装入到许多不相邻接的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是端，则称为分段存储管理方式</strong>。</p>
<a id="more"></a>
<p><strong>在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，或称为纯分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行</strong>。</p>
<h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><p><strong>1.页面</strong></p>
<p><strong>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页</strong>，并为各页加以编号，从0开始，如第0页、第1页等。相应地，<strong>也把内存空间分成与页面相同的若干个存储块，称为（物理块）或页框（frame）</strong>，也同样为它们加以编号，如0#块、1#块等等。在为进程分配内存时以块为单位将进程中的若干页分别装入到多个可以不相邻的物理块中。<strong>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</strong></p>
<p>在分页系统中的页面其大小应适中。页面若太小，一方面虽然可使内存碎片减小，从<br>而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较<br>多的页面，从而导致进程的页表过长，占用大量内存；此外，还会降低页面换进换出的效<br>率。然而，如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，<br>但却又会使页内碎片增大。因此，<strong>页面的大小应选择适中，且页面大小应是 2 的幂，通常<br>为 512 B～8 KB。</strong></p>
<p><strong>2.地址结构</strong></p>
<p>分页地址中的地址结构（逻辑地址）：</p>
<pre><code>31        12  11         0
    页号P        位移量W
</code></pre><p>它含有两部分：前一部分为页号P，后一部分为位移量W（或称为页内地址）。图中的地址长度为32位，其中0-11位为页内地址，即每页的大小为4kB；12-31位为页号，地址空间最多允许有1M页。</p>
<p>对于某特定机器，其地址结构是一定的。若给定一个逻辑地址空间中的地址为 A，页<br>面的大小为 L，则页号 P 和页内地址 d 可按下式求得：<br>​<br>    P = INT[A/L]<br>    d = [A] MOD L</p>
<p>其中，INT 是整除函数，MOD 是取余函数。例如，其系统的页面大小为 1 KB，设 A = 2170 B，<br>则由上式可以求得 P = 2，d = 122。</p>
<p><strong>3.页表</strong></p>
<p>在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，<strong>即能在内存中找到每个页面所对应的物理块</strong>。为此，<strong>系统又为每个进程建立了一张页面映射表，简称页表。</strong> </p>
<p>在进程地址空间内的所有页(0～n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，见图 4-12 的中间部分。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，<strong>页表的作用是实现从页号到物理块号的地址映射</strong>。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E9%A1%B5%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="image"></p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对<br>地址)分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在<br>执行检索之前，<strong>先将页号与页表长度进行比较</strong>，如果页号大于或等于页表长度，则表示本<br>次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现并产生一地址越界<br>中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，<strong>便得到该表项<br>在页表中的位置，于是可从中得到该页的物理块号</strong>，将之装入物理地址寄存器中。与此同<br>时，<strong>再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完<br>成了从逻辑地址到物理地址的变换</strong>。图 4-13 示出了分页系统的地址变换机构。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="image"></p>
<p><strong>具有快表的地址变换机构</strong></p>
<p>由于页表是存在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次时访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，已形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据（或向此地址中写入数据）。因此，采用这种方式使计算机的处理速度降低近1/2。</p>
<p><strong>具有快表的地址变换过程：</strong></p>
<p>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速<br>缓冲寄存器，又称为“联想寄存器”(Associative Memory)，或称为“<strong>快表</strong>”，在 IBM 系统中<br>又取名为 TLB(Translation Lookaside Buffer)，用以存放当前访问的那些页表项。此时的地址<br>变换过程是：<strong>在 CPU 给出有效地址后，由地址变换机构自动地将页号 P 送入高速缓冲寄存<br>器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示<br>所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到<br>物理地址寄存器中。如在块表中未找到对应的页表项，则还须再访问内存中的页表，找到<br>后，把从页表项中读出的物理块号送地址寄存器；同时，再将此页表项存入快表的一个寄<br>存器单元中，亦即，重新修改快表。但如果联想寄存器已满，则 OS 必须找到一个老的且已<br>被认为不再需要的页表项，将它换出</strong>。图 4-14 示出了具有快表的地址变换机构。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="image"></p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>现代的大多数计算机系统，都支持非常大的逻辑地址空间(232～264)。在这样的环境下，<br>页表就变得非常大，要占用相当大的内存空间。例如，对于一个具有 32 位逻辑地址空间的<br>分页系统，规定页面大小为 4 KB 即 212 B，则在每个进程页表中的页表项可达 1 兆个之多。<br>又因为每个页表项占用一个字节，故每个进程仅仅其页表就要占用 1 MB 的内存空间，而且<br>还要求是连续的。显然这是不现实的，我们可以采用下述两个方法来解决这一问题：</p>
<p>(1) 采用离散分配方式来解决难以找到一块连续的大内存空间的问题；</p>
<p>(2) 只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再<br>调入。</p>
<p>1.两级页表</p>
<p>对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页，并离散地将各个页面分别存放在不同的物理块中的办法来加以解决，同样也要为离散分配的页表再建立一张页表，称为外层页表（Outer Page Table），再每个页表项中记录了页表页面的物理块号。</p>
<p>下面我们仍以前面的 32 位逻辑地址空间为例来说明。当页面大小为 4 KB 时(12 位)，若采<br>用一级页表结构，应具有 20 位的页号，即页表项应有 1 兆个；在采用两级页表结构时，再<br>对页表进行分页，使每页中包含 210 (即 1024)个页表项，最多允许有 210个页表分页；或者<br>说，外层页表中的外层页内地址 P2为 10 位，外层页号 P1也为 10 位。此时的逻辑地址结构<br>可描述如下：</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="image"></p>
<p>由图可以看出，在页表的每个表项中存放的是进程的某页在内存中的物理块号，如第<br>0#页存放在 1#物理块中；1#页存放在 4#物理块中。而在外层页表的每个页表项中，所存放的<br>是某页表分页的首址，如第 0#页表是存放在第 1011#物理块中。我们可以利用外层页表和页<br>表这两级页表，来实现从进程的逻辑地址到内存中物理地址间的变换。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本分页存储管理方式&quot;&gt;&lt;a href=&quot;#基本分页存储管理方式&quot; class=&quot;headerlink&quot; title=&quot;基本分页存储管理方式&quot;&gt;&lt;/a&gt;基本分页存储管理方式&lt;/h2&gt;&lt;p&gt;连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。&lt;strong&gt;如果允许将一个进程直接分散地装入到许多不相邻接的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是端，则称为分段存储管理方式&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="存储管理" scheme="http://www.wangxinri.cn/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>连续分配存储方式</title>
    <link href="http://www.wangxinri.cn/2018/01/24/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.wangxinri.cn/2018/01/24/连续分配存储管理方式/</id>
    <published>2018-01-24T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:30.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常都要经过以下几个步骤：</p>
<a id="more"></a>
<ul>
<li>编译，由编译程序（Compiler）对用户源程序进行编译，形成若干个目标模块（Object Module）。</li>
<li>链接，由链接程序（Linker）将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块（Load Module）</li>
<li>装入，由装入程序（Loader）将装入模块装入内存。</li>
</ul>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>为了能将用户程序装入内存，必须为它分配一定大小的内存空间。<strong>连续分配方式</strong>是最早出现的一种存储器分配方式，<strong>该分配方式为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻</strong>。</p>
<p>连续分配方式可分为四类：<strong>单一连续分配</strong>、<strong>固定分区分配</strong>、<strong>动态分区分配</strong>以及<strong>动态重定位分区分配</strong>算法。</p>
<ul>
<li>单一连续分配：这是最简单的一种存储管理方式，但是<strong>只能用于单用户、单任务的操作系统中</strong>。采用这种存储管理方式时，可把内存分为系统区和用户区两部分。</li>
<li><p>固定分区分配：<strong>固定分区式分配是最简单的一种可运行多道程序的存储管理方式</strong>。这是将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行，当该作业结束时，又可再从后备作业队列中找到另一个作业调入该分区。</p>
<p> 划分分区的方法：</p>
<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
<p>内存分配：为了便于内存分配，通常将分区按大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配）。</p>
<p>固定分区分配，是最早的多道程序的存储管理方式，<strong>由于每个分区的大小固定，必然会造成存储空间的浪费，因而现在已很少将它用于通用计算机中</strong>。</p>
</li>
</ul>
<h3 id="动态分区分配（重点）"><a href="#动态分区分配（重点）" class="headerlink" title="动态分区分配（重点）"></a>动态分区分配（重点）</h3><p>动态分区分配是根据进程的实际需要，动态地为之分配内存空间。在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作这样三个问题。</p>
<h4 id="分区分配中的数据结构"><a href="#分区分配中的数据结构" class="headerlink" title="分区分配中的数据结构"></a>分区分配中的数据结构</h4><ul>
<li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。</li>
<li>空闲分区链。</li>
</ul>
<h4 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h4><p>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。目前常用的一下所述的五种分配算法。</p>
<p><strong>1.首次适应算法（first fit）</strong></p>
<p>我们以空闲分区链为例来说明采用 FF 算法时的分配情况。<strong>FF 算法要求空闲分区链以<br>地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要<br>求的空闲分区为止</strong>；然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，<br>余下的空闲分区仍留在空闲链中。若从链首直至链尾都不能找到一个能满足要求的分区，<br>则此次内存分配失败，返回。 <strong>该算法倾向于优先利用内存中低址部分的空闲分区，从而保<br>留了高址部分的大空闲区。这给为以后到达的大作业分配大的内存空间创造了条件。其缺<br>点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是<br>从低址部分开始，这无疑会增加查找可用空闲分区时的开销</strong> 。</p>
<p><strong>2.循环首次适应算法（next fit）</strong></p>
<p>该算法是由首次适应算法演变而成的。<strong>在为进程分配内存空间时，不再是每次都从链<br>首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满<br>足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业</strong>。为实现该算法，<br>应设置一起始查寻指针，用于指示下一次起始查寻的空闲分区，并采用循环查找方式，即<br>如果最后一个(链尾)空闲分区的大小仍不能满足要求，则应返回到第一个空闲分区，比较其<br>大小是否满足要求。找到后，应调整起始查寻指针。<strong>该算法能使内存中的空闲分区分布得<br>更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区</strong>。</p>
<p><strong>3.最佳适应算法（best fit）</strong></p>
<p>所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区<br>分配给作业，避免“大材小用”。为了加速寻找，<strong>该算法要求将所有的空闲分区按其容量以<br>从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区，必然是最<br>佳的</strong>。孤立地看，<strong>最佳适应算法似乎是最佳的，然而在宏观上却不一定。因为每次分配后<br>所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区</strong>。</p>
<p><strong>4.最坏适应算法（worst fit）</strong></p>
<p>最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给<br>作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业<br>有利，同时最坏适应分配算法查找效率很高。<strong>该算法要求将所有的空闲分区按其容量以从<br>大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。但是该算<br>法的缺点也是明显的，它会使存储器中缺乏大的空闲分区</strong>。<font color="red"> <strong>最坏适应算法与前面所述的首<br>次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法</strong>。 </font></p>
<p><strong>5.快速适应算法（quick fit）</strong></p>
<p><font color="red"> <strong>该算法又称为分类搜索法</strong> </font>，是将空闲分区根据其容量大小进行分类，对于每一类具有<br>相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区<br>链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，<br>并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进<br>行划分，如 2 KB、4 KB、8 KB 等，对于其它大小的分区，如 7 KB 这样的空闲区，既可以<br>放在 8 KB 的链表中，也可以放在一个特殊的空闲区链表中。</p>
<p>该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区<br>链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区<br>产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。</p>
<p>该算法的缺点是在分区归还主存时算法复杂，系统开销较大。此外，该算法在分配空<br>闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，<br>或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存<br>储空间浪费，这是典型的以空间换时间的作法。</p>
<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><p>在动态分区存储管理方式中，主要的操作是分配内存和回收内存。</p>
<p><strong>1）分配内存</strong></p>
<p>系统应利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。设请求的分区大<br>小为 u.size，表中每个空闲分区的大小可表示为 m.size。若 m.size-u.size≤size(size 是事先规定的不再切割的剩余分区的大小)，说明多余部分太小，可不再切割，将整个分区分配给请求者；否则(即多余部分超过size)，从该分区中按请求的大小划分出一块内存空间分配出去， 余下的部分仍留在空闲分区链(表)中。然后，将分配区的首址返回给调用者。图 4-7 示出了<br>分配流程。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<p><strong>2）回收内存</strong></p>
<p>当进程运行完毕是释放内存时，<strong>系统根据回收区的首址</strong>，从空闲区链（表）中找到响应的插入点，此时可能出现以下四种情况之一：</p>
<p>(1) 回收区与插入点的前一个空闲分区 F1相邻接，见图 4-8(a)。此时应将回收区与插入<br>点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区 F1的大小。</p>
<p>(2) 回收分区与插入点的后一空闲分区 F2相邻接，见图 4-8(b)。此时也可将两分区合并，<br>形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。</p>
<p>(3) 回收区同时与插入点的前、后两个分区邻接，见图 4-8(c)。此时将三个分区合并，<br>使用 F1的表项和 F1的首址，取消 F2的表项，大小为三者之和。</p>
<p>(4) 回收区既不与 F1邻接，又不与 F2邻接。这时应为回收区单独建立一新表项，填写<br>回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5.png" alt="image"></p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p><strong>固定分区和动态分区方式都有不足之处。固定分区方式限制了活动进程的数目，当进<br>程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空<br>闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对以上两种内存方式的一<br>种折衷方案</strong>。</p>
<p>伙伴系统规定，无论已分配分区或空闲分区，其大小均为 2 的 k 次幂，k 为整数，<br>l≤k≤m，其中：21 表示分配的最小分区的大小，2m 表示分配的最大分区的大小，通常 2m<br>是整个可分配内存的大小。</p>
<p>假设系统的可利用空间容量为 2m个字，则系统开始运行时，整个内存区是一个大小为 2m<br>的空闲分区。在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区，<br>将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独<br>设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了 k(0≤k≤m)个空闲分区链表。</p>
<p>当需要为进程分配一个长度为 n 的存储空间时，首先计算一个 i 值，使 2i－1&lt;n≤2i，然<br>后在空闲分区大小为 2i 的空闲分区链表中查找。若找到，即把该空闲分区分配给进程。否<br>则，表明长度为 2i 的空闲分区已经耗尽，则在分区大小为 2i＋1 的空闲分区链表中寻找。若<br>存在 2i＋1 的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙<br>伴，其中的一个分区用于分配，而把另一个加入分区大小为 2i 的空闲分区链表中。若大小<br>为 2i＋1的空闲分区也不存在，则需要查找大小为 2i＋2的空闲分区，若找到则对其进行两次分<br>割：第一次，将其分割为大小为 2i＋1 的两个分区，一个用于分配，一个加入到大小为 2i＋1<br>的空闲分区链表中；第二次，将第一次用于分配的空闲区分割为 2i 的两个分区，一个用于<br>分配，一个加入到大小为 2i 的空闲分区链表中。若仍然找不到，则继续查找大小为 2i＋3 的<br>空闲分区，以此类推。由此可见，在最坏的情况下，可能需要对 2k的空闲分区进行 k 次分<br>割才能得到所需分区。</p>
<p>与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，如回收大小<br>为 2i的空闲分区时，若事先已存在 2i的空闲分区时，则应将其与伙伴分区合并为大小为<br>2i＋1的空闲分区，若事先已存在 2i＋1的空闲分区时，又应继续与其伙伴分区合并为大小为<br>2i＋2的空闲分区，依此类推。</p>
<p>在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空<br>闲分区所花费的时间。与前面所述的多种方法相比较，由于该算法在回收空闲分区时，需<br>要对空闲分区进行合并，所以其时间性能比前面所述的分类搜索算法差，但比顺序搜索算<br>法好，而其空间性能则远优于前面所述的分类搜索法，比顺序搜索法略差。</p>
<p>需要指出的是，<strong>在当前的操作系统中，普遍采用的是下面将要讲述的基于分页和分段<br>机制的虚拟内存机制</strong>，该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系<br>统仍不失为一种有效的内存分配和释放的方法，得到了大量的应用。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>在上述的分类搜索算法（快速适应算法（quick fit））和伙伴系统中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在一张管理索引表中查找所需空间大小所对应的表项，从中得到对应的空闲分区链表表头指针，从而通过查找得到一个空闲分区。如果对空闲愤怒分类较细，则相应的空闲分区链表也较多，因此选择合适的空闲链表的开销也相应增加，且时间性能降低。</p>
<p><strong>哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</strong></p>
<p>当进行空闲分区分配时，<strong>根据所需空间分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略</strong>。</p>
<h3 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h3><ol>
<li>动态重定位的引入</li>
</ol>
<p><strong>在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间</strong>。如果在系统中只有若干个小的区块，即使它们的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。这些不能被利用的小分区称为“零头”或“碎片”。</p>
<p>若想把作业装入，可采用的一种方法是：将内存中的所有作业进行移动，使它们全都相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时就可把作业装入该区。这种通过移动内存中作业的位置，以把原来多个分散的小分区拼接成一个大分区的方法，称为“拼接”或“紧凑”，见下图，由于经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，<strong>在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。</strong></p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E7%B4%A7%E5%87%91%E7%9A%84%E7%A4%BA%E6%84%8F.png" alt="image"></p>
<ol>
<li>动态重定位的实现</li>
</ol>
<p>在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，<strong>即须在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址</strong>。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p>
<p>图 4-10 示出了动态重定位的实现原理。<br><strong>地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态<br>重定位</strong>。当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时，不需对<br>程序做任何修改，只要用该程序在内存的新起始地址，去置换原来的起始地址即可</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p>
<ol>
<li>动态重定位分区分配算法</li>
</ol>
<p>动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：这种分配算法中，增加了紧凑的功能，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。如下图：</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p>
<h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><p>1.对换的引入</p>
<p>在多道程序环境下，一方面，在内存中某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降。为了解决这一问题，在系统中又增设了对换（也称交换）设施。<strong>所谓“对换”，是指把内存中暂时不能运行的内存或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施</strong>。</p>
<p><strong>如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”</strong>。这种对换被<br>广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用<br>率。<strong>而如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段<br>对换”，又统称为“部分对换”</strong>。这种对换方法是实现后面要讲到的请求分页和请求分段式<br>存储管理的基础，其目的是为了支持虚拟存储系统。在此，我们只介绍进程对换，而分页<br>或分段对换将放在虚拟存储器中介绍。<strong>为了实现进程对换，系统必须能实现三方面的功能：<br>对换空间的管理、进程的换出，以及进程的换入</strong></p>
<p>2．对换空间的管理</p>
<p><strong>在具有对换功能的 OS 中，通常把外存分为文件区和对换区。前者用于存放文件，后者<br>用于存放从内存换出的进程</strong>。由于通常的文件都是较长久地驻留在外存上，故对文件区管理<br>的主要目标，是提高文件存储空间的利用率，为此，<strong>对文件区采取离散分配方式</strong>。然而，进<br>程在对换区中驻留的时间是短暂的，对换操作又较频繁，故对对换空间管理的主要目标，<br>是提高进程换入和换出的速度。为此，<strong>对换区采取的是连续分配方式</strong>，较少考虑外存中的碎片问题。</p>
<p>为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外<br>存的使用情况。<strong>其形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空<br>闲分区表或空闲分区链</strong>。在空闲分区表中的每个表目中应包含两项，即对换区的首址及其<br>大小，分别用盘块号和盘块数表示。</p>
<p><strong>由于对换分区的分配是采用连续分配方式，因而对换空间的分配与回收，与动态分区<br>方式时的内存分配与回收方法雷</strong>同。其分配算法可以是首次适应算法、循环首次适应算法<br>或最佳适应算法。具体的分配操作，也与图 4-7 中内存的分配过程相同，这里不再赘述。</p>
<ol>
<li>进程的换出和换入</li>
</ol>
<p>（1）进程的换出。每当一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。其过程是：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。若传送过程未出现错误，便可回收进程所占用的内存空间，并对该进程和进程控制块做相应的修改。</p>
<p>（2）进程的换入。系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间最久（换出到磁盘上）的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序的装入和链接&quot;&gt;&lt;a href=&quot;#程序的装入和链接&quot; class=&quot;headerlink&quot; title=&quot;程序的装入和链接&quot;&gt;&lt;/a&gt;程序的装入和链接&lt;/h2&gt;&lt;p&gt;用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常都要经过以下几个步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="存储管理" scheme="http://www.wangxinri.cn/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>调度算法</title>
    <link href="http://www.wangxinri.cn/2018/01/22/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <id>http://www.wangxinri.cn/2018/01/22/处理机调度/</id>
    <published>2018-01-22T13:59:00.000Z</published>
    <updated>2018-04-06T13:49:32.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>在多道程序环境下，内存中存在着多个进程，其数目往往多于处理机数目。这就要求系统能按某种算法，动态地将处理机分配给处于就绪状态的一个进程、使之执行。分配处理机的任务是由处理机调度程序完成的。对于大型系统运行时的性能，如系统吞吐量、资源利用率、作业周转时间或响应的及时性等，在很大程度上都取决于处理机调度性能的好坏。因而，处理机调度便成为OS中至关重要的部分。</p>
<a id="more"></a>
<h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><p><strong>1.先来先服务(FCFS)调度算法</strong></p>
<p>该算法即可用于作业调度，也可用于进程调度</p>
<p><strong>2.短作业优先(short job first SJF)的调度算法</strong></p>
<p>可以分别作用于作业调度和进程调度，作业的长度是以作业所要求的运行时间来衡量的（预估时间）。</p>
<p><strong>3.优先级调度算法（PSA）</strong></p>
<p>可以作为作业调度算法，也可作为进程调度算法。根据优先级进行调度。</p>
<p><strong>4.高响应比优先调度算法（HRRN)</strong></p>
<p>为每个作业引入一个动态优先级，即优先级可以改变，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。</p>
<p><strong>优先权 = (等待时间+要求服务时间)/要求服务时间</strong></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>早期所采用的非抢占方式存在着很大的局限性，很难满足交互性作业和实时任务的需求。为此，在进程调度中又引入了抢占方式。</p>
<ul>
<li>非抢占方式</li>
<li><p>抢占方式</p>
<p> 1.优先权原则<br> 2.短进程优先原则<br> 3.时间片原则</p>
</li>
</ul>
<h4 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h4><p>基于时间片的的轮转（RR）调度算法。系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并设置每隔一定时间间隔（如30ms）即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程（或新到达的紧迫进程）。由此，可保证就绪队列中的所有进程在一个确定的时间段内，都能够获得一次CPU执行。</p>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p>1、设有N个队列（Q1,Q2….QN），其中各个队列对于处理机的优先级是不一样的，也就是说位于各个队列中的作业(进程)的优先级也是不一样的。一般来说，优先级Priority(Q1) &gt; Priority(Q2) &gt; … &gt; Priority(QN)。怎么讲，位于Q1中的任何一个作业(进程)都要比Q2中的任何一个作业(进程)相对于CPU的优先级要高（也就是说，Q1中的作业一定要比Q2中的作业先被处理机调度），依次类推其它的队列。</p>
<p>2、对于某个特定的队列来说，里面是遵循时间片轮转法。也就是说，位于队列Q2中有N个作业，它们的运行时间是通过Q2这个队列所设定的时间片来确定的（为了便于理解，我们也可以认为特定队列中的作业的优先级是按照FCFS来调度的）。</p>
<p>3、各个队列的时间片是一样的吗？不一样，这就是该算法设计的精妙之处。各个队列的时间片是随着优先级的增加而减少的，也就是说，优先级越高的队列中它的时间片就越短。同时，为了便于那些超大作业的完成，最后一个队列QN(优先级最低的队列)的时间片一般很大(不需要考虑这个问题)。</p>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><h4 id="最早截止时间优先EDF算法"><a href="#最早截止时间优先EDF算法" class="headerlink" title="最早截止时间优先EDF算法"></a>最早截止时间优先EDF算法</h4><p><strong>该算法是根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机</strong>。最早截止时间优先算法即可用于抢占式调度，也可用于非抢占式调度方式。</p>
<h4 id="最低松弛度优先LLF算法"><a href="#最低松弛度优先LLF算法" class="headerlink" title="最低松弛度优先LLF算法"></a>最低松弛度优先LLF算法</h4><p>该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。例如，一个任务在200ms时必须完成，而它本身所需的运行时间是100ms，因此调度程序必须在100ms之前调度执行，该任务的紧急程度（松弛程度）为100ms。<strong>在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在最前面，调度程序选择队列中的队首任务执行</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;处理机调度&quot;&gt;&lt;a href=&quot;#处理机调度&quot; class=&quot;headerlink&quot; title=&quot;处理机调度&quot;&gt;&lt;/a&gt;处理机调度&lt;/h2&gt;&lt;p&gt;在多道程序环境下，内存中存在着多个进程，其数目往往多于处理机数目。这就要求系统能按某种算法，动态地将处理机分配给处于就绪状态的一个进程、使之执行。分配处理机的任务是由处理机调度程序完成的。对于大型系统运行时的性能，如系统吞吐量、资源利用率、作业周转时间或响应的及时性等，在很大程度上都取决于处理机调度性能的好坏。因而，处理机调度便成为OS中至关重要的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="调度" scheme="http://www.wangxinri.cn/tags/%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://www.wangxinri.cn/2018/01/20/%E6%AD%BB%E9%94%81/"/>
    <id>http://www.wangxinri.cn/2018/01/20/死锁/</id>
    <published>2018-01-20T13:59:00.000Z</published>
    <updated>2018-04-06T13:40:41.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁：指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都讲无法向前推进。</strong></p>
<p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的（Deadlock)。</p>
<a id="more"></a>
<h3 id="计算机系统中的死锁"><a href="#计算机系统中的死锁" class="headerlink" title="计算机系统中的死锁"></a>计算机系统中的死锁</h3><ul>
<li>竞争不可抢占性资源引发死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ul>
<p><strong>产生死锁的必要条件</strong></p>
<ul>
<li><strong>互斥条件</strong>。即在一段时间内，某资源只能被一个进程占用。</li>
<li><strong>请求和保持条件</strong>。进程已经保持了至少一个资源，但又提出了新的资源请求，该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li><strong>不可抢占条件</strong>。</li>
<li><strong>循环等待条件</strong>。在发生死锁时，必然存在一个进程-资源的循环链，即进程集合{p0,p1,…,pn}中的p0正在等待一个p1占用的资源，p1正在等待p2占用的资源，…pn正在等待已被p0占用的资源。</li>
</ul>
<p><strong>处理死锁的方法</strong></p>
<p>目前处理死锁的方法可归结为四种。</p>
<p><strong>预防死锁</strong> ：实现预防方法，该方法通过设置某些限制条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。</p>
<ul>
<li><strong>避免死锁</strong>：同样属于事先预防策略，在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免发生死锁。</li>
<li><strong>检测死锁</strong>：允许运行过程中发生死锁。但可通过检测机构及时的检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。</li>
<li><strong>解除死锁</strong>：当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。常用的方法是撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其能继续运行。</li>
</ul>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏产生死锁的后三个条件。</p>
<ul>
<li><strong>破坏请求和保持</strong></li>
</ul>
<p>第一种协议：一次性申请其在整个运行过程中的全部资源。</p>
<p>第二种协议：允许一个进程只获得运行初期所需的资源后，便开始运行，进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。</p>
<ul>
<li><strong>破坏不可抢占条件</strong></li>
</ul>
<p>当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。</p>
<ul>
<li><strong>破坏循环等待条件</strong></li>
</ul>
<p>一个能保证“循环等待”条件不成立的方法是，对系统的所有资源类型进行线性排序，并赋予不同的序号，这样不可能再出现环路，因而破坏了“循环等待”条件。</p>
<h3 id="避免死锁-（银行家算法）"><a href="#避免死锁-（银行家算法）" class="headerlink" title="避免死锁 （银行家算法）"></a>避免死锁 （银行家算法）</h3><p><strong>避免死锁的基本思想：</strong> 确保系统始终处于安全状态，一个系统开始是处于安全状态的。当有进程请求一个可用资源时，系统需对该进程的请求进行计算，若将资源分配给进程后系统仍处于安全状态，才将该资源分配给进程。</p>
<p><strong>利用银行家算法来避免死锁</strong> </p>
<p>当前序列是安全的，即当前状态不会发生死锁。此时如果某个进程请求资源，当前资源如果小于等于它需要的值，执行下一步，否则，返回异常；</p>
<p>继续判断需求的资源值是否小于等于系统中尚有的可用资源数，如果大于，则需等待其它进程释放资源，否则，系统试探性的将资源分配给该进程，并修改相应的资源数</p>
<p>接着系统调用安全判定算法，如果安全，也就是存在一个安全系列，资源分配成功；如果不安全，恢复原来的资源分配状态，让该进程继续等待。</p>
<p><strong>银行家算法</strong>：</p>
<p>我们将第i个进程请求的资源数记为Requests[i]。</p>
<p>1.如果Requests[i]&lt;=Need[i]，则转到第二步。否则，返回异常。这一步是控制进程申请的资源不得大于需要的资源。</p>
<p>2.如果Requests[i]&lt;=Available，则转到第三步，否则表示尚无足够资源，pi需等待。</p>
<p>3.如果满足前两步，那么做如下操作：</p>
<p>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Available = Available -Requests[i]   </div><div class="line">Allocation = Allocation[i]+Requests[i]</div><div class="line">Need[i]=Need[i]-Requests[i]</div></pre></td></tr></table></figure>
<p>4.调用安全判定算法，检查是否安全<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(安全)</div><div class="line">&#123;</div><div class="line">    申请成功，资源分配</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    申请失败，资源撤回。第三步前几个操作进行逆操作</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.cnblogs.com/chuxiuhong/p/6103928.html" target="_blank" rel="external">参考链接：银行家算法学习笔记</a></p>
<h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p>如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能会发生死锁。在这种情况下，系统应当提供两个算法：<br>​                              </p>
<ul>
<li>死锁检测算法。该方法用于检测系统状态，以确定系统中是否发生了死锁。</li>
<li>死锁解除算法。当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>
</ul>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>系统死锁，可利用<strong>资源分配图</strong>来描述。如图所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</p>
<p>所示的资源分配图中，进程P1已经分得了两个R1资源，并又请求一个R2资源；进程P2分得了一个R1和一个R2资源，并又请求一个R1资源。</p>
<p><strong>死锁定理</strong><br><strong>可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态</strong>。简化方法如下：</p>
<p>1) 在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图2-18(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到图248(b)所示的情况。</p>
<p>2) 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图2-17中，进程P2就满足这样的条件。根据第1)条中的方法进行一系列简化后,<strong>若能消去图中所有的边，则称该图是可完全简化</strong>的，如图2-18(c)所示。</p>
<p><strong>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理</strong>。 </p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="image"></p>
<h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>常采用解除死锁的两种方法：</p>
<ul>
<li><strong>抢占资源</strong>。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</li>
<li><strong>终止（或撤销）进程</strong>。终止（或撤销）系统中的一个或多个死锁进程，直到打破循环环路，使系统从死锁状态解脱出来。</li>
</ul>
<ol>
<li>终止进程的方法</li>
</ol>
<ul>
<li><strong>终止所有死锁进程</strong></li>
<li><strong>逐个终止进程</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;死锁：指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都讲无法向前推进。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的（Deadlock)。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="http://www.wangxinri.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>经典进程同步问题</title>
    <link href="http://www.wangxinri.cn/2018/01/15/%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://www.wangxinri.cn/2018/01/15/经典进程同步问题/</id>
    <published>2018-01-15T13:59:00.000Z</published>
    <updated>2018-04-06T13:37:14.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经典进程同步问题：生产者-消费者问题、哲学家进餐问题、读者-写者问题，通过信号量来实现进程之间的同步。</p>
<a id="more"></a>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p><strong>1.利用记录型信号量解决生产者-消费者问题</strong></p>
<p>假定在生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可利用互斥信号mutex实现诸进程对缓冲池的互斥使用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> in = <span class="number">0</span>,out = <span class="number">0</span>;</div><div class="line">item buffer[n];</div><div class="line">semaphore mutex = <span class="number">1</span>,empty = n,full=<span class="number">0</span>;</div><div class="line"><span class="keyword">void</span> producer&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        producer an item nextp;</div><div class="line">        ...</div><div class="line">        wait(empty);</div><div class="line">        wait(mutex);</div><div class="line">        buffer[in] = nextp;</div><div class="line">        in = (in+<span class="number">1</span>)%n;</div><div class="line">        signal(mutex);</div><div class="line">        signal(full);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        wait(full);</div><div class="line">        wait(mutex);</div><div class="line">        nextc = buffer[out];</div><div class="line">        out = (out+<span class="number">1</span>)%n;</div><div class="line">        signal(mutex);</div><div class="line">        signal(empty);</div><div class="line">        consumer the item in nextc;</div><div class="line">        ...</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    cobegin</div><div class="line">        producer(); consumer();</div><div class="line">    coend</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2.利用And信号量解决生产者-消费者问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> in = <span class="number">0</span>,out = <span class="number">0</span>;</div><div class="line">item buffer[n];</div><div class="line">semaphore mutex = <span class="number">1</span>,empty = n,full=<span class="number">0</span>;</div><div class="line"><span class="keyword">void</span> producer&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        producer an item nextp;</div><div class="line">        ...</div><div class="line">        Swait(empty,mutex);</div><div class="line">        buffer[in] = nextp;</div><div class="line">        in = (in+<span class="number">1</span>)%n;</div><div class="line">        Ssignal(mutex,full);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        Swait(full,mutex);</div><div class="line">        nextc = buffer[out];</div><div class="line">        out = (out+<span class="number">1</span>)%n;</div><div class="line">        Ssignal(mutex,empty);</div><div class="line">        consumer the item in nextc;</div><div class="line">        ...</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    cobegin</div><div class="line">        producer(); consumer();</div><div class="line">    coend</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>五个哲学家共用一张圆桌，分别坐在周围的五个椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替的进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。</p>
<p><strong>1.利用记录型信号量解决哲学家进餐问题</strong></p>
<p>经分析，放在桌子上的筷子时临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</div></pre></td></tr></table></figure>
<p>所有信号量均被初始化为1，第i为哲学家的活动可描述为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    wait(chopstick[i]);</div><div class="line">    wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">    ...</div><div class="line">    <span class="comment">//eat</span></div><div class="line">    ...</div><div class="line">    signal(chopstick[i]);</div><div class="line">    signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">    ...</div><div class="line">    <span class="comment">//think</span></div><div class="line">    ...</div><div class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>假如五位哲学家同时各自拿起左边的筷子时，就会使五个信号量chopstick为0，当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。对于这种死锁问题，可采取一下几种解决方法。</p>
<p><strong>首先给出两个断言：</strong></p>
<p>（1）系统中有N个并发进程。若规定每个进程需要申请2个某类资源，则当系统提供N+1个同类资源时，无论采用何种方式申请资源， 一定不会发生死锁。分析：N+1个资源被N 个进程竞争， 由抽屉原理可知， 则至少存在一个进程获2个以上的同类资源。这就是前面提到的哲学家就餐问题中5个哲学家提供6支筷子时一定不会发生死锁的原因。</p>
<p>（2）系统中有N个并发进程。若规定每个进程需要申请R个某类资源，则当系统提供K＝N*（R-1）+1个同类资源时，无论采用何种方式申请使用，一定不会发生死锁。分析：在最坏的情况下，每个进程都申请到R-1个同类资源， 此时它们均阻塞。 试想若系统再追加一个同类资源， 则 N 个进程中必有一个进程获得R个资源，死锁解除。 </p>
<p><strong>(1)破坏请求保持条件</strong></p>
<p>利用原子思想完成。即只有拿起两支筷子的哲学家才可以进餐，否则，一支筷子也不拿。</p>
<p><strong>解法一：利用AND机制实现第i位哲学家的活动描述为：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> i)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        think;</div><div class="line">        swait(chopstick[(i+<span class="number">1</span>)]%<span class="number">5</span>，chopstick[i])；</div><div class="line">        eat;</div><div class="line">        Ssignal(chopstick[i]，chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解法二：利用记录型信号量机制实现在初始化中增加一个信号量定义：semaphore mutex=1：<br>该方法将拿两只筷子的过程作为临界资源，一次只允许一个哲学家进入。</strong></p>
<p>第I位哲学家的活动描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> I)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        思考;</div><div class="line">        wait(mutex)；</div><div class="line">        wait(stiCk[I]);</div><div class="line">        wait(Stick[(I+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">        signal(mutex)；</div><div class="line">        进餐；</div><div class="line">        signal(stick[I]);</div><div class="line">        Signal(Stick[(I+<span class="number">1</span>)%<span class="number">5</span>])；</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>(2)破坏环路等待条件</strong></p>
<p><strong>解法一</strong>：奇数号哲学家先拿他左边的筷子，偶数号哲学家先拿他右边的筷子。这样破坏了同方向环路，一个哲学家拿到一只筷子后，就阻止了他邻座的一个哲学家吃饭。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。算法描述如下：</p>
<p>1)第i个哲学家的活动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> I)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        思考;</div><div class="line">        If I%<span class="number">2</span>==<span class="number">1</span> then</div><div class="line">            wait(Stick[I]);</div><div class="line">            wait(stick[(I+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">            进餐;</div><div class="line">            signal(stick[I])；</div><div class="line">            signal(stick[(I+<span class="number">1</span>)%<span class="number">5</span>]);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            wait(stick[(I+<span class="number">1</span>)%<span class="number">5</span>])；</div><div class="line">            wait(stick[I]);</div><div class="line">            进餐；</div><div class="line">            signal(stick[(I+<span class="number">1</span>)%<span class="number">5</span>])；</div><div class="line">            signal(stick[I]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解法二</strong>：至多允许四位哲学家进餐，将最后一个哲学家停止申请资源，断开环路。最终能保证有一位哲学家能进餐，用完释放两只筷子，从而使更多的哲学家能够进餐。增加一个信号量定义semaphore count=4：算法描述第1个哲学家的活动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">philosopher (<span class="keyword">int</span> I)&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">        思考；</div><div class="line">        wait(count)；</div><div class="line">        wait(chopstiok[I])；</div><div class="line">        wait(chopstick[I+<span class="number">1</span>]%<span class="number">5</span>)；</div><div class="line">        进餐;</div><div class="line">        signal(chopstick[I])；</div><div class="line">        signal(chopstick[I+<span class="number">1</span>]%<span class="number">5</span>)</div><div class="line">        signal(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>允许多个进程同时读一个共享对象，但不允许一个write进程和其他reader进程或writer进程同时访问共享对象。所谓读者-写者问题是指：<strong>保证一个writer进程必须与其他进程互斥地访问共享对象的同步问题。</strong></p>
<p><strong>1.记录型信号量解决读者-写者问题</strong></p>
<p>为实现reader和writer之间的互斥而设置一个互斥信号量wmutex。同时，增加一个count计数器，用来记录reader进程的个数，reader进程执行时，并且count==0时，此时wait(wmutex)，禁止写进程去写，然后++count；reader进程执行完毕后，–count，如果count ==0时，此时表示无reader进程，则signal(wmutex)，允许writer去写。同时由于reader进程互斥的共享count，所以我们设置一个rmutex来互斥访问count。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">seamphore rmutex=<span class="number">1</span>,wmutex=<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        wait(rmutex);</div><div class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) wait(wmutex)</div><div class="line">        ++count;</div><div class="line">        signal(rmutex);</div><div class="line">        ...</div><div class="line">        reader</div><div class="line">        ...</div><div class="line">        wait(rmutex);</div><div class="line">        --count;</div><div class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) signal(wmutex);</div><div class="line">        signal(rmutex);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        wait(wmutex);</div><div class="line">        ...</div><div class="line">        writer</div><div class="line">        ...</div><div class="line">        signal(wmutex);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    cobegin</div><div class="line">        reader(); writer();</div><div class="line">    coend</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2.利用信号量集机制解决读者-写者问题</strong></p>
<p>Swait((S,1,0)：是一种很特殊且很有用的信号量操作。当S&gt;=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个开关。</p>
<p>这里我们增加一个限制，即最多允许RN个读者同时读。为此我们引入一个信号量L，并赋予其初值为RN，通过执行Swait(L,1,1)来控制读者的数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> RN;   <span class="comment">//最多允许RN个读者同时读</span></div><div class="line">semaphore L = RN,mx = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        Swait(L,<span class="number">1</span>,<span class="number">1</span>);   <span class="comment">//L个资源（读进程），每次分配1个，当L&lt;1时，无法分配资源，阻塞</span></div><div class="line">        SWait(mx,<span class="number">1</span>,<span class="number">0</span>);  <span class="comment">//mx&gt;=1,允许多个读进程进程进入</span></div><div class="line">        ...</div><div class="line">        read</div><div class="line">        ...</div><div class="line">        Ssignal(L,<span class="number">1</span>);     <span class="comment">//释放L资源（读者数被释放+1）</span></div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        Swait(mx,<span class="number">1</span>,<span class="number">1</span>;L,RN,<span class="number">0</span>);  <span class="comment">//表示仅当既无writer进程在写操作（mx=1)、又无reader进程在读操作（L=RN)时，writer进程才能进入临界区</span></div><div class="line">        ...</div><div class="line">        writer</div><div class="line">        ...</div><div class="line">        signal(mx,<span class="number">1</span>);</div><div class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经典进程同步问题：生产者-消费者问题、哲学家进餐问题、读者-写者问题，通过信号量来实现进程之间的同步。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.wangxinri.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="http://www.wangxinri.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多重继承与虚继承</title>
    <link href="http://www.wangxinri.cn/2017/12/04/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.wangxinri.cn/2017/12/04/多重继承与虚继承/</id>
    <published>2017-12-04T02:59:00.000Z</published>
    <updated>2018-02-23T08:00:41.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p><strong>多重继承</strong>（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</p>
<a id="more"></a>
<h3 id="多重派生"><a href="#多重派生" class="headerlink" title="多重派生"></a>多重派生</h3><p>在派生类的派生列表中可以包含多个基类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Bear : public ZooAnimal &#123; /* ... */ &#125;;</div><div class="line">class Panda : public Bear,public Endangered &#123; /* ... */ &#125;;</div></pre></td></tr></table></figure>
<p><strong>和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的</strong>。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。</p>
<h4 id="多重继承的派生类从每个基类中继承状态"><a href="#多重继承的派生类从每个基类中继承状态" class="headerlink" title="多重继承的派生类从每个基类中继承状态"></a>多重继承的派生类从每个基类中继承状态</h4><p>在多重继承关系中，派生类的对象包含有每个基类的子对象。在panda对象中含有Bear部分（其中又含有ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。</p>
<p><img src="http://ou6yob3zd.bkt.clouddn.com/201712041506.png" alt="image"></p>
<h4 id="派生类构造函数初始化所有基类"><a href="#派生类构造函数初始化所有基类" class="headerlink" title="派生类构造函数初始化所有基类"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象。但只能初始化它的直接基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//显式地初始化所有基类</span></div><div class="line">Panda::Panda(<span class="built_in">string</span> name,<span class="keyword">bool</span> onExhibit):Bear(name,onExhibit,<span class="string">"Panda"</span>),Endangered(Endangered::critical) &#123;&#125;</div><div class="line"><span class="comment">//隐式地使用Bear的默认构造函数初始化Bear子对象</span></div><div class="line">Panda::Panda():Endangered(Endangered::critical) &#123;&#125;</div></pre></td></tr></table></figure>
<p>派生类的构造函数初始化列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类出现顺序一致，而与派生类构造函数初始值列表中基类的顺序无关。</p>
<p>一个Panda对象按照如下词序进行初始化：</p>
<ul>
<li>ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。</li>
<li>接下来初始化Panda的第一个直接基类Bear。</li>
<li>然后初始化Panda的第二个直接基类Endangered。</li>
<li>最后初始化Panda。</li>
</ul>
<h4 id="继承的构造函数与多重继承"><a href="#继承的构造函数与多重继承" class="headerlink" title="继承的构造函数与多重继承"></a>继承的构造函数与多重继承</h4><p>在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span>&#123;</span></div><div class="line">    Base1() <span class="keyword">default</span>;</div><div class="line">    Base1(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div><div class="line">    Base1(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span></div><div class="line">    Base2() = <span class="keyword">default</span>;</div><div class="line">    Base2(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div><div class="line">    Base2(<span class="keyword">int</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//错误：D1试图从两个基类中都继承D1::D1(const string&amp;)</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2 &#123;</div><div class="line">    <span class="keyword">using</span> Base1::Base1;      <span class="comment">//从Base1继承构造函数</span></div><div class="line">    <span class="keyword">using</span> Base2::Base2;      <span class="comment">//从Base2继承构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2 &#123;</div><div class="line">    <span class="keyword">using</span> Base1::Base1;      <span class="comment">//从Base1继承构造函数</span></div><div class="line">    <span class="keyword">using</span> Base2::Base2;      <span class="comment">//从Base2继承构造函数</span></div><div class="line">    <span class="comment">//D2必须自定义一个接受string的构造函数</span></div><div class="line">    D2(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s):Base1(s),Base2(s) &#123;&#125;</div><div class="line">    D2() = <span class="keyword">default</span>;  <span class="comment">//一旦定义了自己的构造函数，系统不提供默认构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="析构函数与多重继承"><a href="#析构函数与多重继承" class="headerlink" title="析构函数与多重继承"></a>析构函数与多重继承</h4><p>和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</p>
<p>析构函数的调用顺序正好与构造函数相反。</p>
<h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。</p>
<p>与只有一个基类的继承一样，<strong>对象、指针或引用的静态类型决定了我们能够使用哪些成员。</strong><br>如果我们使用一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered特有的部分都不可见。</p>
<h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>在只有一个基类的情况下，派生类的作用域嵌套在直接和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。</p>
<p>在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。</p>
<p>在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。</p>
<p>为避免产生多个子对象，在C++语言中我们通过<strong>虚继承</strong>（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为<strong>虚基类</strong>（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</p>
<p><strong>note: 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</strong></p>
<h3 id="使用虚基类"><a href="#使用虚基类" class="headerlink" title="使用虚基类"></a>使用虚基类</h3><p>我们指定虚基类的方式是在派生列表中添加关键字virtual：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关键字public和virtual的顺序随意</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccoon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123; <span class="comment">/* ... */</span>&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal &#123; <span class="comment">/* ... */</span>&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类</p>
<p>virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。</p>
<p>如果某个类指定了虚基类，则该类的派生仍按常规方式进行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> :</span> <span class="keyword">public</span> Bear,<span class="keyword">public</span> Raccoon,<span class="keyword">public</span> Endangered&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Panda中只有一个ZooAnimal基类部分</p>
<h3 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h3><p>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。</p>
<p>与非虚的多重继承体系一样，<strong>解决这种二义性问题最好的方法是在派生类中为成员自定义新的示例。</strong></p>
<h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p><strong>在虚派生中，虚基类是由最底层的派生类（也就是最最后面的派生类）初始化的。</strong>，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。</p>
<p>为了理解这一规则，我们不妨假设当以普通规则处理初始任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。</p>
<p>当创建一个Bear（或Raccoon）的对象时，将直接初始化其ZooAnimal基类部分。</p>
<p>当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Panda::Panda(<span class="built_in">string</span> name,<span class="keyword">bool</span> onExhibit):ZooAnimal(name,onExhibit,<span class="string">"Panda"</span>),</div><div class="line">                Bear(name,onExhibit),Raccoon(name,onExhibit),</div><div class="line">                Endangered(Endangered::critical),sleeping_flag(<span class="literal">false</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="虚继承的对象的构造方式"><a href="#虚继承的对象的构造方式" class="headerlink" title="虚继承的对象的构造方式"></a>虚继承的对象的构造方式</h3><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。</p>
<p>例如：当我们创建一个Panda对象时：</p>
<ul>
<li>首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。</li>
<li>接下来构造Bear部分</li>
<li>然后构造Raccoon部分</li>
<li>然后构造第三个直接基类Endangered</li>
<li>最后构造Panda部分</li>
</ul>
<p>如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。</p>
<p><strong>note: 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</strong></p>
<h3 id="构造函数与析构函数的次序"><a href="#构造函数与析构函数的次序" class="headerlink" title="构造函数与析构函数的次序"></a>构造函数与析构函数的次序</h3><p>一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> &#123;</span> ...&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character &#123; ...&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span> &#123;</span> ...&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BookCharacter,<span class="keyword">public</span> Bear,<span class="keyword">public</span> <span class="keyword">virtual</span> ToyAnimal &#123;...&#125;;</div></pre></td></tr></table></figure>
<p>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，创建一个TeddyBear对象，需要按照如下次序调用这些构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ZooAnimal();      //Bear的虚基类</div><div class="line">ToyAnimal();      //直接虚基类</div><div class="line">Character();      //第一个非虚基类的间接基类</div><div class="line">BookCharacter();     //第一个直接非虚基类</div><div class="line">Bear();           //第二个直接非虚基类</div><div class="line">TeddyBear();      //最低层的派生类</div></pre></td></tr></table></figure>
<p>合成的拷贝和移动构造函数按照完成相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后ZooAnimal部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多重继承与虚继承&quot;&gt;&lt;a href=&quot;#多重继承与虚继承&quot; class=&quot;headerlink&quot; title=&quot;多重继承与虚继承&quot;&gt;&lt;/a&gt;多重继承与虚继承&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;多重继承&lt;/strong&gt;（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="虚继承" scheme="http://www.wangxinri.cn/tags/%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>异常处理与命令空间</title>
    <link href="http://www.wangxinri.cn/2017/12/03/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4/"/>
    <id>http://www.wangxinri.cn/2017/12/03/异常处理与命令空间/</id>
    <published>2017-12-03T02:59:00.000Z</published>
    <updated>2018-02-23T08:03:17.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>异常处理</strong>（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。</p>
<a id="more"></a>
<p>当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。</p>
<p>因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。</p>
<h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><p>当抛出一个异常时，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch字句。当throw出现在一个<strong>try语句块</strong>内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。</p>
<p>上述过程被称为<strong>栈展开</strong>（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。</p>
<p>假设找到了一个匹配的catch字句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。</p>
<p>如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数<strong>terminate</strong>，顾名思义，terminate负责终止程序的执行过程。</p>
<p><strong>note:</strong> 一个异常如果没有被捕获，则它将终止当前的程序。</p>
<h3 id="栈展开过程中对象被自动销毁"><a href="#栈展开过程中对象被自动销毁" class="headerlink" title="栈展开过程中对象被自动销毁"></a>栈展开过程中对象被自动销毁</h3><p>块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。</p>
<p>如果异常发生在构造函数中，则当前的对象可能只构造了一部分。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。数组或标准库容器的元素初始化过程中，也是一样的。</p>
<h3 id="析构函数与异常"><a href="#析构函数与异常" class="headerlink" title="析构函数与异常"></a>析构函数与异常</h3><p>在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。</p>
<h3 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h3><p>异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。</p>
<p>异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。</p>
<p>当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>catch子句中的<strong>异常声明</strong>（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>
<p>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。</p>
<h4 id="查找匹配的处理代码"><a href="#查找匹配的处理代码" class="headerlink" title="查找匹配的处理代码"></a>查找匹配的处理代码</h4><p>在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。</p>
<p>因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，<strong>使得派生类异常的处理代码出现在基类异常的处理代码之前。</strong></p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会在某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发<strong>命名空间污染</strong>。</p>
<p><strong>命名空间</strong>（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命令空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>一个命令空间的定义包含两个部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。</p>
<p><strong>using声明：</strong> 是一种将命名空间中的某个名字注入当前作用域的机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div></pre></td></tr></table></figure>
<p>上述语句使得命令空间std中的名字cout在当前作用域可见。之后，我们将可以直接使用cout而无须前缀std::了。</p>
<p><strong>using指示：</strong> 是具有如下形式的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> NS;</div></pre></td></tr></table></figure>
<p>上述语句使得命名空间NS的所有名字在using指示所在的作用域以及NS所在的作用域都变得可见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;异常处理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;异常处理&lt;/strong&gt;（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="异常处理" scheme="http://www.wangxinri.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>函数模版和类模板</title>
    <link href="http://www.wangxinri.cn/2017/12/01/%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    <id>http://www.wangxinri.cn/2017/12/01/函数模版和类模板/</id>
    <published>2017-12-01T02:59:00.000Z</published>
    <updated>2018-02-23T07:21:59.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。</p>
<a id="more"></a>
<p>本书第Ⅱ部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。</p>
<p>例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。</p>
<p>模版是泛型编程的基础。我们不必了解模版是如何定义的就能使用它们，实际上我们已经这样用了。</p>
<p><strong>模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。</strong> </p>
<h2 id="定义模版"><a href="#定义模版" class="headerlink" title="定义模版"></a>定义模版</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v1&lt;v2) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(v2&lt;v1) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模版定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p>
<p><strong>note: 在模板定义中，模板参数列表不能为空。</strong></p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。</p>
<p>T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。</p>
<h4 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h4><p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用参数的类型来确定绑定到模板参数T的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//T为int</span></div></pre></td></tr></table></figure>
<p>实参类型是int。编译器会推断出模板参数为int，并将它绑定到模板参数T。</p>
<p>编译器用推断出的模板参数来为我们<strong>实例化</strong>（instantiate）一个特定版本的函数。</p>
<p>如上调用将实例化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化出 int compare(const int&amp;, const int&amp;) &#123; ...; &#125;</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//T为int</span></div></pre></td></tr></table></figure>
<h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>一般来说，我们可以将模板类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确：返回类型和参数类型相同</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="function">T <span class="title">foo</span><span class="params">(T *p)</span></span>&#123;</div><div class="line">    T tem = *p;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类型参数前必须使用关键字typename 或 class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误：U之前必须加上class或typename</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,U&gt;</div><div class="line"><span class="comment">//正确：在模板参数列表中，typename和class没有什么不同</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></div></pre></td></tr></table></figure>
<p>typename是在模板已经广泛使用之后才引入C++语言的，推荐使用。</p>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。</p>
<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>
<p>例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char 的数组。由于我们不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N,<span class="keyword">unsigned</span> M&gt;</div><div class="line">int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们调用这个版本的compare时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compare(<span class="string">"hi"</span>,<span class="string">"mom"</span>)</div></pre></td></tr></table></figure>
<p>编译器会实例化出如下版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</div></pre></td></tr></table></figure>
<p>在模板定义内，模板非类型参数时一个常量值。在需要常量表达式的地方，可以使用非类型参数。</p>
<p><strong>note: 非类型模板参数的模板实参必须是常量表达式。</strong></p>
<h4 id="inline-和-constexpr的函数模板"><a href="#inline-和-constexpr的函数模板" class="headerlink" title="inline 和 constexpr的函数模板"></a>inline 和 constexpr的函数模板</h4><p>函数模板可以声明为inline或constexpr的，如同非模板函数一样。<strong>inline或constexpr说明符放在模板参数之后，返回类型之前。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确：inline说明符跟在模板参数列表之后</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="编写类型无关的代码"><a href="#编写类型无关的代码" class="headerlink" title="编写类型无关的代码"></a>编写类型无关的代码</h4><p>我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：</p>
<ul>
<li>模板中的函数参数是const的引用。</li>
<li>函数体中的条件判断仅使用&lt;比较运算。</li>
</ul>
<p>大多数类型都允许拷贝，但是，不允许拷贝的类类型也是存在的。通过设置为引用，保证这写类型可以处理。而且，当处理大对象时，这种设计策略还能使函数运行得更快。</p>
<p><strong>注意： 模板程序应该尽量减少对实参类型的要求。</strong></p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。</p>
<p><strong>note: 函数模板和雷模板成员函数的定义通常放在头文件中</strong>。</p>
<font color="red"> <strong>警告：保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。</strong> </font>

<p>示例：定义自己版本的begin和end，同时编写一个constexpr模板，返回给定数组的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// the same as std::begin</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> size&gt;</div><div class="line">T* begin_def(T(&amp;arr)[size])&#123;   //arr数组的引用</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">// the same as std::end</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">unsigned</span> size&gt;</div><div class="line">T* end_def(T(&amp;arr)[size])&#123;</div><div class="line">    <span class="comment">//We usually don't use a function name which is the same as the function of standard libary</span></div><div class="line">    <span class="comment">//This should not be const</span></div><div class="line">    <span class="keyword">return</span> arr + size;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> size&gt;</div><div class="line">constexpr unsigned getSize(const T(&amp;arr)[size])&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s[] = &#123; <span class="string">"sssss"</span>,<span class="string">"ss"</span>,<span class="string">"ss"</span>,<span class="string">"ssssszzzz"</span> &#125;;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(begin_def(s)) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(end_def(s) - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">string</span> s1[] = &#123; <span class="string">"sss"</span> &#125;;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; getSize(s1) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//1</span></div><div class="line">    <span class="keyword">char</span> c[] = <span class="string">"s"</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; getSize(c) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//2</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p><strong>类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息—-用来代替模板参数的模板实参列表。</strong></p>
<h4 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h4><p>类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。</p>
<h4 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h4><p>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。</string></p>
<h4 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h4><p>类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，<strong>定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。</strong></p>
<p>对应的Blob的成员应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>)</div></pre></td></tr></table></figure>
<h4 id="类模板成员函数的实例化"><a href="#类模板成员函数的实例化" class="headerlink" title="类模板成员函数的实例化"></a>类模板成员函数的实例化</h4><p>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p>
<h4 id="在类代码内简化模板类名的使用"><a href="#在类代码内简化模板类名的使用" class="headerlink" title="在类代码内简化模板类名的使用"></a>在类代码内简化模板类名的使用</h4><p>当我们使用一个类模板类型时必须提供模板参数，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参</p>
<h4 id="在类模板外使用类模板名"><a href="#在类模板外使用类模板名" class="headerlink" title="在类模板外使用类模板名"></a>在类模板外使用类模板名</h4><p>当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重载BlobPtr&lt;T&gt;模板类的后置递增运算符</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   <span class="comment">//类外，返回类型BlobPtr&lt;T&gt;</span></div><div class="line">    <span class="comment">//类内，BlobPtr无须提供模板参数，写成 BlobPtr 等价 BlobPtr&lt;T&gt; ret = *this;</span></div><div class="line">    BlobPtr ret = *<span class="keyword">this</span>;   </div><div class="line">    ++*<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> ret;     <span class="comment">//返回保存的类型</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类模板完整示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span>    <span class="comment">//typedef int size;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::size_type size_type;</div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    Blob();</div><div class="line">    Blob(<span class="built_in">initializer_list</span>&lt;T&gt; i1);</div><div class="line">    <span class="comment">//Blob中的元素数目</span></div><div class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;size(); &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</div><div class="line">    <span class="comment">//添加和删除元素</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>&#123; data-&gt;push_back(t); &#125;</div><div class="line">    <span class="comment">//移动版本</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; data-&gt;push_back(move(t)); &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//元素访问</span></div><div class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</div><div class="line">    T&amp; <span class="keyword">operator</span>[] (size_type i);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;T&gt;&gt; data;</div><div class="line">    <span class="comment">//若data[i]无效，则抛出msg</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i,<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T&amp; Blob&lt;T&gt;::back()&#123;</div><div class="line">    check(<span class="number">0</span>,<span class="string">"subscript out of range"</span>);</div><div class="line">    <span class="keyword">return</span> data-&gt;back();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i) &#123;</div><div class="line">    check(i,<span class="string">"subscript out of range"</span>);</div><div class="line">    (*data)[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> Blob&lt;T&gt;::pop_back()&#123;</div><div class="line">    check(<span class="number">0</span>,<span class="string">"pop_back on empty Blob"</span>);</div><div class="line">    data-&gt;pop_back();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Blob&lt;T&gt;::Blob():data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Blob&lt;T&gt;::Blob(<span class="built_in">initializer_list</span>&lt;T&gt; i1): data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;(i1)) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i,<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg) <span class="keyword">const</span>&#123;</div><div class="line">    <span class="keyword">if</span>(i&gt;=data-&gt;size()) <span class="keyword">throw</span> out_of_range(msg);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Blob&lt;<span class="keyword">int</span>&gt; ib = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</div><div class="line">    <span class="keyword">int</span> back = ib.back();</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;back&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;ib.size()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数。</strong></p>
<h4 id="类模板和友元（暂时不看）"><a href="#类模板和友元（暂时不看）" class="headerlink" title="类模板和友元（暂时不看）"></a>类模板和友元（暂时不看）</h4><h4 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h4><p>与任何其他类相同，类模板可以声明static成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</div><div class="line">    <span class="comment">//其他接口成员</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr;</div><div class="line">    <span class="comment">//其他实现成员</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个Foo的实例都有其自己的static成员实例。即，对于任意给定类型X，都有一个Foo<x>::ctr和一个Foo<x>::count成员。所有Foo<x>类型的对象共享相同的ctr对象和count对象。</x></x></x></p>
<p>我们将static数据成员也定义为模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;  <span class="comment">//定义并初始化ctr</span></div></pre></td></tr></table></figure>
<p>访问类模板的static成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;     <span class="comment">//实例化Foo&lt;int&gt;类和static数据成员ctr</span></div><div class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt;:count();       <span class="comment">//实例化Foo&lt;int&gt;::count</span></div><div class="line">ct = fi.count();        <span class="comment">//使用Foo&lt;int&gt;::count</span></div><div class="line">ct = Foo::count();       <span class="comment">//错误：使用哪个模板实例的count?</span></div></pre></td></tr></table></figure>
<p>类似于任何其他成员函数，一个static成员函数只有在使用时才会实例化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="模板" scheme="http://www.wangxinri.cn/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>模板参数与成员模版</title>
    <link href="http://www.wangxinri.cn/2017/12/01/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E6%A8%A1%E7%89%88/"/>
    <id>http://www.wangxinri.cn/2017/12/01/模板参数与成员模版/</id>
    <published>2017-12-01T02:49:00.000Z</published>
    <updated>2018-02-23T08:08:23.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><h3 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h3><p>模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span>&#123;</div><div class="line">    A tmp = a;         <span class="comment">//tmp的类型为模板参数A的类型，而非double</span></div><div class="line">    <span class="keyword">double</span> B;         <span class="comment">//错误：重声明模板参数B</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误：非法重用模板参数名V</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> V&gt;   <span class="comment">//...</span></div></pre></td></tr></table></figure>
<h3 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h3><p>模版声明必须包含模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明但不定义compare和Blob</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></div></pre></td></tr></table></figure>
<p>与函数参数相同，声明中的模板参数的名字不必与定义中相同。</p>
<p><strong>建议：</strong> 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>
<h3 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h3><p>例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T::size_type * p;</div></pre></td></tr></table></figure>
<p>它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。</p>
<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="comment">//typename T::value_type 使用关键字通过编译器该名字T::value_type表示类型</span></div><div class="line"><span class="keyword">typename</span> T::<span class="function">value_type <span class="title">top</span> <span class="params">(<span class="keyword">const</span> T &amp;c)</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="red">  <strong>note:当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。</strong> </font> 

<h3 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h3><p>就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。</p>
<p>例如，我们重写compare，默认使用标准库的less函数对象模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> F = less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2, F f = F())&#123;</div><div class="line">    <span class="keyword">if</span>(f(v1,v2)) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(f(v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h3><p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt;</span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">Numbers</span>&#123;</span>    <span class="comment">//T默认为int</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Numbers(T v=<span class="number">0</span>):val(v) &#123;&#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; num1;</div><div class="line">Numbers&lt;&gt; num2;        <span class="comment">//空&lt;&gt;表示我们希望使用默认类型</span></div></pre></td></tr></table></figure>
<p>习题示例：</p>
<p>编写函数，接受一个容器的引用，打印容器中的元素，两种方式，一种使用容器的size_type和size成员来控制打印元素的循环；另一种使用begin和end返回迭代器来控制循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">(<span class="keyword">const</span> Container &amp;container)</span></span>&#123;</div><div class="line">    <span class="comment">//typename Container::size_type  表明size_type是一个类型</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> Container::size_type i = <span class="number">0</span>;i&lt;container.size();++i)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;container[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(<span class="keyword">const</span> Container &amp;container)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = container.begin();iter!=container.end();++iter)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</div><div class="line">print1(ivec);</div><div class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist = &#123;<span class="string">"wang"</span>,<span class="string">"xin"</span>,<span class="string">"ri"</span>&#125;;</div><div class="line">print2(slist);</div></pre></td></tr></table></figure>
<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（member template）。成员模板不能是虚函数。</p>
<h3 id="普通（非模板）类的成员模板"><a href="#普通（非模板）类的成员模板" class="headerlink" title="普通（非模板）类的成员模板"></a>普通（非模板）类的成员模板</h3><p>例如，我们定义一个类，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。由于希望delete使用于任何类型，所以我们将调用运算符定义为一个模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DebugDelete(ostream &amp;s = <span class="built_in">cerr</span>):os(s)&#123;&#125;</div><div class="line">    <span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span> </span>&#123;    <span class="comment">//成员模板，重载函数调用运算符</span></div><div class="line">        os&lt;&lt;<span class="string">"deleting unique_ptr"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">delete</span> p;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    ostream &amp;os;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">double</span> *p = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    DebugDelete d;</div><div class="line">    d(p);     <span class="comment">//调用DebugDelete::operator() (double*),释放p</span></div><div class="line">    <span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>;</div><div class="line">    <span class="comment">//在一个临时DebugDelete对象上调用operator()(int*)</span></div><div class="line">    DebugDelete()(ip);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h3><p>对于类模板，我们也可以为其定义成员模板。再此情况下，类和成员各自有自己的、独立的模板参数。</p>
<p>与类模板的普通函数成员不同，成员模板是函数模板。<strong>当我们在类模板外定义一个成员模板时</strong>，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类模板外定义成员模板</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">//类的类型参数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;      <span class="comment">//构造函数的类型参数</span></div><div class="line">Blob&lt;T&gt;::Blob(It b,It e):data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;(b,e)) &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h2><p>当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例。</p>
<p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过<strong>显式实例化</strong>来避免这种开销。一个显式实例化有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;        <span class="comment">//实例化声明</span></div><div class="line"><span class="keyword">template</span> declaration；              <span class="comment">//实例化定义</span></div></pre></td></tr></table></figure>
<p>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化声明与定义</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>         <span class="comment">//声明</span></div><div class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;       <span class="comment">//定义</span></div></pre></td></tr></table></figure>
<p>当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<p><strong>警告：</strong> 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</p>
<h3 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h3><p>一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。</p>
<p><strong>note:</strong> 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模板参数&quot;&gt;&lt;a href=&quot;#模板参数&quot; class=&quot;headerlink&quot; title=&quot;模板参数&quot;&gt;&lt;/a&gt;模板参数&lt;/h2&gt;&lt;h3 id=&quot;模板参数与作用域&quot;&gt;&lt;a href=&quot;#模板参数与作用域&quot; class=&quot;headerlink&quot; title=&quot;模板参数与作用域&quot;&gt;&lt;/a&gt;模板参数与作用域&lt;/h3&gt;&lt;p&gt;模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="模板" scheme="http://www.wangxinri.cn/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>虚函数与抽象基类</title>
    <link href="http://www.wangxinri.cn/2017/11/23/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
    <id>http://www.wangxinri.cn/2017/11/23/虚函数与抽象基类/</id>
    <published>2017-11-23T13:59:00.000Z</published>
    <updated>2018-02-23T00:58:41.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，<strong>所以所有的虚函数都必须有定义</strong>。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。</p>
<a id="more"></a>
<h3 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h3><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。</p>
<p>必须要搞清楚一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">base = derived;     <span class="comment">//把derived的Quote部分拷贝给base</span></div><div class="line">base.net_price(<span class="number">20</span>);     <span class="comment">//调用Quote::net_price</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</p>
<h3 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>当我们在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p><strong>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</strong></p>
<p>同样，派生类中虚函数的返回类型也必须与基类匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。</p>
<h3 id="final和override说明符"><a href="#final和override说明符" class="headerlink" title="final和override说明符"></a>final和override说明符</h3><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>在类的设计中常常会用到虚函数。但是存在一个问题，在派生类中本来是要重写基类中的虚函数的时候，由于写错参数类型，写错函数名等问题，造成重新定义了一个函数，这往往会造成意想不到的错误。想要调试并发现这样的错误显然非常困难，c++11引入关键字<strong>override</strong>。在派生类中重写了虚函数以后，可以使用override来修饰重写的虚函数，这个时候如果基类中没有这个虚函数，此时编译器将报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span>B&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> override</span>;    <span class="comment">//正确：f1与基类中的f1匹配</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> override</span>;         <span class="comment">//错误：B没有形如f2(int)的函数</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> override</span>;         <span class="comment">//错误：f3不是虚函数</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> override</span>;           <span class="comment">//错误：B没有名为f4的函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>在设计基类的时候，有时候我们不想后续的的派生类覆盖某个方法，这个时候，我们可以将这个方法修饰为 final 。派生类中任何试图覆盖该函数的行为都将导致错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span>:</span>B&#123;</div><div class="line">    <span class="comment">//从B继承f2()和f3(),覆盖f1(int)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;        <span class="comment">//不允许后续的其他类覆盖f1(int)</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span>:</span>D2 &#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">//正确：覆盖从间接基类B继承而来的f2</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;      <span class="comment">//错误：D2已经将f2声明成final</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h3><p><strong>虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</strong></p>
<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p><strong>建议：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</strong></p>
<h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。<strong>使用作用域运算符可以实现这一目的</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么</span></div><div class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</div></pre></td></tr></table></figure>
<p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p><strong>和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。</strong></p>
<p>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能再类的内部为一个=0的函数提供函数体。</p>
<h3 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h3><p>含有（或者未经覆盖直接继承）纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。<strong>我们不能（直接）创建一个抽象基类的对象。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数</span></div><div class="line">Disc_quote discounted;        <span class="comment">//错误：不能定义Disc_quote的对象</span></div><div class="line">Bulk_quote bulk;              <span class="comment">//正确：Bulk_quote中没有纯虚函数</span></div></pre></td></tr></table></figure>
<p><strong>note:</strong> <font color="red"> <strong>我们不能创建抽象基类的对象。</strong> </font></p>
<h3 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h3><p>先初始化基类的构造函数、再初始化自己的构造函数，最后执行构造函数体部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h2&gt;&lt;p&gt;在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，&lt;strong&gt;所以所有的虚函数都必须有定义&lt;/strong&gt;。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="虚函数" scheme="http://www.wangxinri.cn/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>访问控制与继承</title>
    <link href="http://www.wangxinri.cn/2017/11/23/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.wangxinri.cn/2017/11/23/访问控制与继承/</id>
    <published>2017-11-23T02:59:00.000Z</published>
    <updated>2018-02-23T08:13:10.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。</p>
<a id="more"></a>
<h3 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h3><ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>
<li>和共有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
</ul>
<p>此外，protected还有另外一条重要的性质。</p>
<ul>
<li><strong>派生类的成员或友元只能通过派生类对象来访问基类受的保护成员。派生类对于一个基类对象中的受保护的成员没有任何访问权限</strong>。</li>
</ul>
<p>考虑如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> prot_mem;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;     <span class="comment">//能访问Sneaky::prot_mem</span></div><div class="line">    friend void clobber(Base&amp;)；   //不能访问Base::prot_mem</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//正确：clobber能访问Sneaky对象的private和protected成员</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123;s.j = s.prot_mem = <span class="number">0</span>;&#125;</div><div class="line"><span class="comment">//错误：clobber不能访问Base的protected成员</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123; b.prot_mem = <span class="number">0</span>;&#125;</div></pre></td></tr></table></figure>
<h3 id="公有、私有和受保护继承-（重点）"><a href="#公有、私有和受保护继承-（重点）" class="headerlink" title="公有、私有和受保护继承  （重点）"></a>公有、私有和受保护继承  （重点）</h3><p>某个类对其继承而来的成员的访问权限受到两个因素影响：<strong>一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</strong></p>
<p><strong>派生类访问说明符</strong>（继承的类是公有、私有还是受保护）对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，基类成员的访问权限只与基类中的访问说明符有关（派生类的成员不能访问基类私有成员，可以访问基类公有和受保护成员）。</p>
<p><strong>派生类访问说明符的目的</strong>是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：</p>
<ul>
<li>如果继承是公有的，对于派生类用户来讲，基类中成员遵循其原有的访问说明符。</li>
<li>如果继承是私有的，对于派生类用户来讲，基类中的成员访问说明符都是私有的。</li>
<li>如果继承是受保护的，对于派生类用户来讲，基类的所有公有成员在新定义的类中都是受保护的，基类中的受保护和私有成员遵循原来的访问说明符。</li>
</ul>
<h3 id="派生类向基类转换的可访问性-（略）"><a href="#派生类向基类转换的可访问性-（略）" class="headerlink" title="派生类向基类转换的可访问性  （略）"></a>派生类向基类转换的可访问性  （略）</h3><ul>
<li><strong>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护或者私有的，则用户代码不能使用该转换。</strong></li>
</ul>
<p><strong>关键概念：类的设计与受保护的成员</strong></p>
<p>不考虑继承的话，我们可以认为一个类有两种不同的用户：<strong>普通用户和类的实现者</strong>。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。</p>
<p>如果进一步考虑继承的话就会出现第三种用户：<strong>即派生类</strong>。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可以供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。</p>
<h3 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h3><p>不能继承友元关系；每个类负责控制各自成员的访问权限。</p>
<h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用<strong>using声明</strong>可以达到这一目的。</p>
<p>派生类只能为那些它可以访问的名字提供using声明。</p>
<h3 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h3><p>使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。</p>
<p>一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;访问控制与继承&quot;&gt;&lt;a href=&quot;#访问控制与继承&quot; class=&quot;headerlink&quot; title=&quot;访问控制与继承&quot;&gt;&lt;/a&gt;访问控制与继承&lt;/h2&gt;&lt;p&gt;每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.wangxinri.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>OOP概述（object-oriented programming）</title>
    <link href="http://www.wangxinri.cn/2017/11/19/OOP%E6%A6%82%E8%BF%B0%EF%BC%88object-oriented-programming%EF%BC%89/"/>
    <id>http://www.wangxinri.cn/2017/11/19/OOP概述（object-oriented-programming）/</id>
    <published>2017-11-19T13:59:00.000Z</published>
    <updated>2018-02-22T13:23:07.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面向对象程序设计基于三个基本概念：<strong>数据抽象、继承和动态绑定</strong>。</p>
<a id="more"></a>
<p><strong>继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。</strong></p>
<h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p>面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为<strong>派生类</strong>。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为<strong>运行时绑定</strong>。</p>
<p><strong>note:</strong> <strong>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong>。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p><strong>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</strong></p>
<h3 id="成员函数和继承"><a href="#成员函数和继承" class="headerlink" title="成员函数和继承"></a>成员函数和继承</h3><p>派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以<strong>覆盖</strong>（override）从基类继承而来的旧定义。</p>
<p>在C++语言中，基类必须将它的两种成员函数区分开来：<strong>一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数</strong>。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，<strong>该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</strong></p>
<p>基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。<strong>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</strong></p>
<p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>
<h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，<strong>派生类能访问公用成员，而不能访问私有成员</strong>。不过在某些时候基类中还有这样一种成员，<strong>基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员</strong>。</p>
<ul>
<li>private member: base class itself and friend can access</li>
<li>protected members: base class itself,friend and derived classes can access</li>
</ul>
<h2 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h2><p>派生类必须通过使用<strong>派生类列表</strong>明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。</p>
<p>如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。</p>
<h3 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字<strong>override</strong>。</p>
<h3 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h3><p>一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>
<p><strong>在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。</strong></p>
<h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分</span></div><div class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">string</span>&amp; book,<span class="keyword">double</span> p,<span class="keyword">size_t</span> qty,<span class="keyword">double</span> disc):Quote(book,p),min_qty(qty),discount(disc) &#123;&#125;</div></pre></td></tr></table></figure>
<font color="red"> <strong>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</strong> </font>


<h3 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h3><p><strong>派生类可以访问基类的公有成员和受保护成员</strong>：</p>
<p>其中price是基类中的受保护成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了</span></div><div class="line"><span class="keyword">double</span> Bulk_quote::net_price(<span class="keyword">size_t</span> cnt) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">if</span>(cnt &gt;= min_qty) &#123;</div><div class="line">        <span class="keyword">return</span> cnt*(<span class="number">1</span>-discount)*price;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> cnt*price;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>遵循基类的接口</strong></p>
<p>必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。</p>
<p>因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void Derived::f(const Derived &amp;derived_obj)&#123;</div><div class="line">    Base::statmem();</div><div class="line">    Derived::statmem();</div><div class="line">    derived_obj.statmem();</div><div class="line">    statmem();         //通过this对象访问</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h3><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p>
<p>一个类不能派生它本身。</p>
<h3 id="防止继承发生"><a href="#防止继承发生" class="headerlink" title="防止继承发生"></a>防止继承发生</h3><p>有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，<strong>即在类名后跟一个关键字final</strong>。</p>
<h2 id="类型抓换与继承"><a href="#类型抓换与继承" class="headerlink" title="类型抓换与继承"></a>类型抓换与继承</h2><p><strong>理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。</strong></p>
<p>通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：<strong>我们可以将基类的指针或引用绑定到派生类对象上</strong>。</p>
<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>
<h3 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h3><p>因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Quote base;</div><div class="line">Bulk_quote* bulkP = &amp;base;    <span class="comment">//错误：不能将基类转换成派生类</span></div><div class="line">Bulk_quote* bulkRef = base;   <span class="comment">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>
<p>除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bulk_quote bulk;</div><div class="line">Quote *itemP = &amp;bulk;      <span class="comment">//正确：动态类型是Bulk_quote</span></div><div class="line">Bulk_quote *bulkP = itemP;      <span class="comment">//错误：不能将基类转换成派生类</span></div></pre></td></tr></table></figure>
<h3 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h3><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bulk_quote bulk;      <span class="comment">//派生类对象</span></div><div class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;     <span class="comment">//使用Quote::Quote(const Quote&amp;)  构造函数</span></div><div class="line">item = bulk;          <span class="comment">//调用Quote::operator=(const Quote&amp;)</span></div></pre></td></tr></table></figure>
<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
<p><strong>关键概念：存在继承关系的类型之间的转换规则</strong></p>
<p>1、从派生类向基类的类型转换只对指针或引用类型有效。</p>
<p>2、基类向派生类不存在隐式类型转换。</p>
<p>3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。</p>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;面向对象程序设计基于三个基本概念：&lt;strong&gt;数据抽象、继承和动态绑定&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://www.wangxinri.cn/categories/C/"/>
    
    
      <category term="OOP" scheme="http://www.wangxinri.cn/tags/OOP/"/>
    
  </entry>
  
</feed>
