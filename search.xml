<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程同步之互斥量]]></title>
    <url>%2F2018%2F05%2F19%2F%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%87%8F%2F</url>
    <content type="text"><![CDATA[线程同步当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图，如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。 同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性，但是，当一个线程可以修改的变量，其他线程也可以读取和修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容是不会访问到无效值的。 为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量（互斥访问）。 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量（mutex）从本质上来说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种情况下，每次只有一个线程可以向前执行。 互斥变量是用pthread_mutex_t数据类型表示的。在使用互斥变量之前，必须首先对它进行初始化，可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于静态分配的互斥量），也可以调用pthread_mutex_init函数进行初始化。如果动态分配互斥量（例如，通过调用malloc函数），在释放内存前需要调用pthread_mutex_destroy。 1234#include&lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);int pthread_mutex_destory(pthread_mutex_t *mutex); 返回值：成功返回0，失败返回错误编号； 如果使用默认初始化互斥量，只需把attr设置为NULL；对互斥量进行加锁，需要调用pthread_mutex_lock,如果互斥量已经上锁，调用线程将会阻塞到互斥量被解锁。对互斥量解锁，需要调用pthread_mutex_unlock。 12345#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex); 返回值：成功返回0，错误返回错误编号； 如果线程不希望被阻塞，它可以使用pthread_mutex_trylock尝试对互斥量进行加锁（如果互斥量被加锁，函数返回EBUSY，线程不会被阻塞）。如果调用pthread_mutex_trylock时互斥量处于未锁住状态，那么pthread_mutex_trylock将锁住互斥量，不会出现阻塞并返回0，否则失败不能锁住互斥量，而返回EBUSY；使用pthread_mutex_trylock()接口可以避免死锁。 示例使用互斥量来实现三个线程分别打印出ABC，循环五次。 主要思路如下 123456mutex1 = 1 mutex2 = 0mutex3 = 0thread1 p(mutex1) v(mutex2)thread2 p(mutex2) v(mutex3)thread3 p(mutex3) v(mutex1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include "head.h"pthread_mutex_t mutex1;pthread_mutex_t mutex2;pthread_mutex_t mutex3;void Init()&#123; //initialization int err; err = pthread_mutex_init(&amp;mutex1,NULL); if(err != 0)&#123; printf("init mutex1 error\n"); &#125; err = pthread_mutex_init(&amp;mutex2,NULL); if(err != 0)&#123; printf("init mutex2 error\n"); &#125; err = pthread_mutex_init(&amp;mutex3,NULL); if(err != 0)&#123; printf("init mutex3 error\n"); &#125; err = pthread_mutex_lock(&amp;mutex2); if(err != 0)&#123; printf("mutex2 lock error\n"); &#125; err = pthread_mutex_lock(&amp;mutex3); if(err != 0)&#123; printf("mutex3 lock error\n"); &#125;&#125;void* thr_fn1(void *arg)&#123; int i; int err; for(i=0;i&lt;5;++i)&#123; err = pthread_mutex_lock(&amp;mutex1); if(err != 0)&#123; printf("mutex1 lock error\n"); &#125; printf("thread1: A\n"); err = pthread_mutex_unlock(&amp;mutex2); if(err != 0)&#123; printf("mutex2 unlock error\n"); &#125; &#125; return (void*)0;&#125;void* thr_fn2(void *arg)&#123; int i; int err; for(i=0;i&lt;5;++i)&#123; err = pthread_mutex_lock(&amp;mutex2); if(err != 0)&#123; printf("mutex2 lock error\n"); &#125; printf("thread2: B\n"); err = pthread_mutex_unlock(&amp;mutex3); if(err != 0)&#123; printf("mutex3 unlock error\n"); &#125; &#125; return (void*)0;&#125;void* thr_fn3(void *arg)&#123; int i; int err; for(i=0;i&lt;5;++i)&#123; err = pthread_mutex_lock(&amp;mutex3); if(err != 0)&#123; printf("mutex3 lock error\n"); &#125; printf("thread3: C\n"); err = pthread_mutex_unlock(&amp;mutex1); if(err != 0)&#123; printf("mutex1 unlock error\n"); &#125; &#125; return (void*)0;&#125; void Destory()&#123; int err; err = pthread_mutex_unlock(&amp;mutex2); if(err != 0)&#123; printf("mutex2 unlock error\n"); &#125; err = pthread_mutex_unlock(&amp;mutex3); if(err != 0)&#123; printf("mutex3 unlock error\n"); &#125; err = pthread_mutex_destroy(&amp;mutex1); if(err != 0)&#123; printf("mutex1 destory error\n"); &#125; err = pthread_mutex_destroy(&amp;mutex2); if(err != 0)&#123; printf("mutex2 destory error\n"); &#125; err = pthread_mutex_destroy(&amp;mutex3); if(err != 0)&#123; printf("mutex3 destory error\n"); &#125;&#125;int main(void)&#123; int err; pthread_t tid1,tid2,tid3; Init(); err = pthread_create(&amp;tid1,NULL,thr_fn1,NULL); if(err != 0)&#123; printf("can't create thread1\n"); &#125; err = pthread_create(&amp;tid2,NULL,thr_fn2,NULL); if(err != 0)&#123; printf("can't create thread2\n"); &#125; err = pthread_create(&amp;tid3,NULL,thr_fn3,NULL); if(err != 0)&#123; printf("can't create thread2\n"); &#125; err = pthread_join(tid1,NULL); if(err != 0)&#123; printf("can't join with thread1\n"); &#125; err = pthread_join(tid2,NULL); if(err != 0)&#123; printf("can't join with thread2\n"); &#125; err = pthread_join(tid3,NULL); if(err != 0)&#123; printf("can't join with thread3\n"); &#125; Destory(); exit(0);&#125; 1234567891011121314151617[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadMutex.c -lpthread -o pthreadMutex.o [vrlive@iZ23chs2r19Z eleven]$ ./pthreadMutex.o thread1: Athread2: Bthread3: Cthread1: Athread2: Bthread3: Cthread1: Athread2: Bthread3: Cthread1: Athread2: Bthread3: Cthread1: Athread2: Bthread3: C 注意：pthread_mutex_lock和pthread_mutex_unlock必须成对出现，不然pthread_mutex_destory函数调用出错。 避免死锁1.线程A试图对用一个互斥量mutexA加锁两次，那么它自身就会陷入死锁状态， 用伪代码表示就是： 12pthread_mutex_lock(&amp;mutexA) pthread_mutex_lock(&amp;mutexA) /* 这里死锁 */ 2.程序中使用多个互斥量时，如果允许一个线程一直占有第一个互斥量，并且试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥量的线程也在试图锁住第一个互斥量，这时就发生死锁。因为两个线程都在互相请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是产生死锁。 用伪代码表示就是： 12345678910pthreadA: pthread_mutex_lock(&amp;mutexA) pthread_mutex_lock(&amp;mutexB) /* 这里死锁 */ pthreadB: pthread_mutex_lock(&amp;mutexB) pthread_mutex_lock(&amp;mutexA) /* 这里死锁 */ 有时候，应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构，可用的函数并不能把它转换成简单的层次，那么就需要采用另外的方法。在这种情况下，可以先释放占有的锁，然后过段时间再试。这种情况可以使用pthread_mutex_trylock接口避免死锁。如果已经占有某些锁而且pthread_mutex_trylock接口返回成功，那么就可以前进。但是，如果不能获取锁，可以先释放已经占有的锁，做好清理工作，然后过一段时间再重新试。 函数pthread_mutex_timedlock当线程试图获取一个已加锁的互斥量时，pthread_mutex_timedlock互斥量原语允许绑定线程阻塞时间。pthread_mutex_timedlock函数与pthread_mutex_lock是基本等价的，但是在达到超时时间值时，pthread_mutex_timelock不会对互斥量进行加锁，而是返回错误码ETIMEDOUT。 123456#include &lt;pthread.h&gt;#include &lt;time.h&gt;int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //返回值：若成功，返回0；否则，返回错误编码 超时指定愿意等待的绝对时间（某个具体的时间）（与相对时间对比而言，指定在时间X之前可以阻塞等待，而不是说愿意阻塞Y秒）。这个超时时间是用timespec结构来表示，它用秒和纳秒来描述时间。 示例下面示例给出了如何用pthread_mutex_timedlock避免永久阻塞。 123456789101112131415161718192021222324252627282930#include "head.h"int main(void)&#123; int err; struct timespec tout; struct tm *tmp; char buf[64]; pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_lock(&amp;lock); printf("mutex is locked\n"); clock_gettime(CLOCK_REALTIME,&amp;tout); tmp = localtime(&amp;tout.tv_sec); strftime(buf,sizeof(buf),"%r",tmp); printf("current time is %s\n",buf); tout.tv_sec += 10; //10 seconds from new //caution: this could lead to deadlock err = pthread_mutex_timedlock(&amp;lock,&amp;tout); clock_gettime(CLOCK_REALTIME,&amp;tout); tmp = localtime(&amp;tout.tv_sec); strftime(buf,sizeof(buf),"%r",tmp); printf("the time is now %s\n",buf); if(err == 0)&#123; printf("mutex locked again\n"); &#125;else&#123; printf("can't lock mutex again:%s\n",strerror(err)); &#125; exit(0);&#125; 123456[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadMutexTimelock.c -lpthread -o pthreadMutexTimelock.o[vrlive@iZ23chs2r19Z eleven]$ ./pthreadMutexTimelock.o mutex is lockedcurrent time is 06:38:24 PMthe time is now 06:38:34 PMcan't lock mutex again:Connection timed out]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程分离和结合]]></title>
    <url>%2F2018%2F05%2F19%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BB%E4%B8%8E%E7%BB%93%E5%90%88%2F</url>
    <content type="text"><![CDATA[线程的分离与结合在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。 线程的分离状态决定一个线程以什么样的方式来终止自己。在上面的例子中，我们采用了线程的默认属性，即为非分离状态（即可结合的，joinable，需要回收），这种情况下，原有的线程等待创建的线程结束；只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。 设置线程分离状态的函数为pthread_attr_setdetachstate（pthread_attr_t *attr, int detachstate）。第二个参数可选为PTHREAD_CREATE_DETACHED（分离线程）和 PTHREAD _CREATE_JOINABLE（非分离线程）。这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timewait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait（）之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。 另外一个可能常用的属性是线程的优先级，它存放在结构sched_param中。用函数pthread_attr_getschedparam和函数pthread_attr_setschedparam进行存放，一般说来，我们总是先取优先级，对取得的值修改后再存放回去。 线程等待——正确处理线程终止1234#include &lt;pthread.h&gt;void pthread_exit(void *retval);void pthread_join(pthread_t th,void *thread_return);//挂起等待th结束,*thread_return=retval;int pthread_detach(pthread_t th); 如果线程处于joinable状态，则只能只能被创建他的线程等待终止。 在Linux平台默认情况下，虽然各个线程之间是相互独立的，一个线程的终止不会去通知或影响其他的线程。但是已经终止的线程的资源并不会随着线程的终止而得到释放，我们需要调用 pthread_join() 来获得另一个线程的终止状态并且释放该线程所占的资源。（说明：线程处于joinable状态下） 调用该函数的线程将挂起，等待 th 所表示的线程的结束。 thread_return 是指向线程 th 返回值的指针。需要注意的是 th 所表示的线程必须是 joinable 的，即处于非 detached（游离）状态；并且只可以有唯一的一个线程对 th 调用 pthread_join() 。如果 th 处于 detached 状态，那么对 th 的 pthread_join() 调用将返回错误。 如果不关心一个线程的结束状态，那么也可以将一个线程设置为 detached 状态，从而让操作系统在该线程结束时来回收它所占的资源。将一个线程设置为detached 状态可以通过两种方式来实现。一种是调用 pthread_detach() 函数，可以将线程 th 设置为 detached 状态。另一种方法是在创建线程时就将它设置为 detached 状态，首先初始化一个线程属性变量，然后将其设置为 detached 状态，最后将它作为参数传入线程创建函数 pthread_create()，这样所创建出来的线程就直接处于 detached 状态。 创建 detach 线程： 12345pthread_t tid;pthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);pthread_create(&amp;tid, &amp;attr, THREAD_FUNCTION, arg); 总之为了在使用 pthread时避免线程的资源在线程结束时不能得到正确释放，从而避免产生潜在的内存泄漏问题，在对待线程结束时，要确保该线程处于 detached 状态，否着就需要调用 pthread_join() 函数来对其进行资源回收。 参考：线程分离状态的理解]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号集]]></title>
    <url>%2F2018%2F05%2F18%2F%E4%BF%A1%E5%8F%B7%E9%9B%86%2F</url>
    <content type="text"><![CDATA[信号集我们需要有一个能表示多个信号—信号集（signal set）的数据类型。我们将在sigprocmask类函数中使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。 如前所述，不同的信号的编号可能超过一个整型变量所包含的位数，所有一般而言，不能用整型量中的一位代表一种信号，也就是不能用一个整型量表示信号集。POSIX.1定义数据类型sigset_t以包含一个信号集，并且定义了下列5个处理信号集的函数。 1234567#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set,int signo);int sigdelset(sigset_t *set,int signo); //4个函数返回值：若成功，返回0，若出错，返回-1int sigismember(const sigset_t *set,int signo); //返回值，若真，返回1，若假，返回0 函数sigemptyset初始化由set指向的信号集，清除其中所有信号。函数sigfillset初始化由set指向的信号集，使其包括所有信号。所有应用程序在使用信号集前，要对该信号集调用sigemptyset或sigfillset一次。这是因为C编译器将不赋初值的外部变量和静态变量都初始化为0，而这是否与给定系统上信号集的视线相对应并不清楚。 一旦已经初始化了一个信号集，以后就可在该信号集中增、删特定的信号。 实现如果实现的信号数目少于一个整型量所包含的位数，则可用一位代表一个信号的方法实现信号集，例如，假定一种实现有31种信号和32位整型。sigemptyset函数将整型设置为0，sigfillset函数则将整型中的各位设置为1. 12#define sigemptyset(ptr) (*(ptr) = 0)#define sigfillset(ptr) (*(ptr) = ~(sigset_t)0,0) 注意，除了设置信号集中各位为1外，sigfillset必须返回0，所以使用c语言的逗号运算符，它将逗号运算符后的值作为表达式的值返回。 其他关闭某一位、开启某一位、检查某一位的操作类似bitmap算法操作。 函数sigprocmask一个进程的信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集。调用函数sigprocmask可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。 123#include &lt;signal.h&gt;int sigprocmask(int how,const sigset_t *restrict set,sigset_t *restrict oset); //返回值：若成功，返回0，若出错，返回-1 首选，若oset是非空指针，那么进程的当前信号屏蔽字通过oset返回。 其次，若set是一个非空指针，则参数how指示如何修改当前信号量屏蔽字。下图说明了how可选的值。SIG_BLOCK是或操作，而SIG_SETMASK则是赋值操作。注意，不能阻塞SIGKILL和SIGSTOP信号。 如果set是个空指针，则不改变该进程的信号屏蔽字，how的值也无意义。 在调用sigprocmask后如果由任何未决的、不在阻塞的信号，则在sigprocmask返回前，至少将其中之一递送给该进程。 函数sigpendingsigpending 函数返回一个信号集，对于调用进程而言。其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过set参数返回。 12#include &lt;signal.h&gt;int sigpending(sigset_t *set); //返回值：若成功，返回0，若出错，返回-1 示例展示了前面的大部分函数和信号功能 1234567891011121314151617181920212223242526272829303132333435363738#include "head.h"static void sig_quit(int);int main(void)&#123; sigset_t newmask,oldmask,pendmask; if(signal(SIGQUIT,sig_quit) == SIG_ERR)&#123; printf("can't catch SIGQUIT\n"); &#125; // block SIGQUIT and save current signal mask sigemptyset(&amp;newmask); sigaddset(&amp;newmask,SIGQUIT); if(sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask) &lt; 0)&#123; printf("SIG_BLOCK error\n"); &#125; sleep(5); //SIGQUIT here will remain pending if(sigpending(&amp;pendmask) &lt; 0)&#123; printf("sigpending error\n"); &#125; if(sigismember(&amp;pendmask,SIGQUIT))&#123; printf("\nSIGQUIT pending\n"); &#125; // Restore signal mask which unblocks SIGQUIT if(sigprocmask(SIG_SETMASK,&amp;oldmask,NULL) &lt; 0)&#123; printf("SIG_SETMASK error\n"); &#125; printf("SIGQUIT unblocked\n"); sleep(5); exit(0);&#125;static void sig_quit(int signo)&#123; printf("caught SIGQUIT\n"); if(signal(SIGQUIT,SIG_DFL) == SIG_ERR)&#123; //restablished new handler printf("can't reset SIGQUIT\n"); &#125;&#125; 进程阻塞SIGQUIT信号，同时保存了当前信号屏蔽字（以便后面恢复），然后休眠5秒。在此期间，发送若干退出信号SIGQUIT，这些信号都被阻塞，不递送至该进程，休眠结束后，将SIGQUIT设置为不再阻塞，在sigprocmask设置为之前未阻塞的信号集返回前，之前阻塞的SIGQUIT被递送到进程，并执行相应的信号处理函数，这是我们发现，之前发送的多个SIGQUIT只执行了一次，说明信号在该系统中没有进行排队，然后重新注册新的SIGQUIT信号处理函数为默认，也就是终止进程，此时，进程调用sleep再此休眠5秒，再此期间，如果接收到SIGQUIT信号，则执行默认处理，终止进程。 12345678910[vrlive@iZ23chs2r19Z ten]$ ./sigprocmask.o ^\^\^\^\SIGQUIT pendingcaught SIGQUITSIGQUIT unblocked^\Quit[vrlive@iZ23chs2r19Z ten]$ ./sigprocmask.o ^\SIGQUIT pendingcaught SIGQUITSIGQUIT unblocked^\Quit]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alarm与pause]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%87%BD%E6%95%B0alarm%E5%92%8Cpause%2F</url>
    <content type="text"><![CDATA[alarm使用alarm函数可以设置一个定时器（闹钟时间），在将来的某个时刻该定时器会超时。当定时器超时时，产生SIGALRM信号。如果忽略或不捕获此信号，则其默认动作是终止调用该alarm函数的进程。 12#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); //返回值：0或以前设置的闹钟时间的余留秒数 参数seconds的值是产生信号SIGALRM需要经过的时钟秒数。当这一时刻到达时，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一个时间间隔。 每个进程只能有一个闹钟时间。如果在调用alarm时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次alarm函数调用的值返回。已经注册的闹钟时间则被新值取代。 如果由以前注册的尚未超过的闹钟时间，而且本次调用的second值是0，则取消以前的闹钟时间，其余留值仍作为为alarm函数的返回值。 示例123456789101112131415161718#include "head.h"static void sig_alarm(int signo)&#123; printf("receivec %d signal\n");&#125;int main(void)&#123; if(signal(SIGALRM,sig_alarm) == SIG_ERR)&#123; printf("signal error\n"); &#125; alarm(10); sleep(5); printf("sleep over\n"); int ret = alarm(2); //restablished new alarm printf("last alarm last second = %d\n",ret); pause(); return 0;&#125; 1234[vrlive@iZ23chs2r19Z ten]$ ./alarm.o sleep overlast alarm last second = 5receivec 14 signal pausepause函数使调用进程挂起直至捕捉到一个信号。 12#include &lt;unistd.h&gt;int pause(void); //返回值-1，errno设置为EINTR 只有执行了一个信号处理程序并从其中返回时，pause才返回。这种情况下，pause返回-1，errno设置为EINTR。 123456789101112131415#include "head.h"static void sig_usr(int signo)&#123; printf("wangxinri\n");&#125;int main(void)&#123; if(signal(SIGUSR1,sig_usr) == SIG_ERR)&#123; printf("signal error\n"); &#125; printf("begin the pause function\n"); pause(); printf("end the main function\n"); return 0;&#125; 1234567891011121314[vrlive@iZ23chs2r19Z ten]$ ps -aufUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDvrlive 5263 0.0 0.0 115512 2148 pts/0 Ss 19:50 0:00 -bashvrlive 5291 0.0 0.0 4168 356 pts/0 S+ 19:51 0:00 \_ ./sleep.ovrlive 5226 0.0 0.0 115512 2144 pts/1 Ss 19:45 0:00 -bashvrlive 5293 0.0 0.0 139496 1612 pts/1 R+ 19:52 0:00 \_ ps -aufroot 473 0.0 0.0 110036 844 tty1 Ss+ 2017 0:00 /sbin/agetty --noclear tty1 linux[vrlive@iZ23chs2r19Z ten]$ kill -USR1 5291[vrlive@iZ23chs2r19Z ten]$ ./sleep.o begin the pause functionwangxinriend the main function]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2018%2F05%2F18%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[引言使用多个控制线程（或者简单地说就是线程）在单进程环境中执行多个任务。一个进程中的所有线程都可以访问该进程的组成部分，如文件描述符和内存。 不管什么情况下，只要单个资源需要在多个用户间共享，就必须处理一致性问题。本章的最后将讨论目前可用的同步机制，防止多个线程在共享资源时出现不一致的问题。 线程的概念典型的UNIX进程可以看成只有一个控制线程，一个进程在某一时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处。 通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件描述符。 有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下，一个单线程进程要完成多个任务，只需要把这些任务串行化。但有多个控制线程时，相互独立的任务的处理就可以交叉进行，此时只需要为每个任务分配一个单独的线程。当然只有在两个任务的处理过程互不依赖的情况下，两个任务才可以交叉执行。 交互的程序同样可以通过使用多线程来改善响应时间，多线程可以把程序中处理用户输入输出的部分与其他部分分开。 即使多线程程序在串行化任务时不得不阻塞，由于某些线程在阻塞的时候还有另外一些线程可以运行，所以多线程程序在单处理器上运行还是可以改善响应时间和吞吐量。 每个线程都包含有表示执行环境所必需的信息，其中包含进程中标识线程的线程ID，一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。 线程标识就像每个进程有一个进程ID一样，每个线程也有一个线程ID，进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义。 线程ID是用pthread_t数据类型来表示，必须使用一个函数来对两个线程ID进行比较。 123#include &lt;pthread.h&gt;int pthread_equal(pthread_t tid1,pthread_t tid2); //若相等，返回非0数值；否则，返回0 线程可以通过调用pthread_self函数获得自身的线程ID。 1pthread_t pthread_self(void); //返回值：调用线程的线程ID 线程创建在传统的UNIX进程模型中，每个进程只有一个控制线程。从概念上来讲，这与基于线程的模型中每个进程只包含一个线程是相同的。在POSIX线程（pthread）的情况下，程序开始运行时，他也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用pthread_create函数创建。 123456#include &lt;pthread.h&gt;int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg); //返回值：若成功，返回0；否则，返回错误编码。 参数说明： tidp：新创建的线程ID会被设置成tidp指向的内存单元。 attr：用于定制各种不同的线程属性，如果设置为NULL，则创建一个具有默认属性的线程。 start_rtn：新创建的线程从start_rtn函数的地址开始运行，该函数只有一个void类型的指针参数arg，如果start_rtn需要多个参数，可以将参数放入一个结构中，然后将结构的地址作为arg传入。 线程创建时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。 注意：pthread函数在调用失败后通常会返回错误码，它们并不像其他的POSIX函数一样设置errno。每个线程都提供errno的副本，这只是为了与使用errno的现有函数兼容。在线程中，从函数中返回错误码更为清晰整洁，不需要依赖那些随着函数执行不断变化的全局状态。这样可以把错误的范围限制在引起出错的函数中。 示例创建一个线程，打印进程ID、新线程的线程ID以及初始化线程的线程ID。 123456789101112131415161718192021222324252627#include "head.h"pthread_t ntid;void printids(const char *s)&#123; pid_t pid; pthread_t tid; pid = getpid(); tid = pthread_self(); printf("%s pid %lu,tid %lu (0x%lx)\n",s,pid,tid,tid);&#125;void* thr_fn(void *arg)&#123; printids("new thread: "); return (void*)0;&#125;int main(void)&#123; int err; err = pthread_create(&amp;ntid,NULL,thr_fn,NULL); if( err != 0)&#123; printf("pthread_create error\n"); &#125; printids("main thread: "); sleep(1); exit(0);&#125; 1234[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadCreate.c -o pthreadCreate.o -lpthread[vrlive@iZ23chs2r19Z eleven]$ ./pthreadCreate.o main thread: pid 7229,tid 140149555926848 (0x7f771c7f1740)new thread: pid 7229,tid 140149547579136 (0x7f771bffb700) 在编译中要加 -lpthread参数，因为pthread库不是linux默认的库。 这个示例有两个特别之处。 第一个特别之处在于，主线程需要休眠，如果主线程不休眠，它就可能会退出，这样新线程还没有机会运行，整个进程就可能已经终止了。这种行为依赖于操作系统中的线程实现和调度算法。 第二个特别之处在于新线程是通过调用pthread_self函数获取自己的线程ID的，而不是从共享内存中读出的，或者从线程的启动例程中以参数的形式接收到的。在这个例子中，主线程把新线程ID存放在ntid中，但是新建的线程并不能安全地使用它，如果新线程在主线程调用pthread_create返回之前就运行了，那么新线程有可能看到的是未经初始化的ntid的内容。这个内容并不是正确的线程ID。 线程终止如果进程中的任意线程调用了exit、_Exit、_exit，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。 单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。 线程可以简单地从启动例程中返回，返回值是线程的退出码。 线程可以被同一进程中的其他线程取消。 线程调用pthread_exit。 12#include &lt;pthread.h&gt;void pthread_exit(void *rval_ptr); rval_ptr参数是一个无类型的指针，与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用pthread_join函数访问到这个指针上。 12#include &lt;pthread.h&gt;int pthread_join(pthread_t thread,void **rval_ptr); //若成功，返回0；否则，返回错误编码 调用线程将一直阻塞，直到指定的线程调用pthread_exit、从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，rval_ptr就包含返回码。如果线程被取消，由rval_ptr指定的内存单元被设置为PTHREAD_CANCELED。 可以通过调用pthread_join自动把线程置于分离状态，这样资源就可以恢复。如果线程已经处于分离状态，pthread_join调用就会失败，返回EINVAL，尽管这种行为是与具体实现相关的。 如果对线程的返回值并不敢兴趣，那么可以把rval_ptr设置为NULL。在这种情况下，调用pthread_join函数可以等待指定的线程终止，但并不获取线程的终止状态。 示例获取已终止线程的退出码。 123456789101112131415161718192021222324252627282930313233343536#include "head.h"void* thr_fn1(void *arg)&#123; printf("thread 1 returning\n"); return ((void*)1);&#125;void* thr_fn2(void *arg)&#123; printf("thread 2 exiting\n"); pthread_exit((void*)2);&#125;int main(void)&#123; int err; pthread_t tid1,tid2; void *tret; err = pthread_create(&amp;tid1,NULL,thr_fn1,NULL); if(err != 0)&#123; printf("can't create thread1\n"); &#125; err = pthread_create(&amp;tid2,NULL,thr_fn2,NULL); if(err != 0)&#123; printf("can't create thread2\n"); &#125; err = pthread_join(tid1,&amp;tret); if(err != 0)&#123; printf("can't join with thread 1\n"); &#125; printf("thread1 exit code %ld\n",(long)tret); err = pthread_join(tid2,&amp;tret); if(err != 0)&#123; printf("can't join with thread1\n"); &#125; printf("thread2 exit code %ld\n",(long)tret); exit(0);&#125; 123456[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadJoin.c -o pthreadJoin.o -lpthread[vrlive@iZ23chs2r19Z eleven]$ ./pthreadJoin.o thread 1 returningthread1 exit code 1thread 2 exitingthread2 exit code 2 可以看出，当一个线程通过调用pthread_exit退出或简单地从启动例程中返回时，进程中的其他线程可以通过调用pthread_join函数获得该进程的退出状态。 pthread_create和pthread_exit函数的无类型指针参数可以传递的值不止一个，这个指针可以传递包含复杂信息的结构的地址，但是注意，这个结构体所使用的内存在调用者完成调用以后必须仍然是有效的。 示例： 程序给出了用自动变量（分配在栈上）作为pthread_exit的参数时出现的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include "head.h"struct foo&#123; int a,b,c,d;&#125;;void printfoo(const char *s,const struct foo *fp)&#123; printf("%s",s); printf(" structure at 0x%lx\n",(unsigned long)fp); printf(" foo.a = %d\n",fp-&gt;a); printf(" foo.b = %d\n",fp-&gt;b); printf(" foo.c = %d\n",fp-&gt;c); printf(" foo.d = %d\n",fp-&gt;d);&#125;void* thr_fn1(void *arg)&#123; struct foo f = &#123;1,2,3,4&#125;; //initinal printfoo("thread1 :\n",&amp;f); pthread_exit((void*)&amp;f);&#125;void* thr_fn2(void *arg)&#123; printf("thread 2: ID is %lu\n",(unsigned long)pthread_self()); pthread_exit((void*)0);&#125;int main(void)&#123; int err; pthread_t tid1,tid2; struct foo *fp; err = pthread_create(&amp;tid1,NULL,thr_fn1,NULL); if(err != 0)&#123; printf("can't create thread1\n"); &#125; err = pthread_join(tid1,(void*)&amp;fp); if(err != 0)&#123; printf("can't join with thread1\n"); &#125; sleep(1); printf("parent starting second thread\n"); err = pthread_create(&amp;tid2,NULL,thr_fn2,NULL); if(err != 0)&#123; printf("can't create thread2\n"); &#125; err = pthread_join(tid2,NULL); if(err != 0)&#123; printf("can't join with thread2\n"); &#125; sleep(1); printfoo("parent:\n",fp); exit(0);&#125; 12345678910111213141516[vrlive@iZ23chs2r19Z eleven]$ gcc pthreadExit.c -o pthreadExit.o -lpthread[vrlive@iZ23chs2r19Z eleven]$ ./pthreadExit.o thread1 : structure at 0x7ff5ec397f00 foo.a = 1 foo.b = 2 foo.c = 3 foo.d = 4parent starting second threadthread 2: ID is 140694206908160parent: structure at 0x7ff5ec397f00 foo.a = 0 foo.b = 0 foo.c = 1 foo.d = 0 解决办法，可以使用全局结构（全局变量，static修饰），或者用malloc函数分配结构。 取消线程线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程。 12#include &lt;pthread.h&gt;int pthread_cancel(pthread_t tid); //返回值，若成功，返回0，否则，返回错误编码 在默认情况下，pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数，但是，线程可以选择忽略取消或者控制如何被取消。注意，pthread_cancel并不等待线程终止，它仅仅提出请求。 线程可以安排它退出时需要调用的函数，这与进程在退出时可以用atexit函数安排退出是类似的。这样的函数称为线程清理处理程序（thread cleanup handler）。一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们的注册时相反。 123#include &lt;pthread.h&gt;void pthread_cleanup_push(void (*rtn)(void *)，void *arg);void pthread_cleanup_pop(int execute); 当线程执行以下动作时，清理函数rtn是由pthread_cleanup_push函数调度的，调用时只有一个参数arg： 调用pthread_exit时； 响应取消请求时； 用非零execute参数调用pthread_cleanup_pop时。 如果execute参数设置为0，清理函数将不被调用。不管发生上述哪种情况，pthread_cleanup_pop都将删除上次pthread_cleanup_push调用建立的清理处理程序。 这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include "head.h"void cleanup(void *arg)&#123; printf("cleanup: %s\n",(char*)arg);&#125;void* thr_fn1(void *arg)&#123; printf("thread1 start\n"); pthread_cleanup_push(cleanup,"thread1 first handler"); pthread_cleanup_push(cleanup,"thread1 second handler"); printf("thread1 push complete\n"); if(arg)&#123; // (void*)1 return ((void*)1); &#125; printf("pthread1 pthread_cleanup_pop start\n"); pthread_cleanup_pop(0); pthread_cleanup_pop(0); return ((void*)1);&#125;void* thr_fn2(void *arg)&#123; printf("thread2 start\n"); pthread_cleanup_push(cleanup,"thread2 first handler"); pthread_cleanup_push(cleanup,"thread2 second handler"); printf("thread2 push complete\n"); if(arg)&#123; pthread_exit((void*)2); &#125; printf("pthread2 pthread_cleanup_pop start\n"); pthread_cleanup_pop(0); pthread_cleanup_pop(0); pthread_exit((void*)2);&#125;int main(void)&#123; int err; pthread_t tid1,tid2; void *tret; err = pthread_create(&amp;tid1,NULL,thr_fn1,(void*)1); if(err != 0)&#123; printf("can't create thread1\n"); &#125; err = pthread_create(&amp;tid2,NULL,thr_fn2,(void*)1); if(err !=0)&#123; printf("can't create thread2\n"); &#125; err = pthread_join(tid1,&amp;tret); if(err != 0)&#123; printf("can't join with thread1\n"); &#125; printf("thread1 exit code %ld\n",(long)tret); err = pthread_join(tid2,&amp;tret); if(err != 0)&#123; printf("can't join with thread2\n"); &#125; printf("thread2 exit code %ld\n",(long)tret); exit(0);&#125; 123456789[vrlive@iZ23chs2r19Z eleven]$ ./pthreadCleanup.o thread1 startthread1 push completethread1 exit code 1thread2 startthread2 push completecleanup: thread2 second handlercleanup: thread2 first handlerthread2 exit code 2 从输入结果可以看到，两个线程都正确地启动和退出了，但是只有第二个线程的清理处理程序被调用了。因此，如果线程是通过从它的启动例程中返回而终止的话，它的清理处理程序就不会被调用，还要注意清理处理程序是按照与它们安装时相反的顺序被调用的。 现在，让我们了解一下线程函数和进程函数之间的相似之处，下图总结了这些相似的函数。 进程原语 线程原语 描述 fork pthread_create 创建新的控制流 exit pthread_exit 从现在的控制流中退出 waitpid pthread_join 从控制流中得到退出状态 atexit pthread_cancel_push 注册在调用控制流时调用的函数 getpid pthread_self 获取控制流ID abort pthread_cancel 请求控制流的非正常退出 在默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。在线程分离后，我们不能用pthread_join函数等待它的终止状态，因为对分离状态的线程调用pthread_join会产生未定义行为。可以调用pthread_detach分离线程。 12#include &lt;pthread.h&gt;int pthread_detach(pthread_t tid); //若成功，返回0；否则，返回错误编码]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kill和raise]]></title>
    <url>%2F2018%2F05%2F17%2F%E5%87%BD%E6%95%B0kill%E5%92%8Craise%2F</url>
    <content type="text"><![CDATA[kill和raisekill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。 1234#include &lt;signal.h&gt;int kill(pid_t pid,int signo);int raise(int signo); //若成功，返回0；若出错，返回-1 调用123raise(signo);//等价于调用kill(getpid(),signo); kill的pid参数有以下4中不同的情况。 pid&gt;0 将该信号发送给进程ID为pid的进程。 pid == 0 将该信号发送给与发送进程属于同一进程组的所有进程。 pid &lt; 0 将该信号发送给其他进程组ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程。 pid == -1 该信号发送给发送进程有权限向它们发送信号的所有进程。 12345678910111213141516#include "head.h"static void sig_usr1(int);int main(void)&#123; if(signal(SIG_USR1,sig_usr1) == SIG_ERR)&#123; printf("signal error\n"); &#125; kill(getpid(),SIG_USR1); printf("send a SIG_USR1\n"); exit(0);&#125;static void sig_usr1(int signo)&#123; printf("received a %d signal\n");&#125; 123[vrlive@iZ23chs2r19Z ten]$ ./kill.o received a 897804016 signalsend a SIGUSR1]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号]]></title>
    <url>%2F2018%2F05%2F16%2F%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[引言信号是软件中断。很多比较重要的应用程序都需要处理信号，信号提供了一种处理异步事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。 信号概念首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，SIGABRT是夭折信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，由alarm函数设置的定时器超时后将产生此信号。 在头文件中，信号名都被定义为正整数常量（信号编号）。 不存在编号为0的信号。kill函数对信号编号0有特殊的应用。POSIX.1将此种信号编号值称为空信号。 很多条件可以产生信号： 当用户按某些终端键时，引发终端产生的信号。在终端上按Delete键（或者很多系统中的Ctrl+C键）通常产生中断信号（SIGINT）。这是停止一个已失去控制程序的方法。 硬件异常产生信号：除数为0、无效的内存引用等。这些条件通常由硬件检测到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无效内存引用的进程产生SIGSEGV信号。 进程调用kill函数可将任意信号发送给另一个进程或进程组。自然，对此有所限制，接受信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。 用户可用kill命令将信号发送给其他进程。此命令只是kill函数的接口。常用此命令终止一个失控的后台进程。 当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是硬件产生条件（如除以0），而是软件条件。例如SIGURG（在网络连接上传来带外的数据）、SIGPIPE（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM（进程所设置的定时器已经超时）。 信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单的测试一个变量（如errno）来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。 在某个信号出现时，可以告诉内核按下列3中方式之一进行处理，我们称之为信号的处理或与信号相关的动作。 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却绝不能忽略，它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号（如非法内存引用或除以0），则进程的运行行为是未定义的。 捕获信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。比如，如果捕获到SIGCHLD信号，则表示一个子进程已经终止，所以此信号的捕获函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。注意：不能捕获SIGKILL和SIGSTOP信号。 执行系统默认动作，对大多数系统默认动作是终止该进程。 下面较详细地逐一说明这些信号： 参考UNIX环境高级编程。 函数signalUNIX系统信号机制最简单的接口是signal函数。 123#include &lt;signal.h&gt;void (*signal(int signo ,void (*func)(int))) (int); //若成功，返回以前的信号处理配置；若出错，返回SIG_ERR 通过typedef可以转换成这样： 12typedef void Sigfunc(int);Sigfunc *signal(int,Sigfunc *); 也就是说，signal有两个参数，一个是int,一个是Sigfunc ,返回值也是Sigfunc ，该指针指向一个参数为int，无返回值的函数。 signo参数是上图中的信号名。func的值是常量SIG_IGN、常量SIGDFL或当接到此信号后要调用的函数的地址。 SIG_IGN，则向内核表示忽略此信号（记住有两个信号SIGKILL和SIGSTOP不能忽略）。 SIG_DFL，则表示接到此信号后的动作是系统默认动作。 当指定函数地址时，则在信号发生时，调用该信号，我们称这种处理为捕获该信号，称此函数为信号处理程序（signal handler）或信号捕获函数（signal-catching function）。 当调用signal设置处理程序时，第二个参数是指向该函数（也就是信号处理程序）的指针。signal的返回值则是指向在此之前的信号处理程序的指针。 signal 的第1个参数signum表示要捕捉的信号，第2个参数是个函数指针，表示要对该信号进行捕捉的函数，该参数也可以是SIG_DEF(表示交由系统缺省处理，相当于白注册了)或SIG_IGN(表示忽略掉该信号而不做任何处理)。signal如果调用成功，返回以前该信号的处理函数的地址，否则返回 SIG_ERR。 123#define SIG_ERR (void(*)())-1#define SIG_DFL (void(*)())0#define SIG_IGN (void(*)())1 这些常量可用于表示“指向函数的指针，该函数要求一个整形参数，并且无返回值”。signal的第二个参数及其返回值就可用它们表示。这些常量所使用的3个值不一定是-1、0和1，但它们必须是3个值而绝不能是任一函数的地址。 注： 为什么不是这样定义的呢？？ 123#define SIG_ERR (void (*)(int))-1#define SIG_DEL (void (*)(int))0#define SIG_IGN (void (*)(int))1 在网上搜索之后找到答案，C语言中是可以这样定义的，C语言中前向声明是可以省略参数的，意味着可以有任意多个参数： 123456789void fun(); int main()&#123; fun(1,2);&#125; void fun(int i, int j)&#123; printf("%d\n",i+j);&#125; 只是将-1强制转换为一个指针，通过编译。就像 1#define NULL (void *)0 可以将SIG_ERR跟其他的信号理解的一样，是一个整数。 示例下面给出了一个简单的信号处理程序，它捕获两个用户定义的信号并打印信号编号，pause函数，它使调用进程在接到一信号前挂起。 1234567891011121314151617181920212223242526#include "head.h"static void sig_usr(int); //one handler for both signalsint main(void)&#123; if(signal(SIGUSR1,sig_usr) == SIG_ERR)&#123; printf("can't catch error\n"); &#125; if(signal(SIGUSR2,sig_usr) == SIG_ERR)&#123; printf("can't catch error\n"); &#125; printf("we come here,catch no signal\n"); for(;;)&#123; pause(); &#125;&#125;static void sig_usr(int signo)&#123; //argument is signal number if(signo == SIGUSR1)&#123; printf("received SIGUSR1\n"); &#125;else if(signo == SIGUSR2)&#123; printf("received SIGUSR2\n"); &#125;else&#123; printf("received signal %d\n",signo); &#125;&#125; 我们使程序在后台运行，并且用kill命令将信号发送给它。 注意，在UNIX系统中，杀死（kill）这个术语是不恰当的。kill命令和kill函数只是将一个信号发送给一个进程或进程组。该信号是否终止进程取决于该信号的类型，以及进程是否安排了捕获该信号。 12345678[vrlive@iZ23chs2r19Z ten]$ ./signal.o &amp; //后台启动进程[4] 3243 //进程ID[vrlive@iZ23chs2r19Z ten]$ kill -USR1 3243received SIGUSR1[vrlive@iZ23chs2r19Z ten]$ kill -USR2 3243received SIGUSR2[vrlive@iZ23chs2r19Z ten]$ kill 3243 //默认向该进程发送SIGTERM[4]+ Terminated ./signal.o 程序启动当执行一个程序时，所有信号的状态都是系统默认或者忽略。通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。确切地讲，exec函数将原先设置为要捕获的信号都更改为默认状态，其他信号的状态不变（一个进程原先要捕获的信号，当其执行一个新程序后，就不再捕获了，因为信号捕获函数的地址很可能在所执行的新程序文件中已无意义）。 很多捕获这两个信号的交互程序具有下列形式的代码： 123456void sig_int(int);void sig_quit(int);if(signal(SIGINT,SIG_IGN) != SIG_IGN) signal(SIGINT,sig_int);if(signal(SIGQUIT,SIG_IGN) != SIG_IGN) signal(SIGQUIT,sig_quit); 这样处理后，仅当SIGINT和SIGQUIT当前未被忽略时，进程才会捕获它们。 从signal的这两个调用中也可以看到这种函数的限制：不改变信号的处理方式就不能确定信号的当前处理方式。 进程创建当一个进程调用fork时，其子进程继承父进程的信号处理方式，因为子进程在开始时复制了父进程的内存映像，所以信号捕获函数的地址在子进程中时有意义的。 示例首先注册一个信号处理函数，发送信号后，注册信号处理函数更新新的注册信号函数，代替之前的信号处理函数。 1234567891011121314151617181920212223#include "head.h"static void sig_usr(int);static void sig_usr1(int);int main(void)&#123; if(signal(SIGUSR1,sig_usr) == SIG_ERR)&#123; printf("can't catch SIGUSR1\n"); &#125; for(;;)&#123; pause(); &#125;&#125;static void sig_usr(int signo)&#123; signal(SIGUSR1,sig_usr1); printf("now we reestablish handler for next time\n");&#125;static void sig_usr1(int signo)&#123; printf("this handler is new handler\n");&#125; 12345678910[vrlive@iZ23chs2r19Z ten]$ ps -aufUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDvrlive 4420 0.0 0.0 115512 2136 pts/1 Ss 10:18 0:00 -bashvrlive 4444 0.0 0.0 139496 1616 pts/1 R+ 10:18 0:00 \_ ps -aufvrlive 4378 0.0 0.0 115516 2140 pts/0 Ss 10:03 0:00 -bashvrlive 4415 0.0 0.0 4164 352 pts/0 S+ 10:17 0:00 \_ ./changesignal.oroot 473 0.0 0.0 110036 844 tty1 Ss+ 2017 0:00 /sbin/agetty --noclear tty1 linux[vrlive@iZ23chs2r19Z ten]$ kill -USR1 4415[vrlive@iZ23chs2r19Z ten]$ kill -USR1 4415[vrlive@iZ23chs2r19Z ten]$ kill -USR1 4415 12345[vrlive@iZ23chs2r19Z ten]$ ./changesignal.o now we reestablish handler for next timethis handler is new handlerthis handler is new handler]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程组]]></title>
    <url>%2F2018%2F05%2F16%2F%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[进程组每个进程除了有一进程ID外，还属于一个进程组。 进程组是一个或多个进程的集合。通常，他们是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID—它是一个正整数，并可存放在pid_t数据类型中。函数getpgrp返回调用进程的进程组ID。 12#include &lt;unistd.h&gt;pid_t getpgrp(void); //调用进程的进程组ID Single UNiX Specification定义了getpgid函数模仿此种运行行为。该函数的参数时pid，返回该进程的进程组ID。 12#include &lt;unistd.h&gt;pid_t getpgid(pid_t pid); 若pid是0，返回调用进程的进程组ID，于是，getpgid(0); 等价于 getpgrp(); 123456789#include "head.h"int main(void)&#123; printf("pid = %d,ppid = %d\n",getpid(),getppid()); //主进程的父进程是bash printf("pgrp = %d\n",getpgrp()); printf("pgrp = %d\n",getpgid(0)); system("ps -O pgid"); //打印进程状态 exit(0);&#125; 12345678[vrlive@iZ23chs2r19Z nine]$ ./getppid.o pid = 1174,ppid = 1103 //1103为bashpgrp = 1174pgrp = 1174 PID PGID S TTY TIME COMMAND 1103 1103 S pts/1 00:00:00 -bash 1174 1174 S pts/1 00:00:00 ./getppid.o 1175 1174 R pts/1 00:00:00 ps -O pgid 每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。 进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。 进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组。 12#include &lt;unistd.h&gt;int setpgid(pid_t pid,pid_t pgid); //若成功，返回0；若出错，返回-1 setpgid 函数将pid进程的进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。如果pid是0，则使用调用者的进程ID。另外，如果pgid是0，则由pid指定的进程ID用作进程组ID。 一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后，它就不再更改该子进程的进程组ID。 在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID。在这来两个调用中有一个是冗余的，但让父进程和子进程都这样做可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如果不这样做，在fork之后，由于父进程和子进程运行的先后次序不确定，会因为子进程的组员身份取决于哪个进程首先执行而产生竞争条件。 会话会话（session）是一个或多个进程组的集合。 进程调用setsid函数建立一个新会话。 12#include &lt;unistd.h&gt;pid_t setsid(void); //若成功，返回进程组ID，若出错，返回-1 如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事。 该进程变成新会话的会话首进程。此时，该进程是新会话中的唯一进程。 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。 该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断。 如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。 getsid函数返回会话首进程的进程组ID。 12#include &lt;unistd.h&gt;pid_t getsid(pid_t pid); //若成功，返回会话首进程的进程组ID；若出错，返回-1 如若pid是0，getsid返回调用进程的会话首进程的进程ID。处于安全方面的考虑，一些实现有如下限制：如若pid并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组ID。 示例1234567891011121314151617181920212223242526#include "head.h"int main(void)&#123; pid_t pid; if((pid = fork()) &lt; 0)&#123; printf("fork error\n"); &#125;else if(pid == 0)&#123; pid_t sid; sid = getsid(0); printf("in child(before setsid) sid = %d\n",sid); sid = setsid(); printf("in child(after setsid) sid = %d\n",sid); printf("in child sid = %d,pgrpid = %d,pid = %d\n",sid,getpgrp(),getpid()); exit(0); &#125; pid_t sid; sid = setsid(); //error -1 printf("in parent sid = %d,pgrpid = %d,pid = %d\n",sid,getpgrp(),getpid()); sid = getsid(0); printf("in parent sid = %d\n",sid); sid = getsid(pid); printf("in parent get child sid = %d\n",sid); sid = getsid(1); printf("in parent get init sid = %d\n",sid); waitpid(pid,NULL,0); return 0;&#125; 12345678[vrlive@iZ23chs2r19Z nine]$ ./session.o in parent sid = -1,pgrpid = 1469,pid = 1469in parent sid = 1329in parent get child sid = 1329in parent get init sid = 1in child(before setsid) sid = 1329in child(after setsid) sid = 1470in child sid = 1470,pgrpid = 1470,pid = 1470 在父进程中，调用setsid，因为该进程是进程组组长（pid和pgrpid都是1469），所以返回-1。 获取父进程sid是1329。 在父进程中获取子进程sid也是1329。 在父进程中获取init的sid是1。（好像能获取任何进程的sid） 在子进程中获取sid是1329（此时和父进程子在同一个会话中） 在子进程中setsid后，子进程处在新的会话中，新会话的ID是1470， 在子进程中获取sid是1470，进程组ID和进程ID都是1470，说明该子进程是会话中的第一个进程，而且是进程组的组长。 参考：https://blog.csdn.net/todd911/article/details/16965971]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exit与wait函数系列]]></title>
    <url>%2F2018%2F05%2F15%2Fexit%E5%92%8Cwait%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[函数exit进程有5中正常终止和3中异常终止方式。5中正常终止方式具体如下： 在main函数内执行return语句。这等效于调用exit。 调用exit函数，此函数由ISO C定义，其操作包括调用各终止处理程序（终止处理程序在调用atexit函数时登记），然后关闭所有标准I/O流等。 调用_exit或者 _Exit函数。ISOC定义 _Exit，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗，这取决于实现。在UNIX系统中， _Exit和 _exit是同义的，并不冲洗标准I/O流。 _exit函数由exit函数调用（在大多数UNIX系统实现中，exit是标准C库中的一个函数，而 _exit则是一个系统调用）。 进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。 进程的最后一个线程调用pthread_exit函数，如同前面一样，在这种情况中，进程终止状态总是0，这与传送给pthread_exit的参数无关。 3中异常终止具体如下： 调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例。 当进程接收到某些信号时。信号可由进程自身（如调用abort函数）、其他进程或内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生响应的信号。 最后一个线程对“取消”（cancellation）请求作出响应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止。 不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。 12345#include &lt;stdlib.h&gt;void exit(int status);void _Exit(int status);#include &lt;unistd.h&gt;void _exit(int status); 对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数（exit、_exit和 _Exit），实现这一点的方法是，将其退出状态（exit status）作为参数传递给函数。在异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态（termination status）。在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态。 子进程在父进程调用fork后产生，子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，将如何呢？ 对于父进程已经终止的所有进程，它们的父进程都改变为init进程。我们称这些进程由init进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就改为1（init进程ID）。这种处理办法保证了每个进程有一个父进程。 内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或者waitpid时，可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。 在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程称为僵死进程（Zombie） 一个由init进程收养的进程终止时会发生什么？它会不会变成一个僵死进程？对此问题的回答是“否”，因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了系统中塞满僵死进程。 函数wait和waitpid当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号，因为子进程终止是个异步时间（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。对于这种信号的系统默认动作是忽略它，现在需要知道的是调用wait或waitpid的进程可能会发生什么。 如果其所有子进程都还在运行，则阻塞。 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。 如果它没有任何子进程，则立即出错返回。 如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在调用wait，则进程可能会阻塞。 1234#include &lt;sys/wait.h&gt;pid_t wait(int *statloc);pid_t waitpid(pid_t pid,int *statloc,int options);//两个函数返回值：若成功，返回进程ID；若出错，返回0或-1 两个函数的区别 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞。 waitpid并不等待在其调用之后的第一个终止进程，它有若干个选项，可以控制它所等待的进程。 如果子进程已经终止，并且是一个僵死进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。如调用者阻塞而且它有多个子进程，则在其某一子进程终止时，wait就立即返回。因为wait返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。 这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。 依据传统，这两个函数返回的整型状态字是由实现定义的。其中某些位表示退出状态（正常返回），其他位则指示信号编号（异常返回），有一位指示是否产生了core文件等。POSIX.1规定，终止状态用定义在中的各个宏来查看。有4个互斥的宏可用来取得进程终止的原因，它们的名字都以WIF开始。基于这4个宏中哪一个值为真，就可选用其他宏来取得退出状态、信号编号等，这4个互斥的宏如下图： 函数pr_exit使用上图中中的宏以打印进程终止状态的说明。 head.h12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;wchar.h&gt;#include &lt;sys/utsname.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;setjmp.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/wait.h&gt;#define FLAGS O_RDWR | O_CREAT#define MODE S_IRUSR | S_IWUSR | S_IXUSR#define MAXLINE 4096void pr_exit(int status)&#123; if(WIFEXITED(status))&#123; printf("normal termination,exit status = %d\n",WEXITSTATUS(status)); &#125;else if(WIFSIGNALED(status))&#123; printf("abnormal termination,signal number = %d %s\n",WTERMSIG(status), #ifdef WCOREDUMP WCOREDUMP(status) ? " (core file generated)" : " "); #else " "); #endif &#125;else if(WIFSTOPPED(status))&#123; printf("child stopped,signal number = %d\n",WSTOPSIG(status)); &#125;&#125; wait.c 123456789101112131415161718192021222324252627282930313233343536373839#include "head.h"int main(void)&#123; pid_t pid; int status; if((pid=fork()) &lt;0 )&#123; printf("fork error\n"); &#125; else if(pid ==0)&#123; exit(7); //child &#125; if(wait(&amp;status) != pid)&#123; //wait for child printf("wait error\n"); &#125; pr_exit(status); //print child status if((pid=fork()) &lt; 0)&#123; printf("fork error\n"); &#125;else if(pid == 0)&#123; //child abort(); //generates SIGABRT &#125; if(wait(&amp;status) != pid)&#123; printf("wait error\n"); &#125; pr_exit(status); if((pid=fork())&lt;0)&#123; printf("fork error\n"); &#125; else if(pid == 0)&#123; status /= 0; //divide by 0 generates SIGFPE &#125; if(wait(&amp;status) != pid)&#123; printf("wait error\n"); &#125; pr_exit(status); exit(0);&#125; 1234[vrlive@iZ23chs2r19Z eight]$ ./wait.o normal termination,exit status = 7abnormal termination,signal number = 6 //SIGABRT的值为6abnormal termination,signal number = 8 //SIGFPE的值为8 waitpid123#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid,int *statloc,int options);//若成功，返回进程ID；若出错，返回0或-1 等待一个指定的进程终止，POSIX定义了waitpid函数以提供这种功能（以及其他一些功能）。 对于waitpid函数中pid参数的作用解释如下： pid == -1 等待任一子进程。此种情况下，waitpid与wait等效。 pid&gt;0 等待进程ID与pid相等的子进程。 pid == 0 等待组ID等于调用进程组ID的任一子进程。 pid &lt; -1 等待组ID等于pid绝对值的任一子进程。 waitpid函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由statloc指向的存储单元中。对于wait，其唯一的出错是调用进程没有子进程（函数调用被另一个信号中断时，也可能返回另一种出错）。但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错。 options参数使我们能进一步控制waitpid的操作。此参数或者是0，或者是下图中常量按位或运算的结果。 waitpid函数提供了wait函数没有提供的3个功能： waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。 waitpid提供了一个wait的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。 waitpid通过WUNTRACED和WCONTINUED选项支持作业控制。 示例：如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止，实现这一要求的诀窍是调用fork两次。 123456789101112131415161718192021222324#include "head.h"int main(void)&#123; pid_t pid; if((pid=fork()) &lt; 0) &#123; printf("fork error\n"); &#125;else if(pid == 0)&#123; //first child if((pid=fork()) &lt;0)&#123; printf("fork error\n"); &#125;else if(pid &gt; 0)&#123; //first child,second parent exit(0); //parent from second fork == first child &#125; // second child sleep(2); printf("second child,parent pid = %d\n",getppid()); exit(0); &#125; // first child parent if(waitpid(pid,NULL,0) != pid)&#123; //wait for first child printf("waitpid error\n"); &#125; printf("parent process end\n"); exit(0);&#125; 第二个子进程调用sleep以保证在打印父进程ID时第一个子进程已终止。在fork之后，父进程和子进程都可继续执行，并且我们无法预知哪一个会先执行。在fork之后，如果不使第二个子进程休眠，那么它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程，而不是init进程（进程ID为1）。 123[vrlive@iZ23chs2r19Z eight]$ ./forktwice.o parent process end[vrlive@iZ23chs2r19Z eight]$ second child,parent pid = 1 1.为何要fork()两次来避免产生僵尸进程？ 当我们只fork()一次后，存在父进程和子进程。这时有两种方法来避免产生僵尸进程： 父进程调用waitpid()等函数来接收子进程退出状态。 父进程先结束，子进程则自动托管到Init进程（pid = 1）。 目前先考虑子进程先于父进程结束的情况： 若父进程未处理子进程退出状态，在父进程退出前，子进程一直处于僵尸进程状态。若父进程调用waitpid()（这里使用阻塞调用确保子进程先于父进程结束 ）来等待子进程结束，将会使父进程在调用waitpid()后进入睡眠状态，只有子进程结束父进程的waitpid()才会返回。 如果存在子进程结束，但父进程还未执行到waitpid()的情况，那么这段时期子进程也将处于僵尸进程状态。 由此，可以看出父进程与子进程有父子关系，除非保证父进程先于子进程结束或者保证父进程在子进程结束前执行waitpid()，子进程均有机会成为僵尸进程。那么如何使父进程更方便地创建不会成为僵尸进程的子进程呢？这就要用两次fork()了。 父进程一次fork()后产生一个子进程随后立即执行waitpid(子进程pid, NULL, 0)来等待子进程结束，然后子进程fork()后产生孙子进程随后立即exit(0)。这样子进程顺利终止（父进程仅仅给子进程收尸，并不需要子进程的返回值），然后父进程继续执行。这时的孙子进程由于失去了它的父进程（即是父进程的子进程），将被转交给Init进程托管。于是父进程与孙子进程无继承关系了，它们的父进程均为Init，Init进程在其子进程结束时会自动收尸，这样也就不会产生僵尸进程了。 示例2 1234567891011121314151617181920212223242526272829303132333435#include "head.h"int main(void)&#123; pid_t pid; if((pid=fork()) &lt; 0)&#123; printf("fork error\n"); &#125;else if(pid != 0)&#123; //parent sleep(2); if(waitpid(pid,NULL,0)!=pid)&#123; printf("waitpid error\n"); &#125;else&#123; printf("waitpid first child success\n"); &#125; exit(2); &#125; //first child printf("pid = %d,ppid = %d\n",getpid(),getppid()); if((pid=fork()) &lt; 0)&#123; printf("fork error\n"); &#125;else if(pid != 0)&#123; sleep(4); if(waitpid(pid,NULL,0)!=pid)&#123; printf("waitpid error\n"); &#125;else&#123; printf("waitpid second child success\n"); &#125; abort(); &#125; // seond child printf("second child\n"); exit(0);&#125; 12345[vrlive@iZ23chs2r19Z eight]$ ./account.o pid = 676,ppid = 675second childwaitpid second child successwaitpid first child success waitidwaitid：取得进程终止状态的函数，此函数类似于waitpid，但提供了更多的灵活性。 123#include &lt;sys/wait.h&gt;int waitid(idtype_t idtype,id_t id,siginfo_t *infop,int options);//若成功，返回0；失败，返回-1 具体介绍参考APUE wait3和wait4wait3和wait4提供的功能比wait、waitpid和waitid所提供功能要多一个，这与附加参数有关，该参数允许内核返回由终止进程及其所有子进程使用的资源概况。 1234567#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;pid_t wait3(int *statloc,int options,struct rusage *rusage);pid_t wait4(pid_t pid,int *statloc,int options,struct rusage *rusage);//若成功，返回进程ID；若出错，返回-1 资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。 相比较于waitid，wait3，wait4，wait和waitpid已经可以满足大多数应用，waitid使用方法与waitpid相似，可以看做是waitpid的增强版。wait3和wait4相比较于wait，waitpid，waitid，增加了获取进程所使用资源的功能。]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>系统函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器文件]]></title>
    <url>%2F2018%2F05%2F14%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[解释器文件所有现今的UNIX系统都支持解释器文件（interpreter file）。这种文件是文本文件，其起始行的形式是： 1#! pathname[optional-argument] 在感叹号和pathname之间的空格是可选的。最常见的解释器文件以下列行开始: 1#! /bin/sh pathname通常是绝对路径名，对它不进行什么特殊的处理（不使用PATH进行路径搜索）。对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程实际执行的并不是该解释器文件，而是在该解释器文件第一行中pathname所指定的文件。一定要将解释器文件（文本文件，它以#!开头）和解释器（由该解释器文件第一行中的pathname指定）区分开来。 示例execl执行的文件是一个解释器文件时，内核如何处理execl参数及该解释器文件第一行的可选参数。 execinterp.c 123456789101112131415#include "head.h"int main(void)&#123; pid_t pid; if((pid = fork()) &lt; 0)&#123; printf("fork error\n"); &#125;else if(pid == 0)&#123; //child if( execl("/home/vrlive/linuxProgram/apueProgram/eight/testinterp","testinterp","myarg1","MY ARG2",(char*)0) &lt; 0)&#123; printf("execl error\n"); &#125; &#125; if(waitpid(pid,NULL,0) &lt; 0)&#123; //parent printf("waitpid error\n"); &#125; exit(0);&#125; 其中testinterp为解释器文件，之前运行老出错，是因为testinterp文件没有可执行权限。 1234[vrlive@iZ23chs2r19Z eight]$ ll | grep testinterp -rwxrwxr-x 1 vrlive vrlive 61 May 14 16:51 testinterp[vrlive@iZ23chs2r19Z eight]$ cat testinterp #! /home/vrlive/linuxProgram/apueProgram/eight/echoarg.o foo echoarg.o是echoarg.c的可执行文件，回显每一个命令行参数。 echoarg.c 123456789#include "head.h"int main(int argc,char *argv[])&#123; int i = 0; for(i = 0;i&lt;argc;++i)&#123; printf("argv[%d]: %s\n",i,argv[i]); &#125; exit(0);&#125; 输出结果： 123456[vrlive@iZ23chs2r19Z eight]$ ./execinterp.o argv[0]: /home/vrlive/linuxProgram/apueProgram/eight/echoarg.oargv[1]: fooargv[2]: /home/vrlive/linuxProgram/apueProgram/eight/testinterpargv[3]: myarg1argv[4]: MY ARG2 当内核exec解释器时（/home/vrlive/linuxProgram/apueProgram/eight/echoarg.o）时，argv[0]是该解释器的pathname，argv[1]是解释器文件中的可选参数，其余参数是pathname（excel函数pathname参数值/home/vrlive/linuxProgram/apueProgram/eight/testinterp）以及execl的第2个和第3个参数（myarg1、MY ARG2）。调用execl时的argv[1]和argv[2]已右移了两个位置。 注意，内核取execl调用中的pathname而非第一个参数（testinterp），因为一般而言，pathname包含了比第一个参数更多的信息。 后续待补充…]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exec系列]]></title>
    <url>%2F2018%2F05%2F14%2Fexec%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[exec用fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序，当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文短、数据段、堆段和栈段。 有7中不同的exec函数可供使用，它们常常被统称为exec函数，我们可以使用这7个函数中的任一个。这些exec函数使得UNIX系统进程控制原语更加完善。用fork可以创建新进程，用exec可以初始执行新的程序。exit函数和wait函数处理终止和等待终止。这些是我们需要的基本的进程控制原语。 123456789#include &lt;unistd.h&gt;int execl(const char *pathname,const char *arg0, ... /* (char*)0 */ );int execv(const char *pathname,char *const argv[]);int execle(const char *pathname,const char *arg0, ... /* (char*)0,char *const envp[] */);int execve(const char *pathname,char *const argv[],char *const envp[]);int execlp(const char *filename,const char *arg0, ... /* (char*)0 */);int execvp(const char *filename,char *const argv[]);int fexecve(int fd,char *const argv[],char *const envp[]); //若出错，返回-1；若成功，不返回 这些函数之间的第一个区别是前4个函数去路径名作为参数，后两个函数则取文件名作为参数，最后一个取文件描述符作为参数。当指定filename作为参数时： 如果filename中包含/，则就将其视为路径名。 否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件。 PATH变量包含了一张目录表（称为路径前缀），目录之间用冒号（:）分隔。 查看PATH环境变量： 12[vrlive@iZ23chs2r19Z eight]$ env | grep PATHPATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/vrlive/.local/bin:/home/vrlive/bin 如果execlp或者execvp使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器长生的机器可执行文件，则就认为该文件是一个shell脚本，于是试着调用/bin/sh，并以该filename作为shell的输入。 第二个区别与参数表的传递有关（l表示list，v表示矢量vector）。函数execl、execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数以空指针结尾（(char*)0）。对于另外4个函数（execv、execvp、execve和fexecve），则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数。 最后一个区别与向新程序传递的环境表相关。以e结尾的3个函数（execle、execve和fexecve）可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有环境。 这7个exec函数的参数很难记忆。函数名中的字符串会给我们一些帮助。字母p表示该函数取filename作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，它与字母v互斥。v表示该函数取一个argv[]矢量。最后，字母e表示该函数取envp[]数组，而不使用当前环境。下图显式了这7个函数之间的区别。 在很多UNIX实现中，这7个函数中只有execve时内核的系统调用。另外6个只是库函数，他们最终都要调用该系统调用。这7个函数之间的关系如下： 在这种安排下，库函数execlp和execvp使用PATH环境变量，查找查找第一个包含名为filename的可执行文件的路径名前缀。fexecve库函数使用/proc把文件描述符参数转换成路径名，execve用该路径名去执行程序。 示例演示execle和execlp的用法 exec.c 12345678910111213141516171819202122232425262728#include "head.h"char *env_init[] = &#123;"USER = unknown","PATH=/tmp",NULL&#125;;int main(void)&#123; pid_t pid; if((pid = fork()) &lt; 0)&#123; printf("fork error\n"); &#125;else if(pid == 0)&#123; //child specify pathname,specify environment if(execle("/home/vrlive/linuxProgram/apueProgram/eight/echoall.o","echoall.o","myarg1","MY ARG2",(char*)0,env_init) &lt; 0) printf("execle error\n"); &#125; if(waitpid(pid,NULL,0) &lt; 0)&#123; printf("waitpid error\n"); &#125; if((pid = fork()) &lt; 0)&#123; printf("fork error\n"); &#125;else if(pid == 0)&#123; if(execlp("echoall.o","echoall.o","only 1 arg",(char*)0) &lt; 0) printf("execlp error\n"); &#125; if(waitpid(pid,NULL,0) &lt; 0)&#123; printf("waitpid error\n"); &#125; exit(0);&#125; 程序要执行两次的echoall程序如下echoall.c所示。这是一个很普通的程序，它回显所有命令行参数及全部环境表。 注意： 我们将第一个参数（新程序中的argv[0]）设置为路径名的文件名分量（”echoall.o”）。某些shell将此参数设置为完全的路径名。这只是一个惯例。我们可将argv[0]设置为任何字符串。当login命令执行shell时就是这样做的。在执行shell之前，login在argv[0]之前加一个/作为前缀，这向shell指明它是作为登录shell被调用的。登录shell将执行启动配置文件（start-up profile）命令，而非登录shell则不会执行这些命令。 execle要求路径名和一个特定的环境。而execlp，它用一个文件名，所以其PATH环境变量所指向的各目录中搜寻可执行文件，我们的echoall.o在/home/vrlive/bin也有一份。 12[vrlive@iZ23chs2r19Z eight]$ env | grep PATHPATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/vrlive/.local/bin:/home/vrlive/bin echoall.c 12345678910111213#include "head.h"int main(int argc,char *argv[])&#123; int i; char **ptr; extern char **environ; //extern the environ for(i = 0;i&lt;argc;++i)&#123; //echo all command-line args printf("argv[%d]: %s\n",i,argv[i]); &#125; for(ptr = environ;*ptr!=0;++ptr)&#123; printf("%s\n",*ptr); &#125; exit(0);&#125; 123456789101112131415161718192021222324252627282930[vrlive@iZ23chs2r19Z eight]$ ./exec.o argv[0]: echoall.oargv[1]: myarg1argv[2]: MY ARG2USER = unknownPATH=/tmp //first child endargv[0]: echoall.o argv[1]: only 1 argXDG_SESSION_ID=25503HOSTNAME=iZ23chs2r19ZTERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=14.108.30.83 34140 22SSH_TTY=/dev/pts/2USER=vrliveLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:MAIL=/var/spool/mail/vrlivePATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/vrlive/.local/bin:/home/vrlive/binPWD=/home/vrlive/linuxProgram/apueProgram/eightLANG=en_US.UTF-8HISTCONTROL=ignoredupsSHLVL=1HOME=/home/vrliveLOGNAME=vrliveSSH_CONNECTION=14.108.30.83 34140 172.16.0.1 22LESSOPEN=||/usr/bin/lesspipe.sh %sXDG_RUNTIME_DIR=/run/user/1000_=./exec.oOLDPWD=/home/vrlive/linuxProgram/apueProgram]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竞争条件]]></title>
    <url>%2F2018%2F05%2F14%2F%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[竞争条件当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件（race condition）。如果再fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行，那么fork函数就会是竞争条件活跃的滋生地。通常，我们不能预料哪一个进程先运行。即使我们知道哪一个进程先运行，在该进程开始运行后所发生的事情也依赖于系统负载以及内核的调度算法。 如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个（子进程终止前，父进程被阻塞了）。如果一个进程要等待其父进程终止，则可使用下列形式的循环： 123while(getppid() != 1)&#123; sleep(1);&#125; 这种形式的循环称为轮询（polling），它的问题是浪费了CPU时间，因为调用者每隔一秒都被唤醒，然后进行条件测试。 为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收方法，在UNIX中可以使用信号机制，各种形式的进程间通信（IPC）也可使用。 示例：程序输出两个字符串：一个由子进程输出，另一个由父进程输出。因为输出依赖于内核使这两个进程的运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞争条件。 12345678910111213141516171819202122#include "head.h"static void charatatime(char *);int main(void)&#123; pid_t pid; if((pid = fork()) &lt;0)&#123; printf("fork error\n"); &#125;else if(pid == 0)&#123; //child charatatime("output for child\n"); &#125;else&#123; //parent charatatime("output for parent\n"); &#125; exit(0);&#125;static void charatatime(char *str)&#123; char *ptr; int c; setbuf(stdout,NULL); //set unbuffered for(ptr = str; (c=*str++) != '\0';)&#123; putc(c,stdout); &#125;&#125; 在程序中将标准输出设置为不带缓冲的，于是每个字符输出都需调用一次write（内核系统调用）。本例的目的是使内核能尽可能多次地在两个进程之间进行切换，以便演示竞争条件。 123456789101112[vrlive@iZ23chs2r19Z eight]$ ./race.o ouotputpuut for childt for parent[vrlive@iZ23chs2r19Z eight]$ ./race.o output for parentoutput for[vrlive@iZ23chs2r19Z eight]$ child./race.o ououtputtput for child for parent[vrlive@iZ23chs2r19Z eight]$ ./race.o output for parentoutput for child]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[system函数]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%87%BD%E6%95%B0system%2F</url>
    <content type="text"><![CDATA[函数system在程序中执行一个命令字符串很方便，例如，假定要将时间和日期放在某个文件中：通过调用time得到当前日历时间，接着调用localtime将日历时间变换为年、月、日、时、分、秒的分解形式，然后调用strftime对上面的结果进行格式化处理，最后将结果写入到文件中。 123456789101112131415161718#include "head.h"int main()&#123; time_t t; struct tm *tmp; char buf1[16]; char buf2[64]; time(&amp;t); tmp = localtime(&amp;t); if(strftime(buf1,16,"time and date:%r,%a %b %d,%Y",tmp) == 0) printf("buffer length 16 is too small\n"); else printf("%s\n",buf1); if(strftime(buf2,64,"time and date:%r,%a %b %d,%Y",tmp) == 0) printf("buffer length 64 is too small\n"); else printf("%s\n",buf2); return 0;&#125; 123[vrlive@iZ23chs2r19Z six]$ ./strftime.o buffer length 16 is too smalltime and date:07:31:31 PM,Mon May 14,2018 但是用下面的system函数则更容易做到这一点： 12345678//system("date&gt;file");#include "head.h"int main()&#123; system("date&gt;file"); exit(0);&#125; 函数原型： 12#include &lt;stdlib.h&gt;int system(const char *cmdstring); 如果cmdstring是一个空指针，则仅当命令处理程序可用时，system返回非0值，这一特征可以确定在一个给定的操作系统上是否支持system函数。在UNIX中，system总是可用的。 因为system在其实现中调用了fork、exec和waitpid，因此有3种返回值。 fork失败或者waitpid返回除EINTR之外的出错，则system返回-1，并且设置errno以指示错误类型。 如果exec失败（表示不能执行shell），则其返回值如果shell执行了exit(127)一样。 否则所有3个函数（fork、exec和waitpid）都成功，那么system的返回值是shell的终止状态，其格式已在waitpid中说明。 如下给出了system函数的一种实现。它对信号没有进行处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[vrlive@iZ23chs2r19Z eight]$ cat head.h #include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;wchar.h&gt;#include &lt;sys/utsname.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;setjmp.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;#define FLAGS O_RDWR | O_CREAT#define MODE S_IRUSR | S_IWUSR | S_IXUSR#define MAXLINE 4096void pr_exit(int status)&#123; if(WIFEXITED(status))&#123; printf("normal termination,exit status = %d\n",WEXITSTATUS(status)); &#125;else if(WIFSIGNALED(status))&#123; printf("abnormal termination,signal number = %d %s\n",WTERMSIG(status), #ifdef WCOREDUMP WCOREDUMP(status) ? " (core file generated)" : " "); #else " "); #endif &#125;else if(WIFSTOPPED(status))&#123; printf("child stopped,signal number = %d\n",WSTOPSIG(status)); &#125;&#125;int system(const char *cmdstring)&#123; //version without signal handling pid_t pid; int status; if(cmdstring == NULL)&#123; return(1); //always a command processor with UNIX &#125; if( (pid=fork()) &lt; 0)&#123; status = -1; //probably out of processes &#125;else if(pid == 0)&#123; execl("/bin/sh","sh","-c",cmdstring,(char*)0); _exit(127); //execl error &#125;else&#123; while(waitpid(pid,&amp;status,0) &lt; 0)&#123; if(errno != EINTR)&#123; status = -1; //error other than EINTR form waitpid() &#125; &#125; &#125; return(status);&#125; shell的-c选项告诉shell程序取下一个命令行参数（在这里是cmdstring）作为命令输入（而不是从标准输入或从一个给定的文件中读命令）。shell对以null字节终止的字符串进行语法分析，将它们分成命令行参数。传递给shell的命令字符串可以包含任一有效的shell命令。例如，可以用&lt;和&gt;对输入和输出重定向。 注意，我们调用_exit而不是exit。这是为了防止任一标准I/O缓冲（这些缓冲会在fork中由父进程复制到子进程）在子进程中被冲洗。 以下代码对system函数进行测试： 123456789101112131415161718#include "head.h"int main()&#123; int status; if((status = system("date")) &lt; 0)&#123; printf("system() error\n"); &#125; pr_exit(status); if((status = system("nosuchcommand")) &lt; 0)&#123; printf("system() error\n"); &#125; pr_exit(status); if((status = system("who; exit 44")) &lt; 0)&#123; printf("system() error\n"); &#125; pr_exit(status); exit(0);&#125; 1234567891011[vrlive@iZ23chs2r19Z eight]$ ./runsystem.o Mon May 14 21:00:03 CST 2018normal termination,exit status = 0 //datesh: nosuchcommand: command not foundnormal termination,exit status = 127 //nosuchcommandvrlive pts/0 2018-05-14 19:23 (14.108.28.90)vrlive pts/1 2018-05-14 19:23 (14.108.28.90)vrlive pts/2 2018-05-14 19:23 (14.108.28.90)vrlive pts/3 2018-05-14 20:32 (119.86.103.135)vrlive pts/4 2018-05-14 20:40 (119.86.103.135)normal termination,exit status = 44 //exit 44 使用system而不是直接使用fork和exec的优点是：system进行了所需要的各种出错处理以及各种信号处理。 下面这一块不太懂，以后再看看： 注：如果一个进程正以特殊的权限（设置用户ID或设置组ID）运行，它又想生成另一个进程执行另一个程序，则它应当直接使用fork和exec，而且在fork之后、exec之前要更改会普通权限，设置用户ID或者设置组ID程序绝不应调用system函数。]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>系统函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与fork]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E5%92%8Cfork%2F</url>
    <content type="text"><![CDATA[引言介绍UNIX系统的进程控制，包括创建新进程、执行程序和进程终止。还将说明进程属性的各种ID—实际、有效和保存的用户ID和组ID，以及它们如何受到进程控制原语的影响。 进程标识每个进程都有一个非负整形表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。例如，应用程序有时就把进程ID作为名字的一部分来创建一个唯一的文件名。 虽然是唯一的，但是进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。 ID为0的进程通常是调度进程，常常被称为交换进程，也被成为系统进程。 ID为1的进程通常是init进程。init进程绝不会终止，他是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。 ID为2的进程是页守护进程，此进程负责支持虚拟存储器系统的分页操作。 进程标志函数1234567891011#include "head.h"int main()&#123; pid_t pid = getpid(); //获取进程id pid_t ppid = getppid(); //获取进程的父id uid_t uid = getuid(); //获取进程的实际用户id uid_t euid = geteuid(); //获取进程的有效用户id gid_t gid = getgid(); //获取进程的实际组id gid_t egid = getegid(); //获取进程的有效组id printf("pid=%d,ppid=%d,uid=%d,euid=%d,gid=%d,egid=%d\n",pid,ppid,uid,euid,gid,egid); return 0;&#125; 实际用户Id 和实际组id 是 用户的性质。他是当前登录用户的信息。 有效用户id 和 有效组 id是进程拥有的性质。放该进程访问一些资源时，他们是内核用来测试该进程是否具有权限的依据。通常情况下他们和用户实际id 和实际组id 一样。 函数fork一个现有的进程可以调用fork函数创建一个新进程。 12#include&lt;unistd.h&gt;pid_t fork(void); //返回值：子进程返回0，父进程返回子进程ID,若出错，返回-1 由fork创建的新进程被称为子进程。fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID，将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数可以获得其所有子进程的进程ID。fork使子进程得到返回值0的理由是：一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID（进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0，这样就可以区别哪个是父进程哪个是子进程了）。 当创建了子进程后，子进程和父进程继续执行fork调用之后的命令，包括都执行fork()调用后的返回值。 子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。 如下演示了fork函数，从中可以看到子进程对变量所做的改变并不影响父进程中该变量的值。 123456789101112131415161718192021#include "head.h"int globvar = 6;char buf[] = "a write to stdout\n";int main(void)&#123; int var = 88; pid_t pid; if(write(STDOUT_FILENO,buf,sizeof(buf)-1) != sizeof(buf)-1)&#123; printf("write error\n"); &#125; printf("before fork\n"); if((pid = fork())&lt;0)&#123; printf("fork error\n"); &#125;else if(pid ==0)&#123; //child ++globvar; ++var; &#125;else&#123; //parent sleep(2); &#125; printf("pid = %d,glob = %d,var= %d\n",getpid(),globvar,var); return 0;&#125; 123456789101112[vrlive@iZ23chs2r19Z eight]$ ./fork.o a write to stdoutbefore forkpid = 29103,glob = 7,var= 89pid = 29102,glob = 6,var= 88[vrlive@iZ23chs2r19Z eight]$ ./fork.o &gt; temp.out[vrlive@iZ23chs2r19Z eight]$ cat temp.out a write to stdoutbefore forkpid = 29105,glob = 7,var= 89before forkpid = 29104,glob = 6,var= 88 fork之后，父进程先执行还是子进程先执行是不确定的，则取决于内核所用的调度算法，该程序中，父进程使自己休眠2s，以此使子进程先执行。但不保证2s已经足够。 当写标准输出时，我们将buf长度减去1作为输出字节数，这是为了避免将终止null字节输出。 标准I/O库是带缓冲的，如果标准输出（printf）连到终端设备，则它是行缓冲的；否则它是全缓冲的，当以交互方式运行该程序时，只得到该printf输出的行一次，其原因是标准输出缓冲区由换行符冲洗。但是当将标准输出重定向到一个文件时，却得到printf输出行两次。其原因是，在fork之前调用了printf一次，但当调用fork时，该行数据仍在缓冲区中，然后在将父进程数据空间赋值到子进程中时，该缓冲区数据也被复制到子进程中，此时父进程和子进程各自有了带该行内容的缓冲区。在exit之前的第二个printf将其数据追加到已有的缓冲区中。当每个进程终止时，其缓冲区中的内容都被写到相应文件中。 文件共享fork的一个特性时父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了dup函数。父进程和子进程每个相同的打开描述符共享一个文件表项（文件表项含有文件的偏移量），也就是说，父进程和子进程共享同一个文件偏移量。 假设父子进程都向标准输出进行写操作。如果父进程的标准输出已重定向，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。当父进程等待子进程时，子进程写到标准输出；而在子进程终止时，父进程也写到标准输出上，并且知道其输出会追加到子进程所写数据之后。如果父进程和子进程不共享同一文件偏移量，要实现这种形式的交互就要困难得多，可能需要父进程显式地动作。 如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步（如使父进程等待子进程），那么它们的输出就会相互混合（假定所用的描述符是在fork之前打开的）。 在fork之后处理文件描述符有以下两种常见情况。 父进程等待子进程完成。在这种情况下，父进程无须对其描述符做任何处理。当子进程终止后，它曾进行过读写操作的任一共享描述符的文件偏移量已做了相应更新。 父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件描述符，这样就不会干扰到对方使用的文件描述符。这种方法是网络服务进程经常使用的。 除了打开文件之外，父进程的很多其他属性也由子进程继承，包括： 实际用户id、实际组id、有效用户id、有效组id 附属组id 进程组id 会话id 控制终端 设置用户id标志和设置组id标志 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭（close-on-exec）标志 环境 连接的共享存储段 存储映像 资源限制 父进程和子进程之间的区别具体如下 fork的返回值不同。 进程ID不同。 这两个进程的父进程ID不同。 子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0。 子进程不继承父进程设置的文件锁。 子进程的未处理闹钟被清除。 子进程的未处理信号集设置为空集。 fork失败的两个主要原因 系统中已经有太多的进程。 该实际用户ID的进程总数超过了系统限制。 fork有以下两种用法 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是最常见的—父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。 一个进程要执行一个不同的程序。这对shell是常见的情况，在这种情况下，子进程从fork返回后立即调用exec。]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vfork]]></title>
    <url>%2F2018%2F04%2F20%2Fvfork%2F</url>
    <content type="text"><![CDATA[vforkvfork函数的调用序列和返回值与fork相同，但两者的语义不同。 vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都会创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec(或exit)，于是它并不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。这种优化工作方式在某些UNIX系统的实现中提高了效率，但如果子进程修改了数据（除了用于存放vfork返回值的变量）、进行函数调用、或者没有调用exec或exit就返回都可能带来未知的结果（就像上一节fork中提及的，实现采用写时复制技术以提高fork之后跟随exec操作的效率，但是不复制比部分赋值还是更快一些）。 vfork和fork之间的另一个区别是：vfork保证子进程先运行，再它调用exec或者exit之后父进程才可能被调度运行（子进程调用exec或exit之前，内核会使父进程处于休眠状态），当子进程调用这两个函数中的任意一个时，父进程会恢复运行。（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁）。 示例123456789101112131415161718#include "head.h"int globvar = 6;int main(void)&#123; int var; pid_t pid; var = 88; printf("before vfork\n"); if( (pid=vfork()) &lt; 0)&#123; printf("vfork error\n"); &#125;else if(pid == 0)&#123; ++globvar; //child; ++var; _exit(0); //child terminates &#125; //parent continues here printf("pid = %d,glob = %d,var = %d\n",getpid(),globvar,var); exit(0);&#125; 123[vrlive@iZ23chs2r19Z eight]$ ./vfork.o before vforkpid = 29440,glob = 7,var = 89 子进程对变量做增1的操作，结果改变了父进程中的变量值。因为子进程子进程在父进程的地址空间中运行，所以这并不令人惊讶。但是其作用的确与fork不同。 fork与vfork的区别：1）fork()： 父子进程的执行次序不确定。 vfork()：保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。 2）fork()： 子进程拷贝父进程的地址空间，子进程是父进程的一个复制品。 vfork()：子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的） 用 vfork() 创建进程，子进程里一定要调用 exec（进程替换） 或 exit（退出进程 _exit(0) ），否则，程序会出问题，没有意义。 参考：vfork() 函数详解]]></content>
      <categories>
        <category>UNIX环境高级编程</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8皇后问题]]></title>
    <url>%2F2018%2F04%2F20%2F8queen%2F</url>
    <content type="text"><![CDATA[八皇后问题在8*8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一条对角线上。请问总共有多少种符合条件的摆法？ 思路剑指offer上的方法，通过排列组合求出所有不在同一行、同一列的组合，然后剔除在同一对角线的组合，即为最终结果 定义一个数组ivec[8]，数组中第i个数字表示位于第i行的皇后的列号，先把数组ivec中的8个数字分别用0-7初始化，然后对数组ivec进行全排列，因为我们用不同的数字初始化数组，所以任意两个皇后肯定不同列。接下来只需要判断每一个排列对应的8个皇后是不是在同一条对角线上，也就是对于数组的两个下标i,j，如果存在 (abs(i-j)) == (abs(ivec[i]-ivec[j]))，则剔除。否则为其中一种摆法。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/*问题描述:在8*8的国际象棋上排放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一条对角线上。*/void helper(vector&lt;int&gt; &amp;ivec,int start,vector&lt;vector&lt;int&gt;&gt; &amp;allVec)&#123; if(start == (ivec.size()-1)) allVec.push_back(ivec); for(int i=start;i&lt;ivec.size();++i)&#123; swap(ivec[i],ivec[start]); helper(ivec,start+1,allVec); swap(ivec[i],ivec[start]); &#125;&#125;void Permutation(vector&lt;int&gt; &amp;ivec,vector&lt;vector&lt;int&gt;&gt; &amp;allVec)&#123; helper(ivec,0,allVec);&#125;int main()&#123; vector&lt;int&gt; ivec&#123;0,1,2,3,4,5,6,7&#125;; //先求所有皇后可能出现的列的组合，排列组合问题 vector&lt;vector&lt;int&gt;&gt; allVec; Permutation(ivec,allVec); //此时保证皇后都是不同行，不同列的情况，接着剔除同一对角线的 // abs(i-j) == abs(vec[i]-vec[j])，处于同一对角线，删除 vector&lt;vector&lt;int&gt;&gt; resVec; for(auto iter=allVec.begin();iter!=allVec.end();++iter)&#123; bool flag = true; for(int i=0;i&lt;8;++i)&#123; bool flag2 = true; for(int j=0;j&lt;8;++j)&#123; if(i!=j)&#123; if( (abs(i-j)) == ( abs((*iter)[i]-(*iter)[j]) ) )&#123; //剔除 flag = false; flag2 = false; break; &#125; &#125; &#125; if(!flag2) break; &#125; if(flag) resVec.push_back(*iter); &#125; cout&lt;&lt;"解法共有："&lt;&lt;resVec.size()&lt;&lt;endl; int i = 1; for(auto vec : resVec)&#123; cout&lt;&lt;"解法"&lt;&lt;i&lt;&lt;": "; for(auto ele : vec) cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;endl; ++i; &#125; return 0;&#125; 结果解法共有92种，时间复杂度为 8！ ((8 7)/2)。8！为排列组合需要的时间复杂度，(8 * 7)/2 为剔除每一个排列组合需要的时间复杂度。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试编程题0414]]></title>
    <url>%2F2018%2F04%2F14%2F2019%E6%90%9C%E7%8B%90%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言2019搜狐春招笔试题，两道都ac了，还是挺开心的。 题目系统设计会员成长值 = 每天成长值 + 任务成长值。 大体意思是：给定多行，每行第一个值为1给出了某个时间范围每天的成长值，每行第一个值为2给出了某天做任务的任务值。每行中每天的成长值的时间范围可能有重复的，选择成长值最大的来作为当天最大成长值。求出总的会员成长值。 123453 1 1 5 102 3 41 4 6 -5输出49 思路：遍历找出每天成长值的时间范围，然后依次比较每天的成长值，得到最大的成长值作为当天的成长值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int N; cin&gt;&gt;N; int len = N; vector&lt;vector&lt;int&gt;&gt; growVec; vector&lt;vector&lt;int&gt;&gt; tastVec; int num; while(len--)&#123; cin&gt;&gt;num; if(num == 1)&#123; //成长 int tem; vector&lt;int&gt; ivec; for(int i=0;i&lt;3;++i)&#123; cin&gt;&gt;tem; ivec.push_back(tem); &#125; growVec.push_back(ivec); &#125;else&#123; //任务 int tem; vector&lt;int&gt; ivec; for(int i=0;i&lt;2;++i)&#123; cin&gt;&gt;tem; ivec.push_back(tem); &#125; tastVec.push_back(ivec); &#125; &#125; /* for(auto ivec : growVec)&#123; for(auto ele : ivec) cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;endl; &#125; for(auto ivec : tastVec)&#123; for(auto ele : ivec) cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;endl; &#125; cout&lt;&lt;"-------------------"&lt;&lt;endl; */ int mintime = 1000000; int maxtime = -1000000; for(auto iter = growVec.begin();iter!=growVec.end();++iter)&#123; if((*iter)[0] &lt; mintime) mintime = (*iter)[0]; if((*iter)[1] &gt; maxtime) maxtime = (*iter)[1]; &#125; //cout&lt;&lt;mintime&lt;&lt;" "&lt;&lt;maxtime&lt;&lt;endl; //时间范围 int res = 0; for(int i = mintime;i&lt;=maxtime;++i)&#123; int MaxValue = -1000000; for(auto iter = growVec.begin();iter!=growVec.end();++iter)&#123; if(i&gt;=(*iter)[0]&amp;&amp;i&lt;=(*iter)[1])&#123; if(MaxValue&lt;(*iter)[2]) MaxValue = (*iter)[2]; &#125; &#125; //cout&lt;&lt;MaxValue&lt;&lt;endl; res += MaxValue; &#125; //cout&lt;&lt;"here"&lt;&lt;endl; for(auto iter = tastVec.begin();iter!=tastVec.end();++iter)&#123; res += (*iter)[1]; &#125; if(res &lt; 0) cout&lt;&lt;&lt;&lt;endl; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; Top K问题找出某个序列中第K小的数。 思路：维护一个K大的大根堆，堆顶元素是最大的值，遍历数组序列，如果存在比堆顶元素小的数，将堆顶元素删除，将新值添加进堆。 注：默认所有make_heap操作都是大根堆，也就是所有的第三个参数时less(),如果需要生成小根堆，操作也是一样的，第三个参数全为greater()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; GetSmallKNum(vector&lt;int&gt; &amp;input, int k) &#123; vector&lt;int&gt; ivec; if(k&gt;input.size() || k&lt;1) return ivec; auto iter = input.begin(); //从第一个元素开始遍历 for(int i=0;i&lt;k;++i)&#123; ivec.push_back(*iter); ++iter; &#125; make_heap(ivec.begin(),ivec.end()); auto end = input.end(); for(;iter!=end;++iter)&#123; if(*iter&lt;ivec[0])&#123; //小于最大值 pop_heap(ivec.begin(),ivec.end()); //删除堆顶元素 ivec.pop_back(); ivec.push_back(*iter); push_heap(ivec.begin(),ivec.end()); //插入新的元素 &#125; &#125; //对大根堆进行排序 sort_heap(ivec.begin(),ivec.end()); return ivec;&#125;;int main()&#123; int len,k; cin&gt;&gt;len&gt;&gt;k; int size = len; vector&lt;int&gt; input; int num; while(len--)&#123; cin&gt;&gt;num; input.push_back(num); &#125; vector&lt;int&gt; res = GetSmallKNum(input,k); int length = res.size(); int i; for(i=0;i&lt;length-1;++i) cout&lt;&lt;res[i]&lt;&lt;","; cout&lt;&lt;res[i]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>春招笔试</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap简单实现]]></title>
    <url>%2F2018%2F04%2F08%2FBitmap%2F</url>
    <content type="text"><![CDATA[BitMap算法Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。 我们知道，一般可以直接操控的最小的单位是字节，比如在C/C++中，定义一个类型char，对它进行各种操作。然后很多时候，面对一个很大数据量，且我们仅仅希望知道某个数是否存在，我们不妨可以（有时候是必须）使用Bitmap算法来完成相关操作。比如腾讯的下面这道题： 示例在40亿个没有排序的无符号整数中，我们如何快速判断某个无符号整数是否在这40亿个数中？ 40亿，这是一个很大的数字，就是海量数据的处理，所以我们必须要考虑到内存的问题。我们知道一个无符号整数的大小为4个字节，那么40亿个需要占多少的内存？440亿是多大量级？咋一看有点难算，不过我们可以估算一下。1KB=1024B1MB=1024KB1GB=1024MB我们近似估计一下，1GB≈1000 1000 1000B= 1 000 000 000B = 10亿B，因此40亿4B / 10亿B = 16G。就是说需要占据大概16GB的内存，这显然对于一般的电脑是不行的。 如果我们可以使用位图来存，一整型占4字节32比特位，因此如果用一个bit来存的话，在上面的例子中仅仅需要16G/32=0.5G大概就是500MB的内存。 题目要求我们快速判断，最快的算法当然是O（1）的操作，我们可以开一个无符号整型最大值的空间（保证这42亿个数都在这个范围内），每个数映射一个bit位，如果存在就将该bit位置1，不然就置0。因此想要查找某个数只需要开他映射的那个比特位是0还是1就可以了。 比如我们想要在这些数中查找一个33。 首先我们要开辟一块size_t（无符号整型）的空间，我们不妨使用整形数组arr来存。 其中每个元素都是size_t占4个字节32位. 刚开始每个空格全是0，这时候我们存一个33，arr[0]对应着0-31的比特位，arr[1]对应着32-63的比特位，因此33就在arr[1]第二个比特位。。。我们只需要将这个比特位置1就好了，到时候查找也是这个位是否为1。 bitmap表为： arr[0] ——&gt; 0 - 31 arr[1] ——&gt; 32 - 63 arr[2] ——&gt; 64 - 95 arr[3] ——&gt; 96 - 127 结论：对于任意一个数x，x / 32对应着它在vector的第几个位置，x % 32对应它的比特位。 简单实现1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N = 100; //数组容量为100int arr[N] = &#123;0&#125;;void setNumber(int num)&#123; //设置num所在位标志为1 int index = num/32; //所在数组的对应下标 int pos = num%32; //对应下标具体的位置 arr[index] |= (1&lt;&lt;pos);&#125;bool hasExisted(int num)&#123; //checknum是否存在 int index = num/32; int pos = num%32; if((arr[index]&amp;(1&lt;&lt;pos))!=0) return true; return false;&#125;int main()&#123; setNumber(10); setNumber(50); if(hasExisted(10)) cout&lt;&lt;"10 is existed"&lt;&lt;endl; if(hasExisted(20)) cout&lt;&lt;"20 is existed"&lt;&lt;endl; else cout&lt;&lt;"20 is not existed"&lt;&lt;endl; if(hasExisted(50)) cout&lt;&lt;"50 is existed"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试编程题0403]]></title>
    <url>%2F2018%2F04%2F03%2F2019%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言2019去哪儿网春招笔试编程题，去哪儿网的春招笔试编程题还是挺难的，再做一遍，总结总结。 题目找最短的转换序列题目记不太清，大致是给一个初始单词和一个最终单词，同时给定一个单词列表，初始单词每次可以更改一个字母，找出最短的序列使得初始单词经过若干步转化为最终单词，并且转换的单词必须出现在单词列表中，存在的话，返回序列长度，否则返回0。 比如：beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] 最短转换序列为： &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,返回 5. 注意：单词长度都是固定的，并且都是小写字母。 思路 ：用广度优先搜索～先将beginWord放入队列中，然后将队列中的每一个单词从头到尾换26个字母一遍～如果换后的单词在字典中能找到～而且没有被访问过～（如果每次都找访问过的就死循环啦，不停的变来变去变同一个咋办～）那就将这个单词放入队列中继续变换～直到有一次发现在字典中找到单词的时候，这个单词恰好是endWord为止～ 很像二叉树的层次遍历，找到endword后，直接返回所在的层数。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; int length = 1; unordered_set&lt;string&gt; wordSet; for(auto iter = wordList.begin();iter!=wordList.end();++iter)&#123; wordSet.insert(*iter); &#125; queue&lt;string&gt; sq; unordered_set&lt;string&gt; visitSet; sq.push(beginWord); while(!sq.empty())&#123; //队列不为空 int size = sq.size(); ++length; while(size--)&#123; string word = sq.front(); sq.pop(); for(int i=0;i&lt;word.size();++i)&#123; string newword = word; for(int j=0;j&lt;26;++j)&#123; newword[i] = 'a' + j; if(wordSet.find(newword)!=wordSet.end() &amp;&amp; visitSet.find(newword) == visitSet.end())&#123; //存在且未被访问 if(newword == endWord) return length; visitSet.insert(newword); //加入到队列中 sq.push(newword); &#125; &#125; &#125; &#125; &#125; return 0; &#125;&#125;; 第二题题意：从给定数组中找到一组数字，要求这组数字之和等于target。另外，数组中的数字不允许被使用多次，但如果一开始就存在多个的话，可以使用多次。 比如给一个集合：[10,1,2,7,6,1,5] 和目标值8，输出 [1, 7] [1, 2, 5] [2, 6] [1, 1, 6] 解题思路：显然先排序，然后dfs。其中有一点要注意的是：因为不能重复，所以要跳过一样的数字。以上面为例，如果不跳过重复的1的话，会出现多个：[1,7]。 递归流程图：以1,1,1,2为例，target = 3，输出[1,1,1]、[1,2]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stdlib.h&gt;#include &lt;unordered_set&gt;using namespace std;void helper(vector&lt;int&gt; &amp;candidates,int target,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt;&gt; &amp;result,int start)&#123; int len = candidates.size(); if(target==0)&#123; result.push_back(path); return; &#125; for(int i=start;i&lt;len;++i)&#123; if(i&gt;start &amp;&amp; candidates[i]==candidates[i-1])&#123; //避免再同一层中出现，去除重复 continue; &#125; if(target&lt;candidates[i]) return; //剪枝，目标值小于待遍历值时，不用继续往下搜寻了 path.push_back(candidates[i]); helper(candidates,target-candidates[i],path,result,i+1); path.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt; &amp;candidates,int target)&#123; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; sort(candidates.begin(),candidates.end()); //排序 //递归 helper(candidates,target,path,result,0); return result;&#125;int main()&#123; //所有的数都是正整数 vector&lt;int&gt; candidates = &#123;10,1,2,7,6,1,5&#125;; int target = 8; sort(candidates.begin(),candidates.end()); vector&lt;vector&lt;int&gt;&gt; result = combinationSum(candidates,target); for(auto ivec : result)&#123; for(auto ele : ivec) cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>春招笔试</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试编程题0401]]></title>
    <url>%2F2018%2F04%2F01%2F201958%E5%90%8C%E5%9F%8E%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言201958同城春招实习机试题，一共两道编程题，解答题热搜top10问题，用topK来实现的，TCP和UDP在直播中的优缺点，简单的介绍了下TCP和UDP的特点和区别，还涉及到SQL和事务，重复读问题。 应用题是海量数据问题，统计UID出现的次数并排序，用了hashtable来实现的，并用Introspective sort（内省排序）进行排序，总体来说，难度还可以，主要是一个半小时，时间略少，题量略多。 最后记录两道编程题。 编程题找出符合条件的子字符串比如字符串为“aabbbccddddeeffggghh”，给定大小为n，输出所有长度为n的重复子串，比如n=2，输出(0,1,aa)(5,6,cc)(11,12,ee)(13,14,ff)(18,19,hh)。 通过设置两个指针first和last，通过cnt记录每个字符出现的次数，找到满足次数的字符输出即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void GetSubstr(const string &amp;str,int n)&#123; int length = str.size(); int first = 0; int last = 0; int cnt = 1; char tem = str[0]; for(int i=1;i&lt;length;++i)&#123; if(str[i]==str[i-1])&#123; ++last; ++cnt; &#125;else&#123; if(cnt == n)&#123; cout&lt;&lt;"("&lt;&lt;first&lt;&lt;","&lt;&lt;last&lt;&lt;","; for(int j=0;j&lt;n;++j) cout&lt;&lt;tem; cout&lt;&lt;")"; &#125; tem = str[i]; first = i; last = i; cnt = 1; &#125; &#125; if(cnt == n)&#123; cout&lt;&lt;"("&lt;&lt;first&lt;&lt;","&lt;&lt;last&lt;&lt;","; for(int j=0;j&lt;n;++j) cout&lt;&lt;tem; cout&lt;&lt;")"; &#125;&#125;int main()&#123; string str = "aabbbccddddeeffggghh"; GetSubstr(str,2); return 0;&#125; 最大连续字数组的和比如输入：2,-3,4,11,-5,8,3,-6 则输出：21 f(i) = max(f(i-1)+ivec[i],ivec[i]); res = max(res,f(i)); 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int GetMaxSubSum(vector&lt;int&gt; &amp;ivec)&#123; int len = ivec.size(); int f1 = ivec[0]; int res = ivec[0]; for(int i=1;i&lt;len;++i)&#123; f1 = max(f1+ivec[i],ivec[i]); res = max(f1,res); &#125; return res;&#125;int GetMaxSubSum1(vector&lt;int&gt; &amp;ivec)&#123; int len = ivec.size(); int res = ivec[0]; int sum = 0; for(int i=0;i&lt;len;++i)&#123; sum += ivec[i]; if(sum&gt;res) res = sum; if(sum&lt;0)&#123; sum = 0; &#125; &#125; return res;&#125;int main()&#123; vector&lt;int&gt; ivec = &#123;2,-3,4,11,-5,8,3,-6&#125;; int result = GetMaxSubSum(ivec); cout&lt;&lt;result&lt;&lt;endl; result = GetMaxSubSum1(ivec); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>春招笔试</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试编程题0329]]></title>
    <url>%2F2018%2F03%2F29%2F2019%E5%8D%8E%E4%B8%BA%E6%98%A5%E6%8B%9B%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言2019华为春招实习机试题，ac两道，最后一道80%，找不出原因，本地完全没问题。 题目Rake接收最大径索引。在无线通信接收，接收到的信号一般会有RAKE多经。现给出RAKE接收机21径能量；多经索引为0-20；用一个4径的接收窗在21径上进行滑动，滑动窗口判断什么位置接收最大能量。接收窗索引以窗内第一径的索引为准。比如窗最大能量框住径为0,1,2,3；则窗索引为0；如果两个窗的能量一样，则以索引最小为输出。 遍历一边，求出各个能量窗的值，找出最大的的能量窗的索引输出。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int num; vector&lt;int&gt; ivec; while(cin&gt;&gt;num)&#123; ivec.push_back(num); &#125; vector&lt;int&gt; result = &#123;0&#125;; int window_sum = 0; for(int i=0;i&lt;4;++i)&#123; window_sum+=ivec[i]; &#125; result.push_back(window_sum); for(int i=4; i&lt;ivec.size();++i)&#123; window_sum = window_sum-ivec[i-4]+ivec[i]; result.push_back(window_sum); &#125; int min_index = 0; int max_value = result[0]; for(int i=1; i&lt;result.size(); ++i)&#123; if(result[i] &gt; max_value)&#123; max_value = result[i]; min_index = i; &#125; &#125; cout &lt;&lt; min_index-1 &lt;&lt; endl; return 0;&#125; 标准键盘与自然键盘映射输入一个字符串，表示按照标准键盘输入动作，在自然键盘上打字产生的字符串。输出打字人在标准键盘上要打印的实际内容。 比如输入“H kz k xif”，输出”I am a boy”。 标准键盘：&quot;QWERTYUIOPASDFGHJKLZXCVBNM&quot; 自然键盘：&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main()&#123; char str[256] = &#123;0&#125;; string sta = "QWERTYUIOPASDFGHJKLZXCVBNM"; string nat = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; int size = sta.size(); for(int i=0;i&lt;size;++i)&#123; str[nat[i]] = sta[i]; //大写的转换 str[nat[i]+32] = sta[i]+32; //小写的转换 &#125; string input; string output = ""; getline(cin,input); int length = input.size(); for(int i=0;i&lt;length;++i)&#123; if((input[i]&gt;='A'&amp;&amp;input[i]&lt;='Z') || (input[i]&gt;='a'&amp;&amp;input[i]&lt;='z'))&#123; cout&lt;&lt;str[input[i]]; &#125; else&#123; cout&lt;&lt;input[i]; &#125; &#125; cout&lt;&lt;endl; return 0;&#125; 最大连续字数组的和输入：2,-3,4,11,-5,8,3,-6 输出：21 不知道为啥只通过了80%，先对字符串拆分出各个数字，然后通过动态规划求出最大连续子串和。 f(i) = max(f(i-1)+ivec[i],ivec[i]); res = max(res,f(i)); 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; getline(cin,s); int size = s.size(); int flag = true; long long num=0; vector&lt;long long&gt; ivec; for(int i=0;i&lt;size;++i)&#123; if(s[i]=='-') flag = false; //如果是负数 else if(s[i]=='+') flag = true; //如果是正数 else if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') num = num*10+(s[i]-'0'); else if(s[i]==',')&#123; //遇到逗号 num = flag?num:-1*num; ivec.push_back(num); flag = true; num = 0; &#125;else if(s[i]==' ') continue; else&#123; //输入错误 cout&lt;&lt;"输入有误"&lt;&lt;endl; return 0; &#125; &#125; num = flag?num:(-1)*num; ivec.push_back(num); long long maxsubarray = ivec[0]; //先假设最大值为nums[0] 后面依次更新 long long sum = 0; for(int i=0;i&lt;ivec.size();++i)&#123; sum += ivec[i]; if(sum&gt;maxsubarray) maxsubarray = sum; if(sum&lt;0) sum = 0; &#125; cout&lt;&lt;maxsubarray&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>春招笔试</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法实现]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言各种排序算法的实现，这东西，几天不写，就略感手生，需要定期不断温习，各种排序算法的思想都很清晰，写的过程中需要额外注意边界情况，递归结束条件，各种边界判断条件。没事写写，温故而知新。 手写排序算法选择排序12345678910111213//选择排序struct Selection&#123; static void select(int a[],int length)&#123; //不稳定 cout&lt;&lt;"select sort"&lt;&lt;endl; for(int i=0;i&lt;length;++i)&#123; int mindex = i; for(int j=i;j&lt;length;++j)&#123; if(a[j]&lt;a[mindex]) mindex = j; &#125; swap(a[i],a[mindex]); &#125; &#125;&#125;; 冒泡排序1234567891011//冒泡排序struct Bubble&#123; static void bubble(int a[],int length)&#123; //稳定 cout&lt;&lt;"bubble sort"&lt;&lt;endl; for(int i=0;i&lt;length;++i)&#123; for(int j=0;j&lt;length-i-1;++j)&#123; if(a[j]&gt;a[j+1]) swap(a[j],a[j+1]); &#125; &#125; &#125;&#125;; 直接插入排序1234567891011121314151617//插入排序struct Insert&#123; static void insert(int a[],int length)&#123; //稳定 cout&lt;&lt;"insert sort"&lt;&lt;endl; for(int i=1;i&lt;length;++i)&#123; //找到带插入位置 int tem = a[i]; int j; for(j=i-1;j&gt;=0;--j)&#123; if(a[j]&gt;tem)&#123; a[j+1] = a[j]; &#125;else break; &#125; a[j+1] = tem; &#125; &#125;&#125;; 希尔排序123456789101112131415161718192021//希尔排序struct Shell&#123; static void shell(int a[],int length)&#123; //不稳定 cout&lt;&lt;"shell sort"&lt;&lt;endl; int h = 1; while(h&lt;length/3) h = 3*h+1; //增量分别为1,4,13,40,... while(h&gt;=1)&#123; for(int i=h;i&lt;length;++i)&#123; int tem = a[i]; int j; for(j=i-h;j&gt;=0;j-=h)&#123; if(a[j]&gt;tem)&#123; a[j+h] = a[j]; &#125;else break; &#125; a[j+h] = tem; &#125; h = h/3; &#125; &#125;&#125;; 归并排序 递归版本 123456789101112131415161718192021222324//递归归并排序struct MergeSort&#123; //稳定 static void Merge_sort(int a[],int low,int high,int aux[])&#123; //将[low,high]进行归并 if(high&lt;=low) return; int mid = low + (high-low)/2; Merge_sort(a,low,mid,aux); Merge_sort(a,mid+1,high,aux); Merge(a,low,mid,high,aux); &#125; static void Merge(int a[],int low,int mid,int high,int aux[])&#123; //将[low,mid] 与 [mid+1,high]进行归并 int i = low; int j = mid + 1; int index = low; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(a[i]&lt;a[j]) aux[index++] = a[i++]; else aux[index++] = a[j++]; &#125; while(i&lt;=mid) aux[index++] = a[i++]; while(j&lt;=high) aux[index++] = a[j++]; for(int k=low;k&lt;=high;++k)&#123; a[k] = aux[k]; &#125; &#125;&#125;; 非递归版本 12345678910111213141516171819202122232425//非递归归并排序struct NoRecMergeSort&#123; //稳定 static norecMergeSort(int a[],int length,int aux[])&#123; cout&lt;&lt;"norecMergeSort"&lt;&lt;endl; for(int sz = 1;sz&lt;length;sz=sz+sz)&#123; for(int lo = 0;lo&lt;length-sz;lo+=sz+sz)&#123; //lo = lo + sz + sz Merge(a,lo,lo+sz-1,min(lo+sz+sz-1,length-1),aux); // lo lo+sz-1 min(lo+sz+sz-1,length-1) &#125; &#125; &#125; static void Merge(int a[],int low,int mid,int high,int aux[])&#123; //将[low,mid] 与 [mid+1,high]进行归并 int i = low; int j = mid + 1; int index = low; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(a[i]&lt;a[j]) aux[index++] = a[i++]; else aux[index++] = a[j++]; &#125; while(i&lt;=mid) aux[index++] = a[i++]; while(j&lt;=high) aux[index++] = a[j++]; for(int k=low;k&lt;=high;++k)&#123; a[k] = aux[k]; &#125; &#125;&#125;; 快速排序1234567891011121314151617181920212223242526//快速排序struct QuickSort&#123; //不稳定 static void quicksort(int a[],int low,int high)&#123; //对[low,high]进行快排 if(high&lt;=low) return; int j = Partition(a,low,high); quicksort(a,low,j-1); quicksort(a,j+1,high); &#125; static int Partition(int a[],int low,int high)&#123; int i = low; int j = high + 1; int v = a[low]; while(true)&#123; while(a[++i]&lt;=v) &#123; if(i==high) break; &#125; while(a[--j]&gt;=v) &#123; if(j==low) break; &#125; if(i&gt;=j) break; swap(a[i],a[j]); &#125; swap(a[low],a[j]); return j; &#125;&#125;; 堆排序12345678910111213141516171819202122232425//堆排序struct HeapSort&#123; //大根堆 static void Sink(int a[],int length,int index)&#123; //数组下标为index的元素进行下沉操作 while(2*index+1&lt;length)&#123; //有左孩子节点 int big = 2*index+1; if((2*index+2&lt;length) &amp;&amp; (a[2*index+2]&gt;a[2*index+1])) &#123; big = 2*index+2; &#125; //右子节点存在且大于左子节点 if(a[big]&lt;=a[index]) break; //已经有序，无须交换 swap(a[index],a[big]); //父节点和左右子节点中的较大值进行交换 index = big; &#125; &#125; static void heapSort(int a[],int length)&#123; int i = length/2-1; //构建堆 while(i&gt;=0)&#123; Sink(a,length,i); i--; &#125; //堆排序 for(int j = length-1;j&gt;0;--j)&#123; swap(a[j],a[0]); Sink(a,j-1,0); &#125; &#125;&#125;; 完整程序示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;iostream&gt;using namespace std;void display(int a[],int length)&#123; for(int i=0;i&lt;length;++i)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;//选择排序struct Selection&#123; static void select(int a[],int length)&#123; //不稳定 cout&lt;&lt;"select sort"&lt;&lt;endl; for(int i=0;i&lt;length;++i)&#123; int mindex = i; for(int j=i;j&lt;length;++j)&#123; if(a[j]&lt;a[mindex]) mindex = j; &#125; swap(a[i],a[mindex]); &#125; &#125;&#125;;//冒泡排序struct Bubble&#123; static void bubble(int a[],int length)&#123; //稳定 cout&lt;&lt;"bubble sort"&lt;&lt;endl; for(int i=0;i&lt;length;++i)&#123; for(int j=0;j&lt;length-i-1;++j)&#123; if(a[j]&gt;a[j+1]) swap(a[j],a[j+1]); &#125; &#125; &#125;&#125;;//插入排序struct Insert&#123; static void insert(int a[],int length)&#123; //稳定 cout&lt;&lt;"insert sort"&lt;&lt;endl; for(int i=1;i&lt;length;++i)&#123; //找到带插入位置 int tem = a[i]; int j; for(j=i-1;j&gt;=0;--j)&#123; if(a[j]&gt;tem)&#123; a[j+1] = a[j]; &#125;else break; &#125; a[j+1] = tem; &#125; &#125;&#125;;//希尔排序struct Shell&#123; static void shell(int a[],int length)&#123; //不稳定 cout&lt;&lt;"shell sort"&lt;&lt;endl; int h = 1; while(h&lt;length/3) h = 3*h+1; //增量分别为1,4,13,40,... while(h&gt;=1)&#123; for(int i=h;i&lt;length;++i)&#123; int tem = a[i]; int j; for(j=i-h;j&gt;=0;j-=h)&#123; if(a[j]&gt;tem)&#123; a[j+h] = a[j]; &#125;else break; &#125; a[j+h] = tem; &#125; h = h/3; &#125; &#125;&#125;;//递归归并排序struct MergeSort&#123; //稳定 static void Merge_sort(int a[],int low,int high,int aux[])&#123; //将[low,high]进行归并 if(high&lt;=low) return; int mid = low + (high-low)/2; Merge_sort(a,low,mid,aux); Merge_sort(a,mid+1,high,aux); Merge(a,low,mid,high,aux); &#125; static void Merge(int a[],int low,int mid,int high,int aux[])&#123; //将[low,mid] 与 [mid+1,high]进行归并 int i = low; int j = mid + 1; int index = low; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(a[i]&lt;a[j]) aux[index++] = a[i++]; else aux[index++] = a[j++]; &#125; while(i&lt;=mid) aux[index++] = a[i++]; while(j&lt;=high) aux[index++] = a[j++]; for(int k=low;k&lt;=high;++k)&#123; a[k] = aux[k]; &#125; &#125;&#125;;//非递归归并排序struct NoRecMergeSort&#123; //稳定 static norecMergeSort(int a[],int length,int aux[])&#123; cout&lt;&lt;"norecMergeSort"&lt;&lt;endl; for(int sz = 1;sz&lt;length;sz=sz+sz)&#123; for(int lo = 0;lo&lt;length-sz;lo+=sz+sz)&#123; //lo = lo + sz + sz Merge(a,lo,lo+sz-1,min(lo+sz+sz-1,length-1),aux); // lo lo+sz-1 min(lo+sz+sz-1,length-1) &#125; &#125; &#125; static void Merge(int a[],int low,int mid,int high,int aux[])&#123; //将[low,mid] 与 [mid+1,high]进行归并 int i = low; int j = mid + 1; int index = low; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(a[i]&lt;a[j]) aux[index++] = a[i++]; else aux[index++] = a[j++]; &#125; while(i&lt;=mid) aux[index++] = a[i++]; while(j&lt;=high) aux[index++] = a[j++]; for(int k=low;k&lt;=high;++k)&#123; a[k] = aux[k]; &#125; &#125;&#125;;//快速排序struct QuickSort&#123; //不稳定 static void quicksort(int a[],int low,int high)&#123; //对[low,high]进行快排 if(high&lt;=low) return; int j = Partition(a,low,high); quicksort(a,low,j-1); quicksort(a,j+1,high); &#125; static int Partition(int a[],int low,int high)&#123; int i = low; int j = high + 1; int v = a[low]; while(true)&#123; while(a[++i]&lt;=v) &#123; if(i==high) break; &#125; while(a[--j]&gt;=v) &#123; if(j==low) break; &#125; if(i&gt;=j) break; swap(a[i],a[j]); &#125; swap(a[low],a[j]); return j; &#125;&#125;;//堆排序struct HeapSort&#123; //大根堆 static void Sink(int a[],int length,int index)&#123; //数组下标为index的元素进行下沉操作 while(2*index+1&lt;length)&#123; //有左孩子节点 int big = 2*index+1; if((2*index+2&lt;length) &amp;&amp; (a[2*index+2]&gt;a[2*index+1])) &#123; big = 2*index+2; &#125; //右子节点存在且大于左子节点 if(a[big]&lt;=a[index]) break; //已经有序，无须交换 swap(a[index],a[big]); //父节点和左右子节点中的较大值进行交换 index = big; &#125; &#125; static void heapSort(int a[],int length)&#123; int i = length/2-1; //构建堆 while(i&gt;=0)&#123; Sink(a,length,i); i--; &#125; //堆排序 for(int j = length-1;j&gt;0;--j)&#123; swap(a[j],a[0]); Sink(a,j-1,0); &#125; &#125;&#125;;int main()&#123; int a[] = &#123;3,1,2,4,8,9,0,3,6,8,7&#125;; int aux[sizeof(a)/sizeof(a[0])] = &#123;0&#125;; //Selection::select(a,sizeof(a)/sizeof(a[0])); //Bubble::bubble(a,sizeof(a)/sizeof(a[0])); //Insert::insert(a,sizeof(a)/sizeof(a[0])); //Shell::shell(a,sizeof(a)/sizeof(a[0])); //MergeSort::Merge_sort(a,0,sizeof(a)/sizeof(a[0])-1,aux); //NoRecMergeSort::norecMergeSort(a,sizeof(a)/sizeof(a[0]),aux); //QuickSort::quicksort(a,0,9); HeapSort::heapSort(a,sizeof(a)/sizeof(a[0])); display(a,sizeof(a)/sizeof(a[0])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的各种操作]]></title>
    <url>%2F2018%2F03%2F22%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言二叉树的各种操作，前中后序的递归与非递归实现，二叉树的构建（序列化和反序列化），二叉树的最大高度与最小高度，打印出从根节点到叶子的节点的所有路径，打印出根节点到特定节点的路径，反转二叉树，判断两个二叉树是否相等等等操作。 算法这东西，就得多练，几天不写，还是感觉手生，需要定期不断温习，温故而知新啊，好好努力。 二叉树的各种操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;struct TreeNode&#123; char val; //节点值 TreeNode *left; //左节点 TreeNode *right; //右节点 TreeNode(char v='0'):val(v),left(nullptr),right(nullptr)&#123;&#125;&#125;;/* A / \ B C / \ / D E F / G*///前序序列化二叉树 ABDG$$$E$$CF$$$TreeNode* CreateTree(vector&lt;char&gt;::iterator &amp;iter)&#123; if(*iter=='$') return nullptr; TreeNode *root = new TreeNode(*iter); root-&gt;left = CreateTree(++iter); root-&gt;right = CreateTree(++iter); return root;&#125;//获取前序序列串void getSequence(TreeNode *root,vector&lt;char&gt; &amp;sequence)&#123; if(!root) &#123; sequence.push_back('$'); return; &#125; sequence.push_back(root-&gt;val); getSequence(root-&gt;left,sequence); getSequence(root-&gt;right,sequence);&#125;void Print(vector&lt;char&gt; &amp;sequence)&#123; for(auto ele:sequence)&#123; cout&lt;&lt;ele&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;//递归先序遍历void PreTravel(TreeNode *root)&#123; if(!root) return; cout&lt;&lt;root-&gt;val&lt;&lt;" "; PreTravel(root-&gt;left); PreTravel(root-&gt;right);&#125;//非递归先序遍历void NonCurPreTravel(TreeNode *root)&#123; stack&lt;TreeNode*&gt; s; if(!root) return; TreeNode *iter = root; while(!s.empty()||iter)&#123; if(iter)&#123; //如果左节点不为空的话，遍历左子树 cout&lt;&lt;iter-&gt;val&lt;&lt;" "; s.push(iter); iter = iter-&gt;left; //左结点依次入栈 &#125;else&#123; //左节点为空，遍历右子树 iter = s.top(); s.pop(); iter = iter-&gt;right; //出栈，遍历右子树 &#125; &#125; cout&lt;&lt;endl;&#125;//递归中序遍历void InTravel(TreeNode *root)&#123; if(!root) return; InTravel(root-&gt;left); cout&lt;&lt;root-&gt;val&lt;&lt;" "; InTravel(root-&gt;right);&#125;//非递归中序遍历void NonCurInTravel(TreeNode *root)&#123; stack&lt;TreeNode*&gt; s; if(!root) return; TreeNode *iter = root; while(!s.empty()||iter)&#123; if(iter)&#123; //如果左节点不为空的话，遍历左子树 s.push(iter); iter = iter-&gt;left; //左结点依次入栈 &#125;else&#123; //左节点为空，遍历右子树 iter = s.top(); cout&lt;&lt;iter-&gt;val&lt;&lt;" "; s.pop(); iter = iter-&gt;right; //出栈，遍历右子树 &#125; &#125; cout&lt;&lt;endl;&#125;//递归后序遍历void PostTravel(TreeNode *root)&#123; if(!root) return; PostTravel(root-&gt;left); PostTravel(root-&gt;right); cout&lt;&lt;root-&gt;val&lt;&lt;" ";&#125;//非递归后序遍历void NonCurPostTravel(TreeNode *root)&#123; if(!root) return ; stack&lt;TreeNode*&gt; s; TreeNode *prenode = nullptr; TreeNode *curnode = root; while(curnode)&#123; s.push(curnode); curnode = curnode-&gt;left; //cur先走到左子树最左边结点 &#125; while(!s.empty())&#123; curnode = s.top(); s.pop(); if(curnode-&gt;right==nullptr||curnode-&gt;right==prenode)&#123; //右子树为空，或者右子树已经访问过了，此时访问根结点 cout&lt;&lt;curnode-&gt;val&lt;&lt;" "; prenode = curnode; &#125;else&#123; //根节点继续入栈，因为此时根节点右子树没有访问，我们需要访问完右子树，还需要继续访问根节点，所以根节点要再此入栈 s.push(curnode); //访问右子树 curnode = curnode-&gt;right; while(curnode)&#123; s.push(curnode); curnode = curnode-&gt;left; &#125; &#125; &#125; cout&lt;&lt;endl;&#125;//层次遍历void LevelTravel(TreeNode *root)&#123; if(!root) return; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; //队列非空 TreeNode *node = q.front(); //获得队首 q.pop(); //移除队列中的第一个元素 cout&lt;&lt;node-&gt;val&lt;&lt;" "; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; cout&lt;&lt;endl;&#125;//获取树的高度(最大高度)int GetTreeMaxHigh(TreeNode *root)&#123; if(!root) return 0; //根节点为空 int leftHigh = GetTreeMaxHigh(root-&gt;left); int rightHigh = GetTreeMaxHigh(root-&gt;right); return leftHigh&gt;rightHigh?leftHigh+1:rightHigh+1;&#125;//获取树的最小高度,递归实现int GetTreeMinHigh(TreeNode *root)&#123; if(!root) return 0; if(!root-&gt;left)&#123; //左子树为空，返回右子树的高度 return GetTreeMinHigh(root-&gt;right)+1; &#125; if(!root-&gt;right)&#123; //右子树为空，返回左子树的高度 return GetTreeMinHigh(root-&gt;left)+1; &#125; //左右子树不空，返回左右子树高度的较小值 int leftHigh = GetTreeMinHigh(root-&gt;left); int rightHigh = GetTreeMinHigh(root-&gt;right); return leftHigh&gt;rightHigh?rightHigh+1:leftHigh+1;&#125;//获取树的最小高度，层次遍历实现，也就是找到第一个叶子节点，得到该叶子节点所在的层即可int GetTreeMinHighWithLevelTravel(TreeNode *root)&#123; if(!root) return 0; queue&lt;TreeNode*&gt; q; int level = 0; q.push(root); while(!q.empty())&#123; int length = q.size(); ++level; while(length--)&#123; TreeNode *node = q.front(); q.pop(); if(node-&gt;left==nullptr&amp;&amp;node-&gt;right==nullptr) return level; //找到第一个叶子节点，返回 if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; &#125; return level;&#125;//获取从根节点到所有叶子节点的路径，递归前序遍历思想void GetAllPath(TreeNode *root,vector&lt;vector&lt;char&gt;&gt; &amp;allpath,vector&lt;char&gt; &amp;path)&#123; if(!root) return; path.push_back(root-&gt;val); if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)&#123; //叶子节点，将path存入到allpath中 allpath.push_back(path); &#125; GetAllPath(root-&gt;left,allpath,path); GetAllPath(root-&gt;right,allpath,path); path.pop_back(); //在返回到父节点之前，在路径上删除当前节点&#125;//获取根节点到某一固定节点的路径，递归前序遍历的思想void GetPathFromRootTOnode(TreeNode *root,vector&lt;vector&lt;char&gt;&gt; &amp;allpath,vector&lt;char&gt; &amp;path,char &amp;ch)&#123; //allpath,可能有多个相同的节点 if(!root) return ; path.push_back(root-&gt;val); if(root-&gt;val == ch)&#123; //找到该节点，保存路径 allpath.push_back(path); &#125; GetPathFromRootTOnode(root-&gt;left,allpath,path,ch); GetPathFromRootTOnode(root-&gt;right,allpath,path,ch); path.pop_back(); //在返回到父节点之前，在路径上删除当前结点&#125;void Print(vector&lt;vector&lt;char&gt;&gt; &amp;allpath)&#123; for(auto path : allpath)&#123; for(auto ele : path)&#123; cout&lt;&lt;ele&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;//判断两棵树是否相同bool IsSameTree(TreeNode *root1,TreeNode *root2)&#123; if(!root1 &amp;&amp; !root2) return true; if(!root1 || !root2) return false; //两个节点都不为空 if(root1-&gt;val == root2-&gt;val)&#123; return IsSameTree(root1-&gt;left,root2-&gt;left) &amp;&amp; IsSameTree(root1-&gt;right,root2-&gt;right); &#125; //不相等 return false;&#125;//反转二叉树，层次遍历实现TreeNode* invertTree1(TreeNode* root) &#123; //层次遍历，遍历每一层时，同时翻转该层的左右子树 if(!root) return root; //如果根节点为空，返回根节点 queue&lt;TreeNode*&gt; q; q.push(root); //根节点入队列 while(!q.empty())&#123; //队列不为空 TreeNode *node = q.front(); //遍历每层时，交换节点的左右节点 q.pop(); //出队 swap(node-&gt;left,node-&gt;right); //交换左右节点 if(node-&gt;left) q.push(node-&gt;left); //左右结点不为空入队 if(node-&gt;right) q.push(node-&gt;right); &#125; return root;&#125;//反转二叉树，递归实现TreeNode* invertTree2(TreeNode *root)&#123; if(root)&#123; invertTree2(root-&gt;left); invertTree2(root-&gt;right); swap(root-&gt;left,root-&gt;right); &#125; return root;&#125;int main()&#123; //构建一个二叉树 vector&lt;char&gt; sequence = &#123;'A','B','D','G','$','$','$','E','$','$','C','F','$','$','$'&#125;; auto iter = sequence.begin(); TreeNode *root = CreateTree(iter); cout&lt;&lt;"获取前序序列串"&lt;&lt;endl; vector&lt;char&gt; s; getSequence(root,s); Print(s); cout&lt;&lt;"先序递归与非递归"&lt;&lt;endl; PreTravel(root); cout&lt;&lt;endl; NonCurPreTravel(root); cout&lt;&lt;"中序递归与非递归"&lt;&lt;endl; InTravel(root); cout&lt;&lt;endl; NonCurInTravel(root); cout&lt;&lt;"后序递归与非递归"&lt;&lt;endl; PostTravel(root); cout&lt;&lt;endl; NonCurPostTravel(root); cout&lt;&lt;"层次遍历"&lt;&lt;endl; LevelTravel(root); cout&lt;&lt;"树的高度(最大高度)"&lt;&lt;endl; int maxhigh = GetTreeMaxHigh(root); cout&lt;&lt;maxhigh&lt;&lt;endl; cout&lt;&lt;"树的最小高度(根节点到叶子节点的最小距离)"&lt;&lt;endl; cout&lt;&lt;GetTreeMinHigh(root)&lt;&lt;endl; cout&lt;&lt;GetTreeMinHighWithLevelTravel(root)&lt;&lt;endl; cout&lt;&lt;"输出根节点到叶子节点的所有路径"&lt;&lt;endl; vector&lt;vector&lt;char&gt;&gt; allpath; vector&lt;char&gt; path; GetAllPath(root,allpath,path); Print(allpath); cout&lt;&lt;"输出根节点到某一特定节点的路径"&lt;&lt;endl; vector&lt;vector&lt;char&gt;&gt; allivec; vector&lt;char&gt; ivec; char ch = 'E'; GetPathFromRootTOnode(root,allivec,ivec,ch); Print(allivec); cout&lt;&lt;"判断两棵树是否相同"&lt;&lt;endl; if(IsSameTree(root,root)) cout&lt;&lt;"is the same"&lt;&lt;endl; else cout&lt;&lt;"is not the same"&lt;&lt;endl; cout&lt;&lt;"反转二叉树"&lt;&lt;endl; root = invertTree2(root); LevelTravel(root); return 0;&#125; 12345678/* A / \ B C / \ / D E F / G*/ 输出结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本分页存储管理]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本分页存储管理方式连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。如果允许将一个进程直接分散地装入到许多不相邻接的分区中，则无须再进行“紧凑”。基于这一思想而产生了离散分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是端，则称为分段存储管理方式。 在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，或称为纯分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。 页面与页表1.页面 分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始，如第0页、第1页等。相应地，也把内存空间分成与页面相同的若干个存储块，称为（物理块）或页框（frame），也同样为它们加以编号，如0#块、1#块等等。在为进程分配内存时以块为单位将进程中的若干页分别装入到多个可以不相邻的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。 在分页系统中的页面其大小应适中。页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存；此外，还会降低页面换进换出的效率。然而，如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是 2 的幂，通常为 512 B～8 KB。 2.地址结构 分页地址中的地址结构（逻辑地址）： 31 12 11 0 页号P 位移量W 它含有两部分：前一部分为页号P，后一部分为位移量W（或称为页内地址）。图中的地址长度为32位，其中0-11位为页内地址，即每页的大小为4kB；12-31位为页号，地址空间最多允许有1M页。 对于某特定机器，其地址结构是一定的。若给定一个逻辑地址空间中的地址为 A，页面的大小为 L，则页号 P 和页内地址 d 可按下式求得：​ P = INT[A/L] d = [A] MOD L 其中，INT 是整除函数，MOD 是取余函数。例如，其系统的页面大小为 1 KB，设 A = 2170 B，则由上式可以求得 P = 2，d = 122。 3.页表 在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块。为此，系统又为每个进程建立了一张页面映射表，简称页表。 在进程地址空间内的所有页(0～n)，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号，见图 4-12 的中间部分。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 地址变换机构当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对地址)分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现并产生一地址越界中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器中。与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完成了从逻辑地址到物理地址的变换。图 4-13 示出了分页系统的地址变换机构。 具有快表的地址变换机构 由于页表是存在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次时访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，已形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据（或向此地址中写入数据）。因此，采用这种方式使计算机的处理速度降低近1/2。 具有快表的地址变换过程： 为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”(Associative Memory)，或称为“快表”，在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer)，用以存放当前访问的那些页表项。此时的地址变换过程是：在 CPU 给出有效地址后，由地址变换机构自动地将页号 P 送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。如在块表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中，亦即，重新修改快表。但如果联想寄存器已满，则 OS 必须找到一个老的且已被认为不再需要的页表项，将它换出。图 4-14 示出了具有快表的地址变换机构。 两级和多级页表现代的大多数计算机系统，都支持非常大的逻辑地址空间(232～264)。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。例如，对于一个具有 32 位逻辑地址空间的分页系统，规定页面大小为 4 KB 即 212 B，则在每个进程页表中的页表项可达 1 兆个之多。又因为每个页表项占用一个字节，故每个进程仅仅其页表就要占用 1 MB 的内存空间，而且还要求是连续的。显然这是不现实的，我们可以采用下述两个方法来解决这一问题： (1) 采用离散分配方式来解决难以找到一块连续的大内存空间的问题； (2) 只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入。 1.两级页表 对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页，并离散地将各个页面分别存放在不同的物理块中的办法来加以解决，同样也要为离散分配的页表再建立一张页表，称为外层页表（Outer Page Table），再每个页表项中记录了页表页面的物理块号。 下面我们仍以前面的 32 位逻辑地址空间为例来说明。当页面大小为 4 KB 时(12 位)，若采用一级页表结构，应具有 20 位的页号，即页表项应有 1 兆个；在采用两级页表结构时，再对页表进行分页，使每页中包含 210 (即 1024)个页表项，最多允许有 210个页表分页；或者说，外层页表中的外层页内地址 P2为 10 位，外层页号 P1也为 10 位。此时的逻辑地址结构可描述如下： 由图可以看出，在页表的每个表项中存放的是进程的某页在内存中的物理块号，如第0#页存放在 1#物理块中；1#页存放在 4#物理块中。而在外层页表的每个页表项中，所存放的是某页表分页的首址，如第 0#页表是存放在第 1011#物理块中。我们可以利用外层页表和页表这两级页表，来实现从进程的逻辑地址到内存中物理地址间的变换。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续分配存储方式]]></title>
    <url>%2F2018%2F01%2F24%2F%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[程序的装入和链接用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常都要经过以下几个步骤： 编译，由编译程序（Compiler）对用户源程序进行编译，形成若干个目标模块（Object Module）。 链接，由链接程序（Linker）将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块（Load Module） 装入，由装入程序（Loader）将装入模块装入内存。 连续分配存储管理方式为了能将用户程序装入内存，必须为它分配一定大小的内存空间。连续分配方式是最早出现的一种存储器分配方式，该分配方式为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻。 连续分配方式可分为四类：单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配算法。 单一连续分配：这是最简单的一种存储管理方式，但是只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分。 固定分区分配：固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分为几个分区，便允许有几道作业并发运行，当该作业结束时，又可再从后备作业队列中找到另一个作业调入该分区。 划分分区的方法： 分区大小相等 分区大小不等 内存分配：为了便于内存分配，通常将分区按大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配）。 固定分区分配，是最早的多道程序的存储管理方式，由于每个分区的大小固定，必然会造成存储空间的浪费，因而现在已很少将它用于通用计算机中。 动态分区分配（重点）动态分区分配是根据进程的实际需要，动态地为之分配内存空间。在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作这样三个问题。 分区分配中的数据结构 空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。 空闲分区链。 分区分配算法为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。目前常用的一下所述的五种分配算法。 1.首次适应算法（first fit） 我们以空闲分区链为例来说明采用 FF 算法时的分配情况。FF 算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。 该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这给为以后到达的大作业分配大的内存空间创造了条件。其缺点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是从低址部分开始，这无疑会增加查找可用空闲分区时的开销 。 2.循环首次适应算法（next fit） 该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。为实现该算法，应设置一起始查寻指针，用于指示下一次起始查寻的空闲分区，并采用循环查找方式，即如果最后一个(链尾)空闲分区的大小仍不能满足要求，则应返回到第一个空闲分区，比较其大小是否满足要求。找到后，应调整起始查寻指针。该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。 3.最佳适应算法（best fit） 所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区，必然是最佳的。孤立地看，最佳适应算法似乎是最佳的，然而在宏观上却不一定。因为每次分配后所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区。 4.最坏适应算法（worst fit） 最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高。该算法要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。但是该算法的缺点也是明显的，它会使存储器中缺乏大的空闲分区。 最坏适应算法与前面所述的首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。 5.快速适应算法（quick fit） 该算法又称为分类搜索法 ，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分，如 2 KB、4 KB、8 KB 等，对于其它大小的分区，如 7 KB 这样的空闲区，既可以放在 8 KB 的链表中，也可以放在一个特殊的空闲区链表中。 该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。 该算法的缺点是在分区归还主存时算法复杂，系统开销较大。此外，该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存储空间浪费，这是典型的以空间换时间的作法。 分区分配操作在动态分区存储管理方式中，主要的操作是分配内存和回收内存。 1）分配内存 系统应利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。设请求的分区大小为 u.size，表中每个空闲分区的大小可表示为 m.size。若 m.size-u.size≤size(size 是事先规定的不再切割的剩余分区的大小)，说明多余部分太小，可不再切割，将整个分区分配给请求者；否则(即多余部分超过size)，从该分区中按请求的大小划分出一块内存空间分配出去， 余下的部分仍留在空闲分区链(表)中。然后，将分配区的首址返回给调用者。图 4-7 示出了分配流程。 2）回收内存 当进程运行完毕是释放内存时，系统根据回收区的首址，从空闲区链（表）中找到响应的插入点，此时可能出现以下四种情况之一： (1) 回收区与插入点的前一个空闲分区 F1相邻接，见图 4-8(a)。此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区 F1的大小。 (2) 回收分区与插入点的后一空闲分区 F2相邻接，见图 4-8(b)。此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。 (3) 回收区同时与插入点的前、后两个分区邻接，见图 4-8(c)。此时将三个分区合并，使用 F1的表项和 F1的首址，取消 F2的表项，大小为三者之和。 (4) 回收区既不与 F1邻接，又不与 F2邻接。这时应为回收区单独建立一新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。 伙伴系统固定分区和动态分区方式都有不足之处。固定分区方式限制了活动进程的数目，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对以上两种内存方式的一种折衷方案。 伙伴系统规定，无论已分配分区或空闲分区，其大小均为 2 的 k 次幂，k 为整数，l≤k≤m，其中：21 表示分配的最小分区的大小，2m 表示分配的最大分区的大小，通常 2m是整个可分配内存的大小。 假设系统的可利用空间容量为 2m个字，则系统开始运行时，整个内存区是一个大小为 2m的空闲分区。在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了 k(0≤k≤m)个空闲分区链表。 当需要为进程分配一个长度为 n 的存储空间时，首先计算一个 i 值，使 2i－1&lt;n≤2i，然后在空闲分区大小为 2i 的空闲分区链表中查找。若找到，即把该空闲分区分配给进程。否则，表明长度为 2i 的空闲分区已经耗尽，则在分区大小为 2i＋1 的空闲分区链表中寻找。若存在 2i＋1 的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于分配，而把另一个加入分区大小为 2i 的空闲分区链表中。若大小为 2i＋1的空闲分区也不存在，则需要查找大小为 2i＋2的空闲分区，若找到则对其进行两次分割：第一次，将其分割为大小为 2i＋1 的两个分区，一个用于分配，一个加入到大小为 2i＋1的空闲分区链表中；第二次，将第一次用于分配的空闲区分割为 2i 的两个分区，一个用于分配，一个加入到大小为 2i 的空闲分区链表中。若仍然找不到，则继续查找大小为 2i＋3 的空闲分区，以此类推。由此可见，在最坏的情况下，可能需要对 2k的空闲分区进行 k 次分割才能得到所需分区。 与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，如回收大小为 2i的空闲分区时，若事先已存在 2i的空闲分区时，则应将其与伙伴分区合并为大小为2i＋1的空闲分区，若事先已存在 2i＋1的空闲分区时，又应继续与其伙伴分区合并为大小为2i＋2的空闲分区，依此类推。 在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。与前面所述的多种方法相比较，由于该算法在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比前面所述的分类搜索算法差，但比顺序搜索算法好，而其空间性能则远优于前面所述的分类搜索法，比顺序搜索法略差。 需要指出的是，在当前的操作系统中，普遍采用的是下面将要讲述的基于分页和分段机制的虚拟内存机制，该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，得到了大量的应用。 哈希算法在上述的分类搜索算法（快速适应算法（quick fit））和伙伴系统中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在一张管理索引表中查找所需空间大小所对应的表项，从中得到对应的空闲分区链表表头指针，从而通过查找得到一个空闲分区。如果对空闲愤怒分类较细，则相应的空闲分区链表也较多，因此选择合适的空闲链表的开销也相应增加，且时间性能降低。 哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。 当进行空闲分区分配时，根据所需空间分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。 可重定位分区分配 动态重定位的引入 在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的区块，即使它们的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。这些不能被利用的小分区称为“零头”或“碎片”。 若想把作业装入，可采用的一种方法是：将内存中的所有作业进行移动，使它们全都相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时就可把作业装入该区。这种通过移动内存中作业的位置，以把原来多个分散的小分区拼接成一个大分区的方法，称为“拼接”或“紧凑”，见下图，由于经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。 动态重定位的实现 在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。 图 4-10 示出了动态重定位的实现原理。地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态重定位。当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时，不需对程序做任何修改，只要用该程序在内存的新起始地址，去置换原来的起始地址即可 动态重定位分区分配算法 动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：这种分配算法中，增加了紧凑的功能，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。如下图： 对换1.对换的引入 在多道程序环境下，一方面，在内存中某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降。为了解决这一问题，在系统中又增设了对换（也称交换）设施。所谓“对换”，是指把内存中暂时不能运行的内存或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施。 如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。这种对换被广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。而如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。这种对换方法是实现后面要讲到的请求分页和请求分段式存储管理的基础，其目的是为了支持虚拟存储系统。在此，我们只介绍进程对换，而分页或分段对换将放在虚拟存储器中介绍。为了实现进程对换，系统必须能实现三方面的功能：对换空间的管理、进程的换出，以及进程的换入 2．对换空间的管理 在具有对换功能的 OS 中，通常把外存分为文件区和对换区。前者用于存放文件，后者用于存放从内存换出的进程。由于通常的文件都是较长久地驻留在外存上，故对文件区管理的主要目标，是提高文件存储空间的利用率，为此，对文件区采取离散分配方式。然而，进程在对换区中驻留的时间是短暂的，对换操作又较频繁，故对对换空间管理的主要目标，是提高进程换入和换出的速度。为此，对换区采取的是连续分配方式，较少考虑外存中的碎片问题。 为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外存的使用情况。其形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空闲分区表或空闲分区链。在空闲分区表中的每个表目中应包含两项，即对换区的首址及其大小，分别用盘块号和盘块数表示。 由于对换分区的分配是采用连续分配方式，因而对换空间的分配与回收，与动态分区方式时的内存分配与回收方法雷同。其分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法。具体的分配操作，也与图 4-7 中内存的分配过程相同，这里不再赘述。 进程的换出和换入 （1）进程的换出。每当一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。其过程是：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。若传送过程未出现错误，便可回收进程所占用的内存空间，并对该进程和进程控制块做相应的修改。 （2）进程的换入。系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间最久（换出到磁盘上）的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调度算法]]></title>
    <url>%2F2018%2F01%2F22%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[处理机调度在多道程序环境下，内存中存在着多个进程，其数目往往多于处理机数目。这就要求系统能按某种算法，动态地将处理机分配给处于就绪状态的一个进程、使之执行。分配处理机的任务是由处理机调度程序完成的。对于大型系统运行时的性能，如系统吞吐量、资源利用率、作业周转时间或响应的及时性等，在很大程度上都取决于处理机调度性能的好坏。因而，处理机调度便成为OS中至关重要的部分。 作业与作业调度1.先来先服务(FCFS)调度算法 该算法即可用于作业调度，也可用于进程调度 2.短作业优先(short job first SJF)的调度算法 可以分别作用于作业调度和进程调度，作业的长度是以作业所要求的运行时间来衡量的（预估时间）。 3.优先级调度算法（PSA） 可以作为作业调度算法，也可作为进程调度算法。根据优先级进行调度。 4.高响应比优先调度算法（HRRN) 为每个作业引入一个动态优先级，即优先级可以改变，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。 优先权 = (等待时间+要求服务时间)/要求服务时间 进程调度早期所采用的非抢占方式存在着很大的局限性，很难满足交互性作业和实时任务的需求。为此，在进程调度中又引入了抢占方式。 非抢占方式 抢占方式 1.优先权原则 2.短进程优先原则 3.时间片原则 轮转调度算法基于时间片的的轮转（RR）调度算法。系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并设置每隔一定时间间隔（如30ms）即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程（或新到达的紧迫进程）。由此，可保证就绪队列中的所有进程在一个确定的时间段内，都能够获得一次CPU执行。 多级反馈队列调度算法1、设有N个队列（Q1,Q2….QN），其中各个队列对于处理机的优先级是不一样的，也就是说位于各个队列中的作业(进程)的优先级也是不一样的。一般来说，优先级Priority(Q1) &gt; Priority(Q2) &gt; … &gt; Priority(QN)。怎么讲，位于Q1中的任何一个作业(进程)都要比Q2中的任何一个作业(进程)相对于CPU的优先级要高（也就是说，Q1中的作业一定要比Q2中的作业先被处理机调度），依次类推其它的队列。 2、对于某个特定的队列来说，里面是遵循时间片轮转法。也就是说，位于队列Q2中有N个作业，它们的运行时间是通过Q2这个队列所设定的时间片来确定的（为了便于理解，我们也可以认为特定队列中的作业的优先级是按照FCFS来调度的）。 3、各个队列的时间片是一样的吗？不一样，这就是该算法设计的精妙之处。各个队列的时间片是随着优先级的增加而减少的，也就是说，优先级越高的队列中它的时间片就越短。同时，为了便于那些超大作业的完成，最后一个队列QN(优先级最低的队列)的时间片一般很大(不需要考虑这个问题)。 实时调度最早截止时间优先EDF算法该算法是根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机。最早截止时间优先算法即可用于抢占式调度，也可用于非抢占式调度方式。 最低松弛度优先LLF算法该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。例如，一个任务在200ms时必须完成，而它本身所需的运行时间是100ms，因此调度程序必须在100ms之前调度执行，该任务的紧急程度（松弛程度）为100ms。在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在最前面，调度程序选择队列中的队首任务执行。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2018%2F01%2F20%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁死锁：指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都讲无法向前推进。 如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的（Deadlock)。 计算机系统中的死锁 竞争不可抢占性资源引发死锁 竞争可消耗资源引起死锁 进程推进顺序不当引起死锁 产生死锁的必要条件 互斥条件。即在一段时间内，某资源只能被一个进程占用。 请求和保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 不可抢占条件。 循环等待条件。在发生死锁时，必然存在一个进程-资源的循环链，即进程集合{p0,p1,…,pn}中的p0正在等待一个p1占用的资源，p1正在等待p2占用的资源，…pn正在等待已被p0占用的资源。 处理死锁的方法 目前处理死锁的方法可归结为四种。 预防死锁 ：实现预防方法，该方法通过设置某些限制条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。 避免死锁：同样属于事先预防策略，在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免发生死锁。 检测死锁：允许运行过程中发生死锁。但可通过检测机构及时的检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。 解除死锁：当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。常用的方法是撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其能继续运行。 预防死锁由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏产生死锁的后三个条件。 破坏请求和保持 第一种协议：一次性申请其在整个运行过程中的全部资源。 第二种协议：允许一个进程只获得运行初期所需的资源后，便开始运行，进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。 破坏不可抢占条件 当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。 破坏循环等待条件 一个能保证“循环等待”条件不成立的方法是，对系统的所有资源类型进行线性排序，并赋予不同的序号，这样不可能再出现环路，因而破坏了“循环等待”条件。 避免死锁 （银行家算法）避免死锁的基本思想： 确保系统始终处于安全状态，一个系统开始是处于安全状态的。当有进程请求一个可用资源时，系统需对该进程的请求进行计算，若将资源分配给进程后系统仍处于安全状态，才将该资源分配给进程。 利用银行家算法来避免死锁 当前序列是安全的，即当前状态不会发生死锁。此时如果某个进程请求资源，当前资源如果小于等于它需要的值，执行下一步，否则，返回异常； 继续判断需求的资源值是否小于等于系统中尚有的可用资源数，如果大于，则需等待其它进程释放资源，否则，系统试探性的将资源分配给该进程，并修改相应的资源数 接着系统调用安全判定算法，如果安全，也就是存在一个安全系列，资源分配成功；如果不安全，恢复原来的资源分配状态，让该进程继续等待。 银行家算法： 我们将第i个进程请求的资源数记为Requests[i]。 1.如果Requests[i]&lt;=Need[i]，则转到第二步。否则，返回异常。这一步是控制进程申请的资源不得大于需要的资源。 2.如果Requests[i]&lt;=Available，则转到第三步，否则表示尚无足够资源，pi需等待。 3.如果满足前两步，那么做如下操作： 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值： 123Available = Available -Requests[i] Allocation = Allocation[i]+Requests[i]Need[i]=Need[i]-Requests[i] 4.调用安全判定算法，检查是否安全12345678if(安全)&#123; 申请成功，资源分配&#125;else&#123; 申请失败，资源撤回。第三步前几个操作进行逆操作&#125; 参考链接：银行家算法学习笔记 死锁的检测与解除如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能会发生死锁。在这种情况下，系统应当提供两个算法：​ 死锁检测算法。该方法用于检测系统状态，以确定系统中是否发生了死锁。 死锁解除算法。当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解脱出来。 检测死锁系统死锁，可利用资源分配图来描述。如图所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。 所示的资源分配图中，进程P1已经分得了两个R1资源，并又请求一个R2资源；进程P2分得了一个R1和一个R2资源，并又请求一个R1资源。 死锁定理可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下： 1) 在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图2-18(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到图248(b)所示的情况。 2) 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图2-17中，进程P2就满足这样的条件。根据第1)条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如图2-18(c)所示。 S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理。 死锁的解除常采用解除死锁的两种方法： 抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。 终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直到打破循环环路，使系统从死锁状态解脱出来。 终止进程的方法 终止所有死锁进程 逐个终止进程]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典进程同步问题]]></title>
    <url>%2F2018%2F01%2F15%2F%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言经典进程同步问题：生产者-消费者问题、哲学家进餐问题、读者-写者问题，通过信号量来实现进程之间的同步。 生产者-消费者问题1.利用记录型信号量解决生产者-消费者问题 假定在生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可利用互斥信号mutex实现诸进程对缓冲池的互斥使用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。 1234567891011121314151617181920212223242526272829303132int in = 0,out = 0;item buffer[n];semaphore mutex = 1,empty = n,full=0;void producer&#123; do&#123; producer an item nextp; ... wait(empty); wait(mutex); buffer[in] = nextp; in = (in+1)%n; signal(mutex); signal(full); &#125;while(true);&#125;void consumer()&#123; do&#123; wait(full); wait(mutex); nextc = buffer[out]; out = (out+1)%n; signal(mutex); signal(empty); consumer the item in nextc; ... &#125;while(true);&#125;void main()&#123; cobegin producer(); consumer(); coend&#125; 2.利用And信号量解决生产者-消费者问题 12345678910111213141516171819202122232425262728int in = 0,out = 0;item buffer[n];semaphore mutex = 1,empty = n,full=0;void producer&#123; do&#123; producer an item nextp; ... Swait(empty,mutex); buffer[in] = nextp; in = (in+1)%n; Ssignal(mutex,full); &#125;while(true);&#125;void consumer()&#123; do&#123; Swait(full,mutex); nextc = buffer[out]; out = (out+1)%n; Ssignal(mutex,empty); consumer the item in nextc; ... &#125;while(true);&#125;void main()&#123; cobegin producer(); consumer(); coend&#125; 哲学家进餐问题五个哲学家共用一张圆桌，分别坐在周围的五个椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替的进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。 1.利用记录型信号量解决哲学家进餐问题 经分析，放在桌子上的筷子时临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下： 1semaphore chopstick[5] = &#123;1,1,1,1,1&#125;; 所有信号量均被初始化为1，第i为哲学家的活动可描述为： 123456789101112do&#123; wait(chopstick[i]); wait(chopstick[(i+1)%5]); ... //eat ... signal(chopstick[i]); signal(chopstick[(i+1)%5]); ... //think ...&#125;while(true); 假如五位哲学家同时各自拿起左边的筷子时，就会使五个信号量chopstick为0，当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。对于这种死锁问题，可采取一下几种解决方法。 首先给出两个断言： （1）系统中有N个并发进程。若规定每个进程需要申请2个某类资源，则当系统提供N+1个同类资源时，无论采用何种方式申请资源， 一定不会发生死锁。分析：N+1个资源被N 个进程竞争， 由抽屉原理可知， 则至少存在一个进程获2个以上的同类资源。这就是前面提到的哲学家就餐问题中5个哲学家提供6支筷子时一定不会发生死锁的原因。 （2）系统中有N个并发进程。若规定每个进程需要申请R个某类资源，则当系统提供K＝N*（R-1）+1个同类资源时，无论采用何种方式申请使用，一定不会发生死锁。分析：在最坏的情况下，每个进程都申请到R-1个同类资源， 此时它们均阻塞。 试想若系统再追加一个同类资源， 则 N 个进程中必有一个进程获得R个资源，死锁解除。 (1)破坏请求保持条件 利用原子思想完成。即只有拿起两支筷子的哲学家才可以进餐，否则，一支筷子也不拿。 解法一：利用AND机制实现第i位哲学家的活动描述为： 12345678philosopher (int i)&#123; while(true)&#123; think; swait(chopstick[(i+1)]%5，chopstick[i])； eat; Ssignal(chopstick[i]，chopstick[(i+1)%5]); &#125;&#125; 解法二：利用记录型信号量机制实现在初始化中增加一个信号量定义：semaphore mutex=1：该方法将拿两只筷子的过程作为临界资源，一次只允许一个哲学家进入。 第I位哲学家的活动描述： 123456789101112philosopher (int I)&#123; while(true)&#123; 思考; wait(mutex)； wait(stiCk[I]); wait(Stick[(I+1)%5]); signal(mutex)； 进餐； signal(stick[I]); Signal(Stick[(I+1)%5])； &#125;&#125; (2)破坏环路等待条件 解法一：奇数号哲学家先拿他左边的筷子，偶数号哲学家先拿他右边的筷子。这样破坏了同方向环路，一个哲学家拿到一只筷子后，就阻止了他邻座的一个哲学家吃饭。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。算法描述如下： 1)第i个哲学家的活动： 1234567891011121314151617philosopher (int I)&#123; while(true)&#123; 思考; If I%2==1 then wait(Stick[I]); wait(stick[(I+1)%5]); 进餐; signal(stick[I])； signal(stick[(I+1)%5]); else wait(stick[(I+1)%5])； wait(stick[I]); 进餐； signal(stick[(I+1)%5])； signal(stick[I]); &#125;&#125; 解法二：至多允许四位哲学家进餐，将最后一个哲学家停止申请资源，断开环路。最终能保证有一位哲学家能进餐，用完释放两只筷子，从而使更多的哲学家能够进餐。增加一个信号量定义semaphore count=4：算法描述第1个哲学家的活动： 123456789101112philosopher (int I)&#123; while(true) 思考； wait(count)； wait(chopstiok[I])； wait(chopstick[I+1]%5)； 进餐; signal(chopstick[I])； signal(chopstick[I+1]%5) signal(count); &#125;&#125; 读者-写者问题允许多个进程同时读一个共享对象，但不允许一个write进程和其他reader进程或writer进程同时访问共享对象。所谓读者-写者问题是指：保证一个writer进程必须与其他进程互斥地访问共享对象的同步问题。 1.记录型信号量解决读者-写者问题 为实现reader和writer之间的互斥而设置一个互斥信号量wmutex。同时，增加一个count计数器，用来记录reader进程的个数，reader进程执行时，并且count==0时，此时wait(wmutex)，禁止写进程去写，然后++count；reader进程执行完毕后，–count，如果count ==0时，此时表示无reader进程，则signal(wmutex)，允许writer去写。同时由于reader进程互斥的共享count，所以我们设置一个rmutex来互斥访问count。 1234567891011121314151617181920212223242526272829303132seamphore rmutex=1,wmutex=1;int count=0;void reader()&#123; do&#123; wait(rmutex); if(count==0) wait(wmutex) ++count; signal(rmutex); ... reader ... wait(rmutex); --count; if(count==0) signal(wmutex); signal(rmutex); &#125;while(true);&#125;void write()&#123; do&#123; wait(wmutex); ... writer ... signal(wmutex); &#125;while(true);&#125;void main()&#123; cobegin reader(); writer(); coend&#125; 2.利用信号量集机制解决读者-写者问题 Swait((S,1,0)：是一种很特殊且很有用的信号量操作。当S&gt;=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个开关。 这里我们增加一个限制，即最多允许RN个读者同时读。为此我们引入一个信号量L，并赋予其初值为RN，通过执行Swait(L,1,1)来控制读者的数量。 123456789101112131415161718192021int RN; //最多允许RN个读者同时读semaphore L = RN,mx = 1;void reader()&#123; do&#123; Swait(L,1,1); //L个资源（读进程），每次分配1个，当L&lt;1时，无法分配资源，阻塞 SWait(mx,1,0); //mx&gt;=1,允许多个读进程进程进入 ... read ... Ssignal(L,1); //释放L资源（读者数被释放+1） &#125;while(true);&#125;void writer()&#123; do&#123; Swait(mx,1,1;L,RN,0); //表示仅当既无writer进程在写操作（mx=1)、又无reader进程在读操作（L=RN)时，writer进程才能进入临界区 ... writer ... signal(mx,1); &#125;while(true);&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重继承与虚继承]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[多重继承与虚继承多重继承（multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。 多重派生在派生类的派生列表中可以包含多个基类： 12class Bear : public ZooAnimal &#123; /* ... */ &#125;;class Panda : public Bear,public Endangered &#123; /* ... */ &#125;; 和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是final的。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。 多重继承的派生类从每个基类中继承状态在多重继承关系中，派生类的对象包含有每个基类的子对象。在panda对象中含有Bear部分（其中又含有ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。 派生类构造函数初始化所有基类构造一个派生类的对象将同时构造并初始化它的所有基类子对象。但只能初始化它的直接基类： 1234//显式地初始化所有基类Panda::Panda(string name,bool onExhibit):Bear(name,onExhibit,"Panda"),Endangered(Endangered::critical) &#123;&#125;//隐式地使用Bear的默认构造函数初始化Bear子对象Panda::Panda():Endangered(Endangered::critical) &#123;&#125; 派生类的构造函数初始化列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类出现顺序一致，而与派生类构造函数初始值列表中基类的顺序无关。 一个Panda对象按照如下词序进行初始化： ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。 接下来初始化Panda的第一个直接基类Bear。 然后初始化Panda的第二个直接基类Endangered。 最后初始化Panda。 继承的构造函数与多重继承在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误： 123456789101112131415struct Base1&#123; Base1() default; Base1(const string&amp;); Base1(shared_ptr&lt;int&gt;);&#125;;struct Base2&#123; Base2() = default; Base2(const string&amp;); Base2(int);&#125;//错误：D1试图从两个基类中都继承D1::D1(const string&amp;)struct D1: public Base1,public Base2 &#123; using Base1::Base1; //从Base1继承构造函数 using Base2::Base2; //从Base2继承构造函数&#125; 如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本： 1234567struct D1: public Base1,public Base2 &#123; using Base1::Base1; //从Base1继承构造函数 using Base2::Base2; //从Base2继承构造函数 //D2必须自定义一个接受string的构造函数 D2(const string &amp;s):Base1(s),Base2(s) &#123;&#125; D2() = default; //一旦定义了自己的构造函数，系统不提供默认构造函数&#125; 析构函数与多重继承和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。 析构函数的调用顺序正好与构造函数相反。 类型转换与多个基类我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。 与只有一个基类的继承一样，对象、指针或引用的静态类型决定了我们能够使用哪些成员。如果我们使用一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered特有的部分都不可见。 多重继承下的类作用域在只有一个基类的情况下，派生类的作用域嵌套在直接和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。 在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。 虚继承尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。 在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。 为避免产生多个子对象，在C++语言中我们通过虚继承（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。 note: 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。 使用虚基类我们指定虚基类的方式是在派生列表中添加关键字virtual： 123//关键字public和virtual的顺序随意class Raccoon : public virtual ZooAnimal &#123; /* ... */&#125;class Bear : virtual public ZooAnimal &#123; /* ... */&#125; 通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类 virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。 如果某个类指定了虚基类，则该类的派生仍按常规方式进行： 123class Panda : public Bear,public Raccoon,public Endangered&#123; //...&#125;; Panda中只有一个ZooAnimal基类部分 虚基类成员的可见性因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。 与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自定义新的示例。 构造函数与虚继承在虚派生中，虚基类是由最底层的派生类（也就是最最后面的派生类）初始化的。，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。 为了理解这一规则，我们不妨假设当以普通规则处理初始任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。 当创建一个Bear（或Raccoon）的对象时，将直接初始化其ZooAnimal基类部分。 当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal。 123Panda::Panda(string name,bool onExhibit):ZooAnimal(name,onExhibit,"Panda"), Bear(name,onExhibit),Raccoon(name,onExhibit), Endangered(Endangered::critical),sleeping_flag(false) &#123;&#125; 虚继承的对象的构造方式含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。 例如：当我们创建一个Panda对象时： 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。 接下来构造Bear部分 然后构造Raccoon部分 然后构造第三个直接基类Endangered 最后构造Panda部分 如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。 note: 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。 构造函数与析构函数的次序一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal是Bear的虚基类： 1234class Character &#123; ...&#125;;class BookCharacter : public Character &#123; ...&#125;;class ToyAnimal &#123; ...&#125;;class TeddyBear : public BookCharacter,public Bear,public virtual ToyAnimal &#123;...&#125;; 编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。因此，创建一个TeddyBear对象，需要按照如下次序调用这些构造函数： 123456ZooAnimal(); //Bear的虚基类ToyAnimal(); //直接虚基类Character(); //第一个非虚基类的间接基类BookCharacter(); //第一个直接非虚基类Bear(); //第二个直接非虚基类TeddyBear(); //最低层的派生类 合成的拷贝和移动构造函数按照完成相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后ZooAnimal部分。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>虚继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理与命令空间]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[异常处理异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。 当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。 因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。 栈展开当抛出一个异常时，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch字句。当throw出现在一个try语句块内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。 上述过程被称为栈展开（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。 假设找到了一个匹配的catch字句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。 如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数terminate，顾名思义，terminate负责终止程序的执行过程。 note: 一个异常如果没有被捕获，则它将终止当前的程序。 栈展开过程中对象被自动销毁块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。 如果异常发生在构造函数中，则当前的对象可能只构造了一部分。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。数组或标准库容器的元素初始化过程中，也是一样的。 析构函数与异常在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。 异常对象异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。 异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁。 当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。 捕获异常catch子句中的异常声明（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。 通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。 查找匹配的处理代码在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。 因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类异常的处理代码之前。 命名空间大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会在某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染。 命名空间（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命令空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。 命名空间定义一个命令空间的定义包含两个部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。 using声明： 是一种将命名空间中的某个名字注入当前作用域的机制： 1using std::cout; 上述语句使得命令空间std中的名字cout在当前作用域可见。之后，我们将可以直接使用cout而无须前缀std::了。 using指示： 是具有如下形式的声明： 1using NS; 上述语句使得命名空间NS的所有名字在using指示所在的作用域以及NS所在的作用域都变得可见。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数模版和类模板]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[前言面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。 本书第Ⅱ部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。 例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。 模版是泛型编程的基础。我们不必了解模版是如何定义的就能使用它们，实际上我们已经这样用了。 模版是C++中泛型编程的基础。一个模版就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。 定义模版函数模板我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样： 123456template &lt;typename T&gt;int compare(const T &amp;v1,const T &amp;v2)&#123; if(v1&lt;v2) return -1; if(v2&lt;v1) return 1; return 0;&#125; 模版定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。 note: 在模板定义中，模板参数列表不能为空。 模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。 T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。 实例化函数模板当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用参数的类型来确定绑定到模板参数T的类型。 1cout &lt;&lt; compare(1,0) &lt;&lt;endl; //T为int 实参类型是int。编译器会推断出模板参数为int，并将它绑定到模板参数T。 编译器用推断出的模板参数来为我们实例化（instantiate）一个特定版本的函数。 如上调用将实例化： 12//实例化出 int compare(const int&amp;, const int&amp;) &#123; ...; &#125;cout &lt;&lt; compare(1,0) &lt;&lt;endl; //T为int 模板类型参数一般来说，我们可以将模板类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换： 1234567//正确：返回类型和参数类型相同template &lt;typename T&gt; T foo(T *p)&#123; T tem = *p; //... return temp;&#125; 类型参数前必须使用关键字typename 或 class 1234//错误：U之前必须加上class或typenametemplate &lt;typename T,U&gt;//正确：在模板参数列表中，typename和class没有什么不同template&lt;typename T, class U&gt; typename是在模板已经广泛使用之后才引入C++语言的，推荐使用。 非类型模板参数除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。 例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char 的数组。由于我们不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度： 1234template&lt;unsigned N,unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123; return strcmp(p1,p2);&#125; 当我们调用这个版本的compare时： 1compare("hi","mom") 编译器会实例化出如下版本： 1int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]) 在模板定义内，模板非类型参数时一个常量值。在需要常量表达式的地方，可以使用非类型参数。 note: 非类型模板参数的模板实参必须是常量表达式。 inline 和 constexpr的函数模板函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr说明符放在模板参数之后，返回类型之前。 12//正确：inline说明符跟在模板参数列表之后template &lt;typename T&gt; inline T min(const T&amp;,const T&amp;); 编写类型无关的代码我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则： 模板中的函数参数是const的引用。 函数体中的条件判断仅使用&lt;比较运算。 大多数类型都允许拷贝，但是，不允许拷贝的类类型也是存在的。通过设置为引用，保证这写类型可以处理。而且，当处理大对象时，这种设计策略还能使函数运行得更快。 注意： 模板程序应该尽量减少对实参类型的要求。 模板编译当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。 note: 函数模板和雷模板成员函数的定义通常放在头文件中。 警告：保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，时调用者的责任。 示例：定义自己版本的begin和end，同时编写一个constexpr模板，返回给定数组的大小 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// the same as std::begintemplate&lt;typename T, unsigned size&gt;T* begin_def(T(&amp;arr)[size])&#123; //arr数组的引用 return arr;&#125;// the same as std::endtemplate&lt;typename T, unsigned size&gt;T* end_def(T(&amp;arr)[size])&#123; //We usually don't use a function name which is the same as the function of standard libary //This should not be const return arr + size;&#125;template&lt;typename T,unsigned size&gt;constexpr unsigned getSize(const T(&amp;arr)[size])&#123; return size;&#125;int main()&#123; string s[] = &#123; "sssss","ss","ss","ssssszzzz" &#125;; cout &lt;&lt; *(begin_def(s)) &lt;&lt; endl; cout &lt;&lt; *(end_def(s) - 1) &lt;&lt; endl; string s1[] = &#123; "sss" &#125;; cout &lt;&lt; getSize(s1) &lt;&lt; endl; //1 char c[] = "s"; cout &lt;&lt; getSize(c) &lt;&lt; endl; //2 return 0;&#125; 类模板类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息—-用来代替模板参数的模板实参列表。 定义类模板类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值。 实例化类模板一个类模板的每个实例都形成一个独立的类。类型Blob与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。 类模板的成员函数类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。 对应的Blob的成员应该是这样的： 12template &lt;typename T&gt;ret-type Blob&lt;T&gt;::member-name(parm-list) 类模板成员函数的实例化默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。 在类代码内简化模板类名的使用当我们使用一个类模板类型时必须提供模板参数，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参 在类模板外使用类模板名当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。 12345678//重载BlobPtr&lt;T&gt;模板类的后置递增运算符template &lt;typename T&gt;BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::operator++(int) &#123; //类外，返回类型BlobPtr&lt;T&gt; //类内，BlobPtr无须提供模板参数，写成 BlobPtr 等价 BlobPtr&lt;T&gt; ret = *this; BlobPtr ret = *this; ++*this; return ret; //返回保存的类型&#125; 类模板完整示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std;template &lt;typename T&gt;class Blob&#123; //typedef int size;public: typedef T value_type; typedef typename vector&lt;T&gt;::size_type size_type; //构造函数 Blob(); Blob(initializer_list&lt;T&gt; i1); //Blob中的元素数目 size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; //添加和删除元素 void push_back(const T &amp;t) &#123; data-&gt;push_back(t); &#125; //移动版本 void push_back(T &amp;&amp;t) &#123; data-&gt;push_back(move(t)); &#125; void pop_back(); //元素访问 T&amp; back(); T&amp; operator[] (size_type i);private: shared_ptr&lt;vector&lt;T&gt;&gt; data; //若data[i]无效，则抛出msg void check(size_type i,const string &amp;msg) const;&#125;;template &lt;typename T&gt;T&amp; Blob&lt;T&gt;::back()&#123; check(0,"subscript out of range"); return data-&gt;back();&#125;template &lt;typename T&gt;T&amp; Blob&lt;T&gt;::operator[](size_type i) &#123; check(i,"subscript out of range"); (*data)[i];&#125;template &lt;typename T&gt;void Blob&lt;T&gt;::pop_back()&#123; check(0,"pop_back on empty Blob"); data-&gt;pop_back();&#125;template &lt;typename T&gt;Blob&lt;T&gt;::Blob():data(make_shared&lt;vector&lt;T&gt;&gt;()) &#123;&#125;template &lt;typename T&gt;Blob&lt;T&gt;::Blob(initializer_list&lt;T&gt; i1): data(make_shared&lt;vector&lt;T&gt;&gt;(i1)) &#123;&#125;template &lt;typename T&gt;void Blob&lt;T&gt;::check(size_type i,const string &amp;msg) const&#123; if(i&gt;=data-&gt;size()) throw out_of_range(msg);&#125;int main()&#123; Blob&lt;int&gt; ib = &#123;1,2,3,4,5,6&#125;; int back = ib.back(); cout&lt;&lt;back&lt;&lt;endl; cout&lt;&lt;ib.size()&lt;&lt;endl; return 0;&#125; 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数。 类模板和友元（暂时不看）类模板的static成员与任何其他类相同，类模板可以声明static成员 123456789template &lt;typename T&gt;class Foo&#123;public: static size_t count() &#123; return ctr; &#125; //其他接口成员private: static size_t ctr; //其他实现成员&#125;; 每个Foo的实例都有其自己的static成员实例。即，对于任意给定类型X，都有一个Foo::ctr和一个Foo::count成员。所有Foo类型的对象共享相同的ctr对象和count对象。 我们将static数据成员也定义为模板： 12template &lt;typename T&gt;size_t Foo&lt;T&gt;::ctr = 0; //定义并初始化ctr 访问类模板的static成员 1234Foo&lt;int&gt; fi; //实例化Foo&lt;int&gt;类和static数据成员ctrauto ct = Foo&lt;int&gt;:count(); //实例化Foo&lt;int&gt;::countct = fi.count(); //使用Foo&lt;int&gt;::countct = Foo::count(); //错误：使用哪个模板实例的count? 类似于任何其他成员函数，一个static成员函数只有在使用时才会实例化。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板参数与成员模版]]></title>
    <url>%2F2017%2F12%2F01%2F%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[模板参数模板参数与作用域模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名： 123456typedef double A;template &lt;typename A,typename B&gt; void f(A a, B b)&#123; A tmp = a; //tmp的类型为模板参数A的类型，而非double double B; //错误：重声明模板参数B&#125; 由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次： 12//错误：非法重用模板参数名Vtemplate &lt;typename V, typename V&gt; //... 模板声明模版声明必须包含模板参数： 123//声明但不定义compare和Blobtemplate &lt;typename T&gt; int compare(const T&amp;,const T&amp;);template &lt;typename T&gt; class Blob; 与函数参数相同，声明中的模板参数的名字不必与定义中相同。 建议： 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。 使用类的类型成员例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时： 1T::size_type * p; 它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点： 12345template &lt;typename T&gt;//typename T::value_type 使用关键字通过编译器该名字T::value_type表示类型typename T::value_type top (const T &amp;c) &#123; //...&#125; note:当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。 默认模板实参就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。在新标准中，我们可以为函数和类模板提供默认实参。 例如，我们重写compare，默认使用标准库的less函数对象模板： 123456template &lt;typename T,typename F = less&lt;T&gt;&gt;int compare(const T &amp;v1,const T &amp;v2, F f = F())&#123; if(f(v1,v2)) return -1; if(f(v2,v1)) return 1; return 0;&#125; 模板默认实参与类模板无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对： 123456789101112template &lt;class T = int&gt;class Numbers&#123; //T默认为intpublic: Numbers(T v=0):val(v) &#123;&#125; //...private: T val;&#125;;Numbers&lt;long double&gt; num1;Numbers&lt;&gt; num2; //空&lt;&gt;表示我们希望使用默认类型 习题示例： 编写函数，接受一个容器的引用，打印容器中的元素，两种方式，一种使用容器的size_type和size成员来控制打印元素的循环；另一种使用begin和end返回迭代器来控制循环。 12345678910111213141516171819202122template&lt;typename Container&gt;void print1(const Container &amp;container)&#123; //typename Container::size_type 表明size_type是一个类型 for(typename Container::size_type i = 0;i&lt;container.size();++i)&#123; cout&lt;&lt;container[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;template&lt;typename Container&gt;void print2(const Container &amp;container)&#123; for(auto iter = container.begin();iter!=container.end();++iter)&#123; cout&lt;&lt;*iter&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;vector&lt;int&gt; ivec = &#123;1,2,3,4&#125;;print1(ivec);list&lt;string&gt; slist = &#123;"wang","xin","ri"&#125;;print2(slist); 成员模板一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数。 普通（非模板）类的成员模板例如，我们定义一个类，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。由于希望delete使用于任何类型，所以我们将调用运算符定义为一个模板： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class DebugDelete&#123;public: DebugDelete(ostream &amp;s = cerr):os(s)&#123;&#125; //与任何函数模板相同，T的类型由编译器推断 template&lt;typename T&gt; void operator()(T *p) const &#123; //成员模板，重载函数调用运算符 os&lt;&lt;"deleting unique_ptr"&lt;&lt;endl; delete p; &#125;private: ostream &amp;os;&#125;;int main()&#123; double *p = new double(10); cout&lt;&lt;*p&lt;&lt;endl; DebugDelete d; d(p); //调用DebugDelete::operator() (double*),释放p int *ip = new int; //在一个临时DebugDelete对象上调用operator()(int*) DebugDelete()(ip); return 0;&#125; 类模板的成员模板对于类模板，我们也可以为其定义成员模板。再此情况下，类和成员各自有自己的、独立的模板参数。 与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表： 1234//类模板外定义成员模板template &lt;typename T&gt; //类的类型参数template &lt;typename It&gt; //构造函数的类型参数Blob&lt;T&gt;::Blob(It b,It e):data(make_shared&lt;vector&lt;T&gt;&gt;(b,e)) &#123;&#125; 控制实例化当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个示例。 在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化来避免这种开销。一个显式实例化有如下形式： 12extern template declaration; //实例化声明template declaration； //实例化定义 declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如， 123//实例化声明与定义extern template class Blob&lt;string&gt;; //声明template int compare(const int&amp;,const int&amp;); //定义 当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。 警告： 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。 实例化定义会实例化所有成员一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。 note: 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚函数与抽象基类]]></title>
    <url>%2F2017%2F11%2F23%2F%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[虚函数在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们知道运行时才能知道到底调用了那个版本的虚函数，所以所有的虚函数都必须有定义。通常情况下，如果我们不适用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用那个虚函数。 对虚函数的调用可能在运行时才被解析当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的哪一个。 必须要搞清楚一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。 12base = derived; //把derived的Quote部分拷贝给basebase.net_price(20); //调用Quote::net_price 注意： 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。 派生类中的虚函数当我们在派生类中覆盖某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。 同样，派生类中虚函数的返回类型也必须与基类匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。 final和override说明符override在类的设计中常常会用到虚函数。但是存在一个问题，在派生类中本来是要重写基类中的虚函数的时候，由于写错参数类型，写错函数名等问题，造成重新定义了一个函数，这往往会造成意想不到的错误。想要调试并发现这样的错误显然非常困难，c++11引入关键字override。在派生类中重写了虚函数以后，可以使用override来修饰重写的虚函数，这个时候如果基类中没有这个虚函数，此时编译器将报错。 1234567891011struct B&#123; virtual void f1(int) const; virtual void f2(); void f3();&#125;;struct D1:B&#123; void f1(int) const override; //正确：f1与基类中的f1匹配 void f2(int) override; //错误：B没有形如f2(int)的函数 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：B没有名为f4的函数&#125;; final在设计基类的时候，有时候我们不想后续的的派生类覆盖某个方法，这个时候，我们可以将这个方法修饰为 final 。派生类中任何试图覆盖该函数的行为都将导致错误。 123456789struct D2:B&#123; //从B继承f2()和f3(),覆盖f1(int) void f1(int) const final; //不允许后续的其他类覆盖f1(int)&#125;;struct D3:D2 &#123; void f2(); //正确：覆盖从间接基类B继承而来的f2 void f1(int) const; //错误：D2已经将f2声明成final&#125;; 虚函数与默认实参虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。 换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。 建议：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。 回避虚函数的机制在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的。 12//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么double undiscounted = baseP-&gt;Quote::net_price(42); 该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。 抽象基类纯虚函数和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。 值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能再类的内部为一个=0的函数提供函数体。 含有纯虚函数的类是抽象基类含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。 123//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数Disc_quote discounted; //错误：不能定义Disc_quote的对象Bulk_quote bulk; //正确：Bulk_quote中没有纯虚函数 note: 我们不能创建抽象基类的对象。 派生类构造函数只初始化它的直接基类先初始化基类的构造函数、再初始化自己的构造函数，最后执行构造函数体部分。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问控制与继承]]></title>
    <url>%2F2017%2F11%2F23%2F%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[访问控制与继承每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问（accessible）。 受保护的成员 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。 和共有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。 此外，protected还有另外一条重要的性质。 派生类的成员或友元只能通过派生类对象来访问基类受的保护成员。派生类对于一个基类对象中的受保护的成员没有任何访问权限。 考虑如下例子： 12345678910111213class Base&#123;protected: int prot_mem;&#125;;class Sneaky : public Base &#123; friend void clobber(Sneaky&amp;); //能访问Sneaky::prot_mem friend void clobber(Base&amp;)； //不能访问Base::prot_mem int j;&#125;;//正确：clobber能访问Sneaky对象的private和protected成员void clobber(Sneaky &amp;s) &#123;s.j = s.prot_mem = 0;&#125;//错误：clobber不能访问Base的protected成员void clobber(Base &amp;b)&#123; b.prot_mem = 0;&#125; 公有、私有和受保护继承 （重点）某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。 派生类访问说明符（继承的类是公有、私有还是受保护）对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，基类成员的访问权限只与基类中的访问说明符有关（派生类的成员不能访问基类私有成员，可以访问基类公有和受保护成员）。 派生类访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限： 如果继承是公有的，对于派生类用户来讲，基类中成员遵循其原有的访问说明符。 如果继承是私有的，对于派生类用户来讲，基类中的成员访问说明符都是私有的。 如果继承是受保护的，对于派生类用户来讲，基类的所有公有成员在新定义的类中都是受保护的，基类中的受保护和私有成员遵循原来的访问说明符。 派生类向基类转换的可访问性 （略） 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护或者私有的，则用户代码不能使用该转换。 关键概念：类的设计与受保护的成员 不考虑继承的话，我们可以认为一个类有两种不同的用户：普通用户和类的实现者。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。 如果进一步考虑继承的话就会出现第三种用户：即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。 和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可以供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。 友元与继承不能继承友元关系；每个类负责控制各自成员的访问权限。 改变个别成员的可访问性有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明可以达到这一目的。 派生类只能为那些它可以访问的名字提供using声明。 默认的继承保护级别使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。 一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOP概述（object-oriented programming）]]></title>
    <url>%2F2017%2F11%2F19%2FOOP%E6%A6%82%E8%BF%B0%EF%BC%88object-oriented-programming%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。 继承和动态绑定对程序的编写有两个方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。 OOP：概述面向对象程序设计（object-oriented programming）的核心是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。 继承通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。 在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。 动态绑定函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为运行时绑定。 note: 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。 定义基类和派生类基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 成员函数和继承派生类可以继承其基类的成员，也可以对基类中的虚函数进行重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的旧定义。 在C++语言中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通过将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。 成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。 访问控制与继承派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他基类的代码一样，派生类能访问公用成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。 private member: base class itself and friend can access protected members: base class itself,friend and derived classes can access 定义派生类派生类必须通过使用派生类列表明确指出它是从哪个基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。 如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。 派生类中的虚函数派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。 C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。 派生类对象及派生类向基类的类型转换一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。 派生类构造函数尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。 12//派生类构造函数初始化，使用基类的构造函数来初始化它的基类部分 Bulk_quote(const string&amp; book,double p,size_t qty,double disc):Quote(book,p),min_qty(qty),discount(disc) &#123;&#125; 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公有成员和受保护成员： 其中price是基类中的受保护成员 12345678//如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了double Bulk_quote::net_price(size_t cnt) const &#123; if(cnt &gt;= min_qty) &#123; return cnt*(1-discount)*price; &#125;else&#123; return cnt*price; &#125;&#125; 遵循基类的接口 必须明确一点：每个类负责定义各自的借口。要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此。 因此，派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。 继承与静态成员如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。 1234567class Base&#123;public: static void statmem();&#125;;class Derived:public Base&#123; void f(const Derived&amp;);&#125;; 静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们即能通过基类使用它也能通过派生类使用它： 123456void Derived::f(const Derived &amp;derived_obj)&#123; Base::statmem(); Derived::statmem(); derived_obj.statmem(); statmem(); //通过this对象访问&#125; 派生类的声明如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。 一个类不能派生它本身。 防止继承发生有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。防止继承发生的方法，即在类名后跟一个关键字final。 类型抓换与继承理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。 通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上。 可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。 不存在从基类向派生类的隐式类型转换因为一个基类对象可能是派生类对象的一部分，也可能不是，所以不存杂从基类向派生类的自动类型转换： 123Quote base;Bulk_quote* bulkP = &amp;base; //错误：不能将基类转换成派生类Bulk_quote* bulkRef = base; //错误：不能将基类转换成派生类 除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换： 123Bulk_quote bulk;Quote *itemP = &amp;bulk; //正确：动态类型是Bulk_quoteBulk_quote *bulkP = itemP; //错误：不能将基类转换成派生类 在对象之间不存在类型转换派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。 123Bulk_quote bulk; //派生类对象Quote item(bulk); //使用Quote::Quote(const Quote&amp;) 构造函数item = bulk; //调用Quote::operator=(const Quote&amp;) 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。 关键概念：存在继承关系的类型之间的转换规则 1、从派生类向基类的类型转换只对指针或引用类型有效。 2、基类向派生类不存在隐式类型转换。 3、和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。 尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显示或隐式低）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意到是，这种操作只处理派生类对象的基类部分。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用运算符重载]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前言当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义：同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。 如果一个运算符函数是成员函数，这他的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数： 12//错误：不能为int重定义内置的运算符int operator+(int,int); 这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。 直接调用一个重载的运算符函数123//一个非成员运算符函数的等价调用data1 + data2; //普通的表达式operator+(data1,data2); //等价的函数调用 这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。 123//一个成员运算符函数的等价调用data1 += data2; //基于“调用”的表达式data1.operator+=(data2); //对成员运算符 这两天语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。 某些运算符不应该被重载某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。 比如：&amp;&amp; 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，这两个运算对象总是会被求值。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。 通常情况下：不应该重载逗号、取地址、逻辑与和逻辑或运算符。 赋值和复合赋值运算符赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧的运算对象的一个引用。重载的赋值运算符应该继承而非违背其内置版本的含义。 如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。+=运算符的行为显然与其内置版本一致，即先执行+，再执行=。 选择作为成员或者非成员 （重点）当我们定义重载的运算符必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。 下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择： 赋值（=）、下标（[])、调用（（））和成员访问箭头（-&gt;）运算符必须是成员 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。 具有对称性的运算符可以转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。 例如，我们能求一个int和一个double的和，因为它们中任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。 当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象，例如： 123string s = "world";string t = s + "!"; //正确：我们能把一个const char*加到一个string对象中string u = "hi" + s; //如果 + 是string的成员，则产生错误 如果operator+是string类的成员，则上面的第一个加法等价于s.operator+(“!”)。同样的，”hi”+s等价于”hi”.operator+(s)。显然”hi”的类型是const char*,这是一种内置类型，根本就没有成员函数。 因为string将+定义成了普通的非成员函数，所以”hi”+s等价于operator+(“hi”,s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准备无误地转换成string。 输入和输出运算符IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。 重载输出运算符&lt;&lt;通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用时因为我们无法直接赋值一个ostream对象。 第二个形参一般来说是一个常量的引用，因为打印对象不会改变对象的内容，为了与其他输出运算符保持一致，operator&lt;&lt;一般要返回它的ostream形参。 1234ostream &amp;operator&lt;&lt;(ostream &amp;os,const Sales_data &amp;item)&#123; os&lt;&lt;item.isbn()&lt;&lt;item.avg_price(); return os;&#125; 输入输出运算符必须是非成员函数，通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。 重载输入运算符&gt;&gt;通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。 12345678910istream&amp; operator&gt;&gt;(istream &amp;is,Sales_data &amp;item)&#123; double price ; is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price; if(is)&#123; //检查输入是否成功 item.revenue = item.units_sold*price; &#125;else&#123; item = Sales_data(); //输入失败：对象被赋予默认的状态 &#125; return is;&#125; note: 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。 算术和关系运算符如果类同时定义了算符运算符和相关的复合赋值运算符（+=），则通常情况下应该使用复合赋值来实现算术运算符。 相等运算符 （==）如果某个类在逻辑上有相等性的含义，则该类应该定义operator == ，这样做可以使得用户更容易使用标准库算法来处理这个类。 关系运算符 （&lt;）定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较有用。 通常情况下关系运算符应该 定义顺序关系，令其与关联容器中对关键字的要求一致。 如果类同时也包含==运算符的话，则定义一种关系令其与 ==保持一致。特别是，如果两个对象是!=的，那么一个对象应该&lt;另外一个。 注意： 如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和 ==产生的结果一致时才定义 &lt;运算符。 赋值运算符我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数 复合赋值运算符赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。 1234567//作为成员的二元运算符：左侧运算对象绑定到隐式的this指针//假定两个对象表示的是同一本书Sales_data&amp; Sales_data::operator+= (const Sales_data &amp;rhs)&#123; this.units_sole += rhs.units_sole; this.revenue += rhs.revenue; return *this;&#125; 下标运算符表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。 note: 下标运算符必须是成员函数。 为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好定义下标运算符的常量版本和非常量版本，当作用与一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。 定义StrVec的下标运算符： 12345678class StrVec &#123;public: string&amp; operator[](size_t n) &#123;return elements[n];&#125; const string&amp; operator[](size_t n) const &#123;return elements[n];&#125; //其他成员定义private: string *element; //指向数组首元素的指针&#125; 当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值： 1234567// 假设svec是一个StrVec对象const StrVec cvec = svec; //把svec的元素拷贝到cvec中//如果svec中含有元素，对第一个元素运行string的empty函数if(svec.size() &amp;&amp; svec[0].empty()) &#123; svec[0] = "zero"; //正确:下标运算符返回string的引用 cvec[0] = "zip"; //错误：对cvec取下标返回的是常量引用，不能再赋值&#125; 递增和递减运算符 （重点）C++语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类成员。 定义前置递增/递减运算符与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。 1Integer&amp; operator++()&#123; ++value; return *this;&#125; //前置运算符 后置运算符后置版本接受一个额外的（不被使用）int类型的形参，因为我们不会用到int形参，所以无须为其命令。 为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。 12345Integer operator++(int) &#123; //后置运算符 Integer ret = *this; ++value; return ret;&#125; 显示调用后置运算符通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值 123Integer INT;INT.operator++(0); //调用后置版本的operator++INT.operator++(); //调用前置版本的operator++ 完整代码实现： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class Integer&#123;public: Integer(int a = 0):value(a)&#123;&#125; //默认值参数，如果不提供参数，调用默认构造函数，提供参数则调用构造函数 Integer(const Integer&amp; Int):value(Int.value)&#123;&#125; //拷贝构造函数 Integer&amp; operator=(const Integer &amp;Int) &#123; value = Int.value; return *this;&#125; //拷贝赋值运算符 Integer&amp; operator++()&#123; ++value; return *this;&#125; //前置运算符 Integer operator++(int) &#123; Integer ret = *this; ++value; return ret;&#125; //后置运算符 int value; //含有一个数据类型&#125;;int main()&#123; Integer a; cout&lt;&lt;a.value&lt;&lt;endl; a.value = 10; Integer b(a); //调用拷贝构造函数 cout&lt;&lt;b.value&lt;&lt;endl; Integer c; c = a; //调用拷贝赋值运算符 cout&lt;&lt;c.value&lt;&lt;endl; ++c; //调用重载前置运算符 cout&lt;&lt;c.value&lt;&lt;endl; cout&lt;&lt;(c++).value&lt;&lt;endl; //调用重载后置运算符 cout&lt;&lt;c.value&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象移动]]></title>
    <url>%2F2017%2F11%2F15%2F%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[对象移动新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。 noet: 标准库容器、string和shared_ptr类及支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。 右值引用为了支持移动操作，新标准引入了一种新的引用类型——右值引用，就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。右值引用一个重要的特性就是只能绑定到将要销毁的对象。 左值和右值是表达式的属性，一些表达式生成或要求左值，而另一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的是对象的值。（可以取地址的、有名字的就是左值；不能取地址的、没有名字的就是右值。）两者明显的区别就是左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。 类似于常规引用（左值引用），一个右值引用也不过是某个对象的另一个名字而已。我们不能将左值引用绑定到要求转换的表达式、字面常量或是返回值的表达式，也不能把右值应用直接绑定到一个左值上。但是，常量左值引用可以绑定到非常量左值、常量左值、右值，是一个万能引用类型。不过相比右值引用所引用的右值，常量左值引用所引用的右值在它的“余生”中只能是只读的。 123456int i = 42;int &amp;r = i; //r引用iint &amp;r2 = i*2; //错误，i*2是一个右值int &amp;&amp;rr = i； //错误，不能将一个右值引用绑定到一个左值上int &amp;&amp;rr2 = i*2; //正确，将rr2绑定到一个乘法结果上const int &amp;r3 = i*2; //正确，将一个常量引用绑定到一个右值上 左值持久；右值短暂考虑左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。 由于右值引用只能绑定到临时对象，我们得知 所引用的对象将要被销毁 该对象没有其他用户 这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。 注意： 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态 变量时左值12int &amp;&amp;rr1 = 42; //正确：字面值常量是右值int &amp;&amp;rr2 = rr1; //错误：表达式rr1是左值 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。 标准库move函数我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。 1int &amp;&amp;rr3 = std::move(rr1); //ok note: 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。 warning: 使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。 移动构造函数和移动赋值运算符12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct X&#123; string i; //内置类型可以移动 string s; //string定义了自己的移动操作&#125;;int main()&#123; X x; x.i = "cqu"; x.s = "wangxinri"; cout&lt;&lt;x.i&lt;&lt;" "&lt;&lt;x.s&lt;&lt;endl; //cqu wangxinri //使用合成的移动构造函数 X x2 = std::move(x); //移后源对象x必须保持有效的、可析构的状态 cout&lt;&lt;x2.i&lt;&lt;" "&lt;&lt;x2.s&lt;&lt;endl; //cqu wangxinri cout&lt;&lt;"---------"&lt;&lt;endl; cout&lt;&lt;x.i&lt;&lt;" "&lt;&lt;x.s&lt;&lt;endl; //输出空字符，说明x的值已经被x2接管了，x是一个可析构的状态 cout&lt;&lt;"---------"&lt;&lt;endl; x.i = "aaa"; x.s = "bbb"; cout&lt;&lt;x.i&lt;&lt;" "&lt;&lt;x.s&lt;&lt;endl; // aaa bbb return 0;&#125; 由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。 move用来将一个右值引用绑定到一个左值的标准库函数。调用move隐含地承诺我们将不会再使用移后源对象，除了销毁它或赋予它一个新值之外。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>右值引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存与智能指针]]></title>
    <url>%2F2017%2F11%2F10%2F%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[前言到目前为止，我们编写的程序中所使用的对象都有着严格定义的生命期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。 除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。 动态对象的正确释放被证明是编程中极其容器出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。 静态内存、栈内存、堆静态内存：用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。 栈内存：用来保存定义在函数内的非static对象。 分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。 除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间（free store）或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。 warning：虽然使用动态内存有时是必要的，但众所周知，正确管理动态内存是非常棘手的。 动态内存与智能指针在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针。我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。 动态内存的使用很容易出问题，因为确保在正确的时间释放内存是及其困难的。有时我们会忘记释放内存，在这种情况下就会产生内存泄漏；有时在尚有指针引用内存的情况下我们就释放它了，在这种情况下就会产生引用非法内存的指针。 为了更容易（同时也安全）地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。只能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种只能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。 shared_ptr类类似vector，只能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种指针的名字： 12shared_ptr&lt;string&gt; p1 ; //shared_ptr,可以指向stringshared_ptr&lt;list&lt;int&gt; &gt; p2; //shared_ptr,可以指向int的list 默认初始化的智能指针中保存着一个空指针。 只能指针的使用方式与普通指针类似。解引用一个智能指针返回它所指的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空： 123//如果p1不为空，检查它是否指向一个空stringif(p1&amp;&amp;p1-&gt;empty()) *p1="hi"; 下表列出了shared_ptr和unique_ptr都支持的操作。只适用shared_ptr的操作列入下面。 shared_ptr和unique_ptr都支持的操作 12345678shared_ptr&lt;T&gt; sp 空智能指针，可以指向类型为T的对象unique_ptr&lt;T&gt; up p 将p用作一个条件判断，若p指向一个对象，则为true*p 解引用p，获得它指向的对象p-&gt;mem 等价于(*p).memp.get() 返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了swap(p,q) 交换p和q中的指针p.swap(q) shared_ptr独有的操作 12345make_shared&lt;T&gt;(args) 返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象shared_ptr&lt;T&gt; p(q) p是shared_ptr q的一个拷贝，此操作会递增q中的计数器。q中的指针必须都能转换为T*p=q p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为0，则将其管理 的原内存释放p.unique() 若p.use_count()为1，返回true，否则返回falsep.use_count() 返回与p共享对象的智能指针的数量；可能很慢，主要用于调试 make_shared函数最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向对象的shared_ptr。与智能指针一样，make_shared也定义在头文件memory中。 当要使用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型： 123456//指向一个值为42的int的shared_ptrshared_ptr&lt;int&gt; p3=make_shared&lt;int&gt; (42);//p4指向一个值为"99999"的stringshared_ptr&lt;string&gt; p4=make_shared&lt;string&gt; (5,'9');//p5指向一个值初始化的int，即，值为0shared_ptr&lt;int&gt; p5=make_shared&lt;int&gt; (); 类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。例如，调用make_shared时传递的参数必须与string的某个构造函数相匹配，调用make_shared 时传递的参数必须能用来初始化一个int，依次类推。如果我们不传递任何参数，对象就会进行值初始化。 当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式较简单： 12//p6指向一个动态分配的空vector&lt;string&gt;auto p6=make_shared&lt;vector&lt;string&gt;&gt; (); shared_ptr的拷贝和赋值当进行拷贝或赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。 12auto p=make_shard&lt;int&gt;(42); //p指向的对象只有p一个引用者auto q(p); //p和q指向相同的对象，此对象有两个引用者 我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器都会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域时，计数器就会递减） 一旦一个shared_ptr的计算器变为0，它就会自动释放自己所管理的对象： 12auto r=make_shared&lt;int&gt;(42); //r指向的int只有一个引用者r=q; //给r赋值，令它指向另一个地址，递增q指向的对象的引用计数，递减r原来指向的对象的引用计数，r原来指向的对象已没有引用者，会自动释放 此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一执行此int的shared_ptr，在把q赋给r的过程中，此int被自动释放。 shared_ptr自动销毁所管理的对象当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——析构函数完成销毁工作的。类似与构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。 析构函数一般用来释放对象分配的资源。例如，string的构造函数（以及其他string成员）会分配内存来保存构成string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。 shared_ptr的析构函数会递减它所指对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。 shared_ptr还会自动释放相关联的内存当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如，我们可能有一个函数，它返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的： 1234567//factory返回一个shared_ptr，指向一个动态分配的对象shared_ptr&lt;Foo&gt; factory(T arg)&#123; //恰当地处理arg //shared_ptr负责释放内存 return make_shared&lt;Foo&gt;(arg);&#125; 由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时刻被释放。例如，下面的函数将factory返回的shared_ptr保存在局部变量中： 123456void use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p //p离开了作用域，它指向的内存会被自动释放掉&#125; 由于p是use_factory的局部变量，在use_factory结束时它将被销毁。当p被销毁时，将递减其引用计数并检查它是否为0。在此例中，p是唯一引用factory返回的内存的对象。由于p将要销毁，p指向的这个对象也会被销毁，所占用的内存会被释放。 但如果有其他的shared_ptr也指向这块内存，它就不会被释放掉： 123456void use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p=factory(arg); //使用p return p; //当我们返回p时，引用计数进行了递增操作&#125; //p离开了作用域，但它指向的内存不会被释放 在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。 由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。shared_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某种元素。在这种情况西下，你应该确保erase删除哪些不再需要的shared_ptr元素。 注意：如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。 使用了动态生存期的资源的类程序使用动态内存处于以下三种原因之一： 1 程序不知道自己需要使用多少个对象； 2 程序不知到所需的准确类型 3 程序需要在多个对象间共享数据 容器类是处于第一种原因而使用动态内存的典型例子。 使用动态内存的一个常见原因是运行多个对象共享相同的状态。 直接管理内存C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete释放new分配的内存。 相对于智能指针，使用这两个运算符管理内存非常容易出错，随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。 使用new动态分配和初始化对象在自由空间分配的内存是无名的。因此，new无法为其分配的对象命名，而是返回一个执行对象的指针： 1int *pi=new int ; // pi指向一个动态分配的、未初始化的无名对象 此new表达式在自由空间构造一个int型对象，并返回指向该对象的指针。 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化： 12string *ps=new string; //初始化为空stringint *pi=new int ; // pi指向一个未初始化的int 我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）： 123int *pi=new int(1024) ;//pi的对象的值为1024string *ps=new string(10,'9') ; //vector有10个元素，值依次从0到9vector&lt;int&gt; *pv=new vector&lt;int&gt;&#123;0,1,2,3,4,5,6,7,8,9&#125;; 也可以对动态的对象进行值初始化，只需在类型名之后跟一对空括号即可： 1234string *ps1=new string; //默认初始化为空stringstring *ps=new string(); //值初始化为空stringint *pi1=new int; //默认初始化：*pi1的值未定义int *pi2=new int(); // 值初始化为0 *pi2为0 对于定义与自己的构造函数的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。 如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto： 12auto p1=new auto(obj) ; //p指向一个与obj类型相同的对象auto p2=new auto(a,b,c) ; //错误：括号中只能有单个初始化器 p1的类型是一个指针，执行从obj自动推断的类型。若obj是一个int，那么p1就算int；若obj是一个string，那么p1是一个string；依次类推。新分配的对象用obj的值进行初始化。 动态分配的const对象用new分配const对象是合法的： 1234//分配并初始化一个const intconst int *pci=new const int(1024);//分配并默认初始化一个const的空stringconst string *pcs=new const string; 类似其他任何const对象，一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，new 返回的指针是一个指向const的指针。 内存耗尽虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败，默认情况下，如果new不能分配所要求的内存空间，它就会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常： 123//如果分配失败，new返回一个空指针int *p1=new int ; //如果分配失败，new抛出std::bad_allocint *p2=new (nothrow) int ; //如果分配失败，new返回一个空指针 我们称这种形式的new为定位new。定位new表达式允许我们向new传递额外的参数，在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。 释放动态内存为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式来将动态内存归还给系统。delete表达式接受一个指针，指向我们想要释放的对象： 1delete p; // p必须指向一个动态分配的对象或是一个空指针 与new 类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。 指针值和delete我们传递给delete的指针必须指向动态分配的内存，或是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的： 1234567int i,*pi1=&amp;i,*pi2=nullptr;double *pd=new double(33),*pd2=pd;delete i; //错误，i不是一个指针delete pi1; //未定义：pi1执行一个局部变量delete pd; //正确delete pd2; //未定义，pd2指向的内存已经被释放了delete pi2; //正确：释放一个空指针总是没有错误的 对于delete i的请求，编译器会生成一个错误信息，因为它知道i不是一个指针。执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些delete表达式，大多数编译器会编译通过，尽管它们是错误的。 虽然一个const对象的值不能被改变，但它本身是可以被销毁的，如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可。 12const int *pci=new const int(1024); delete pci; //正确：释放一个从const对象 动态对象的生存期直到被释放时为止由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个由内置指针管理的动态对象，直到被显示释放之前它都是存在的。 返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存： 123456//factory返回一个指针，指向一个动态分配的对象Foo* factory(T arg)&#123; //视情况处理arg return new Foo(arg); //调用者负责释放此内存&#125; 类似我们之前定义的factory函数，这个版本的factory分配一个对象，但并不delete它。factory的调用者负责在不需要此对象时释放它。不幸的是，调用者经常忘记释放对象： 12345void use_factory(T arg)&#123; Foo *p=factory(arg); //使用p但不delete它&#125; //p离开了它的作用域，但它所指向的内存没有被释放 此外，use_factory函数调用factory，后者分配一个类型为Foo的新对象。当use_factory返回时，局部变量p被销毁，此变量是一个内置指针，而不是一个智能指针。 与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。 注意：由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在。 在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，程序就没有办法释放这块内存了。根据整个程序的逻辑，修正这个错误的正确方法是在use_factory中记得要释放内存： 123456void use_factory(T arg)&#123; Foo *p=factory(arg); //使用p delete p ; //现在记得释放内存，我们已经不需要它了&#125; 还有一种可能，我们的系统中的其他代码要使用use_factory所分配的对象，我们就应该修改此函数，让他返回一个指针，指向它分配的内存： 123456Foo* use_factory(T arg)&#123; Foo *p=factory(arg); //使用p return p; //调用者必须释放内存&#125; 小心：动态内存的管理非常容易出错 使用new和delete管理动态内存存在三个常见问题： 忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。 使用以及释放掉的对象，通过在释放内存后将指针置为空，有时可以检测出这种错误。 同一块内存被释放两次，当有来年刚给指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了，如果我们随后又delete第一个指针，自由空间就可能会被破坏。 相对于查找和修正这种错误来源，制造出这些错误要简单很多。 坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何只能智能指针指向它的情况下，智能指针才会自动释放它。 delete之后重置指针值。。。。当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的空悬指针，即，指向一块层级保存数据对象但现在以及无效的内存的指针。 为初始化指针的所有确定空悬指针也都有，有一种方法可以避免空悬指针的问题；在指针即将要离开其作用域之前释放掉它所关联的内存。这样在指针关联的内存被释放掉之后，就没有机会继续使用指针了。如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。 这只是提供了有限的保护动态内存的一个基本问题是可能有多个指针指向相同的内存，在delete内存之后重置指针的方法只对这个指针有效，对其他任何指向（已释放的）内存的指针是没有作用的。例如： 1234int *p(new int (42)); //p指向动态内存auto q=p; //p和q指向相同的内存delete p; //p和q均变为无效p=nullptr; //指出p不再绑定到任何对象 本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr指出它不再指向任何对象，但是，重置p对q没有任何作用，在我们释放p所指向的（同时也是q所指向的）内存时，q也变为无效了。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关联容器概述]]></title>
    <url>%2F2017%2F11%2F04%2F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、前言关联容器分为有序关联容器和无序关联容器，有序关联容器按关键字有序保存元素，底层数据结构为红黑树；无序关联容器底层数据结构是hashtable，因此是无序的。 关联容器关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。 虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。 关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素是一些关键字-值对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素包含一个关键字；set支持高效的关键字查询操作——检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。 标准库提供8个关联容器，如下表所示。这8个容器间的不同体现在三个维度上：每个容器 （1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保存关键字按顺序存储的容器的名字都以单词unordered开头。因此一个unordered_multi_set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。 类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。 关联容器类型 12345678910按关键字有序保存元素map 关联数组：保存关键字-值对set 关键字即值，即只保存关键字的容器multimap 关键字可重复出现的mapmultiset 关键字可重复出现的set无序容器unordered_map 用哈希函数组织的mapunordered_set 用哈希函数组织的setunordered_multimap 哈希组织的map；关键字可以重复出现unordered_multiset 哈希组织的set；关键字可以重复出现 关联容器概述关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。 除了顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外，无序容器还提供了一些用来调整哈希性能的操作。 关联容器的迭代器都是双向的（可读写，多遍扫描，可递增递减）。 定义关联容器当定义一个map时，必须既指明关键字类型又指明值类型。而定义一个set时，只需指明关键字类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器，我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器中所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化： 1234567map&lt;string,size_t&gt; word_count ; //空容器//列表初始化set&lt;string&gt; exclude=&#123;"the","but","and","or","an","a","The","But","And","Or","An","A"&#125;;//三个元素；authors将姓映射到名map&lt;string,string&gt; autors=&#123; &#123;"Joyce","James"&#125;, &#123;"Austen","Jane"&#125;, &#123;"Dickens","Charles"&#125;&#125;; 与以往一样，初始化器必须能转换为容器中元素的类型。对于set，元素类型就是关键字类型。当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中：1 &#123;key,value&#125; 来指出它们一起构成了map中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。因此，anthors将姓映射到名，初始化它包括三个元素。 初始化multimap或multiset一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字。 关键字类型的要求关联容器对其关键字类型有一些限制。对于无序容器中关键字的要求，我们后面介绍。对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型，在映射类型中，关键字类型是元素的第一部分的类型。因此，word_count的关键字类型是string。类似的，exclude的关键字类型也是string。 有序容器的关键字类型可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个严格弱序。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质： 两个关键字不能同时“小于等于”对方：如果k1“小于等于”k2，那么k2绝不能“小于等于”k1. 如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价与”k2，且k2“等价于”k3，那么k1必须“等价于”k3. 如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map关键字时，只能有一个元素与这个关键字关联，我们可以用两者中任意一个来访问对应的值。 使用关键字的比较函数用来组织一个容器中元素的操作的类型也是容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟这元素类型给出。 在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。 例如，我们不能直接定义一个Sales_data的multiset，因为Sales_data没有&lt;运算符。但是，可以用定义的compareIsbn函数来定义一个multiset。此函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面这样定义 1234bool compareIsbn(const Sales_data &amp;lhs,const Sales_data &amp;rhs)&#123; return lhs.isbn()&lt;rhs.isbn();&#125; 为了使用自己定义的操作，在定义multiset时我们必须提供两个类型。关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向compareIsbn的指针： 123//bookstore中多条记录可以有相同的ISBN//bookstore中的元素以ISBN的顺序进行排序multiset&lt;Sales_data,decltype(compareIsbn)*&gt; bookstore(compareIsbn); 此处，我们使用decltype来指出自定义操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。用compareIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过compareIsbn来为这些元素排序。即，bookstore中的元素将按它们的ISBN成员的值排序。可以用compareIsbn代替&amp;compareIsbn作为构造函数的参数，因为当我们使用一个函数的名字时，在需要的情况下它会自动转化为一个指针。当然，使用&amp;compareIsbn的效果也是一样的。 pair类型在介绍关联容器操作之前，我们需要了解名为pair的标准库类型，它定义在头文件utility中。 一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样： 123pair&lt;string,string&gt; anon; //保存两个stringpair&lt;string,size_t&gt; word_count; //保存一个string和一个size_tpair&lt;string,vector&lt;int&gt;&gt; line; //保存string和vector&lt;int&gt; pair的默认构造函数对数据成员进行值初始化。因此，anon是一个包含两个空string的pair，line保存一个空string和一个空vector。word_count中的size_t 成员值为0，而string成员被初始化为空vector。 我们也可以为每个成员提供初始化器： 1pair&lt;string,string&gt; author&#123;"James","Joyce"&#125;; 这条语句创建了一个名为author的pair，两个成员被初始化为”James”和”Joyce”。 与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号来访问它们，例如 1cout&lt;&lt;w.first&lt;&lt;" occurs "&lt;&lt;w.second&lt;&lt;endl; 此处，w 是指向某个元素的引用。map的元素是pair。在这条语句中，我们首先打印关键字——元素的first成员，接着打印计数器——second成员。标准库只定义了有限的几个pair操作，下表列出了这些操作： pair上的操作 123456789pair&lt;T1,T2&gt; p; p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化pair&lt;T1,T2&gt; p(v1,v2) p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化pair&lt;T1,T2&gt; p=&#123;v1,v2&#125;; 等价于p(v1,v2)make_pair(v1,v2) 返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来p.first 返回p的名为first的（公有）数据成员p.second 返回p的名为second的（公有）数据成员p1 relop p2 关系运算符（&lt;、&gt;、&lt;=、&gt;=）按字典序定义；例如，当p1.first&lt;p2.first或!(p2.first&lt;p1.first)&amp;&amp;p1.second&lt;p2.second成立时，p1&lt;p2为true。关系运算符利用元素的&lt;运算符来实现p1==p2 当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现p1!=p2 创建pair对象的函数想象有一个函数需要返回一个pair。在新标准下，我们可以对返回在进行列表初始化复制代码 123456789pair&lt;string,int&gt;process(vector&lt;string&gt; &amp;v)&#123; //处理v if(!v.empty()) return &#123;v.back(),v.back().size()); // 列表初始化 else return pair&lt;string,int&gt;(); //隐式构造返回值&#125; 在较早的C++版本中，不允许用花括号包围的初始化器来返回pair这种类型的对象，必须显示构造返回值： 12if(!v.empty()) return pair&lt;string,int&gt;(v.back(),v.back().size()); 我们还可以用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数：12if(!v.empty()) return make_pair(v.back(),v.back().size()); 无序容器新标准定义了4个无序关联容器。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显有序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。 虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单。 使用无序容器除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert等）。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。 管理桶无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同的关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。 无序容器提供了一组管理桶的函数。如表所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。 无序容器管理操作 123456789101112131415桶接口c.bucket_count() 正在使用的桶的数目c.max_bucket_count() 容器能容纳的最多的桶的数量c.bucket_size(n) 第n个桶中有多少元素c.bucket(k) 关键字为k的元素在哪个桶中桶迭代local_iterator 可以用来访问桶中元素的迭代器类型const_local_iterator 桶迭代器的const版本c.begin(n),c.end(n) 桶n的首元素迭代器和尾后迭代器c.cbegin(n),c.cend(n) 返回const_local_iterator哈希策略c.load_factor() 每个桶的平均元素数量，返回float值c.max_load_factor() c试图维护的平均桶大小，返回float值，c会在需要时添加新的桶，以使得load_factor&lt;=max_load_factorc.rehash(n) 重组存储，使得bucket_count&gt;=n且bucket_count&gt;size/max_load_factorc.reserve(n) 重组存储，使得c可以保存n个元素且不必rehash 无序容器对关键字类型的要求默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要介绍的智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针的无序容器。 但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。 我们不能使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将Sales_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载函数开始： 123456789size_t hasher(const Sales_data &amp;sd)&#123; return hash&lt;string&gt;()(sd.isbn());&#125;bool eqOp(const Sales_data &amp;lhs,const Sales_data &amp;rhs)&#123; return lhs.isbn()==rhs.isbn();&#125; 我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。 我们使用这些函数来定义一个unordered_multiset 123using SD_multiset=unordered_multiset&lt;Sales_data,decltypr(hasher)*,decltype(eqOp)*&gt;;//参数是桶大小、哈希函数指针和相等型判断运算符指针SD_multiset bookstore(42,hasher,eqOp); 为了简化bookstore的定义，首先为unordered_multiset定义了一个类型别名，此集合的哈希和相等性判断操作与hasher和eqOp函数有着相同的类型。通过使用这种类型，在定义bookstore时可以将我们希望它使用的函数的指针传递给它。 如果我们的类定义了==运算符，则可以只重载哈希函数： 12//使用FooHash生成哈希值；Foo必须有==运算符unordered_set&lt;Foo,decltype(FooHash)*&gt; fooset(10,FooHash); 示例123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main()&#123; unordered_map&lt;string,int&gt; word_count; word_count["to"] = 10; word_count["be"] = 20; auto iter = word_count.find("be"); //查找关键字为"be"的元素是否在unordered_map中，返回一个迭代器 cout&lt;&lt;iter-&gt;first&lt;&lt;endl; cout&lt;&lt;iter-&gt;second&lt;&lt;endl; auto bucket = word_count.bucket("to"); //关键字为"to"的元素在那个桶上 cout&lt;&lt;bucket&lt;&lt;endl; auto beg = word_count.begin(bucket); //桶n的首元素迭代器，pair&lt;string,int&gt;类型 cout&lt;&lt;beg-&gt;first&lt;&lt;endl; cout&lt;&lt;beg-&gt;second&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>关联容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型算法概述]]></title>
    <url>%2F2017%2F10%2F30%2F%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[泛型算法概述顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。 如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如vector或list，还包括内置的数组类型）。 概述大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。例如，假定我们有一个int的vector，希望指定vector中是否包含一个特定值。回答这个问题最方便的方法是调用标准库算法find： 123int val=42; //我们将查找的值//如果在vec中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()auto result=find(vec.cbegin(),vec.cend(),val); 传递给find的前两个参数是表示元素范围的迭代器，第三个参数是一个值。find将范围中每个元素与给定值进行比较。它返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败。因此，我们可以通过比较返回值和第二个参数来判断搜索是否成功。 由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值。例如，可以用find在一个string的list中查找一个给定值： 12string val="a value";auto result=find(lst.cbegin(),lst.cend(),val); 类似的，由于指针就像内置数组上的迭代器一样，我们可以用find在数组中查找值： 123int ia[]=&#123;27,210,12,47,109,83&#125;;int val=83;int *result=find(begin(ia),end(ia),val); 此例中我们使用了标准库begin和end函数来获得指向ia中首元素和尾元素之后的指针，并传递给find。 还可以在序列的子范围中查找，只需要指向子范围首元素和尾元素之后位置的迭代器（指针）传递给find。例如，下面的语句在ia[1],ia[2]和ia[3]中查找指定的元素： 1auto result=find(ia+1,ia+4;val); 算法如何工作为了弄清这些算法如何用于不同类型的容器，让我们来观察一下find。find的工作是在一个未排序的元素序列中查找一个特定的元素。概念上，find应该执行如下步骤： 1 访问序列中的首元素 2 比较此元素与我们要查找的值 3 如果此元素与我们要查找的值匹配，find返回标识此元素的值。 4 否则，find前进到下一个元素，重复执行步骤2和3 5 如果到达序列尾，find应停止 6 如果find到达序列尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型。 这些步骤都不依赖于容器所保存的元素类型。因此，只要有一个迭代器可用来访问元素，find就完全不依赖于容器类型（甚至无须理会保存元素的是不是容器）。 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，在步骤2中，find用元素的==运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持&lt;运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。 注意：算法永远不会执行容器的操作 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。 初始泛型算法除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。 虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解它们是否读取元素、改变元素、或是重排元素顺序。 只读算法一些算法只会读取其输入范围内的元素，而从不改变元素。find就是这样一种算法。 另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列，则： 12//对vec中元素的求和，和的初值是0int sum=accumulate(vec.cbegin(),vec.cend(),0); 这条语句将sum设置为vec中元素的和，和的初值被设置为0. accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。 算法和元素类型accumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。 下面是另一个例子，由于string定义了+运算符，所有我们可以通过调用accumulate来将vector中所有string元素连接起来“ string sum=accumulate(v.cbegin(),v.cend(),string(“”)); 此调用将v中每个元素连接到一个string上，该string初始时是空串。注意，我们通过第三个参数显式地创建了一个string。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。 12//错误：const char*上没有定义+运算符string sum=accumulate(v.cbegin(),v.cend(),""); 原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char。如前所述，此类型决定了使用哪个+运算符。由于const char并没有+运算符，此调用将产生编译错误。 操作两个序列的算法另一个只读算法是equal，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素： 12//roster2中的元素数目应该至少与roster1一样多equal(roster1.cbegin(),roster1.cend(),roster2.cbegin()); 由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector,而roster2是list。 但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。 此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。 写容器元素的算法一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。 一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。 例如，算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。 123fill(vec.begin(),vec.end(),0); //将每个元素重置为0//将容器的一个子序列设置为10fill(vec.begin(),vec.begin()+vec.size()/2,10); 由于fill向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。 关键概念：迭代器参数 一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。例如，第一个序列可能保存于一个vector中，而第二个序列可能保存于一个list、deque、内置数组或其它容器中。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。例如，对equal算法，元素类型不要求相同，但是我们必须能使用==来比较来自两个序列中的元素。 操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如equal，接受三个迭代器：前两个表示一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。 用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。 算法不检查写操作一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素： 123vector&lt;int&gt; vec; //空vector//使用vec，赋予它不同值fill_n(vec.begin(),vec.size(),0); //将所有元素重置为0 函数fill_n假定写入指定个元素是安全的。即，如下形式的调用 1fill_n(dest,n,val) 函数fill_n假定dest指向一个元素，而dest开始的序列至少包含n个元素。 一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）： 123vector&lt;int&gt; vec; //空向量//灾难：修改vec中10个（不存在）元素fill_n(vec.begin(),10,0); 这个调用是一场灾难，我们指定了要写入10个元素，但vec中并没有元素——它是空的，这条语句的结果是未定义的。 向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素。 介绍back_inserter一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器（insert iterator） 是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中。 为了展示如何用算法向容器中写入数据，我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。 back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中： 123vector&lt;int&gt; vec; //空容器auto it=back_inserter(vec); //通过它赋值会将元素添加到vec中*it=42;//vec现在有一个元素，值为42 我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如： 123vector&lt;int&gt; vec; //空向量//正确：back_inserter创建一个插入迭代器，可以用来向vec添加元素fill_n(back_inserter(vec),10,0); //添加10个元素到vec 在每步迭代中，fill_n向给定容器序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，这条fill_n调用语句向vec的末尾添加了10个元素，每个元素的值都是0. 拷贝算法拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。 我们可以用copy实现内置数组的拷贝，如下面代码所示： 123int a[]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;int a2[sizeof(a1)/sizeof(*a1)];auto ret=copy(begin(a1),end(a1),a2); //把a1的内容拷贝到a2 copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。 多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。 例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值： 12//将所有值为0的元素改为42replace(ilist.begin(),ilist.end(),0,42); 此调用将序列中所有0都替换为42,。如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置： 1234//使用back_inserter按需要增长目标序列vector&lt;int&gt; ivec = &#123;1,2,3,3,3,4,4,5,6,7&#125;;vector&lt;int&gt; a;replace_copy(ivec.cbegin(),ivec.cend(),back_inserter(a),4,19); 此调用后，ivec并未改变，a包含与ivec的一份拷贝，不过原来在ivec中值为0的元素在a中都变为42。 重排容器元素的算法某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。 消除重复单词为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分（重复的元素都在末尾，返回指向不重复区域之后一个位置的迭代器），由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作： 12345678vector&lt;string&gt; words = &#123;"to","be","or","not","not","to","be"&#125;;//按字典序排序words,以便查找重复单词sort(words.begin(),words.end());//unique重排输入范围，使得每个单词只出现一次,重复的单词放在后面//排列在范围的前部，返回指向不重复区域之后一个位置的迭代器auto end_unique = unique(words.begin(),words.end());//使用向量操作erase删除重复单词words.erase(end_unique,words.end()); 使用uniquewords排序完毕后，我们希望将每个单词都只保存一次。unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。 words的大小并未改变，但是这些元素的顺序被改变了——相邻的重复元素被“删除”了。我们将删除打引号是因为unique并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，重复的元素出现在后面部分，unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。 使用容器操作删除元素为了真正删除无用元素，我们必须使用容器操作，本例中使用erase。我们删除从end_unique开始直至words末尾的范围内的所有元素。这个调用之后，words包含的重复元素真正被删除了。 值得注意的是，即使words中没有重复单词，这样调用erase也是安全的。在此情况下，unique会返回words.end()。因此，传递给erase的两个参数具有系相同的值：words.end()。迭代器相等意味着传递给erase的元素范围为空。删除一个空范围没有什么不良后果，因此程序中即使在输入元素中无重复元素的情况下也是正确的。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序容器概述]]></title>
    <url>%2F2017%2F10%2F26%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、前言介绍顺序容器的种类及基本操作。 顺序容器一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的是11章的有序和无序关联容器，它们根据关键字的值来存储元素。 所有顺序容器都提供了快速访问元素的能力，但是，这些容器在以下方面都有不同的性能折中。 向容器添加或从容器中删除元素的代价。 非顺序访问容器中的元素。 顺序容器类型： 123456vector 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。list 双向链表。只支持双向顺序访问。在list中任何位置插入/删除都很快forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快。array 固定大小数组。支持快速随机访问。不能添加或删除元素。string 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。 除了array外，其他容器都提供高效、灵活的内存管理。 string和vector将元素保存在连续的内存空间中。因为连续，所以下标访问非常快。但在中间插入、删除较慢（O(n)）。有时添加一个元素还可能需要分配的额外空间，这种情况所有元素必须移动到新的存储空间中 forward_list和array是新C++标准增加的类型。array比内置数组更安全。forward_list没有size()操作。新标准库的容器比旧版本的快得多。 确定使用哪种顺序容器通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。 一般用vector。 如果程序有很多小元素，且空间的额外开销很重要，则不要用list或forward_list。 要随机访问元素用vector或deque。 如果要在中间插入或删除元素，应用list或forward_list。 如果要在头尾插入或删除元素。但不会在中间插入或删除元素，用deque。 如果程序只有在读取输入的时候才需要在容器中间位置插入元素，随后需要随机访问元素。如果确实需要，则考虑在输入阶段用list，一旦输入完成，将list中的元素拷贝到一个vector中。 如果程序既需要随机访问元素，又需要在容器中间插入元素，该怎么办？ 一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。 容器库概述容器类型上的操作形成了一种层次： 某些操作是所有容器类型都提供的。 另外一些操作仅针对顺序容器、关联容器或无序容器。 还有一些操作只适用于一小部分容器。 对容器可以保存的元素类型的限制顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另外一个容器。 1vector&lt;vector&lt;string&gt;&gt; lines; //lines是一个vector，其元类型是string的vector 某些类没有默认的构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数： 123//假定noDefault是一个没有默认构造函数的类型vector&lt;noDefault&gt; v1(10,init); //正确：提供了元素初始化器vector&lt;noDefault&gt; v2(10); //错误：必须提供一个元素初始化器 容器操作：(待补充) 迭代器标准库array具有固定大小与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小： 12array&lt;int,42&gt; //类型为：保存42个int的数组array&lt;string,10&gt; //类型为：保存10个string的数组 为了使用array类型，我们必须同时指定元素类型和大小：12array&lt;int,10&gt;::size_type i; //数组类型包括元素类型和大小array&lt;int&gt;::size_type j; //错误：array&lt;int&gt;不是一个类型 初始化array： 123array&lt;int,10&gt; ia1; //10个默认初始化的intarray&lt;int,10&gt; ia2 = &#123;0,1,2,3,4,5,6,7,8,9&#125;; //列表初始化array&lt;int,10&gt; ia3 = &#123;42&#125;; //ia3[0]为42，剩余元素为0 值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并无此限制。1234int digs[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int cpy[10] = digs; //错误，内置数组不支持拷贝或赋值array&lt;int,10&gt; digits = &#123;0,1,2,3,4,5,6,7,8,9&#125;;array&lt;int,10&gt; copy = digits; //正确，只要数组类型匹配即合法 赋值和swap赋值相关的运算符可用于所有的容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。 12c1 = c2; //将c1的内容替换为c2中元素的拷贝c1 = &#123;a,b,c&#125;; //赋值后，c1大小为3 如果两个容器原来的大小不同，赋值运算后两者的大小都与右边容器的原大小相同。 与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。也就是array进行赋值，左右两边数组大小必须相等。 1.assign(仅顺序容器) 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。例如，我们可以用assign实现将一个vector中的一段char *值赋予一个list中的string： 12345list&lt;string&gt; names;vector&lt;const char *&gt; oldstyle;name = oldstyle; //错误，容器类型不匹配，赋值，类型必须完全一样//正确：可以将const char * 转化为stringnames.assign(oldstyle.cbegin(),oldstyle.cend()); assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素： 1234//等价于slist1.clear();//后跟slist1.insert(slist1.begin(),10,"Hiya!");list&lt;string&gt; slist1(1); //1个元素，为空stringslist1.assign(10,"Hiya!"); 2.使用swap swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换。 123vector&lt;string&gt; svec1(10); //10个元素的vectorvector&lt;string&gt; svec2(24); //24个元素的vectorswap(svec1,svec2); 除array外，swap不对任何元素进行拷贝、删除或插入操作。因此可以保证在常数时间内完成。 在新标准中，容器既提供成员版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。 关系运算符每个容器类型都支持相等运算符（== 和 ！=）；除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器。且必须保存相同类型的元素。 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。 容器的关系运算符使用元素的关系运算符完成比较：容器的相等运算符实际上是使用元素的==运算符 来实现比较的，而其他关系运算符 是使用元素的&lt;运算符 。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算符。 12vector&lt;Sale_data&gt; storeA, storeB;if(storeA &lt; storeB) // 错误：Sales_data没有&lt;运算符 注意： 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。 顺序容器的操作顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。上一节介绍了所有容器都支持的操作。本章剩余部分将介绍顺序容器所特有的操作。 向顺序容器添加元素除了array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。 123456789101112131415向顺序容器添加元素的操作：操作会改变容器的大小；array不支持这些操作。forward_list有自己专有版本的insert和emplace；forward_list不支持push_back和emplace_backvector和string不支持push_front和emplace_frontc.push_back(t) 在c的尾部创建一个值为t或由args创建的元素，返回voidc.emplace_back(args)c.push_front(t) 在c的头部创建一个值为t或由args创建的元素，返回voidc.emplace_front(args)c.insert(p,t) 在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器c.emplace(p,args)c.insert(p,n,t) 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回pc.insert(p,b,e) 将迭代器b和e指向的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回pc.insert(p,il) il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器：若列表为空，则返回p 向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。 当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque的首位之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。 使用push_back我们看到push_back将一个元素追加到一个vector的尾部。除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。 例如，下面的循环每次读取一个string到word中，然后追加到容器尾部： 1234//从标准输入读取数据，将每个单词放到容器末尾string word;while(cin&gt;&gt;word) container.push_back(word); 对push_back的调用在container尾部创建了一个新的元素，将container的size增大了1。该元素的值为word的一个拷贝，container的类型可以是list、vector或deque。 关键概念：当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。 使用push_front除了push_back, list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部： 1234list&lt;int&gt; ilist;//将元素添加到Ilist开头for(size_t ix=0;ix!=4;++ix) ilist.push_front(ix); 此循环将元素0、1、2、3添加到ilist头部。每个元素都插入到list的新的开始位置。即，当我们插入1时，它会被放置在0之前，2被放置在1之前，依次类推。因此，在循环中以这种方式将元素添加到容器中，最终会形成逆序。 注意： deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首部进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置插入元素会很耗时。 在容器中的特定位置添加元素（insert）push_back和push_front操作提供了一种方便地在顺序容器尾部或头部插入单个元素的方法。insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。 每个insert函数都接受一个迭代器作为其一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能， 所有insert函数将元素插入到迭代器所指定的位置之前 。例如，下面的语句 1slist.insert(iter,"Hello!"); //将hello添加到iter之前的位置 虽然某些容器不支持push_front操作，但他们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front: 1234567vector&lt;string&gt; svec;list&lt;string&gt; slist;//等价于调用slist.push_front("Hello!");slist.insert(slist.begin(),"Hello!");//vector不支持push_front，但我们可以插入到begin()之前//警告：插入到vector末尾之外的任何位置都可能很慢svec.insert(svec.begin(),"Hello!"); 将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。 插入范围内元素除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函数类似。其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素够按给定值初始化： 1svec.insert(svec.end(),10,"Anna"); 这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string“Anna”。 接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前： 12345vector&lt;string&gt; v=&#123;"quasi","simba","frollo","scar"&#125;;//将v的最后两个元素添加到slist的开始位置slist.insert(slist.begin(),v.end()-2,v.end());slist.insert(slist.end(),&#123;"these","words","will","go","at","the","end"&#125;);slist.insert(slist.begin(),slist.begin(),slist.end()); //运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器 如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。 使用insert的返回值通过使用insert的返回值，可以在容器中一个特定的位置反复插入元素： 1234list&lt;string&gt; lst;auto iter=lst.begin();while(cin&gt;&gt;word) iter=lst.insert(iter,word); //等价于调用push_front 在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，读取下一个单词。 使用emplace操作使用emplace操作 新标准引入了三个成员——emplace_front、emplace和emplace_back，这些操作（构造而不是拷贝元素）。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定的位置之前或容器尾部。 当调用push或insert成员函数时，我们将元素类型对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素： 123456//在c的末尾构造一个Sales_data对象//使用三个参数的Sales_data的构造函数c.emplace_back("978-0590353403",25,15.99);c.push_back("978-0590353403",25,15.99); //错误：没有接受三个参数的push_back版本//正确：创建一个临时的Sales_data对象传递给push_backc.push_back(Sales_data(("978-0590353403",25,15.99)); 其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。 emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配 ：12345//iter指向c中一个元素，其中保存了Sales_data元素c.emplace_back();//使用Sales_data的默认构造函数c.emplace(iter,"999-999999999"); //使用Sales_data(string)//使用Sales_data的接受一个ISBN、一个count和一个price的构造函数c.emplace_front("978-0590353403",25,15.99);emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。## 访问元素 （访问成员函数返回的是引用）下表列出了我们可以用来在顺序容器值访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。包括array在内的每个顺序容器都有一个front成员函数，而除了forward_list之外的所以顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用：12345678//在解引用一个迭代器或调用front或back之前检查是否有元素if(!c.empty())&#123; //val和val2是c中第一个元素值的拷贝 auto val=*c.begin(),val2=c.front(); //val3和val4是c中最后一个元素值的拷贝 auto last=c.end(); auto val3=*(--last); //不能递减forward_list迭代器 auto val4=c.back(); //forward_list不支持此程序用两种不同方式来获取c中的首元素和尾元素的引用。 直接的方式是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获取尾元素的引用。 在顺序容器中访问元素的操作 123456at和下标操作只适用于string、vector、deque和array。back不适用于forward_list。c.back() 返回c中尾元素的引用。若c为空，函数行为未定义c.front() 返回c中首元素的引用。若c为空，函数行为未定义c[n] 返回c中下标为n的元素的引用，n是一个无符号整数。若n&gt;c.size(),则函数的行为未定义c.at[n] 返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常 对一个空容器调用front和back，就像使用一个越界的下标一样。是一种严重的程序设计错误。 访问成员函数返回的是引用在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值： 1234567if(!c.empty())&#123; c.front() = 42; //将42赋予c中的第一个元素 auto &amp;v = c.back(); //获得指向最后一个元素的引用 v = 1024; //改变c中的元素 auto v2 = c.back(); //v2不是一个引用，它是c.back()的一个拷贝 v2 = 0;&#125; 与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。 下标操作和安全的随机访问提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们已经看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。 我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常： 123vector&lt;string&gt; svec; //空vectorcout&lt;&lt;svec[0]; //运行时错误：svec中没有元素cout&lt;&lt;svec.at[0]; //抛出一个out_of_range异常 删除元素与添加元素的多种方式类似，（非array）容器也有多种删除元素的方式。如下表所示： 顺序容器的删除操作 12345678这些操作会改变容器的大小，所以不适用于arrayforward_list有特殊版本的eraseforward_list不支持pop_back；vector和string不支持pop_frontc.pop_back() 删除c中尾元素，若c为空，则函数行为未定义，函数返回voidc.pop_front() 删除c中首元素，若c为空，则函数行为未定义，函数返回voidc.erase(p) 删除迭代器p所指的元素，返回以指向被删除元素之后的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数的行为未定义c.erase(b,e) 删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器c.clear() 删除c中的所以元素，返回void 删除deque中除首位元素之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。 pop_front和pop_back成员函数pop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似的，forward_list不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。 这些操作返回void，如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它： 1234while(!ilist.empty())&#123; process(ilist.front()); //对ilist的首元素进行一些处理 ilist.pop_front(); //完成处理后删除首元素&#125; 从容器内部删除一个元素成员函数erase从容器中指定位置删除元素，我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。 例如，下面的循环删除一个list中的所有奇数元素： 1234567list&lt;int&gt; lst=(0,1,2,3,4,5,6,7,8,9&#125;;auto it=lst.begin();while(it!=lst.end()) if(*it%2) it=lst.erase(it); //删除此元素 else ++it; 每个循环步中，首先检查当前元素是否是奇数，如果是，就删除该元素，并将it设置为我们所删除的元素之后的元素。如果*it为偶数，我们将it递增，从而在下一步循环检查下一个元素。 删除多个元素接受一对迭代器的erase版本允许我们删除一个范围内的元素： 123//删除两个迭代器表示的范围内的元素//返回指向最后一个被删除元素之后位置的迭代器elem1=slist.erase(elem1,elem2); //调用后，elem1==elem2 迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。 为了删除一个容器中的所有元素，我们既可以调用clear，也可以用begin和end获得的迭代器作为参数调用erase： 12slist.clear() ;//删除容器中的所有元素slist.erase(slist.begin(),slist.end()); //等价调用]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>顺序容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数和拷贝控制]]></title>
    <url>%2F2017%2F10%2F26%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[构造函数和拷贝控制虚析构函数继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。 原因： 当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型（基类）的指针，则该指针有可能实际指向了一个Bulk_quote（派生类）类型的对象。如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。 12345class Quote&#123;public: //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数 virtual ~Quote() = default; //动态绑定析构函数&#125;; 1234Quote *itemP = new Quote; //静态类型与动态类型一致delete itemP; //调用Quote的析构函数itemP = new Bulk_quote; //静态类型与动态类型不一致delete itemP; //调用Bulk_quote的析构函数 警告： 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。 虚析构函数将阻止合成移动操作基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。 合成的拷贝控制与继承基类或派生类的合成构造函数控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。 对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。 派生类中删除的拷贝控制与基类的关系 （略）移动操作与继承如前所述，大多数基类都会定义一个虚析构函数。（如果一个类需要析构函数，那么它同样需要拷贝和控制操作，基类的析构函数并不遵循上诉准则），因此在默认情况下，基类通常不含有合成的移动操作，而且它的派生类中也没有合成的移动操作（如果我们定义了拷贝构造函数，则编译器将不会为类合成一个移动构造函数）。 因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦Quote定义了自己的移动操作，那么它必须同时显式地定义拷贝操作。 12345678910class Quote&#123;public: Quote() = default; //对成员依次进行默认初始化 Quote(const Quote&amp;) = default; //对成员依次拷贝 Quote(Quote&amp;&amp;) = default; //对成员依次拷贝 Quote&amp; operator= (const Quote&amp;) = default; //拷贝赋值 Quote&amp; operator=(Quote&amp;&amp;) = default; //移动赋值 virtual ~Quote() = default; //其他成员与之前的版本一致&#125; 派生类的拷贝控制成员派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。 和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。 警告： 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。 定义派生类的拷贝或移动构造函数 当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。 123456789101112131415161718class Base&#123;public: Base() = default; Base(int value):val(value) &#123;&#125; Base(const Base &amp;b) &#123; this-&gt;val = b.val;&#125; //拷贝构造函数 void show() &#123;cout&lt;&lt;"Base::"&lt;&lt;val&lt;&lt;endl;&#125;private: int val;&#125;;class D:public Base&#123;public: D() = default; D(int dval,int bval):Base(bval),Dval(dval) &#123;&#125; D(const D &amp;d):Base(d),Dval(d.Dval) &#123;&#125; //派生类的拷贝构造函数 void show() &#123;cout&lt;&lt;"D::"&lt;&lt;Dval&lt;&lt;endl;&#125;private: int Dval;&#125;; 123456//D的这个拷贝构造函数很可能是不正确的定义//基类部分被默认初始化，而非拷贝D(const D &amp;d) /*成员初始值，但是没有提供基类初始值*/&#123; /* .... */&#125; 在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的。 警告： 默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。 派生类赋值运算符与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值： 1234567//Base::operator=(const Base&amp;) 不会被自动调用D &amp;D::operator=(const D &amp;rhs)&#123; Base::operator=(rhs); //为基类部分赋值 //按照过去的方式为派生类的成员赋值 //酌情处理自赋值及释放已有资源等情况 return *this;&#125; 值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用他们。例如，对于Base::operator=的调用语句将执行Base的拷贝赋值运算符，至于该运算符是由Base显式定义的还是由编译器合成的无关紧要。 派生类析构函数如前所述，在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源： 12345class D:public Base&#123;public: //Base::~Base被自动调用执行 ~D() &#123; /*该处由用户定义清除派生类成员的操作*/ &#125;&#125;; 对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。 在构造函数和析构函数中调用虚函数如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。 继承的构造函数在C++新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。 派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。 12345678910111213141516class Base&#123;public: Base() = default; Base(int value):val(value) &#123;&#125; //构造函数 void show() &#123;cout&lt;&lt;"Base::"&lt;&lt;val&lt;&lt;endl;&#125;private: int val;&#125;;class D:public Base&#123;public: D() = default; using Base::Base; //继承基类的构造函数 void show() &#123;cout&lt;&lt;"D::"&lt;&lt;Dval&lt;&lt;endl;&#125;private: int Dval;&#125;; 通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。 这些编译器生成的构造函数形如： 1derived(parms):base(args) &#123;&#125; 其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。上述继承的构造函数等价于： 1D(int value):Base(value) &#123;&#125; 如果派生类含有自己的数据成员，则这些成员将被默认初始化。 继承构造函数的特点 一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。 默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>拷贝控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O流与string流]]></title>
    <url>%2F2017%2F10%2F23%2FIO%E6%B5%81%E4%B8%8Estring%E6%B5%81%2F</url>
    <content type="text"><![CDATA[一、前言介绍I/O流和string流及其基本使用。 IO类IO对象无拷贝或赋值由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 条件状态12345678910111213141516171819#include &lt;iostream&gt;using namespace std;istream&amp; func(istream &amp;is)&#123; string buf; while (is &gt;&gt; buf) cout &lt;&lt; buf &lt;&lt; endl; is.clear(); //将流的状态设置为有效 return is;&#125;int main()&#123; istream&amp; is = func(std::cin); cout &lt;&lt; is.rdstate() &lt;&lt; std::endl; cout&lt;&lt;"hi!"&lt;&lt;endl; //输出hi和一个换行，然后刷新缓冲区 cout&lt;&lt;"hi!"&lt;&lt;flush; //输出hi，然后刷新缓冲区，不附加任何额外的字符串 cout&lt;&lt;"hi!"&lt;&lt;ends; //输出hi和一个空字符，然后刷新缓冲区 return 0;&#125; 文件输入输出头文件fstream定义了三个类型来支持文件IO：ifstream从给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写文件。 这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样，特别是，我们可以用IO运算符（&lt;&lt;和&gt;&gt;）来读写文件，可以用getline从一个ifstream读取数据。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;void readfile(string filename,vector&lt;string&gt;&amp; svec)&#123; //从文件中读取数据到svec中 ifstream input; //从一个给定文件读取数据 input.open(filename); if(input)&#123; /* string line; while(getline(input,line))&#123; //按行读取文件，input当成输入流cin处理就行 svec.push_back(line); &#125;*/ string word; while(input&gt;&gt;word)&#123; //按单词读取文件，input当成输入流cin处理就行 svec.push_back(word); &#125; &#125;else&#123; cout&lt;&lt;"couldn't open: " + filename&lt;&lt;endl; &#125; input.close();&#125;void writefile(string filename,const vector&lt;string&gt;&amp; svec)&#123; //从文件中读取数据到svec中 ofstream out; //ofstream向一个给定文件写入数据 out.open(filename,ofstream::app); //不清空文件，末尾追加写入 if(out)&#123; for(auto word : svec)&#123; out&lt;&lt;word&lt;&lt;endl; //输出流，也就将word写入到文件中 &#125; &#125;else&#123; cout&lt;&lt;"couldn't open: " + filename&lt;&lt;endl; &#125; out.close();&#125;int main()&#123; string filename = "STRING.txt"; vector&lt;string&gt; svec; readfile(filename,svec); for(auto line : svec)&#123; cout&lt;&lt;line&lt;&lt;endl; &#125; //从svec写入数据到文件中 filename = "WRITE.txt"; writefile(filename,svec); return 0;&#125; 文件模式每个流都有一个关联的文件模式（mode），用来指出如何使用文件。具体的mode有哪些呢？123456in 以读方式打开out 以写方式打开app 每次写操作前均定位到文件末尾（从文件尾开始写，不覆盖前面写的）ate 打开文件后立即定位到文件末尾trunc 截断文件binary 以二进制方式进行IO 不管用哪种方式打开文件，我们都可以指定文件模式，调用open显式打开或者用一个文件名初始化文件流来隐式打开文件都可指定文件模式。但是上述模式间有限制关系： 只可以对ifstream和ifstream对象设定in模式 只可以对ofstream和fstream对象设定out模式 只有当out被设定时才能设定trunc模式 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式打开 默认情况下，即使我们没有指定trunc模式，以out模式打开的文件也会被截断。为了保留以out模式打开的文件内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。 每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开，与ofstream关联的文件默认以out模式打开，与fstream关联的文件默认以in和out模式打开。 此外，有两点需要特别注意： 1：以out模式打开文件会丢弃已有数据 默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止清空文件的方法是同时指定app模式。 1234567// 这三条语句中，file都将被截断ofstream out("file"); // 隐含以输出模式打开文件并截断文件ofstream out("file",ofstream::out); // 隐含地截断文件ofstream out("file",ofstream::out|ofstream::trunc); //这两条语句中，文件内容将被保存ofstream out("file",ofstream::app); //隐含为输出模式ofstream app("file",ofstream::out|ofstream::app); 小结：保留被ofstream打开的文件中内容的唯一方法是显示指定app或in模式。 2 ：每次调用open时都会确定文件模式 对于一个给个流，每当打开文件时，都可以改变其文件模式。 12345ofstream out; // 未指定文件打开模式out.open("file"); // 隐含设置为输出和截断out.close(); // 与out绑定的名为file的文件被关闭，以便我们将对象out用于其他文件out.open("preFile",ofstream::app); //模式为输出和文件尾追加out.close(); 名为file的文件内容将被清空，名为preFile的文件中已有的数据将都被保存。 小结：每次打开文件时，都要设置文件模式，可以是显式的设置，也可以是隐式的设置。当文件未指定模式时，都是使用默认值。 String流sstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。 istringstream从string读取数据，ostreamstream向string写入数据，而头文件stringstream既可以读数据也可向string写数据。 头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。 12345stringstream特有的操作sstream strm； strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型sstream strm(s); strm是一个sstream对象，保存strings的一个拷贝。此构造函数是explicit的strm.str（） 返回strm所保存的string类型strm.str(s) 将string的s拷贝到strm中，返回void 使用istringstream当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的某个单词时，通常可以使用istringstream。 考虑如下文件，列出了一些人和他们的电话号码（电话号码多选）123morgan 20155555 685522drew 5524566lee 425422 542122 55444222 我们定义一个简单的类来描述输入数据： 1234struct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125; 我们从文本中读入输入数据，并将输入数据写入到vector容器中： 以下是完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace std;//成员默认公有struct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125;;int main()&#123; string filename = "Info.txt"; ifstream input; //从文件中读取数据 vector&lt;PersonInfo&gt; Pvec; input.open(filename); if(input)&#123; string line; string phone; while(getline(input,line))&#123; PersonInfo info; istringstream record(line); //将记录绑定到刚读入的行 record&gt;&gt;info.name; //读取名字 while(record&gt;&gt;phone)&#123; //读取电话号码 info.phones.push_back(phone); &#125; Pvec.push_back(info); //将记录追加到people末尾 &#125; &#125;else&#123; cout&lt;&lt;"couldn't not open file"&lt;&lt;endl; &#125; input.close(); for(auto people : Pvec)&#123; //输出 cout&lt;&lt;people.name; for(auto phone : people.phones)&#123; cout&lt;&lt;" "&lt;&lt;phone; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 使用ostringstream当我们逐步构造输出，希望最后一起打印是，ostringstream是很有用的。 12345ostringstream badNums;string num = "123";string name = "xin";badNums&lt;&lt;num&lt;&lt;name; //将数的字符串的形式存入badNumscout&lt;&lt;badNums.str()&lt;&lt;endl; //输出123xin 输出badNums.str()!]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>I/O流</tag>
        <tag>string流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的基本概念]]></title>
    <url>%2F2017%2F10%2F22%2F%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[一、前言介绍一些类的基本概念，包括类的基本思想，函数成员和数据成员，static成员，友元等。 类类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。 定义成员函数尽管所有成员函数都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。 Sales_data的一个成员函数 1string isbn() const &#123; return bookNo;&#125; 引入this指针12Sales_data total;total.isbn(); 在这里，使用点运算符来访问total对象的isbn成员，然后再调用它。 当我们调用成员函数时，实际上是在替某个对象调用它。它隐式地指向调用该函数的对象的成员。实际上隐式地返回 total.bookNo。 成员函数通过一个名为this的额外参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。 1total.isbn() 相当于： 12//伪代码，用于说明调用成员函数的实际执行过程Sales_data::isbn(&amp;total) 其中调用Sales_data的isbn成员时传入了total地址。 this是一个常量指针，我们不允许改变。 引入const成员函数默认情况下，this的类型是指向类类型非常量版本的常量指针。意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使我们不能在一个常量对象上调用普通的成员函数。 C++允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针（const Sales_data const this）。*像这样使用const的成员函数被称作常量成员函数。 因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内存。 常量对象、以及常量对象的引用或指针都只能调用常量成员函数。 ，非常量对象可以调用常量成员函数。 类作用域和成员函数编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。 因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。 类外部定义的成员的名字必须包含它所属的类名。 定义类相关的非成员函数一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。 点运算符和箭头运算符（. -&gt;)123Person p1 ,*p2;p1.getname(); //针对于对象来使用的p2-&gt;getname(); //针对于指针来使用的，等价于*p2.getname(); 构造函数类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。 构造函数不能被声明成const。 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。 知识点1：构造函数—特殊的成员函数，用来控制对象的初始化过程。无返回类型，可重载，不能被声明为const. 知识点2：若无，则有默认的构造函数，是编译器自己隐式的定义的。又称合成的默认构造函数。 知识点3：某些类是不能使用默认的构造函数的，以下三个原因： 1：在未声明任何构造函数的前提下，类内对象的初始化将不受控制 2：合成的默认构造函数可能会造成不必要的错误，如若没有类内初始值来初始化成员，可能这些成员将是未定义的。 3：如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该对象。 所以，在撰写类的时候，最好定义一个自己的构造函数。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person; //前向声明Person类istream&amp; read(istream&amp; is,Person&amp; person); //声明read函数class Person&#123;public: Person() = default; //默认构造函数 等价于Person()&#123;&#125;; Person(string name,string address); //重载构造函数 Person(istream &amp;is)&#123; //重载构造函数，通过调用非成员函数read对其进行赋值 read(is,*this); &#125; void show(); const string&amp; getname()&#123; return this-&gt;name; &#125; const string&amp; getaddress()&#123; return this-&gt;address; &#125; void setname(string name)&#123; this-&gt;name = name; &#125; void setaddress(string address)&#123; this-&gt;address = address; &#125; Person&amp; combine(const Person &amp;person);private: string name; string address;&#125;;void Person::show()&#123; cout&lt;&lt;"name:"&lt;&lt;this-&gt;name&lt;&lt;" address:"&lt;&lt;this-&gt;address&lt;&lt;endl;&#125;Person::Person(string name,string address):name(name),address(address)&#123;&#125;Person&amp; Person::combine(const Person &amp;person)&#123; name += person.name; return *this;&#125;istream&amp; read(istream&amp; is,Person&amp; person)&#123; //非成员函数 string name ,address; is&gt;&gt;name&gt;&gt;address; person.setname(name); person.setaddress(address); return is;&#125;int main()&#123; Person p1("wangxinri","cqu"); p1.show(); Person p2("ri","cqu"); p1.combine(p2); p1.show(); cout&lt;&lt;p2.getname()&lt;&lt;endl; cout&lt;&lt;p2.getaddress()&lt;&lt;endl; Person p3(cin); p3.show(); return 0;&#125; 拷贝、赋值和析构如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。 对于某些类来说合成的版本无法正常工作，管理动态内存的类通常不能依赖于上述操作的合成版本。 使用vector或者string的类能避免分配和释放内存带来的复杂性。如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。 类的静态成员有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。例如，一个银行账号类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。 声明静态成员我们通过在成员的声明之前加上关键字static使得其与类关联在一起，和其他成员一样，静态成员可以使public得或private的。静态数据成员的类型可以使常量、引用、指针、类类型等。 举个例子，我们定义一个类，用它表示银行的账户记录： 1234567891011class Account&#123;public: void calculate() &#123;amount+=amount*interestRate;&#125; static double rate() &#123;return interestRate;&#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。 因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。 类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的（const是用来修饰this指针类型的），而且我们也不能在static函数体内使用this指针，这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。静态成员函数不可以同时声明为 virtual、const、volatile函数。 12345class base&#123; virtual static void func1();//错误 static void func2() const;//错误 static void func3() volatile;//错误 &#125;; 使用类的静态成员我们使用作用域运算符直接访问静态成员：12double r;r=Account::rate(); //使用作用域运算符访问静态成员 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针类访问静态成员：12345Account ac1;Account *ac2=&amp;ac1;//调用静态成员函数rate的等价形式r=ac1.rate(); //通过Account的对象或引用r=ac2-&gt;rate(); //通过指向Account对象的指针 成员函数不用通过作用域运算符就能直接使用静态成员。 123456class Account&#123;public: void calculate() &#123;amount+=amount*interestRate;&#125;private: static double interestRate;&#125;; 定义静态成员和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：1234void Account::rate(double newRate)&#123; interestRate=newRate;&#125; 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态数据成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。 类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在于程序的整个生命周期中。 我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字： 12//定义并初始化一个静态成员double Account::interestRate=initRate(); 这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以直接使用initRate函数。注意，虽然initRate是私有的，我们也能使用它初始化interestRate。和其他成员的定义一样，interestRate的定义也可以访问类的私有成员。 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一文件中。 静态成员的类内初始化（一般来讲，我们在类的外部定义和初始化）通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适用于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员执行数组成员的维度： 12345678class Account&#123;public: static double rate() &#123; return interestRate;&#125; static void rate(double);private: static constexpr int period=30; double daily_tbl[period]; //period是常量表达式&#125;; 如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了： 12//一个不带初始值的静态成员的定义constexpr int Account::period; //初始值在类的定义内提供 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态成员能用于某些场景，而普遍成员不能如我们所见，静态成员独立于任何对象。因为，在某些非静态数据成员可能非法的场合，静态 成员却可以正常地使用。举个例子，静态数据成员可以是不完全类型。特别地，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。 12345678class Bar&#123;public: //......private: static Bar mem1; //正确：静态成员可以是不完全类型 Bar *mem2; //正确：指针成员可以使不完全类型 Bar mem3; //错误：数据成员必须是完全类型&#125;; 静态成员和普通成员的另一个区别是我们可以使用静态成员作为默认实参： 1234567class Screen&#123;public: //bkground 不是一个在类中稍后定义的静态成员 Screen &amp;clear(char =bkground);private: static const char bkground;&#125;; 非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以从中获取成员的值，最终引发错误。 简单代码示例1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Account&#123;public: static double rate() &#123; return interestRate; &#125; static void rate(double Rate);private: string owner; static double interestRate ; static const int aa = 0; //正确 static constexpr int bb = 0; //正确，constexpr类型可以类内初始化 //static double cc = 0; //错误&#125;;//外层定义static成员不需要加上staticdouble Account::interestRate = 1.0; //定义并初始化一个成员void Account::rate(double Rate)&#123; interestRate = Rate;&#125;int main()&#123; Account a1,a2; cout&lt;&lt;a1.rate()&lt;&lt;" "&lt;&lt;a2.rate()&lt;&lt;endl; a1.rate(2.0); cout&lt;&lt;a1.rate()&lt;&lt;" "&lt;&lt;a2.rate()&lt;&lt;endl; return 0;&#125; 友元（friend）友元：类允许其他类或者函数访问其非公有成员，方法是令其他类或者函数成为它的友元（friend)。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。 友元函数只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员函数也不受它所在区域访问控制级别的约束。 一般来说，最好在类定义开始或者结束前的位置集中声明友元。 友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 友元再探类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数时隐式内联的。 类之间的友元关系12345class Screen&#123; //Window_megr的成员可以访问Screen类的私有部分。 friend class Window_megr; 把Window_megr指定成Screen的友元 //Screen类的剩余部分&#125; 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 必须注意的是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元并不能理所当然地具有访问Screen的特权。 令成员函数作为友元除了令整个Window_mgr作为友元之外，Screen还可以只为Window_mgr成员函数clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类： 12345class Screen&#123; //Window_mgr::clear必须在Screen类之前被声明 friend void Window_mgr::clear(ScreenIndex); //Screen类的剩余部分&#125;; 要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序： 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明 最后定义clear，此时它才可以使用Screen的成员。 函数重载和友元尽管重载函数的名字相同，但他们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明： 1234567//重载的storeOn函数extern ostream&amp; storeOn(ostream＆ ,Screen &amp;);extern BitMap &amp;storeOn(BitMap&amp; ,Screen &amp;);class Screen&#123; //StoreOnde ostream版本能访问Screen对象的私有部分 friend ostream::ostream&amp; storeOn(ostream&amp; ,Screen);&#125;; Screen类把接受ostream&amp;的storeOn函数声明成它的友元，但是接受BitMap&amp;作为参数的版本仍然不能访问Screen。 友元声明和作用域类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。 换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的： 123456789struct X&#123; friend void f() &#123; /*友元函数可以定义在类的内部*/&#125; X() &#123;f();&#125; //错误：f还没有被声明 void g(); void h();&#125;;void X::g()&#123;return f();&#125; //错误：f还没有被声明void f(); //声明那个定义在X中的函数void X::h() &#123;return f();&#125; //正确：现在f的声明在作用域中了 关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。 简单友元类示例1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class student&#123;friend class teacher;public: void show_info()&#123; cout&lt;&lt;"name:"&lt;&lt;name&lt;&lt;" address"&lt;&lt;endl; &#125;private: string name = "xin"; string address = "cqu";&#125;;class teacher&#123;public: void show_info()&#123; cout&lt;&lt;"name:"&lt;&lt;name&lt;&lt;" address"&lt;&lt;endl; &#125; void showStudent(student &amp;STD);private: string name; string address;&#125;;void teacher::showStudent(student &amp;STD)&#123; cout&lt;&lt;STD.name&lt;&lt;" "&lt;&lt;STD.address&lt;&lt;endl;&#125;int main()&#123; student STD; STD.show_info(); teacher TEA; TEA.showStudent(STD); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>static成员</tag>
        <tag>C++</tag>
        <tag>类定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数基础]]></title>
    <url>%2F2017%2F10%2F19%2F%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[函数基础一个典型的函数定义包括以下部分：返回类型、函数名、由0个或多个形参组成的列表以及函数体。 函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。 形参和实参函数有几个形参，我们就必须提供相同数量的实参。 局部对象形参和函数体内部定义的变量（含｛｝块域）统称为局部变量。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。 自动对象对于普通局部变量对应的对象来说, 当函数的控制路径经过变量定义语句时创建该对象, 当到达定义所在的块末尾时销毁它. 我们把只存在于块执行期间的对象称为自动对象, 当块的执行结束后, 块中创建的自动对象的值就变成未定义的了. 形参是一种自动对象, 函数开始时候为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以函数终止, 形参被销毁. 对于局部变量对应的自动对象来说, 分两种情况：如果变量定义本身含初始值, 就用这个初始值初始化;否则, 如果变量定义本身不含初始值, 执行默认初始化.意味着内置类型的未初始化局部变量将产生未定义的值. 局部静态对象当有些时候, 有必要令局部变量的生命周期贯穿函数调用及之后的时间,可以将局部变量定义为static 类型, 局部静态变量在程序执行路径第一次经过对象定义语句时候初始化,并直到程序终止才被销毁。 123456789101112size_t count_calls()&#123; static size_t ctr=0; eturn ++ctr;&#125;int main()&#123; for(size_t i=0; i!=10; i++) cout&lt;&lt; count_calls() &lt;&lt; endl; return 0;&#125; 在控制流第一次经过ctr的定义之前, ctr被创建且初始化为0; 每次调用ctr加1. 每次执行函数, 变量ctr的值已经存在并等于函数上一次退出的时候的值。 函数声明函数只能定义一次，但可以声明多次。（有例外），如果一个函数永远不可能给我们用到，那他可以只有声明没有定义。 函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息，函数声明也称作函数原型。 best practices: 在头文件中进行函数声明，含有函数声明的头文件应该包含到定义函数的源文件中。 分离式编译分离式编译，C++允许我们将程序分割到几个文件中去，每个文件独立编译。 简单的示例： 目录树： source facc.cpp main.cpp header myHead.h 12345678910111213141516171819202122232425262728//facc.cpp#include &lt;iostream&gt;#include "MyHead.h" //定义fac函数，肯定要包含其声明using namespace std;int fac(int n)&#123; if (n==1)&#123; return 1; &#125;else &#123; return n*fac(n-1); &#125;&#125;//main.cpp#include &lt;iostream&gt;#include "MyHead.h" //使用fac，肯定也要包含其声明using namespace std;int main()&#123; cout&lt;&lt;fac(5)&lt;&lt;endl; return 0;&#125;//myHead.h //头文件中只有函数的声明#ifndef MYHEAD_H_INCLUDED#define MYHEAD_H_INCLUDEDint fac(int n); #endif // MYHEAD_H_INCLUDED const形参和实参实参初始化形参会忽略掉顶层const，也就是当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。 我们可以使用非常量初始化底层const，但是反过来不行。 数组形参数组的两个特殊点： 不允许拷贝数组，所以不可以使用传值的方式使用数组参数(传值即为拷贝)。 通常数组的传递使用的是指针形式，传递的是指针的首地址。 尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式： 12345//尽管形式不同，但这三个print函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10]) //这里的维度表示我们期望数组含有多少元素，实际不一定 当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型： 1234int i = 2;int j[2] = &#123;1,2&#125;;print(&amp;i); //正确，&amp;i的类型是int*print(j); //正确，j被转换成int*并指向j[0] 如果我们传给print函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。 由于数组实际上是以指针的形式传递给函数的，因此一开始函数并不知道数组的确切尺寸，调用者应该为此提供额外的一些信息。 管理指针形参有三种常用的技术： 1.使用标记指定数组长度 这种方法要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符就停止： 12345678void print(const char *cp)&#123; if(cp)&#123; //若cp不是空指针 while(*cp)&#123; //只要指针所指字符不是空字符 cout&lt;&lt;*cp++; //输出当前字符并将指针前移 &#125; &#125;&#125; 这个方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。 2.显示传递一个表示数组大小的形参 这种方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。 12345678//const int ia[]等价于const int *ia//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问void print(const int ia[],size_t size)&#123; for(size_t i = 0; i != size; ++i)&#123; cout&lt;&lt;ia[i]&lt;&lt;" "; &#125;&#125; 这种方法通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值：12int j[] = &#123;1,2,3&#125;;print(j,3); 3.使用标准库函数begin和end C++11标准引入两个名为begin和end的函数，begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一位置的指针，这两个函数定义在iterator头文件中。示例代码如下：123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3,4,5,6,7,8,9,-1,5,3,4&#125;; int *pbeg = begin(arr); //指向arr首元素的指针 int *pend = end(arr); //指向arr尾元素的指针 //寻找第一个负值元素，如果已经检查完全部元素则结束循环 while(pbeg != pend &amp;&amp; *pbeg &gt;= 0)&#123; ++pbeg; &#125; cout&lt;&lt;*pbeg&lt;&lt;endl; //输出第一个负数的值&#125; 对于本文的print函数，可以写成如下形式: 123456void print(const int *beg, const int *end)&#123; //输出beg到end之间（不含end）的所有元素 while(beg != end) cout&lt;&lt;*beg++&lt;&lt;" ";&#125; 为了调用这两个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。使用方法如下：12int a[] = &#123;1,2,3&#125;;print(begin(j),end(j)); 数组形参和const当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。 数组引用形参形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上： 12345void print(int (&amp;arr)[10]) &#123; for(auto elem : arr)&#123; cout&lt;&lt;elem&lt;&lt;endl; &#125;&#125; 注意：12f(int &amp;arr[10])//错误,将arr声明为引用的数组f(int (&amp;arr)[10])//正确, arr是有10个整形的数组引用 传递多维数组和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是指向数组的指针，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分, 不能省略: 1234//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组void print(int (*matrix)[10], int rowsize)&#123;...&#125;//等价于void print(int matrix[][10], int rowsize)&#123;...&#125; 我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。 main: 处理命令行选项C/C++语言中的main函数，经常带有参数argc，argv，如下： 12int main(int argc, char** argv)int main(int argc, char* argv[]) 第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。 下面的程序演示argc和argv的使用： 1234567891011#include &lt;iostream&gt;using namespace std;int main(int argc,char *argv[])&#123; int i; for (i=0; i &lt; argc; i++) &#123; cout&lt;&lt;"Argument "&lt;&lt;i&lt;&lt;" is "&lt;&lt;argv[i]&lt;&lt;endl; &#125; return 0;&#125; 假如上述代码编译为hello.exe，那么运行hello.exe a b c d e 将得到 Argument 0 is hello.exe. Argument 1 is a. Argument 2 is b. Argument 3 is c. Argument 4 is d. Argument 5 is e. 含有可变形参的参数（先知道有这么个东西，后面详细了解）返回函数指针函数重载（重点，待完善）对于函数重载来说，形参数量或形参类型上有所不同。 不允许两个函数除了返回类型外，其他所有的要素都相同。 特殊用途语言特性默认实参知识点1：函数反复调用的过程中重复出现的形参，这样的值被称为默认实参。该参数在使用过程中可以被用户指定，也可以使用默认数值 知识点2：调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。 知识点3：一旦某个形参被赋予了默认值，其后所有形参都必须有默认值。 知识点4：顺序很重要！在设计函数时，将默认值的形参放在后面。 知识点5：在给定的作用域中，一个形参只能被赋予一次默认实参，且局部变量不能作为默认实参。 内联函数（inline）调用函数函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。 内联函数可以避免函数调用的开销。 将函数指定为“内联函数(inline)”，将它在每个调用点上“内联的展开”，该说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。一般来说，内联的机制用于优化规模较小、流程直接、频繁调用的函数，建议不大于75行。 constexpr函数constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。 12constexpr int new_sz()&#123; return 42;&#125;constexpr int foo = new_sz(); //正确：foo是一个常量表达式 constexpr函数不一定返回常量表达式 程序的调试帮助：assert和NDEBUG知识点1：预处理宏assert(expr)：包含一个表达式，expr为真时，assert什么也不做，为假时输出信息并终止程序。包含在cassert头文件中。通常用于检查不能发生的条件 知识点2：assert依赖于一个NDEBUG的预处理变量的状态，如果定义了NDEBUG，assert什么也不做，默认状态下NDEBUG是未定义的。编译器也可以预先定义该变量。 知识点3：也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef到#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略。 1234567void pp() &#123; #ifndef NDEBUG cerr&lt;&lt;"my name is:"&lt;&lt;__func__&lt;&lt;endl; #endif //其他代码 &#125; 一些C++编译器定义的调试有用的名字： _ func _ :一个静态数组，存放函数的名字 _ FILE _ :存放文件名的字符串字面值 _ LINE _ :存放当前行号的整形字面值 _ TIME _ :存放文件编译时间的字符串字面值 _ DATE _ :存放文件编译日期的字符串字面值 函数匹配 首先确定候选函数：候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。 接着选出可行函数：可行函数具备两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。 如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。 如果没有找到可行函数，编译器将报告无匹配函数的错误。 3.寻找最佳匹配：它的基本思想是，实参类型与形参类型越接近，他们匹配得越好。 编译器一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功： 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 至少有一个实参的匹配优于其他可行函数提供的匹配。 如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。 函数指针函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：1bool lengthCompare(const string &amp;,const string &amp;); 该函数的类型是bool(const string&amp;,const string&amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。 12//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型bool (*pf) const string&amp; ,const string &amp;); //未初始化 从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 注意： *pf两端的括号必不可少。 知识点2：当我们把函数名当作一个值使用时，函数自动的转换为指针，直接赋予或者取址皆可。可以直接使用只想该函数的指针调用该函数。 知识点3：给指针赋予nullptr或者0时，指针不指向任何函数。 知识点4：函数重载时，指针的类型必须与重载函数精确匹配，包括形参类型数量和返回值类型。 知识点5：虽然不能返回一个函数，但是可以返回一个指向函数的指针。 返回指向函数的指针1int (*f1(int)) (int *,int) 我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int. 出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。 1auto f1(int) -&gt; int (*)(int *,int); 例子12345678910111213141516171819202122#include &lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; int add(int a, int b) &#123; return a+b; &#125; int subtract(int a, int b) &#123; return a - b; &#125; int multiply(int a, int b) &#123; return a * b; &#125; int divide(int a, int b) &#123; return b != 0 ? a / b : 0; &#125;//声明定义函数 int main(int argc, char** argv) &#123; typedef int(*p)(int a, int b); //声明函数指针，未初始化,p为指向函数的指针。使用typedef的声明语句定义的不再是变量而是类型别名 //就是将变量转化为类型别名的一种方式，p原来是指向函数的指针变量，现在变成了指向函数的指针变量的类型别名 vector&lt;p&gt; vec&#123;add, subtract, multiply, divide&#125;;//vector初始化的C++11新特性 for (auto f : vec) cout &lt;&lt; f(2, 2) &lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try语句块和异常处理]]></title>
    <url>%2F2017%2F10%2F15%2Ftry%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、前言简单介绍try语句块和异常处理。 异常异常处理机制为程序中异常检测和异常处理这两部分的协作提供了支持。在C++语言中，异常处理包括： throw表达式（throw expression），异常检测部分使用throw表达式来表示它遇到的了无法处理的问题，我们说throw引发了异常。 try语句块（try block）,异常处理部分使用try语句处理异常。try语句块以关键字try开始，并以一个或多个catch字句结束。try语句块中代码抛出的异常通常会被某个catch字句处理。因为catch字句”处理“异常，所以它们也被称作异常处理代码。 一套异常类（exception class），用于在throw表达式和相关的catch字句之间传递异常具体信息。 throw表达式程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。 try语句块1234567try&#123; program-staments&#125;catch(exception-declaration)&#123; handler-staments&#125;catch(exception-declaration)&#123; handler-staments&#125; ... 代码示例12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stdexcept&gt; //标准异常库using namespace std;int main()&#123; int a,b; cout&lt;&lt;&quot;请输入相除的两个整数：&quot;; while(cin&gt;&gt;a&gt;&gt;b) &#123; try &#123; if (b == 0) throw std::runtime_error(&quot;被除数不能为0&quot;);//runtime_error异常类:只有在运行时才能检测出的问题 cout&lt;&lt;static_cast&lt;double&gt;(a)/b&lt;&lt;endl;//考虑到不可以整除产生小数的情况,先将a强制转化为double类型 &#125; catch (runtime_error err)//err是runtime_error类的一个实例 &#123; cout &lt;&lt; err.what() ; //实例的成员函数，返回内容由编译其决定 cout &lt;&lt; &quot;\n是否需要重新输入? Enter y or n:&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (!cin || c == &apos;n&apos;) break;//break只能用在开关体或者循环体中 &#125;//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理 //如果没有catch部分，仅有try，仍然会报错 cout&lt;&lt;&quot;请输入相除的两个整数：&quot;; &#125; return 0 ;&#125; 输出结果： 请输入相除的两个整数：2 4 0.5 请输入相除的两个整数：2 0 被除数不能为0 是否需要重新输入? n 简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理，如果没有catch部分，仅有try，仍然会报错。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式基础]]></title>
    <url>%2F2017%2F10%2F14%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、前言介绍C++中常见的表达式。 基础概念组合运算符和运算对象对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级、结合律以及运算对象的求值顺序。 重载运算符左值和右值左值可以位于赋值语句的左侧、右值则不能。 当一个对象被用于右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的为止）。 求值顺序（重点）优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。 1int i = f1()*f2(); 我们是无法知道到底f1在f2之前调用还是f2在f1之前调用。 对于那些没有指定执行顺序的运算符来讲，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，比如： 12int i = 0;cout&lt;&lt;i&lt;&lt;" "&lt;&lt;++i&lt;&lt;endl; 表达是的行为不可预知，编译器执行i或者++i的顺序是未知的。 以下4中运算符明确规定了运算对象的求值顺序：&amp;&amp;(逻辑与) ||(逻辑或) ?:(条件运算符) ,(逗号运算符)。 求值顺序、优先级、结合律运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中： 优先级规定，g()的返回值和h()的返回值相乘。 结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。 对于这些函数的调用顺序没有明确规定。 如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。 建议： 处理复合表达式以下两条经验准则对书写复合表达式有益： 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。 算术运算符%运算符如果m%n不等于0，则它的符号和m相同。 m%(-n) 等于 m%n (-m)%n 等于 -(m%n) -21 % -8 = -5 21 % -5 = 1 逻辑和关系运算符逻辑与(&amp;&amp;)和逻辑或(||) 都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 短路求值。 text是存储这string对象的vector，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。123456789//s是对常量的引用；元素既没有被拷贝也不会被改变for(const auto &amp;s : text) &#123; cout&lt;&lt;s; if(s.empty()||s[s.size()-1] == '.')&#123; cout&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;" "; &#125;&#125; 值得注意的是，s被声明成对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以声明成对常量的引用。 优先级注意 算数运算符&gt;关系运算符&gt;逻辑运算符 赋值运算符满足右结合律赋值运算符满足右结合律，这一点与其他二元运算符不太一样。 12int ival,jval;ival = jval = 0; //正确，都被赋值为0 因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0作为靠左的赋值运算符的右侧运算对象。又因为赋值运算符返回的是其左侧运算对象，所以靠右的赋值运算的结果（jval=2返回的结果为左侧运算对象jval）被赋给了ival。1cout&lt;&lt;(jval = 2)&lt;&lt;endl; // 输出2 赋值运算符优先级较低12345int i ;//一种很好的写法while((i=get_value()) != 42) &#123; //其他处理&#125; 注意： 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。 递增和递减运算符递增和递减有两种形式：前置版本和后置版本。 123int i =0,j;j = ++i; //j = 1,i = 1; 前置版本得到递增之后的值j = i++; //j = 1,i = 2; 后置版本得到递增之前的值 区别：前置版本将对象本身作为左值返回，后置版本则将对象的原始副本作为右值返回。 建议：除非必须，否则不用递增递减运算符的后置版本 有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。 对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。 混用解引用和递增运算符12//推荐写法cout&lt;&lt;*iter++&lt;&lt;endl; //等价于*(iter++) 后置运算符的优先级高于解引用运算符。 1vec[ival++] &lt;= vec[ival]; //未定义的错误，先求左侧的值还是先求右侧的值不确定 成员访问运算符点运算符和箭头运算符都可用与访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr-&gt;men等价于(*ptr)mem : 1234string s1 = "a string", *p = &amp;s1;auto n = s1.size(); n = (*p).size(); //运行p所指对象的size成员n = p-&gt;size(); //等价于(*p).size() 注意：解引用运算符的优先级低于点运算符。 1*p.size() // 错误，p是一个指针，它没有名为size的成员 条件运算符优先级 条件运算符优先级高于赋值、逗号运算符，低于其他运算符。 例如：123m&lt;n ? x : a+3 等价于：(m&lt;n) ?(x) :(a+3)a++&gt;=10 &amp;&amp; b--&gt;20 ? a : b 等价于：(a++&gt;=10 &amp;&amp; b--&gt;20) ? a : bx=3+a&gt;5 ? 100 : 200 等价于：x= (( 3+a&gt;5 ) ? 100 : 200 ) 结合性 条件运算符具有右结合性。 当一个表达式中出现多个条件运算符时，应该将位于最右边的问号与离它最近的冒号配对，并按这一原则正确区分各条件运算符的运算对象。 例如： w&lt;x ? x+w : x&lt;y ? x : y 与 w&lt;x ? x+w : ( x&lt;y ? x : y) 等价 与 (w&lt;x ? x+w : x&lt;y) ? x : y 不等价 注意： 随着条件运算嵌套的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。 位运算符（基础，待补充）一个使用位运算符的例子 假设一个班级有30个学生,我们用一个二进制位来代表某个学生在依次测试中是否通过，显然全班的测试结果可以用一个无符号整数来表示： 1unsigned long quizl = 0 ; //我们把这个值当成是位的集合来使用 将quizl类型定义位unsigned long，这样，quizl在任何机器上都将至少拥有32位；给quizl赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。 1234567//1UL是一个unsigned long类型的整数字面值1//1UL&lt;&lt;27; 生成一个值，该值只有第27位为1quizl |= 1UL&lt;&lt;27; //表示学生27通过了测试quizl &amp;= ~(1UL&lt;&lt;27); //学生27未通过测试bool status = quizl &amp; (1UL&lt;&lt;27); //学生27是否通过了测试？ sizeofsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得到的值是一个size_t类型的常量表达式。 sizeof的三种语法形式： 123sizeof(object); //sizeof(对象);sizeof(type_name); //sizeof(类型);sizeof object; //sizeof对象; 12345int i;sizeof(i); //oksizeof i; //oksizeof(int); //oksizeof int; //error 既然写法3可以用写法1代替，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。 1sizeof(*p); //指针所占的空间大小，与指针指向的类型无关 sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针也不会有什么影响，在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。 C++11新标准允许我们使用作用域来获取成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象。因为要想知道类成员的大小无须真的获取该成员。 sizeof运算符的结果部分地依赖于其作用的类型： 对char或者类型为char的表达式指向sizeof运算，结果为1； 对引用类型执行sizeof运算得到被引用对象所占空间的大小； 对指针指向sizeof运算得到指针本身所占空间的大小； 对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效。 对数组执行sizeof运算限制得到整个数组所占空间的大小，等价于对数组这所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数： 123// sizeof(ia)/sizeof(*ia)返回ia的元素数量 constexpr size_t sz = sizeof(ia)/sizeof(*ia); int arr2[sz]; // 正确：sizeof返回一个常量表达式 因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组&指针&string]]></title>
    <url>%2F2017%2F10%2F14%2F%E6%95%B0%E7%BB%84%26%E6%8C%87%E9%92%88%26string%2F</url>
    <content type="text"><![CDATA[一、前言介绍使用数组的基本方法，同时介绍C++中string的初始化和一些常用函数。 数组数组与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是相对地也损失了一些灵活性。 note： 如果不清楚元素的确切个数，请使用vector。 定义和初始化内置数组数组是一种复合类型，数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。 123456unsigned cnt = 42; //不是常量表达式constexpr unsigned sz = 42; //常量表达式int arr[10]; //含有10个整型的数组int *parr[sz]; //含有42个整型指针的数组string bad[cnt]; //错误：cnt不是常量表达式string strs[get_size()]; //当gett_size是constexpr时正确；否则错误 默认情况下，数组的元素被默认初始化。另外数组的元素应为对象，因此不存在引用的数组。 显式初始化数组元素可以对数组的元素进行列表初始化，此时允许忽略数组的纬度。 123456const unsigned sz = 3;int ial[sz] = &#123;0,1,2&#125;; //含有三个元素的数组，元素值分别是０１２int a2[] = &#123;0 ,1 , 2&#125;; //维度是３的数组int a3[5] = &#123;0,1,2&#125;; // 等价于&#123;0,1,2,0,0&#125;string a4[3] = &#123;“hi” , “bye”&#125;; //&#123;“hi”,”bye” ,”“&#125;int a5[2] = &#123;0,1,2&#125; //错误， 初始值太多 字符数组的特殊性（用字符串字面值对数组进行初始化）字符数组可以用字符串字面值初始化，但是特殊的是结束符（’\0’）也会被拷贝进去1234char a1[] = &#123;‘C’,’+’ ,’+’&#125;; //列表初始化没有空字符char a2[] = &#123;‘C’,’+’,‘+’,’\0’&#125;; //列表初始化，含有显示的空字符char a3[] = “C++”; //自动添加表示字符串结束的空字符const char a4[6] =”Daniel”; //错了，没有空间可以存放空字符 a4数组的大小必须至少是7。 数组不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： 123int a[] = &#123;0,1,2&#125;;int a2[] = a; //错误：不允许使用一个数组初始化另一个数组a2 = a; //错误：不能把一个数组直接赋值给另一个数组 理解复杂的数组声明可以定义一个存放指针的数组。又因为数组本身是对象，所以允许定义数组的指针（指向数组的指针）及数组的引用（对数组的引用）。 1234//[]的优先级比*高int *ptrs[10]; //ptrs是含有10个整型指针的数组int (*Parray)[10] = &amp;arr; //Parray指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组 默认情况下，类型修饰符从右向左一次绑定， 对于ptrs来说，首先知道我们定义了一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 Parray的含义：首先*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。最终，Parray是一个指针，它指向一个int数组，数组中包含10个元素。 当然，对修饰符的数量并没有特殊限制： 1int *(&amp;array)[10] = ptrs; //array是数组的引用，该数组含有10个指针 访问数组元素数组的元素也能使用范围for语句或下标运算符来访问。 当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。 123for(auto i : scores) &#123; cout&lt;&lt;i&lt;&lt;" ";&#125; 指针和数组在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。 12string nums[] = &#123;"one","two","three"&#125;; //数组的元素是string对象string *p = &amp;nums[0]; //p指向nums的第一个元素 数组的一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。 1string *p = nums; //等价于p2=&amp;nums[0]; auto 和 decltype1234int ia[] = &#123;0,1,2,3,4,5&#125;;auto ia2(ia); //ia2是一个整型指针，指向ia的第一个元素decltype(ia) ia3 = &#123;3,4,5,6,7,8&#125;; //ia3类型是由10个整数构成的数组，并对该数组进行赋值 指针也是迭代器123int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p = arr; //p指向arr的第一个元素++p; 遍历数组元素，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址： 1234int *e = &amp;arr[10]; //指向尾元素的下一位置的指针for(int *b = arr; b!=e; ++b)&#123; cout&lt;&lt;*b&lt;&lt;end; //输出arr的元素&#125; note: 尽管能计算得到尾后指针，但是这种用法极易出错，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似。 begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。 正确的使用形式：123456int ia[] = &#123;1,2,3,4,5&#125;;int *beg = begin(ia); //指向ia首元素的指针int *last = end(ia); //指向arr尾元素的下一位置的指针for(beg;beg!=last;++beg)&#123; cout&lt;&lt;*beg&lt;&lt;" ";&#125; note: 一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end()函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。 下标和指针12345678int ia[] = &#123;0,2,4,6,8&#125;; //含有5个整数的数组int i = ia[2]; //ia[2]得到(ia+2)所指的元素，即*(ia+2)int *p = ia;i = *(p+2); //等价于i = ia[2];只要指针指向的是数组中的元素(或者数组中尾元素的下一位置，此时下标需要为负值)，都可以执行下标运算。int *p = &amp;ia[2]; //p指向索引为2的元素int j = p[1]; //j = ia[3]int k = p[-2]; //k = ia[0] 注意： 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。 C风格字符串C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\0’）。 C风格字符字符串函数 12345\\p,p1,p2都是字符数组的形式，在string.h头文件中strlen(p) 返回p的长度，空字符不计算在内strcmp(p1,p2) 比较p1和p2的相等。如果p1==p2，返回0；如果p1&gt;p2,返回一个正值；如果p1&lt;p2，返回一个负值strcat(p1,p2) 将p2附加到p1之后，返回p1strcpy(p1,p2) 将p2拷贝给p1,返回p1 对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。 与旧代码的接口现代的C++ 程序不得不与那些充满了数组或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。 混用string对象和C风格字符串允许使用字符串字面值来初始化对象： 1string s("Hello world"); //s的内容是Hello world 更一般的情况，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代： 允许使用空字符结束的字符数组来初始化string对象或为string对象赋值。 在string对象的加法运算过程中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中匀速使用以空字符串结束的字符数组作为右侧的运算对象。 上述性质反过来就不成立，比如不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数。 123string s = "wangxinri";char *p = s ; //错误，不能用string对象直接初始化指向字符的指针const char *str = s.c_str(); //正确 我们无法保证c_str()返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效果。因此使用最好将c_str()返回的数组拷贝一份。 使用数组初始化vector对象不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象 12345int int_arr[] = &#123;0,1,2,3,4,5&#125;;vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));//拷贝三个元素：int_arr[1],int_arr[2],int_arr[3]vector&lt;int&gt; subVec(int_arr+1,int_arr4); 注意： 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。 多维数组（待补充）stringstring表示可变长的字符序列，使用string类型必须首先包含string头文件。 初始化string对象的方式123456string s1 默认初始化，s1是一个空串string s2(s1) s2是s1的副本string s2 = s1 等价于s2(s1)，s2是s1的副本string s3("value") s3是字面值"value"的副本，除了字面值最后的那个空字符外string s3 = "value" 等价于s3("value")，s3是字面值"value"的副本string s4(n, 'c') 把s4初始化为由连续n个字符c组成的串 string对象上的操作1234567891011os&lt;&lt;s 将s写到输出流os当中，返回osis&gt;&gt;s 从is中读取字符串赋给s，字符串以空白分隔，返回isgetline(is, s) 从is中读取一行赋给s，返回iss.empty() s为空赋返回true，否则返回falses.size() 返回s中的字符的个数s[n] 返回s中第n个字符的引用，位置n从0计起s1+s2 返回s1和s2连接后的结果s1=s2 用s2的副本代替s1中原来的字符s1==s2 如果s1和s2中所含的字符完全一样，则它们相等，返回trues1!=s2 如果s1和s2中所含的字符不一样，返回true&lt;, &lt;=, &gt;, &gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 代码示例12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; string str; while(cin&gt;&gt;str)&#123; cout&lt;&lt;str&lt;&lt;endl; &#125; return 0;&#125;#include&lt;iostream&gt;using namespace std;int main() &#123; string line; while(getline(cin,line))&#123; cout&lt;&lt;line&lt;&lt;endl; &#125; return 0;&#125; 处理string对象中的字符对字符处理的一些方法，在cctype头文件中定义了一组标准库函数处理这部分工作12345678910111213isalnmu(c) 当c是字母或数字为真isalpha(c) 当c是字母为真iscntrl(c) 当c是控字符时为真isdigit(c) 当c是数字为真isgraph(c) 当c不是空格但可打印为真islower(c) 当c是小写字母为真isprint(c) 当c是可打印字符为真(即c是空格或c具有可视形式)ispunct(c) 当c是标点符号为真(即c不是控字符、数字、字母、可打印空白中的一种)isspace(c) 当c是空白为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进制符中一种)issupper(c) 当c是大写字母为真isxdigit(c) 当c是十六进制数字为真tolower(c) 若c是大写字母，输出对应小写字母；否则原样输出ctoupper(c) 若c是小写字母，输出对应大写字母；否则原样输出c 处理string每个字符，使用基于范围的for语句12345678910111213141516171819202122232425262728// 用范围for语句和ispunct函数统计string对象中标点符号的个数（使用范围for语句遍历给定序列的每个元素）#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s("Hello World!!!");decltype(s.size()) punct_cnt = 0; //punct_cnt的类型同s.size()，即为string :: size_typefor (auto c : s) // 对于s中的每个字符 if (ispunct(c)) // 如果该字符是标点符号 ++ispunct_cnt; // 计数cout &lt;&lt; punct_cnt &lt;&lt; " punctuation characters in " &lt;&lt; s &lt;&lt; endl;return 0;&#125;// 用范围for语句将字符串改写为大写字母的形式（使用范围for语句改变字符串中的字符）#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s ("Hello World!!!")// 转换成大写形式for (auto &amp;c : s) // 对于s中的每个字符(c是引用) c = toupper(c); // c是一个引用，赋值语句改变了c绑定的字符的值，标准库函数toupper将小写的参数c改为大写cout &lt;&lt; s &lt;&lt; endl;return 0;&#125; 只处理string一部分字符要想访问string对象总的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。 注意：检查下标的合法性 一种简便易行的方法是：总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。 1234const string s = "keep out";for(auto &amp;c :s)&#123; //C的类型是常量引用，不能通过C修改其绑定的对象 cout&lt;&lt;c&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用&指针&const]]></title>
    <url>%2F2017%2F09%2F01%2F%E5%BC%95%E7%94%A8%26%E6%8C%87%E9%92%88%26const%2F</url>
    <content type="text"><![CDATA[本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。 引用一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 12345int a;基本数据类型 声明符（其实就是变量名）//更复杂的声明符 ----接下来的指针和引用int *b; //指针可以不初始化，没语法错误int &amp;b = a; //引用必须初始化 引用（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 123int ival = 1024;int &amp;refVal = ival; //refVal指向ival(是ival的另一个名字)int &amp;refVal2; //报错，引用必须初始化 一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用注意细节 无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。 引用本身不是对象，所以不能定义引用的引用。 引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（两种例外，一种是对常量的引用 const int &amp;） 123int &amp;refVal4 = 10; //错误，引用类型的初始值必须是一个对象double dval = 3.14;int &amp;refVal5 = dval; //错误：此处引用类型初始值必须是int型对象 代码示例12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 2; int c = 4; int &amp;b = a; //b是a的引用，即b是a的别名 //&amp;b = c; 错误,无法令引用重新绑定到另外一个对象上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = 5; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; b = 6; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = c; //将a的值改变，b的值也相应改变，但&amp;a和&amp;b还是一样的 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; b = c; //同上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; return 0;&#125; 2 2 0x28fef8 0x28fef8 5 5 0x28fef8 0x28fef8 6 6 0x28fef8 0x28fef8 4 4 0x28fef8 0x28fef8 0x28fef4 4 4 0x28fef8 0x28fef8 0x28fef4 指针指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。 指针和引用的不同点： 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&amp;）. 12int ival = 42;int *p = &amp;ival; //指针变量p存放变量ival的地址,也即p是指向变量ival的指针 注意细节 引用不是对象，没有实际地址，所有不能定义指向引用的指针。 指针的类型要和它指向的对象严格匹配(两种例外，一种是指向常量的指针)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。 指针值指针的值（即地址）应属下列4种状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值） 注意：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。 利用指针访问对象使用解引用符（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。 空指针空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法： 123int *p1 = nullptr; //等价于int *p1 = 0;int *p2 = 0; //直接将p2初始化为字面常量0int *p3 = NULL; //等价于int *p1 = 0; C++程序最好使用nullptr,同时尽量避免使用NULL。 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。 12int zero = 0 ,*p;pi = zero; // 错误：不能把int变量直接赋给指针 note:建立初始化所有指针 原因：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。 void* 指针void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解： 123double obj = 3.14, *pd = &amp;obj; // 正确：void*能存放任意类型对象的地址void *pv = &amp;obj; // obj可以是任意类型的对象pv = pd; // pv可以存放任意类型的指针 利用void指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象 代码示例1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; double obj = 3.14,*pd = &amp;obj; void *pv = &amp;obj; cout&lt;&lt;&amp;obj&lt;&lt;" "&lt;&lt;obj&lt;&lt;endl; cout&lt;&lt;&amp;pd&lt;&lt;" "&lt;&lt;pd&lt;&lt;" "&lt;&lt;*pd&lt;&lt;endl; cout&lt;&lt;&amp;pv&lt;&lt;" "&lt;&lt;pv&lt;&lt;" "&lt;&lt;endl; //不能直接操作void* 指针所指的对象，即*pv是不合法的 return 0;&#125; 0x28ff08 3.14 0x28ff04 0x28ff08 3.14 0x28ff00 0x28ff08 理解复合类型的声明修饰符（或&amp;）和变量标识符写在一起，修饰符(或者&amp;)都是修饰变量的。 1int *p1,*p2; //p1和p2都是指向int的指针 指向指针的指针指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。 通过的个数可以区分指针的级别。也就是说，表示指向指针的指针，表示指向指针的指针的指，依次类推： 12345int ival = 1024;int *pi = &amp;ival; //pi指向一个int型的数int **ppi = &amp;pi; //ppi指向一个int型的指针//解引用cout&lt;&lt;ival&lt;&lt;" "&lt;&lt;*pi&lt;&lt;" "&lt;&lt;**ppi&lt;&lt;endl; 指向指针的引用引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。 12345int i = 42;int *p; //p是一个int型指针int *&amp;r = p; //r是一个对指针p的引用, 此时r和p指针同名r = &amp;i; //r引用了一个指针，因此给r赋值&amp;i就是令指向i*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0 要理解r的类型到底是什么，最简单的方法就是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。 const限定符const定义有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字const对变量的类型加以限制： 1const int bufSize = 512; //输入缓冲区大小 这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。 123const int i = get_size(); //正确：运行时初始化const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 const类型能参与的操作：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。 默认状态下，const对象仅在文件内有效当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： 1const int bufSize = 512; //输入缓冲区大小 编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在多个文件中声明并使用它。 解决办法： 对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了： 1234//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问extern const int bufferSize = function();//file1.h头文件extern const int bufferSize; //与file1.cpp中定义的是同一个 note：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。 const引用可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 1234const int ci = 1024;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1时对常量的引用int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象 因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。 初始化和对const的引用引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。 尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式： 12345int i = 42; const int &amp;r1 = i; //允许将const int &amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确：r1是一个常量引用const int &amp;r3 = r1*2; //正确：r3是一个常量引用int &amp;r4 = r1*2; //错误：r4是一个普通的非常量y 如果int &amp;r4 = r1*2合法，那么就可以通过r4改变r1的值，而r1是常量引用。 常量引用被绑定到另外一种类型上时到底发生了什么： 12345double dval = 3.14;const int &amp;ri = dval;//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：const int temp = dval; //由双精度浮点数生成一个临时的整形常量const int &amp;ri = temp; //让ri绑定这个临时量 总结：常量引用（const &amp;）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。 对const的引用可能引用一个并非const的对象必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值： 12345int i = 42;int &amp;r1 = i; // 引用r1绑定对象iconst int &amp;r2 = i； // r2也绑定对象i，但是不允许通过r2修改i的值r1 = 0; // r1并非常量引用，i的值修改为0r2 = 0; // 错误：r2是一个常量引用 r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。 指针和const(指向常量的指针 const double *cptr)指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 123456const double pi = 3.14; //pi是一个常量，它的值不能改变double *ptr = &amp;pi; //错误，ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值double dval = 3.2;cptr = &amp;dval; //对的 注意：之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象： 12double dval = 3.14;const double *ptr = &amp;dval; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。 const指针（常量指针 int *const curErr）指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值： 1234int errNumb = 0;int *const curErr = &amp;errNumb; //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; //pip是一个指向常量对象的常量指针 从右向左阅读 此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。 指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值： 1234567*pip = 2.72; // 错误：pip是一个指向常量的指针//如果curErr所指的对象（也就是errNumb）的值不为0if(*curErr)&#123; errorHandler(); *curErr = 0; //正确，把curErr所值得对象的值重置&#125; 总结指向常量的指针（const doubel cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。 12const double pi = 3.14const double *const pip = &amp;pi; 则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primers</tag>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结之排序算法]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中… 注：这里实现的算法都是递增排序，也就是从小到大排序。 初级排序算法1.选择排序思想：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 1234567891011121314public static int [] sort(int a[],int length)&#123; //选择排序 for(int i=0;i&lt;length;i++)&#123; int minIndex = i; //初始化最小元素的索引 for(int j=i+1;j&lt;length;j++)&#123; if(a[minIndex]&gt;a[j])&#123; minIndex = j; //找到最小元素的索引 &#125; &#125; int tem = a[i]; a[i] = a[minIndex]; a[minIndex] = tem; &#125; return a;&#125; 2.直接插入排序思想： 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。 代码： 第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。12345678910public static int [] sort(int a[],int length)&#123; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i;j&gt;0&amp;&amp;a[j]&lt;a[j-1];j--)&#123; int tem = a[j-1]; a[j-1] = a[j]; a[j] = tem; &#125; &#125; return a;&#125; 第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。1234567891011public static int [] sort(int a[],int length)&#123; //不需要交换的插入排序 for(int i=1;i&lt;a.length;i++)&#123; int tem = a[i]; //待插入的元素 int j; for(j=i-1;j&gt;=0&amp;&amp;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; //元素后移,直到找到待插入的元素的位置 &#125; a[j+1] = tem; //将带插入元素插入到查找到的位置 &#125; return a;&#125; 第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j&gt;0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。 1234567891011121314151617181920public static int [] sort(int a[],int length)&#123; int minIndex =0; for(int i=1;i&lt;length;i++)&#123; if(a[minIndex]&gt;a[i])&#123; minIndex = i; &#125; &#125; int tem = a[0]; a[0] = a[minIndex]; a[minIndex] = tem; for(int i=2;i&lt;length;i++)&#123; tem = a[i]; int j; for(j=i-1;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; &#125; a[j+1] = tem; &#125; return a;&#125; 3.希尔排序思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。 我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 代码：12345678910111213141516public static int[] sort(int a[],int length)&#123; int h = length/2; //初始增量 while(h&gt;=1)&#123; //将数组变为h有序 for(int i=h;i&lt;length;i++) &#123; //将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中 for(int j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h)&#123; int tem = a[j-h]; a[j-h] = a[j]; a[j] = tem; &#125; &#125; h = h/2; //每次排完序后,增量减少 &#125; return a;&#125; 参考：dreamcatcher-cx 归并排序简介归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。 2-路归并排序2-路归并排序:假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 该图显示的就是循环2-路归并排序算法的过程： 2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。 递归算法：自顶向下的2-路归并排序中归并结果的轨迹： 循环算法：自底向上的2-路归并排序中归并结果的轨迹： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Mergesort &#123; //2-路归并排序 public static int [] aux; //辅助数组 public static void merge(int a[],int lo,int mid,int hi)&#123; //核心算法 //将a[lo..mid]和a[mid+1,hi](已有序)归并 int i = lo, j = mid+1; for(int k = lo;k&lt;=hi;k++)&#123; //将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid) a[k] = aux[j++]; //左半边用尽，取右半边的元素复制到a中 else if(j&gt;hi) a[k] = aux[i++]; //右半边用尽，取左半边的元素复制到a中 else if(aux[i]&lt;aux[j]) a[k] = aux[i++]; //左半边元素小于右半边元素，取左半边元素复制到a中 else a[k] = aux[j++]; //右半边元素小于左半边元素，取右半边元素复制到a中 &#125; &#125; public static void Mergesort(int a[])&#123; //二路归并递归算法 aux = new int [a.length]; //一次性分配空间 sort(a,0,a.length-1); &#125; private static void sort(int[] a, int lo, int hi) &#123; // 将数组a[lo..hi]排序 if(lo&gt;=hi) return ; int mid = lo + (hi-lo)/2; sort(a,lo,mid); //递归将左半边排序 sort(a,mid+1,hi); //递归将右半边排序 merge(a, lo, mid, hi); //归并结果 &#125; public static void Mergesort1(int [] a) &#123; //二路归并非递归算法 //进行lgN次两两归并 int N = a.length; aux = new int [N]; for(int sz = 1; sz&lt;N;sz = 2*sz)&#123; //sz的子数组大小 for(int lo =0;lo&lt;N-sz; lo+=2*sz)&#123; //子数组的索引 merge(a, lo, lo+sz-1, Math.max(lo+2*sz-1, N-1)); &#125; &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123;2,3,5,1,4,0,7,6&#125;; //Mergesort(a); //调用2-路归并递归排序函数 Mergesort1(a); //调用2-路归并非递归排序函数 for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125; 一些改进1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。 2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。 3.不将元素复制到辅助数组（暂时不太明白）。 快速排序简介快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。 关键算法该方法的关键在于切分，这个过程使得数组满足下面的三个条件： 1.对于某个j,a[j]已经排定； 2.a[lo]到a[j-1]中的所有元素都不大于a[j]； 3.a[j+1]到a[hi]中的所有元素都不小于a[j]。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class QuickSort &#123; public static int[] quicksort(int a[])&#123; sort(a,0,a.length-1); return a; &#125; private static void sort(int[] a, int lo, int hi) &#123; if(hi&lt;=lo) return ; int j=partition(a,lo,hi); //切分 //第j个位置已经在它所在的排好序的位置 sort(a,lo,j-1); sort(a,j+1,hi); &#125; private static int partition(int[] a, int lo, int hi) &#123; int part = a[lo]; //切分元素 int i = lo,j=hi+1; //左右扫描指针 int tem; while(true)&#123; //扫描左右，检查扫描是否结束并交换元素 while(a[++i]&lt;part) &#123; //从左到右(第一个元素除外)找到大于等于part的元素 if(i==hi) break; &#125; while(a[--j]&gt;part)&#123; //从右到左找到小于等于part的元素 if(j==lo) break; &#125; if(i&gt;=j) break; tem = a[i]; a[i] = a[j]; a[j] = tem; &#125; tem = a[lo]; //将part=a[j]放入正确的位置 a[lo] = a[j]; a[j] = tem; return j; &#125; public static void main(String[] args) &#123; int []a = &#123;4,5,4,6,1,3&#125;; a = quicksort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网-剑指offer]]></title>
    <url>%2F2017%2F08%2F19%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[前言牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：点击查看 题目一：二维数组中的查找 （数组）题目描述:在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。 注：时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。 代码： 123456789101112131415161718192021222324252627public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array[0].length==0) &#123; //[[]]的情况 return false; &#125; //判断二维数组是否为空 for(int i=0;i&lt;array.length;i++) &#123; // 找出target所在二维数组的行 if(target&gt;=array[i][0]&amp;&amp;target&lt;=array[i][array[i].length-1]) &#123; //找到所在行之后，因为该行是有序的，此时使用二分查找即可 int low = 0; int high = array[i].length-1; int mid; while(low&lt;=high) &#123; mid = (high + low)/2; if(array[i][mid]&gt;target) &#123; high = mid - 1; &#125;else if(array[i][mid]&lt;target)&#123; low = mid + 1; &#125;else &#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125; 题目二：替换空格 （字符串）题目描述:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路： 第一种： 直接用StringBuffer提供的replace函数。(不可取，得自己搞) 1replace(int start, int end, String str); Replaces the characters in a substring of this sequence with characters in the specified String. 第二种： 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，从后向前遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。 注：从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。 代码： 1234567891011121314151617181920212223public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int oldlength = str.length()-1; int newlength = oldlength; //替换之后新数组的大小 for(int i=0;i&lt;str.length();i++) &#123; if(str.charAt(i)==' ')&#123; newlength += 2; //由一个' '变为"%20",长度增加2 &#125; &#125; str.setLength(newlength+1); //扩展str的长度,多余的位置是空字符 //此时oldlength和newlength都是数组的长度-1 for(;oldlength&gt;=0&amp;&amp;oldlength&lt;newlength;oldlength--)&#123; if(str.charAt(oldlength)==' ')&#123; str.setCharAt(newlength--, '0'); str.setCharAt(newlength--, '2'); str.setCharAt(newlength--, '%'); &#125;else&#123; str.setCharAt(newlength--, str.charAt(oldlength)); &#125; &#125; return str.toString(); &#125;&#125; 题目三：从尾到头打印链表 （链表）题目描述:输入一个链表，从尾到头打印链表每个节点的值。 思路： 第一种： 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low) 第二种： 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。 代码： 1234567891011121314151617181920212223242526272829/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); int count=0; while(listNode != null) &#123; vals.add(listNode.val); listNode = listNode.next; count++; &#125; for(int i=0;i&lt;count/2;i++) &#123; int tem = vals.get(i); vals.set(i, vals.get(count-i-1)); vals.set(count-i-1, tem); &#125; return vals; &#125;&#125; 12345678910public class linklist&#123; public static ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); public static void printListFromTailToHead(ListNode listNode) &#123; if(listNode != null) &#123; printListFromTailToHead(listNode.next); vals.add(listNode.val); &#125; &#125; //return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。&#125; 题目四：重建二叉树 （树）题目五：用两个栈实现队列 （栈、队列）题目描述:用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路： 入队push:将元素进栈A。 出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。 注： 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。 代码： 1234567891011121314151617181920public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; while(stack1.empty()&amp;&amp;stack2.empty())&#123; System.out.println("队列为空!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 题目十一：二进制中1的个数 （位运算）题目描述:输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路： 方法一： 通过n&amp;n-1可以消除整数最右边的1。多次执行n=n&amp;n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。 分析：为啥n&amp;n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 n=12 1100 n-1=11 1011 n=12&amp;11 1000 n=8 1000 n-1=7 0111 n=8&amp;7 0000 代码：12345678public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; n &amp;= n-1; count++; &#125; return count;&#125; 更多参考点击：算法-求二进制数中1的个数 题目十二：数值的整数次方 （代码的完整性）题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路： 方法一：估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。 方法二： 快速幂，快速幂能将复杂度降至O(logb)，确实是快了不少。 原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下： a^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)*a^(2^1)*a^(2^3) 通过使用&amp;和&gt;&gt;位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。 更多信息：快速幂 代码：123456789101112131415161718public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1.0; int e = exponent; exponent = Math.abs(exponent); if(exponent == 0)&#123; return result; &#125; while(exponent!=0)&#123; if((exponent&amp;1)==1)&#123; result *= base; &#125; base *= base; //每移动一位，该为代表的乘数都翻倍 exponent = exponent &gt;&gt; 1; //右移一位 &#125; return e&gt;0?result:1/result; &#125;&#125; 题目十三：调整数组顺序使奇数位于偶数前面 （数组）题目描述:输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路： 方法一： 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。 方法二：重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。 代码：12345678910111213141516public class Solution &#123; public void reOrderArray(int [] array) &#123; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]%2==0)&#123; //偶数的话，继续下一个数 continue; &#125;else&#123; int tem = array[i]; //保存待插入到偶数之前的奇数 int j; for(j=i-1;j&gt;=0&amp;&amp;(array[j]%2==0);j--)&#123; //找到偶数之前插入的位置 array[j+1] = array[j]; //偶数集体后移一位 &#125; array[j+1] = tem; //将奇数插入到该位置上 &#125; &#125; &#125;&#125; 题目十四：链表中倒数第k个结点题目描述:输入一个链表，输出该链表中倒数第k个结点。 思路： 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count&gt;=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。 代码：1234567891011121314151617181920212223242526/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; int count = 0; ListNode p = head; ListNode node = null; //head为空，返回null if(k&lt;=0) return node; //k&lt;=0无效，返回null while(head!=null)&#123; count++; head = head.next; if(count &gt;= k) &#123; //相对第一个元素为k-1的间隔时,head和p同时往后走 node = p; p = p.next; &#125; &#125; return node; &#125;&#125; 题目十五：反转链表题目描述:输入一个链表，反转链表后，输出链表的所有元素。 思路： 依次遍历每个结点，同时通过头插法再重新创建新的链表 注：可以利用之前的结点，而不需要重新创建新的结点，以后改进。 代码：123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode p = null; if(head == null) &#123; return p; &#125;else&#123; p = new ListNode(head.val); &#125; ListNode q = head.next; while(q!=null)&#123; ListNode s = new ListNode(q.val); s.next = p; p = s; q = q.next; &#125; return p; &#125;&#125; 题目十六：合并两个排序的链表题目描述:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。 注：可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode p = new ListNode(0); //创建一个头结点,数据域初始化为0，不存储数据,指针域为null ListNode head = p ; //头指针,指向头结点 if(list1 == null &amp;&amp; list2 == null) return null; while(list1!=null &amp;&amp; list2!=null)&#123; if(list1.val &lt; list2.val)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125;else &#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; &#125; while(list1!=null)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125; while(list2!=null)&#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; return head.next; //头结点不存储元素,head.next指向第一个元素节点，返回 &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>剑指offer</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[样先]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%A0%B7%E5%85%88%2F</url>
    <content type="text"><![CDATA[仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）新日左右： 余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。 予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。 大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。 新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！ 样先 2015.2.18 真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！]]></content>
      <categories>
        <category>兄弟</category>
      </categories>
      <tags>
        <tag>兄弟</tag>
        <tag>朋友</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（二） 提升篇]]></title>
    <url>%2F2017%2F08%2F07%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%20%20%E6%8F%90%E5%8D%87%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言在之前的初级篇中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。 二、更换主题在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。 在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下（此处为G:\GitHub\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件，后者称为主题配置文件。 1. 安装NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 1) 下载主题如果你熟悉Git，建议你使用克隆最新版本的方式，之后的更新可以通过git pull来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了） 在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：12cd G:\GitHub\hexogit clone https://github.com/iissnan/hexo-theme-next themes/next #后面意思是clone到该目录下themes/next文件夹中 2) 启用主题与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。 1theme: next 此时我们在主题配置文件中设置语言。修改language字段。在主题的languages文件夹中选择语言，此处目录为G:\GitHub\hexo\themes\next\languages 。 1language: zh-Hans #选择汉语，选择其他语言填写其他值即可 到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 3) 验证主题进入到博客文件夹根目录，此处为G:\GitHub\hexo，执行如下命令： 123hexo clean #更换主题，最好先清除Hexo缓存hexo generate #生成静态页面hexo server # hexo server -p **** 更换默认4000端口为**** 此时即可使用浏览器访问 http://localhost:4000。 检查站点是否正确运行，如长时间访问不了，更改端口。 现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 三、主题设定NexT官网和网上资料非常丰富，就不细说了，参考如下： 官方参考：NexT使用文档 网上资源：hexo的next主题个性化教程：打造炫酷网站 补充几点： 1. 添加评论功能我选择的是来比力，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。 编辑主题配置文件， 编辑 livere_uid 字段，设置如下： 1livere_uid: #your livere_uid 2. 修改背景图片首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下； 然后进入hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。 12345// Custom styles.body &#123; background:url(/images/background.jpeg); background-attachment: fixed; #固定背景图，使得不随页面移动&#125; 3. 修改博客内容宽度Pisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加 12$main-desktop = 1200px $content-desktop = 900px 可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。 参考：感觉浏览器留白太多，代码块看起来比较麻烦 4. 添加菜单栏在个人网站根目录下使用hexo命令hexo new page “photo” 就直接创建了.\Hexo\source\photo\index.md文件。 在主题配置文件_config.yml中找到meun:字段，添加photo字段123456789menu: home: / categories: /categories/ tags: /tags/ archives: /archives/ photo: /photo/ about: /about/ #sitemap: /sitemap.xml #commonweal: /404.html 给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加photo字段： 123456789101112menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat photo: photo 在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为photo：点击选择图标 将网站中的photo字段显示为中文照片字段 在\themes\next\languages\zh-Hans.yml添加： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 photo: 照片 5. 调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条1.调整文档摘要的高度 在/next/source/css/_common/components/post/post-meta.styl中修改margin的值 123.posts-expand .post-meta &#123; margin: 3px 0 10px 0; color: $grey-dark; 2.调整阅读全文按钮高度 在\next\source\css_common\components\post\post-button.styl中修改margin-top的值 123.post-button &#123; margin-top: 10px; .btn &#123; 3.去除首页文档与文档之间居中灰色的线条 在\next\source\css_common\components\post\post-eof.styl中注释掉如下样式 123456789101112.posts-expand &#123; .post-eof &#123; /* display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 8%; height: 1px; background: $grey-light; text-align: center; */ &#125;&#125; 最终效果如下： 6. 归档页博文列表高度调整在\next\source\css_common\components\post\post-collapse.styl中修改.post 1.post &#123; margin: 0px 0; &#125; 到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。 四、博客管理维护1. 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 注： .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：1.deploy*/ #只忽略上传.deploy*/开头的文件 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 2. 博客搭建流程 1.创建仓库，xinrisanshao.github.io； 2.创建两个分支：master 与 hexo； 3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 4.使用如下命令拷贝仓库 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 6.修改_config.yml中的deploy参数，分支应为master； 7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）； 8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。 这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。 注：流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\xinrisanshao.github.io\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。 3. 博客管理流程1. 编辑与修改博客在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 2.然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 2. 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：1.首先安装Git，Node.js和Hexo。 2.使用下面命令拷贝仓库（默认分支为hexo）； 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。 以上博客管理参考：点击查看 3. 博客图片存放（补）如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。 我选择的是七牛云存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。 五、总结不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（一） 初级篇]]></title>
    <url>%2F2017%2F08%2F06%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%20%20%E5%88%9D%E7%BA%A7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。 今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！ 二、环境准备1. 注册github账号这个就不多说了，账号注册好后，登陆，在首页右边有一个 + 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。 2. 安装Git我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是图形化界面（GUI）,另外一种是通过命令行。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， GitHub和Git Shell,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！ Github for Windows: 点击下载 下载安装完后，桌面上生成GitHub和Git Shell两个图标，然后点击GitHub图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。 Github for Windows 安装配置使用教程: 参考 3. 安装Node.js安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。 点击进入Node.js官网 我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。 4. 安装Hexo以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。 打开终端，输入： 1npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。 1npm config set registry https://registry.npm.taobao.org 安装好Hexo以后，在终端输入： 1hexo 若出现下图，说明hexo安装成功： 三、使用Hexo建站1. 初始化博客新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。 1hexo init [folder] 接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包 1npm install 2. 配置网站的主配置文件为hexo根目录下的_config.yml文件： 默认配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle:description:author: John Doelanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 这些配置项所代表的意思可以参考Hexo中文网：_config.yml配置 ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。 1). 修改网站相关信息123456title: 新日三少的博客 subtitle: Big big pig description: Love Coding,Enjoy Lifeauthor: 新日三少language: zh-CN #themes主题文件夹下的languages下面有很多语言可选timezone: Asia/Shanghai 注意：每一项的填写，其:后面都要保留一个空格，下同。 2). 配置统一资源定位符（个人域名）1url: http://www.wangxinri.cn 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。如无个人域名，无需修改这一项。 3). 配置部署1234deploy: type: git repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git branch: master 其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到： 3. 本地发布博客接下来，在网站中建立第一篇文章，打开终端，进入到博客文件夹根目录，这里是E:Github/hexo，然后输入 1hexo new "文章标题" 我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。 MarkdownPad2：点击下载 Markdown语法：Markdown中文网 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1npm install hexo-deployer-git --save 接下来,我们进行本地发布：12hexo generatehexo server 执行完后，打开浏览器，输入：1http://localhost:4000/ 我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。 4. 发布博客至github仓库但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。 打开终端，进入到博客文件夹根目录，这里还是E:Github/hexo，执行如下命令： 12hexo generatehexo deploy 输入我们的网址：xinrisanshao.github.io ,即可访问博客了。 此时查看github中的仓库，发现我们博客文件夹根目录中的public文件夹里面的文件已经发布到仓库中了。 此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。 好累啊，先休息下，果然还是写博客最累啊。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>