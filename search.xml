<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数基础]]></title>
    <url>%2F2017%2F10%2F19%2F%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[函数基础一个典型的函数定义包括以下部分：返回类型、函数名、由0个或多个形参组成的列表以及函数体。 函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。 形参和实参函数有几个形参，我们就必须提供相同数量的实参。 局部对象形参和函数体内部定义的变量（含｛｝块域）统称为局部变量。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。 自动对象对于普通局部变量对应的对象来说, 当函数的控制路径经过变量定义语句时创建该对象, 当到达定义所在的块末尾时销毁它. 我们把只存在于块执行期间的对象称为自动对象, 当块的执行结束后, 块中创建的自动对象的值就变成未定义的了. 形参是一种自动对象, 函数开始时候为形参申请存储空间, 因为形参定义在函数体作用域之内, 所以函数终止, 形参被销毁. 对于局部变量对应的自动对象来说, 分两种情况：如果变量定义本身含初始值, 就用这个初始值初始化;否则, 如果变量定义本身不含初始值, 执行默认初始化.意味着内置类型的未初始化局部变量将产生未定义的值. 局部静态对象当有些时候, 有必要令局部变量的生命周期贯穿函数调用及之后的时间,可以将局部变量定义为static 类型, 局部静态变量在程序执行路径第一次经过对象定义语句时候初始化,并直到程序终止才被销毁。 123456789101112size_t count_calls()&#123; static size_t ctr=0; eturn ++ctr;&#125;int main()&#123; for(size_t i=0; i!=10; i++) cout&lt;&lt; count_calls() &lt;&lt; endl; return 0;&#125; 在控制流第一次经过ctr的定义之前, ctr被创建且初始化为0; 每次调用ctr加1. 每次执行函数, 变量ctr的值已经存在并等于函数上一次退出的时候的值。 函数声明函数只能定义一次，但可以声明多次。（有例外），如果一个函数永远不可能给我们用到，那他可以只有声明没有定义。 函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息，函数声明也称作函数原型。 best practices: 在头文件中进行函数声明，含有函数声明的头文件应该包含到定义函数的源文件中。 分离式编译分离式编译，C++允许我们将程序分割到几个文件中去，每个文件独立编译。 简单的示例： 目录树： source facc.cpp main.cpp header myHead.h 12345678910111213141516171819202122232425262728//facc.cpp#include &lt;iostream&gt;#include "MyHead.h" //定义fac函数，肯定要包含其声明using namespace std;int fac(int n)&#123; if (n==1)&#123; return 1; &#125;else &#123; return n*fac(n-1); &#125;&#125;//main.cpp#include &lt;iostream&gt;#include "MyHead.h" //使用fac，肯定也要包含其声明using namespace std;int main()&#123; cout&lt;&lt;fac(5)&lt;&lt;endl; return 0;&#125;//myHead.h //头文件中只有函数的声明#ifndef MYHEAD_H_INCLUDED#define MYHEAD_H_INCLUDEDint fac(int n); #endif // MYHEAD_H_INCLUDED const形参和实参实参初始化形参会忽略掉顶层const，也就是当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。 我们可以使用非常量初始化底层const，但是反过来不行。 数组形参数组的两个特殊点： 不允许拷贝数组，所以不可以使用传值的方式使用数组参数(传值即为拷贝)。 通常数组的传递使用的是指针形式，传递的是指针的首地址。 尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式： 12345//尽管形式不同，但这三个print函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10]) //这里的维度表示我们期望数组含有多少元素，实际不一定 当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型： 1234int i = 2;int j[2] = &#123;1,2&#125;;print(&amp;i); //正确，&amp;i的类型是int*print(j); //正确，j被转换成int*并指向j[0] 如果我们传给print函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。 由于数组实际上是以指针的形式传递给函数的，因此一开始函数并不知道数组的确切尺寸，调用者应该为此提供额外的一些信息。 管理指针形参有三种常用的技术： 1.使用标记指定数组长度 这种方法要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符就停止： 12345678void print(const char *cp)&#123; if(cp)&#123; //若cp不是空指针 while(*cp)&#123; //只要指针所指字符不是空字符 cout&lt;&lt;*cp++; //输出当前字符并将指针前移 &#125; &#125;&#125; 这个方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。 2.显示传递一个表示数组大小的形参 这种方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。 12345678//const int ia[]等价于const int *ia//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问void print(const int ia[],size_t size)&#123; for(size_t i = 0; i != size; ++i)&#123; cout&lt;&lt;ia[i]&lt;&lt;" "; &#125;&#125; 这种方法通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值：12int j[] = &#123;1,2,3&#125;;print(j,3); 3.使用标准库函数begin和end C++11标准引入两个名为begin和end的函数，begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一位置的指针，这两个函数定义在iterator头文件中。示例代码如下：123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3,4,5,6,7,8,9,-1,5,3,4&#125;; int *pbeg = begin(arr); //指向arr首元素的指针 int *pend = end(arr); //指向arr尾元素的指针 //寻找第一个负值元素，如果已经检查完全部元素则结束循环 while(pbeg != pend &amp;&amp; *pbeg &gt;= 0)&#123; ++pbeg; &#125; cout&lt;&lt;*pbeg&lt;&lt;endl; //输出第一个负数的值&#125; 对于本文的print函数，可以写成如下形式: 123456void print(const int *beg, const int *end)&#123; //输出beg到end之间（不含end）的所有元素 while(beg != end) cout&lt;&lt;*beg++&lt;&lt;" ";&#125; 为了调用这两个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。使用方法如下：12int a[] = &#123;1,2,3&#125;;print(begin(j),end(j)); 数组形参和const当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。 数组引用形参形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上： 12345void print(int (&amp;arr)[10]) &#123; for(auto elem : arr)&#123; cout&lt;&lt;elem&lt;&lt;endl; &#125;&#125; 注意：12f(int &amp;arr[10])//错误,将arr声明为引用的数组f(int (&amp;arr)[10])//正确, arr是有10个整形的数组引用 传递多维数组和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是指向数组的指针，数组的第二维（以及后面所有维度）的大小都是数组类型的一部分, 不能省略: 1234//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组void print(int (*matrix)[10], int rowsize)&#123;...&#125;//等价于void print(int matrix[][10], int rowsize)&#123;...&#125; 我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内。 main: 处理命令行选项C/C++语言中的main函数，经常带有参数argc，argv，如下： 12int main(int argc, char** argv)int main(int argc, char* argv[]) 第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。 下面的程序演示argc和argv的使用： 1234567891011#include &lt;iostream&gt;using namespace std;int main(int argc,char *argv[])&#123; int i; for (i=0; i &lt; argc; i++) &#123; cout&lt;&lt;"Argument "&lt;&lt;i&lt;&lt;" is "&lt;&lt;argv[i]&lt;&lt;endl; &#125; return 0;&#125; 假如上述代码编译为hello.exe，那么运行hello.exe a b c d e 将得到 Argument 0 is hello.exe. Argument 1 is a. Argument 2 is b. Argument 3 is c. Argument 4 is d. Argument 5 is e. 含有可变形参的参数（先知道有这么个东西，后面详细了解）返回函数指针函数重载（重点，待完善）对于函数重载来说，形参数量或形参类型上有所不同。 不允许两个函数除了返回类型外，其他所有的要素都相同。 特殊用途语言特性默认实参知识点1：函数反复调用的过程中重复出现的形参，这样的值被称为默认实参。该参数在使用过程中可以被用户指定，也可以使用默认数值 知识点2：调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。 知识点3：一旦某个形参被赋予了默认值，其后所有形参都必须有默认值。 知识点4：顺序很重要！在设计函数时，将默认值的形参放在后面。 知识点5：在给定的作用域中，一个形参只能被赋予一次默认实参，且局部变量不能作为默认实参。 内联函数（inline）调用函数函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。 内联函数可以避免函数调用的开销。 将函数指定为“内联函数(inline)”，将它在每个调用点上“内联的展开”，该说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。一般来说，内联的机制用于优化规模较小、流程直接、频繁调用的函数，建议不大于75行。 constexpr函数constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。 12constexpr int new_sz()&#123; return 42;&#125;constexpr int foo = new_sz(); //正确：foo是一个常量表达式 constexpr函数不一定返回常量表达式 程序的调试帮助：assert和NDEBUG知识点1：预处理宏assert(expr)：包含一个表达式，expr为真时，assert什么也不做，为假时输出信息并终止程序。包含在cassert头文件中。通常用于检查不能发生的条件 知识点2：assert依赖于一个NDEBUG的预处理变量的状态，如果定义了NDEBUG，assert什么也不做，默认状态下NDEBUG是未定义的。编译器也可以预先定义该变量。 知识点3：也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef到#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略。 1234567void pp() &#123; #ifndef NDEBUG cerr&lt;&lt;"my name is:"&lt;&lt;__func__&lt;&lt;endl; #endif //其他代码 &#125; 一些C++编译器定义的调试有用的名字： _ func _ :一个静态数组，存放函数的名字 _ FILE _ :存放文件名的字符串字面值 _ LINE _ :存放当前行号的整形字面值 _ TIME _ :存放文件编译时间的字符串字面值 _ DATE _ :存放文件编译日期的字符串字面值 函数匹配 首先确定候选函数：候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。 接着选出可行函数：可行函数具备两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。 如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。 如果没有找到可行函数，编译器将报告无匹配函数的错误。 3.寻找最佳匹配：它的基本思想是，实参类型与形参类型越接近，他们匹配得越好。 编译器一次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功： 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 至少有一个实参的匹配优于其他可行函数提供的匹配。 如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。 函数指针函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：1bool lengthCompare(const string &amp;,const string &amp;); 该函数的类型是bool(const string&amp;,const string&amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。 12//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型bool (*pf) const string&amp; ,const string &amp;); //未初始化 从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 注意： *pf两端的括号必不可少。 知识点2：当我们把函数名当作一个值使用时，函数自动的转换为指针，直接赋予或者取址皆可。可以直接使用只想该函数的指针调用该函数。 知识点3：给指针赋予nullptr或者0时，指针不指向任何函数。 知识点4：函数重载时，指针的类型必须与重载函数精确匹配，包括形参类型数量和返回值类型。 知识点5：虽然不能返回一个函数，但是可以返回一个指向函数的指针。 返回指向函数的指针1int (*f1(int)) (int *,int) 我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int. 出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。 1auto f1(int) -&gt; int (*)(int *,int); 例子12345678910111213141516171819202122#include &lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; int add(int a, int b) &#123; return a+b; &#125; int subtract(int a, int b) &#123; return a - b; &#125; int multiply(int a, int b) &#123; return a * b; &#125; int divide(int a, int b) &#123; return b != 0 ? a / b : 0; &#125;//声明定义函数 int main(int argc, char** argv) &#123; typedef int(*p)(int a, int b); //声明函数指针，未初始化,p为指向函数的指针。使用typedef的声明语句定义的不再是变量而是类型别名 //就是将变量转化为类型别名的一种方式，p原来是指向函数的指针变量，现在变成了指向函数的指针变量的类型别名 vector&lt;p&gt; vec&#123;add, subtract, multiply, divide&#125;;//vector初始化的C++11新特性 for (auto f : vec) cout &lt;&lt; f(2, 2) &lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try语句块和异常处理]]></title>
    <url>%2F2017%2F10%2F15%2Ftry%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、前言简单介绍try语句块和异常处理。 异常异常处理机制为程序中异常检测和异常处理这两部分的协作提供了支持。在C++语言中，异常处理包括： throw表达式（throw expression），异常检测部分使用throw表达式来表示它遇到的了无法处理的问题，我们说throw引发了异常。 try语句块（try block）,异常处理部分使用try语句处理异常。try语句块以关键字try开始，并以一个或多个catch字句结束。try语句块中代码抛出的异常通常会被某个catch字句处理。因为catch字句”处理“异常，所以它们也被称作异常处理代码。 一套异常类（exception class），用于在throw表达式和相关的catch字句之间传递异常具体信息。 throw表达式程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。 try语句块1234567try&#123; program-staments&#125;catch(exception-declaration)&#123; handler-staments&#125;catch(exception-declaration)&#123; handler-staments&#125; ... 代码示例12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stdexcept&gt; //标准异常库using namespace std;int main()&#123; int a,b; cout&lt;&lt;&quot;请输入相除的两个整数：&quot;; while(cin&gt;&gt;a&gt;&gt;b) &#123; try &#123; if (b == 0) throw std::runtime_error(&quot;被除数不能为0&quot;);//runtime_error异常类:只有在运行时才能检测出的问题 cout&lt;&lt;static_cast&lt;double&gt;(a)/b&lt;&lt;endl;//考虑到不可以整除产生小数的情况,先将a强制转化为double类型 &#125; catch (runtime_error err)//err是runtime_error类的一个实例 &#123; cout &lt;&lt; err.what() ; //实例的成员函数，返回内容由编译其决定 cout &lt;&lt; &quot;\n是否需要重新输入? Enter y or n:&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (!cin || c == &apos;n&apos;) break;//break只能用在开关体或者循环体中 &#125;//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理 //如果没有catch部分，仅有try，仍然会报错 cout&lt;&lt;&quot;请输入相除的两个整数：&quot;; &#125; return 0 ;&#125; 输出结果： 请输入相除的两个整数：2 4 0.5 请输入相除的两个整数：2 0 被除数不能为0 是否需要重新输入? n 简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理，如果没有catch部分，仅有try，仍然会报错。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式基础]]></title>
    <url>%2F2017%2F10%2F14%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、前言介绍C++中常见的表达式。 基础概念组合运算符和运算对象对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级、结合律以及运算对象的求值顺序。 重载运算符左值和右值左值可以位于赋值语句的左侧、右值则不能。 当一个对象被用于右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的为止）。 求值顺序（重点）优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。 1int i = f1()*f2(); 我们是无法知道到底f1在f2之前调用还是f2在f1之前调用。 对于那些没有指定执行顺序的运算符来讲，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，比如： 12int i = 0;cout&lt;&lt;i&lt;&lt;" "&lt;&lt;++i&lt;&lt;endl; 表达是的行为不可预知，编译器执行i或者++i的顺序是未知的。 以下4中运算符明确规定了运算对象的求值顺序：&amp;&amp;(逻辑与) ||(逻辑或) ?:(条件运算符) ,(逗号运算符)。 求值顺序、优先级、结合律运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中： 优先级规定，g()的返回值和h()的返回值相乘。 结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。 对于这些函数的调用顺序没有明确规定。 如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。 建议： 处理复合表达式以下两条经验准则对书写复合表达式有益： 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。 第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。 算术运算符%运算符如果m%n不等于0，则它的符号和m相同。 m%(-n) 等于 m%n (-m)%n 等于 -(m%n) -21 % -8 = -5 21 % -5 = 1 逻辑和关系运算符逻辑与(&amp;&amp;)和逻辑或(||) 都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为 短路求值。 text是存储这string对象的vector，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。123456789//s是对常量的引用；元素既没有被拷贝也不会被改变for(const auto &amp;s : text) &#123; cout&lt;&lt;s; if(s.empty()||s[s.size()-1] == '.')&#123; cout&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;" "; &#125;&#125; 值得注意的是，s被声明成对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以声明成对常量的引用。 优先级注意 算数运算符&gt;关系运算符&gt;逻辑运算符 赋值运算符满足右结合律赋值运算符满足右结合律，这一点与其他二元运算符不太一样。 12int ival,jval;ival = jval = 0; //正确，都被赋值为0 因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0作为靠左的赋值运算符的右侧运算对象。又因为赋值运算符返回的是其左侧运算对象，所以靠右的赋值运算的结果（jval=2返回的结果为左侧运算对象jval）被赋给了ival。1cout&lt;&lt;(jval = 2)&lt;&lt;endl; // 输出2 赋值运算符优先级较低12345int i ;//一种很好的写法while((i=get_value()) != 42) &#123; //其他处理&#125; 注意： 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。 递增和递减运算符递增和递减有两种形式：前置版本和后置版本。 123int i =0,j;j = ++i; //j = 1,i = 1; 前置版本得到递增之后的值j = i++; //j = 1,i = 2; 后置版本得到递增之前的值 区别：前置版本将对象本身作为左值返回，后置版本则将对象的原始副本作为右值返回。 建议：除非必须，否则不用递增递减运算符的后置版本 有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。 对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。 混用解引用和递增运算符12//推荐写法cout&lt;&lt;*iter++&lt;&lt;endl; //等价于*(iter++) 后置运算符的优先级高于解引用运算符。 1vec[ival++] &lt;= vec[ival]; //未定义的错误，先求左侧的值还是先求右侧的值不确定 成员访问运算符点运算符和箭头运算符都可用与访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr-&gt;men等价于(*ptr)mem : 1234string s1 = "a string", *p = &amp;s1;auto n = s1.size(); n = (*p).size(); //运行p所指对象的size成员n = p-&gt;size(); //等价于(*p).size() 注意：解引用运算符的优先级低于点运算符。 1*p.size() // 错误，p是一个指针，它没有名为size的成员 条件运算符优先级 条件运算符优先级高于赋值、逗号运算符，低于其他运算符。 例如：123m&lt;n ? x : a+3 等价于：(m&lt;n) ?(x) :(a+3)a++&gt;=10 &amp;&amp; b--&gt;20 ? a : b 等价于：(a++&gt;=10 &amp;&amp; b--&gt;20) ? a : bx=3+a&gt;5 ? 100 : 200 等价于：x= (( 3+a&gt;5 ) ? 100 : 200 ) 结合性 条件运算符具有右结合性。 当一个表达式中出现多个条件运算符时，应该将位于最右边的问号与离它最近的冒号配对，并按这一原则正确区分各条件运算符的运算对象。 例如： w&lt;x ? x+w : x&lt;y ? x : y 与 w&lt;x ? x+w : ( x&lt;y ? x : y) 等价 与 (w&lt;x ? x+w : x&lt;y) ? x : y 不等价 注意： 随着条件运算嵌套的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。 位运算符（基础，待补充）一个使用位运算符的例子 假设一个班级有30个学生,我们用一个二进制位来代表某个学生在依次测试中是否通过，显然全班的测试结果可以用一个无符号整数来表示： 1unsigned long quizl = 0 ; //我们把这个值当成是位的集合来使用 将quizl类型定义位unsigned long，这样，quizl在任何机器上都将至少拥有32位；给quizl赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。 1234567//1UL是一个unsigned long类型的整数字面值1//1UL&lt;&lt;27; 生成一个值，该值只有第27位为1quizl |= 1UL&lt;&lt;27; //表示学生27通过了测试quizl &amp;= ~(1UL&lt;&lt;27); //学生27未通过测试bool status = quizl &amp; (1UL&lt;&lt;27); //学生27是否通过了测试？ sizeofsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得到的值是一个size_t类型的常量表达式。 sizeof的三种语法形式： 123sizeof(object); //sizeof(对象);sizeof(type_name); //sizeof(类型);sizeof object; //sizeof对象; 12345int i;sizeof(i); //oksizeof i; //oksizeof(int); //oksizeof int; //error 既然写法3可以用写法1代替，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。 1sizeof(*p); //指针所占的空间大小，与指针指向的类型无关 sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针也不会有什么影响，在sizeof的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。 C++11新标准允许我们使用作用域来获取成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象。因为要想知道类成员的大小无须真的获取该成员。 sizeof运算符的结果部分地依赖于其作用的类型： 对char或者类型为char的表达式指向sizeof运算，结果为1； 对引用类型执行sizeof运算得到被引用对象所占空间的大小； 对指针指向sizeof运算得到指针本身所占空间的大小； 对解引用指针执行sizeof运算符得到指针指向的对象所占空间的大小，指针不需有效。 对数组执行sizeof运算限制得到整个数组所占空间的大小，等价于对数组这所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数： 123// sizeof(ia)/sizeof(*ia)返回ia的元素数量 constexpr size_t sz = sizeof(ia)/sizeof(*ia); int arr2[sz]; // 正确：sizeof返回一个常量表达式 因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组&指针&string]]></title>
    <url>%2F2017%2F10%2F14%2F%E6%95%B0%E7%BB%84%26%E6%8C%87%E9%92%88%26string%2F</url>
    <content type="text"><![CDATA[一、前言介绍使用数组的基本方法，同时介绍C++中string的初始化和一些常用函数。 数组数组与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序运行时性能较好，但是相对地也损失了一些灵活性。 note： 如果不清楚元素的确切个数，请使用vector。 定义和初始化内置数组数组是一种复合类型，数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。 123456unsigned cnt = 42; //不是常量表达式constexpr unsigned sz = 42; //常量表达式int arr[10]; //含有10个整型的数组int *parr[sz]; //含有42个整型指针的数组string bad[cnt]; //错误：cnt不是常量表达式string strs[get_size()]; //当gett_size是constexpr时正确；否则错误 默认情况下，数组的元素被默认初始化。另外数组的元素应为对象，因此不存在引用的数组。 显式初始化数组元素可以对数组的元素进行列表初始化，此时允许忽略数组的纬度。 123456const unsigned sz = 3;int ial[sz] = &#123;0,1,2&#125;; //含有三个元素的数组，元素值分别是０１２int a2[] = &#123;0 ,1 , 2&#125;; //维度是３的数组int a3[5] = &#123;0,1,2&#125;; // 等价于&#123;0,1,2,0,0&#125;string a4[3] = &#123;“hi” , “bye”&#125;; //&#123;“hi”,”bye” ,”“&#125;int a5[2] = &#123;0,1,2&#125; //错误， 初始值太多 字符数组的特殊性（用字符串字面值对数组进行初始化）字符数组可以用字符串字面值初始化，但是特殊的是结束符（’\0’）也会被拷贝进去1234char a1[] = &#123;‘C’,’+’ ,’+’&#125;; //列表初始化没有空字符char a2[] = &#123;‘C’,’+’,‘+’,’\0’&#125;; //列表初始化，含有显示的空字符char a3[] = “C++”; //自动添加表示字符串结束的空字符const char a4[6] =”Daniel”; //错了，没有空间可以存放空字符 a4数组的大小必须至少是7。 数组不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： 123int a[] = &#123;0,1,2&#125;;int a2[] = a; //错误：不允许使用一个数组初始化另一个数组a2 = a; //错误：不能把一个数组直接赋值给另一个数组 理解复杂的数组声明可以定义一个存放指针的数组。又因为数组本身是对象，所以允许定义数组的指针（指向数组的指针）及数组的引用（对数组的引用）。 1234//[]的优先级比*高int *ptrs[10]; //ptrs是含有10个整型指针的数组int (*Parray)[10] = &amp;arr; //Parray指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组 默认情况下，类型修饰符从右向左一次绑定， 对于ptrs来说，首先知道我们定义了一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 Parray的含义：首先*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。最终，Parray是一个指针，它指向一个int数组，数组中包含10个元素。 当然，对修饰符的数量并没有特殊限制： 1int *(&amp;array)[10] = ptrs; //array是数组的引用，该数组含有10个指针 访问数组元素数组的元素也能使用范围for语句或下标运算符来访问。 当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。 123for(auto i : scores) &#123; cout&lt;&lt;i&lt;&lt;" ";&#125; 指针和数组在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。 12string nums[] = &#123;"one","two","three"&#125;; //数组的元素是string对象string *p = &amp;nums[0]; //p指向nums的第一个元素 数组的一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。 1string *p = nums; //等价于p2=&amp;nums[0]; auto 和 decltype1234int ia[] = &#123;0,1,2,3,4,5&#125;;auto ia2(ia); //ia2是一个整型指针，指向ia的第一个元素decltype(ia) ia3 = &#123;3,4,5,6,7,8&#125;; //ia3类型是由10个整数构成的数组，并对该数组进行赋值 指针也是迭代器123int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p = arr; //p指向arr的第一个元素++p; 遍历数组元素，我们可以设法获取数组尾元素之后的那个并不存在的元素的地址： 1234int *e = &amp;arr[10]; //指向尾元素的下一位置的指针for(int *b = arr; b!=e; ++b)&#123; cout&lt;&lt;*b&lt;&lt;end; //输出arr的元素&#125; note: 尽管能计算得到尾后指针，但是这种用法极易出错，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似。 begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。 正确的使用形式：123456int ia[] = &#123;1,2,3,4,5&#125;;int *beg = begin(ia); //指向ia首元素的指针int *last = end(ia); //指向arr尾元素的下一位置的指针for(beg;beg!=last;++beg)&#123; cout&lt;&lt;*beg&lt;&lt;" ";&#125; note: 一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end()函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。 下标和指针12345678int ia[] = &#123;0,2,4,6,8&#125;; //含有5个整数的数组int i = ia[2]; //ia[2]得到(ia+2)所指的元素，即*(ia+2)int *p = ia;i = *(p+2); //等价于i = ia[2];只要指针指向的是数组中的元素(或者数组中尾元素的下一位置，此时下标需要为负值)，都可以执行下标运算。int *p = &amp;ia[2]; //p指向索引为2的元素int j = p[1]; //j = ia[3]int k = p[-2]; //k = ia[0] 注意： 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。 C风格字符串C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\0’）。 C风格字符字符串函数 12345\\p,p1,p2都是字符数组的形式，在string.h头文件中strlen(p) 返回p的长度，空字符不计算在内strcmp(p1,p2) 比较p1和p2的相等。如果p1==p2，返回0；如果p1&gt;p2,返回一个正值；如果p1&lt;p2，返回一个负值strcat(p1,p2) 将p2附加到p1之后，返回p1strcpy(p1,p2) 将p2拷贝给p1,返回p1 对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。 与旧代码的接口现代的C++ 程序不得不与那些充满了数组或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。 混用string对象和C风格字符串允许使用字符串字面值来初始化对象： 1string s("Hello world"); //s的内容是Hello world 更一般的情况，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代： 允许使用空字符结束的字符数组来初始化string对象或为string对象赋值。 在string对象的加法运算过程中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中匀速使用以空字符串结束的字符数组作为右侧的运算对象。 上述性质反过来就不成立，比如不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数。 123string s = "wangxinri";char *p = s ; //错误，不能用string对象直接初始化指向字符的指针const char *str = s.c_str(); //正确 我们无法保证c_str()返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效果。因此使用最好将c_str()返回的数组拷贝一份。 使用数组初始化vector对象不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象 12345int int_arr[] = &#123;0,1,2,3,4,5&#125;;vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));//拷贝三个元素：int_arr[1],int_arr[2],int_arr[3]vector&lt;int&gt; subVec(int_arr+1,int_arr4); 注意： 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。 多维数组（待补充）stringstring表示可变长的字符序列，使用string类型必须首先包含string头文件。 初始化string对象的方式123456string s1 默认初始化，s1是一个空串string s2(s1) s2是s1的副本string s2 = s1 等价于s2(s1)，s2是s1的副本string s3("value") s3是字面值"value"的副本，除了字面值最后的那个空字符外string s3 = "value" 等价于s3("value")，s3是字面值"value"的副本string s4(n, 'c') 把s4初始化为由连续n个字符c组成的串 string对象上的操作1234567891011os&lt;&lt;s 将s写到输出流os当中，返回osis&gt;&gt;s 从is中读取字符串赋给s，字符串以空白分隔，返回isgetline(is, s) 从is中读取一行赋给s，返回iss.empty() s为空赋返回true，否则返回falses.size() 返回s中的字符的个数s[n] 返回s中第n个字符的引用，位置n从0计起s1+s2 返回s1和s2连接后的结果s1=s2 用s2的副本代替s1中原来的字符s1==s2 如果s1和s2中所含的字符完全一样，则它们相等，返回trues1!=s2 如果s1和s2中所含的字符不一样，返回true&lt;, &lt;=, &gt;, &gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 代码示例12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; string str; while(cin&gt;&gt;str)&#123; cout&lt;&lt;str&lt;&lt;endl; &#125; return 0;&#125;#include&lt;iostream&gt;using namespace std;int main() &#123; string line; while(getline(cin,line))&#123; cout&lt;&lt;line&lt;&lt;endl; &#125; return 0;&#125; 处理string对象中的字符对字符处理的一些方法，在cctype头文件中定义了一组标准库函数处理这部分工作12345678910111213isalnmu(c) 当c是字母或数字为真isalpha(c) 当c是字母为真iscntrl(c) 当c是控字符时为真isdigit(c) 当c是数字为真isgraph(c) 当c不是空格但可打印为真islower(c) 当c是小写字母为真isprint(c) 当c是可打印字符为真(即c是空格或c具有可视形式)ispunct(c) 当c是标点符号为真(即c不是控字符、数字、字母、可打印空白中的一种)isspace(c) 当c是空白为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进制符中一种)issupper(c) 当c是大写字母为真isxdigit(c) 当c是十六进制数字为真tolower(c) 若c是大写字母，输出对应小写字母；否则原样输出ctoupper(c) 若c是小写字母，输出对应大写字母；否则原样输出c 处理string每个字符，使用基于范围的for语句12345678910111213141516171819202122232425262728// 用范围for语句和ispunct函数统计string对象中标点符号的个数（使用范围for语句遍历给定序列的每个元素）#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s("Hello World!!!");decltype(s.size()) punct_cnt = 0; //punct_cnt的类型同s.size()，即为string :: size_typefor (auto c : s) // 对于s中的每个字符 if (ispunct(c)) // 如果该字符是标点符号 ++ispunct_cnt; // 计数cout &lt;&lt; punct_cnt &lt;&lt; " punctuation characters in " &lt;&lt; s &lt;&lt; endl;return 0;&#125;// 用范围for语句将字符串改写为大写字母的形式（使用范围for语句改变字符串中的字符）#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;string s ("Hello World!!!")// 转换成大写形式for (auto &amp;c : s) // 对于s中的每个字符(c是引用) c = toupper(c); // c是一个引用，赋值语句改变了c绑定的字符的值，标准库函数toupper将小写的参数c改为大写cout &lt;&lt; s &lt;&lt; endl;return 0;&#125; 只处理string一部分字符要想访问string对象总的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。 注意：检查下标的合法性 一种简便易行的方法是：总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。 1234const string s = "keep out";for(auto &amp;c :s)&#123; //C的类型是常量引用，不能通过C修改其绑定的对象 cout&lt;&lt;c&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用&指针&const]]></title>
    <url>%2F2017%2F09%2F01%2F%E5%BC%95%E7%94%A8%26%E6%8C%87%E9%92%88%26const%2F</url>
    <content type="text"><![CDATA[本文详细讲解了引用与指针的用法及具体区别，同时探讨了const限定符的基本用法。 引用一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 12345int a;基本数据类型 声明符（其实就是变量名）//更复杂的声明符 ----接下来的指针和引用int *b; //指针可以不初始化，没语法错误int &amp;b = a; //引用必须初始化 引用（reference）为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符号写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 123int ival = 1024;int &amp;refVal = ival; //refVal指向ival(是ival的另一个名字)int &amp;refVal2; //报错，引用必须初始化 一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成。引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用注意细节 无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，即引用即别名。 引用本身不是对象，所以不能定义引用的引用。 引用的类型要和绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。（两种例外，一种是对常量的引用 const int &amp;） 123int &amp;refVal4 = 10; //错误，引用类型的初始值必须是一个对象double dval = 3.14;int &amp;refVal5 = dval; //错误：此处引用类型初始值必须是int型对象 代码示例12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 2; int c = 4; int &amp;b = a; //b是a的引用，即b是a的别名 //&amp;b = c; 错误,无法令引用重新绑定到另外一个对象上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = 5; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; b = 6; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;endl; a = c; //将a的值改变，b的值也相应改变，但&amp;a和&amp;b还是一样的 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; b = c; //同上 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;&amp;a&lt;&lt;" "&lt;&lt;&amp;b&lt;&lt;" "&lt;&lt;&amp;c&lt;&lt;endl; return 0;&#125; 2 2 0x28fef8 0x28fef8 5 5 0x28fef8 0x28fef8 6 6 0x28fef8 0x28fef8 4 4 0x28fef8 0x28fef8 0x28fef4 4 4 0x28fef8 0x28fef8 0x28fef4 指针指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。 指针和引用的不同点： 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符（&amp;）. 12int ival = 42;int *p = &amp;ival; //指针变量p存放变量ival的地址,也即p是指向变量ival的指针 注意细节 引用不是对象，没有实际地址，所有不能定义指向引用的指针。 指针的类型要和它指向的对象严格匹配(两种例外，一种是指向常量的指针)，因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。 指针值指针的值（即地址）应属下列4种状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，也就是上述情况之外的其他值（比如指针未初始化，指针的值也就指向的地址为指针变量内存空间的当前内容，是一个随机值） 注意：指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许，虽然编译可能通过，但如果这样做了，后果无法预计。 利用指针访问对象使用解引用符（操作符*）来访问该对象。解引用操作仅适用于那些确实指向了某个对象的有效指针。 空指针空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法： 123int *p1 = nullptr; //等价于int *p1 = 0;int *p2 = 0; //直接将p2初始化为字面常量0int *p3 = NULL; //等价于int *p1 = 0; C++程序最好使用nullptr,同时尽量避免使用NULL。 把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。 12int zero = 0 ,*p;pi = zero; // 错误：不能把int变量直接赋给指针 note:建立初始化所有指针 原因：在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值（即该地址值是一个随机数）。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。 void* 指针void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解： 123double obj = 3.14, *pd = &amp;obj; // 正确：void*能存放任意类型对象的地址void *pv = &amp;obj; // obj可以是任意类型的对象pv = pd; // pv可以存放任意类型的指针 利用void指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象 代码示例1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; double obj = 3.14,*pd = &amp;obj; void *pv = &amp;obj; cout&lt;&lt;&amp;obj&lt;&lt;" "&lt;&lt;obj&lt;&lt;endl; cout&lt;&lt;&amp;pd&lt;&lt;" "&lt;&lt;pd&lt;&lt;" "&lt;&lt;*pd&lt;&lt;endl; cout&lt;&lt;&amp;pv&lt;&lt;" "&lt;&lt;pv&lt;&lt;" "&lt;&lt;endl; //不能直接操作void* 指针所指的对象，即*pv是不合法的 return 0;&#125; 0x28ff08 3.14 0x28ff04 0x28ff08 3.14 0x28ff00 0x28ff08 理解复合类型的声明修饰符（或&amp;）和变量标识符写在一起，修饰符(或者&amp;)都是修饰变量的。 1int *p1,*p2; //p1和p2都是指向int的指针 指向指针的指针指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。 通过的个数可以区分指针的级别。也就是说，表示指向指针的指针，表示指向指针的指针的指，依次类推： 12345int ival = 1024;int *pi = &amp;ival; //pi指向一个int型的数int **ppi = &amp;pi; //ppi指向一个int型的指针//解引用cout&lt;&lt;ival&lt;&lt;" "&lt;&lt;*pi&lt;&lt;" "&lt;&lt;**ppi&lt;&lt;endl; 指向指针的引用引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。 12345int i = 42;int *p; //p是一个int型指针int *&amp;r = p; //r是一个对指针p的引用, 此时r和p指针同名r = &amp;i; //r引用了一个指针，因此给r赋值&amp;i就是令指向i*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0 要理解r的类型到底是什么，最简单的方法就是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int型指针。 const限定符const定义有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字const对变量的类型加以限制： 1const int bufSize = 512; //输入缓冲区大小 这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。 123const int i = get_size(); //正确：运行时初始化const int j = 42; //正确：编译时初始化const int k; //错误：k是一个未经初始化的常量 const类型能参与的操作：只能在const类型的对象上执行不改变其内容的操作。再不改变const对象的操作中还有一种是初始化。 默认状态下，const对象仅在文件内有效当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样： 1const int bufSize = 512; //输入缓冲区大小 编译器将在编译过程中把用到该变量的地方都替换成对应的值也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，不同文件中分别定义了独立的变量。 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在多个文件中声明并使用它。 解决办法： 对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了： 1234//file1.cpp定义并初始化和一个常量，该常量能被其他文件访问extern const int bufferSize = function();//file1.h头文件extern const int bufferSize; //与file1.cpp中定义的是同一个 note：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。 const引用可以把引用绑定到const对象上，就像绑定其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 1234const int ci = 1024;const int &amp;r1 = ci; //正确：引用及其对应的对象都是常量r1 = 42; //错误：r1时对常量的引用int &amp;r2 = ci; //错误：试图让一个非常量引用指向一个常量对象 因为不允许直接为ci赋值，当然也就是不能通过引用去改变ci。因此，对r2的初始化也是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确。 初始化和对const的引用引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能抓换成引用的类型即可。 尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式： 12345int i = 42; const int &amp;r1 = i; //允许将const int &amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确：r1是一个常量引用const int &amp;r3 = r1*2; //正确：r3是一个常量引用int &amp;r4 = r1*2; //错误：r4是一个普通的非常量y 如果int &amp;r4 = r1*2合法，那么就可以通过r4改变r1的值，而r1是常量引用。 常量引用被绑定到另外一种类型上时到底发生了什么： 12345double dval = 3.14;const int &amp;ri = dval;//为了确保ri绑定一个整数，编译器把上述代码变成了如下形式：const int temp = dval; //由双精度浮点数生成一个临时的整形常量const int &amp;ri = temp; //让ri绑定这个临时量 总结：常量引用（const &amp;）可以绑定到const常量上，也可以绑定到int变量上，但是让一个非常量引用指向一个常量对象是不对的。 对const的引用可能引用一个并非const的对象必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值： 12345int i = 42;int &amp;r1 = i; // 引用r1绑定对象iconst int &amp;r2 = i； // r2也绑定对象i，但是不允许通过r2修改i的值r1 = 0; // r1并非常量引用，i的值修改为0r2 = 0; // 错误：r2是一个常量引用 r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。 指针和const(指向常量的指针 const double *cptr)指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 123456const double pi = 3.14; //pi是一个常量，它的值不能改变double *ptr = &amp;pi; //错误，ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值double dval = 3.2;cptr = &amp;dval; //对的 注意：之前提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一个就是允许令一个指向常量的指针指向一个非常量对象： 12double dval = 3.14;const double *ptr = &amp;dval; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。 const指针（常量指针 int *const curErr）指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值： 1234int errNumb = 0;int *const curErr = &amp;errNumb; //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; //pip是一个指向常量对象的常量指针 从右向左阅读 此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它所指向的对象是一个双精度浮点型常量。 指针本身是一个常量并不意味着不能通过指针修改其所值对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值： 1234567*pip = 2.72; // 错误：pip是一个指向常量的指针//如果curErr所指的对象（也就是errNumb）的值不为0if(*curErr)&#123; errorHandler(); *curErr = 0; //正确，把curErr所值得对象的值重置&#125; 总结指向常量的指针（const doubel cptr）不能用于改变其所指向对象的值，但是可以改变指针本身的值，而常量指针（int const curErr）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了，但是可以修改其所指向对象的值。 12const double pi = 3.14const double *const pip = &amp;pi; 则此时pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能被改变。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primers</tag>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结之排序算法]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言回顾之前学习的各种排序算法，从初级到高级，包括选择排序，冒泡排序，插入排序，希尔排序，快速排序，归并排序，堆排序等等，持续更新中… 注：这里实现的算法都是递增排序，也就是从小到大排序。 初级排序算法1.选择排序思想：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 1234567891011121314public static int [] sort(int a[],int length)&#123; //选择排序 for(int i=0;i&lt;length;i++)&#123; int minIndex = i; //初始化最小元素的索引 for(int j=i+1;j&lt;length;j++)&#123; if(a[minIndex]&gt;a[j])&#123; minIndex = j; //找到最小元素的索引 &#125; &#125; int tem = a[i]; a[i] = a[minIndex]; a[minIndex] = tem; &#125; return a;&#125; 2.直接插入排序思想： 每一步将一个待排序的记录，插入到前面应排好序的有序序列中去，直到查完所有元素为止。 代码： 第一种：从后往前依次比较前面排好序的有序序列，如果插入元素较小时，交换，j- -,继续比较。12345678910public static int [] sort(int a[],int length)&#123; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i;j&gt;0&amp;&amp;a[j]&lt;a[j-1];j--)&#123; int tem = a[j-1]; a[j-1] = a[j]; a[j] = tem; &#125; &#125; return a;&#125; 第二种：不需要交换的直接插入排序，将内循环中较大的元素都向右移动而不总是交换两个元素，从而提高效率。1234567891011public static int [] sort(int a[],int length)&#123; //不需要交换的插入排序 for(int i=1;i&lt;a.length;i++)&#123; int tem = a[i]; //待插入的元素 int j; for(j=i-1;j&gt;=0&amp;&amp;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; //元素后移,直到找到待插入的元素的位置 &#125; a[j+1] = tem; //将带插入元素插入到查找到的位置 &#125; return a;&#125; 第三种：此外还可以通过增加哨兵的形式，在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件j&gt;0。这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为哨兵。 1234567891011121314151617181920public static int [] sort(int a[],int length)&#123; int minIndex =0; for(int i=1;i&lt;length;i++)&#123; if(a[minIndex]&gt;a[i])&#123; minIndex = i; &#125; &#125; int tem = a[0]; a[0] = a[minIndex]; a[minIndex] = tem; for(int i=2;i&lt;length;i++)&#123; tem = a[i]; int j; for(j=i-1;tem&lt;a[j];j--)&#123; a[j+1] = a[j]; &#125; a[j+1] = tem; &#125; return a;&#125; 3.希尔排序思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。 我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 代码：12345678910111213141516public static int[] sort(int a[],int length)&#123; int h = length/2; //初始增量 while(h&gt;=1)&#123; //将数组变为h有序 for(int i=h;i&lt;length;i++) &#123; //将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中 for(int j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h)&#123; int tem = a[j-h]; a[j-h] = a[j]; a[j] = tem; &#125; &#125; h = h/2; //每次排完序后,增量减少 &#125; return a;&#125; 参考：dreamcatcher-cx 归并排序简介归并排序，即将两个有序的数组归并成一个更大的有序数组，要将一个数组排序，可以（递归的）先将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点则是它所需的额外空间和N成正比。 2-路归并排序2-路归并排序:假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2（整数值）个长度为2或1的有序子序列；在两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。 如下为一个典型的例子。 该图显示的就是循环2-路归并排序算法的过程： 2-路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列。 递归算法：自顶向下的2-路归并排序中归并结果的轨迹： 循环算法：自底向上的2-路归并排序中归并结果的轨迹： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Mergesort &#123; //2-路归并排序 public static int [] aux; //辅助数组 public static void merge(int a[],int lo,int mid,int hi)&#123; //核心算法 //将a[lo..mid]和a[mid+1,hi](已有序)归并 int i = lo, j = mid+1; for(int k = lo;k&lt;=hi;k++)&#123; //将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid) a[k] = aux[j++]; //左半边用尽，取右半边的元素复制到a中 else if(j&gt;hi) a[k] = aux[i++]; //右半边用尽，取左半边的元素复制到a中 else if(aux[i]&lt;aux[j]) a[k] = aux[i++]; //左半边元素小于右半边元素，取左半边元素复制到a中 else a[k] = aux[j++]; //右半边元素小于左半边元素，取右半边元素复制到a中 &#125; &#125; public static void Mergesort(int a[])&#123; //二路归并递归算法 aux = new int [a.length]; //一次性分配空间 sort(a,0,a.length-1); &#125; private static void sort(int[] a, int lo, int hi) &#123; // 将数组a[lo..hi]排序 if(lo&gt;=hi) return ; int mid = lo + (hi-lo)/2; sort(a,lo,mid); //递归将左半边排序 sort(a,mid+1,hi); //递归将右半边排序 merge(a, lo, mid, hi); //归并结果 &#125; public static void Mergesort1(int [] a) &#123; //二路归并非递归算法 //进行lgN次两两归并 int N = a.length; aux = new int [N]; for(int sz = 1; sz&lt;N;sz = 2*sz)&#123; //sz的子数组大小 for(int lo =0;lo&lt;N-sz; lo+=2*sz)&#123; //子数组的索引 merge(a, lo, lo+sz-1, Math.max(lo+2*sz-1, N-1)); &#125; &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123;2,3,5,1,4,0,7,6&#125;; //Mergesort(a); //调用2-路归并递归排序函数 Mergesort1(a); //调用2-路归并非递归排序函数 for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125; 一些改进1.对小规模子数组使用插入排序，因为递归会使小规模问题中方法的调用过于频繁，所以改进对他们的处理方法就能改进整个算法。使用插入排序处理小规模子数组（比如长度小于15）。 2.测试数组是否已经有序，我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，此时前半部分有序数组最后一个数小于后半部分有序数组的第一个数，我们就认为数组已经是有序并跳过merge()方法。这个改动不影响排序的递归调用。 3.不将元素复制到辅助数组（暂时不太明白）。 快速排序简介快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分成两半；在快速排序中，切分的位置取决于数组的内容。 关键算法该方法的关键在于切分，这个过程使得数组满足下面的三个条件： 1.对于某个j,a[j]已经排定； 2.a[lo]到a[j-1]中的所有元素都不大于a[j]； 3.a[j+1]到a[hi]中的所有元素都不小于a[j]。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class QuickSort &#123; public static int[] quicksort(int a[])&#123; sort(a,0,a.length-1); return a; &#125; private static void sort(int[] a, int lo, int hi) &#123; if(hi&lt;=lo) return ; int j=partition(a,lo,hi); //切分 //第j个位置已经在它所在的排好序的位置 sort(a,lo,j-1); sort(a,j+1,hi); &#125; private static int partition(int[] a, int lo, int hi) &#123; int part = a[lo]; //切分元素 int i = lo,j=hi+1; //左右扫描指针 int tem; while(true)&#123; //扫描左右，检查扫描是否结束并交换元素 while(a[++i]&lt;part) &#123; //从左到右(第一个元素除外)找到大于等于part的元素 if(i==hi) break; &#125; while(a[--j]&gt;part)&#123; //从右到左找到小于等于part的元素 if(j==lo) break; &#125; if(i&gt;=j) break; tem = a[i]; a[i] = a[j]; a[j] = tem; &#125; tem = a[lo]; //将part=a[j]放入正确的位置 a[lo] = a[j]; a[j] = tem; return j; &#125; public static void main(String[] args) &#123; int []a = &#123;4,5,4,6,1,3&#125;; a = quicksort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网-剑指offer]]></title>
    <url>%2F2017%2F08%2F19%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[前言牛客网剑指offer题目汇总，记录自己刷题历程，原文链接：点击查看 题目一：二维数组中的查找 （数组）题目描述:在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：矩阵从左到右，从上到下都是有序的，因此，先查找目标数target在二维数组中的哪一行，通过判断是否在该行的第一个数和最后一个数之间，如果是，则定位到了行，因为该行是有序的，所以接下来通过二分查找，即可查找成功。 注：时间复杂度的话，查找行花了O(n), 二分查找O(logn),总共应该O(n)+O(logn),奇怪的是我使用普通的遍历查找，运行时间更更少！这不科学，二分查找效率应该更高，这应该是数据量小导致的。 代码： 123456789101112131415161718192021222324252627public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array[0].length==0) &#123; //[[]]的情况 return false; &#125; //判断二维数组是否为空 for(int i=0;i&lt;array.length;i++) &#123; // 找出target所在二维数组的行 if(target&gt;=array[i][0]&amp;&amp;target&lt;=array[i][array[i].length-1]) &#123; //找到所在行之后，因为该行是有序的，此时使用二分查找即可 int low = 0; int high = array[i].length-1; int mid; while(low&lt;=high) &#123; mid = (high + low)/2; if(array[i][mid]&gt;target) &#123; high = mid - 1; &#125;else if(array[i][mid]&lt;target)&#123; low = mid + 1; &#125;else &#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125; 题目二：替换空格 （字符串）题目描述:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路： 第一种： 直接用StringBuffer提供的replace函数。(不可取，得自己搞) 1replace(int start, int end, String str); Replaces the characters in a substring of this sequence with characters in the specified String. 第二种： 先统计出空格的个数，然后计算得到替换后的字符串的长度，然后重新更新字符串的长度，此时，从后向前遍历字符串，如果是空格，替换，如果不是空格，赋原值，知道遍历结束。 注：从后往前，每个空格后面的字符只需要移动一次。从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。 代码： 1234567891011121314151617181920212223public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int oldlength = str.length()-1; int newlength = oldlength; //替换之后新数组的大小 for(int i=0;i&lt;str.length();i++) &#123; if(str.charAt(i)==' ')&#123; newlength += 2; //由一个' '变为"%20",长度增加2 &#125; &#125; str.setLength(newlength+1); //扩展str的长度,多余的位置是空字符 //此时oldlength和newlength都是数组的长度-1 for(;oldlength&gt;=0&amp;&amp;oldlength&lt;newlength;oldlength--)&#123; if(str.charAt(oldlength)==' ')&#123; str.setCharAt(newlength--, '0'); str.setCharAt(newlength--, '2'); str.setCharAt(newlength--, '%'); &#125;else&#123; str.setCharAt(newlength--, str.charAt(oldlength)); &#125; &#125; return str.toString(); &#125;&#125; 题目三：从尾到头打印链表 （链表）题目描述:输入一个链表，从尾到头打印链表每个节点的值。 思路： 第一种： 遍历链表，将链表存入Arraylist数组vals中，然后对vals进行反转。(确实很low) 第二种： 使用递归思想，递归到最后一个结点，然后层层返回，此时依次add进vals数组中。 代码： 1234567891011121314151617181920212223242526272829/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); int count=0; while(listNode != null) &#123; vals.add(listNode.val); listNode = listNode.next; count++; &#125; for(int i=0;i&lt;count/2;i++) &#123; int tem = vals.get(i); vals.set(i, vals.get(count-i-1)); vals.set(count-i-1, tem); &#125; return vals; &#125;&#125; 12345678910public class linklist&#123; public static ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); public static void printListFromTailToHead(ListNode listNode) &#123; if(listNode != null) &#123; printListFromTailToHead(listNode.next); vals.add(listNode.val); &#125; &#125; //return val; 返回val不需要，因为vals本身就相当于全局变量一样，每次迭代更新的都是同一个vals。&#125; 题目四：重建二叉树 （树）题目五：用两个栈实现队列 （栈、队列）题目描述:用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路： 入队push:将元素进栈A。 出队pop:判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，然后栈B出站。 注： 1 push，将数据直接压入stack1即可；2 pop,将stack1中的数据弹出压入到stack2中，则数据顺序相反，为保证最新进入的数据一致处于栈顶，只有将stack2中的数据全部pop后，才能继续将stack1中的数据压入到stack2中，继续做pop。 代码： 1234567891011121314151617181920public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; while(stack1.empty()&amp;&amp;stack2.empty())&#123; System.out.println("队列为空!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 题目十一：二进制中1的个数 （位运算）题目描述:输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路： 方法一： 通过n&amp;n-1可以消除整数最右边的1。多次执行n=n&amp;n-1，最终n为0时，表示所有的1都被消除了，消除1所执行的次数即为1的个数。 分析：为啥n&amp;n-1可以消除整数最右边的1？ 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变成0，原来在最右边1后面的所有的0都会变成1（如果最右边的1后面还有0的话）。其余所有位将不会受到影响。我们发现减1的结果是把从最右边的1开始的所有位都取反了，这个时候将n于n-1做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 n=12 1100 n-1=11 1011 n=12&amp;11 1000 n=8 1000 n-1=7 0111 n=8&amp;7 0000 代码：12345678public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; n &amp;= n-1; count++; &#125; return count;&#125; 更多参考点击：算法-求二进制数中1的个数 题目十二：数值的整数次方 （代码的完整性）题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路： 方法一：估计是个人都能想出来，假设要求a^b，只需将a连乘b次，此时的时间复杂度是O(b)。 方法二： 快速幂，快速幂能将复杂度降至O(logb)，确实是快了不少。 原理：假设我们要求a^b，b拆成二进制时，该二进制数第i位的权值为2^(i-1)，如下： a^11 = a^(1011) = a^(1000+0010+0001) = a^(2^0 + 2^1 + 2^3) = a^(2^0)*a^(2^1)*a^(2^3) 通过使用&amp;和&gt;&gt;位运算操作，依次遍历指数二进制表示中的每一位，我们发现，结果为每一位值为1时，也即a^(2^i)的累乘，此时，相邻位的值都是前一个值的翻倍。 更多信息：快速幂 代码：123456789101112131415161718public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1.0; int e = exponent; exponent = Math.abs(exponent); if(exponent == 0)&#123; return result; &#125; while(exponent!=0)&#123; if((exponent&amp;1)==1)&#123; result *= base; &#125; base *= base; //每移动一位，该为代表的乘数都翻倍 exponent = exponent &gt;&gt; 1; //右移一位 &#125; return e&gt;0?result:1/result; &#125;&#125; 题目十三：调整数组顺序使奇数位于偶数前面 （数组）题目描述:输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路： 方法一： 插入排序的思想。从第二个数开始，之前的数（也就只有一个数）是已经排好序的，此时如果第二个数是奇数的话，我们只需要插入到之前序列中所有偶数之前，如果是偶数的话，则不需要插入；继续第三个数，依次遍历完数组即可。 方法二：重新定义一个vector，从前往后遍历vector,遇到奇数push_back；再遍历一遍vector，遇到偶数push_back,以空间换时间，这就不实现了，easy。 代码：12345678910111213141516public class Solution &#123; public void reOrderArray(int [] array) &#123; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]%2==0)&#123; //偶数的话，继续下一个数 continue; &#125;else&#123; int tem = array[i]; //保存待插入到偶数之前的奇数 int j; for(j=i-1;j&gt;=0&amp;&amp;(array[j]%2==0);j--)&#123; //找到偶数之前插入的位置 array[j+1] = array[j]; //偶数集体后移一位 &#125; array[j+1] = tem; //将奇数插入到该位置上 &#125; &#125; &#125;&#125; 题目十四：链表中倒数第k个结点题目描述:输入一个链表，输出该链表中倒数第k个结点。 思路： 定义两个指针p1,p2，分别指向表头，再定义count=0,表示p1在第0个结点，此时p1开始遍历链表，每经过一个结点count++，当count&gt;=k时，p2开始遍历链表，直到p1遍历结束，此时p2指向的结点即为倒数第k个结点。 代码：1234567891011121314151617181920212223242526/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; int count = 0; ListNode p = head; ListNode node = null; //head为空，返回null if(k&lt;=0) return node; //k&lt;=0无效，返回null while(head!=null)&#123; count++; head = head.next; if(count &gt;= k) &#123; //相对第一个元素为k-1的间隔时,head和p同时往后走 node = p; p = p.next; &#125; &#125; return node; &#125;&#125; 题目十五：反转链表题目描述:输入一个链表，反转链表后，输出链表的所有元素。 思路： 依次遍历每个结点，同时通过头插法再重新创建新的链表 注：可以利用之前的结点，而不需要重新创建新的结点，以后改进。 代码：123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode p = null; if(head == null) &#123; return p; &#125;else&#123; p = new ListNode(head.val); &#125; ListNode q = head.next; while(q!=null)&#123; ListNode s = new ListNode(q.val); s.next = p; p = s; q = q.next; &#125; return p; &#125;&#125; 题目十六：合并两个排序的链表题目描述:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路： 当两个链表list1，list2（指向第一个结点）不空时，比较list1.val和list2.val的值，较小的作为合并后的第一个结点，假设list1.val较小，此时list1 = list1.next，继续比较list1.val和list2.val，直到某一个链表遍历结束，将没遍历结束的链表添加到合并后链表末尾。 注：可以利用之前的结点，而不需要重新创建新的结点，这样，最后直接指向没遍历结束的链表即可，同时也节省了创建新的结点的空间，后续改进。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode p = new ListNode(0); //创建一个头结点,数据域初始化为0，不存储数据,指针域为null ListNode head = p ; //头指针,指向头结点 if(list1 == null &amp;&amp; list2 == null) return null; while(list1!=null &amp;&amp; list2!=null)&#123; if(list1.val &lt; list2.val)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125;else &#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; &#125; while(list1!=null)&#123; ListNode s = new ListNode(list1.val); p.next = s; p = s; list1 = list1.next; &#125; while(list2!=null)&#123; ListNode s = new ListNode(list2.val); p.next = s; p = s; list2 = list2.next; &#125; return head.next; //头结点不存储元素,head.next指向第一个元素节点，返回 &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>剑指offer</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[样先]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%A0%B7%E5%85%88%2F</url>
    <content type="text"><![CDATA[仅以此记录样先发给我的新年贺词，时刻向兄弟学习！（侵犯他的隐私我不管，哈哈）新日左右： 余中求学生涯，惟君与余真正共事三年。初始，吾二人低而普通，待到分班，高而重点，止一年耳。忆往昔高中奋斗岁月，直叫人倍感追忆。 予闻朱子言，为学譬如熬肉，先须用猛火煮，然后用慢火温。盖士人读书，第一要有志，第二要有识，第三要有恒。有志则断不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。余注曰：“有志者，不在其小也。大者如孙、毛以救天下万民于水火为己任，周之为中华崛起而读书，小者以达一己之私，一举手，一投足。然小志者，亦有其蔽也。志小则为己，为己则时怠，怠则退而求其次，盖不知人自忍之大乎。呜呼！”此亦余之不足也，与老奸共勉。 大学确定考研否？准备否？书仍看否？新年细语，浅见孤陋，内心反复，诚惶诚恐。顺问近好。代问伯父、伯母好。 新年快乐！ 学业进步！ 甜甜蜜蜜！ 天天开心！ 样先 2015.2.18 真怀念高中的时光啊，现在大家相处的时间变得少了，遇见你们，真好，与兄弟们共勉，希望自己能做到最后一条，天天开心！]]></content>
      <categories>
        <category>兄弟</category>
      </categories>
      <tags>
        <tag>兄弟</tag>
        <tag>朋友</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（二） 提升篇]]></title>
    <url>%2F2017%2F08%2F07%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%20%20%E6%8F%90%E5%8D%87%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言在之前的初级篇中介绍了如何搭建个人博客。本文介绍如何更换博客主题、设置第三方服务和最重要的如何管理发布博客。 二、更换主题在这篇文章中，假定你已经成功安装了Hexo,并使用Hexo提供的命令创建了一个站点。 在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下（此处为G:\GitHub\hexo），主要包含Hexo本身的配置；另一份位于主题根目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件，后者称为主题配置文件。 1. 安装NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 1) 下载主题如果你熟悉Git，建议你使用克隆最新版本的方式，之后的更新可以通过git pull来快速更新，而不用再次下载压缩包替换。 （说多了都是累啊，早知道就该看官网了，我就是下载的压缩包，估计是没法快速更新了） 在终端窗口下，定位到 Hexo 站点目录下。使用 Git 命令：12cd G:\GitHub\hexogit clone https://github.com/iissnan/hexo-theme-next themes/next #后面意思是clone到该目录下themes/next文件夹中 2) 启用主题与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。 1theme: next 此时我们在主题配置文件中设置语言。修改language字段。在主题的languages文件夹中选择语言，此处目录为G:\GitHub\hexo\themes\next\languages 。 1language: zh-Hans #选择汉语，选择其他语言填写其他值即可 到此，NexT主题安装完成。下一步将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用hexo clean 来清除Hexo的缓存。 3) 验证主题进入到博客文件夹根目录，此处为G:\GitHub\hexo，执行如下命令： 123hexo clean #更换主题，最好先清除Hexo缓存hexo generate #生成静态页面hexo server # hexo server -p **** 更换默认4000端口为**** 此时即可使用浏览器访问 http://localhost:4000。 检查站点是否正确运行，如长时间访问不了，更改端口。 现在，你已经成功安装并启用了NexT主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 三、主题设定NexT官网和网上资料非常丰富，就不细说了，参考如下： 官方参考：NexT使用文档 网上资源：hexo的next主题个性化教程：打造炫酷网站 补充几点： 1. 添加评论功能我选择的是来比力，很简单，注册一个账号，妈的，是韩国的网站，发验证码竟然是韩文，通过有道词典才知道它讲的是啥，输入四位验证码回车后，然后填写相关信息，申请获取代码，然后得到安装代码中的data-uid。 编辑主题配置文件， 编辑 livere_uid 字段，设置如下： 1livere_uid: #your livere_uid 2. 修改背景图片首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下； 然后进入hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加入如下代码就完事了。 12345// Custom styles.body &#123; background:url(/images/background.jpeg); background-attachment: fixed; #固定背景图，使得不随页面移动&#125; 3. 修改博客内容宽度Pisces Scheme 直接在./themes/next/source/css/_variables/custom.styl文件中添加 12$main-desktop = 1200px $content-desktop = 900px 可以避免直接修改源码，可以解决内容宽度问题，而且在移动设备上显示正常。 参考：感觉浏览器留白太多，代码块看起来比较麻烦 4. 添加菜单栏在个人网站根目录下使用hexo命令hexo new page “photo” 就直接创建了.\Hexo\source\photo\index.md文件。 在主题配置文件_config.yml中找到meun:字段，添加photo字段123456789menu: home: / categories: /categories/ tags: /tags/ archives: /archives/ photo: /photo/ about: /about/ #sitemap: /sitemap.xml #commonweal: /404.html 给photo添加相应的图标，还是刚才的主题配置文件_config.yml，添加photo字段： 123456789101112menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat photo: photo 在如下图标库中选择喜欢的icon，添加相应的名称即可，这里添加为photo：点击选择图标 将网站中的photo字段显示为中文照片字段 在\themes\next\languages\zh-Hans.yml添加： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 photo: 照片 5. 调整首页文档摘要和阅读全文按钮高度并删除居中灰色线条1.调整文档摘要的高度 在/next/source/css/_common/components/post/post-meta.styl中修改margin的值 123.posts-expand .post-meta &#123; margin: 3px 0 10px 0; color: $grey-dark; 2.调整阅读全文按钮高度 在\next\source\css_common\components\post\post-button.styl中修改margin-top的值 123.post-button &#123; margin-top: 10px; .btn &#123; 3.去除首页文档与文档之间居中灰色的线条 在\next\source\css_common\components\post\post-eof.styl中注释掉如下样式 123456789101112.posts-expand &#123; .post-eof &#123; /* display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 8%; height: 1px; background: $grey-light; text-align: center; */ &#125;&#125; 最终效果如下： 6. 归档页博文列表高度调整在\next\source\css_common\components\post\post-collapse.styl中修改.post 1.post &#123; margin: 0px 0; &#125; 到这的时候，主题应该也优化的差不多，接下来就是写博客和管理了，加油搞起。 四、博客管理维护1. 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，因为.md文件不存在了，就不可能了（除非你自己写html）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 注： .gitignoree文件中的内容是忽略上传至Github仓库的文件，这里我修改成如下：1.deploy*/ #只忽略上传.deploy*/开头的文件 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 2. 博客搭建流程 1.创建仓库，xinrisanshao.github.io； 2.创建两个分支：master 与 hexo； 3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 4.使用如下命令拷贝仓库 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 5.在本地xinrisanshao.github.io文件夹下通过Git shell依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 6.修改_config.yml中的deploy参数，分支应为master； 7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件（Hexo网站根目录执行）； 8.执行hexo generate -d生成网站并部署到GitHub上（Hexo网站根目录执行）。 这样一来，在GitHub上的xinrisanshao.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。修改了博客网站原始文件，然后发布到hexo分支上进行保存，同时修改后新的静态网页deploy到master,同步更新，两者都保存至Github仓库上，不怕文件丢失了。 注：流程的5,6步hexo init创建的是一个新的Hexo网站文件，我们在本地配置好的Hexo+next主题的网站文件可以直接复制到.\xinrisanshao.github.io\文件夹中，直接代替5,6步创建的流程，这样就不需要我们再次重复配置了，其他的过程都是一样的。 3. 博客管理流程1. 编辑与修改博客在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 2.然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 2. 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：1.首先安装Git，Node.js和Hexo。 2.使用下面命令拷贝仓库（默认分支为hexo）； 1git clone https://github.com/xinrisanshao/xinrisanshao.github.io.git 3.因为之前的.gitignore文件只忽略了上传.deploy*/开头的文件，所以我们上传到hexo分支的是整个的Hexo网站文件，下载之后直接什么依赖配置都好了，此时即可照着编辑与修改博客流程进行博客编辑了，大功告成。 以上博客管理参考：点击查看 3. 博客图片存放（补）如果将博客的图片放在Hexo网站文件中，那么加载博客的时候会变得非常慢，此时，我们可以选择一个合适的图床存放图片，然后获得图片的链接地址，这样访问速度会变快许多。 我选择的是七牛云存放图片，具体使用方法很简单，注册账号，上传图片至空间中，这些就不细说了，网上一大堆资料。 五、总结不想再敲了，好累！这也算是对搭建这个博客的一个总结吧，休息去。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github Pages + Hexo搭建个人博客（一） 初级篇]]></title>
    <url>%2F2017%2F08%2F06%2Fgithub%20Pages%20%2B%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%20%20%E5%88%9D%E7%BA%A7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、前言之前一直是在有道云上做一些笔记的，上周末在网上看到了一些别人搭建的个人博客，顿时感兴趣起来，然后自己就瞎捣鼓了几天，最终搭建成功了，哈哈。在这个过程中发现，搭建一个网站还是比较简单的，难的是管理博客，更难的是写博客！！！这个过程中，注册了自己的第一个github账号（很失败有木有，太out了），同时也了解了一些git的版本控制，还知道了Markdown这种标记语言，后面的这些博客都是用这个标记语言写的，还是很有收获的。 今天特地总结一下使用github Pages + Hexo搭建个人博客的过程，以备不时之需。这里不谈理论，只谈过程，理论自己也不是很清楚，就不瞎说了，以后慢慢熟悉了，在补充！ 二、环境准备1. 注册github账号这个就不多说了，账号注册好后，登陆，在首页右边有一个 + 号图标，点击之后，选择New repository进行仓库的创建。Repository name命名为username.github.io（username是你的账号名，记住一定要这样命令哦)，点击Create repository，创建成功。 2. 安装Git我们之所以要安装git，是因为后面我们要用到git命令，将生成的静态博客网页等信息推送至github仓库，我们的git使用一般由两种方式，一种是图形化界面（GUI）,另外一种是通过命令行。这里我选择安装前者，带界面的，菜鸟嘛，不会git命令，先熟悉熟悉流程，顺带在这个过程中在了解git的一些常用命令。另外安装前者，在桌面上会生成两个图标， GitHub和Git Shell,这两个图标分别是图形界面和命令行工具，意思就是我们不仅可以使用图形界面的工具管理我们github上的仓库，同时也可以使用命令行的形式管理，自由切换，爽歪歪！ Github for Windows: 点击下载 下载安装完后，桌面上生成GitHub和Git Shell两个图标，然后点击GitHub图标，输入前面注册的github账号和密码，登录完成，ok，暂时先这样，接着往下走。 Github for Windows 安装配置使用教程: 参考 3. 安装Node.js安装Node.js,因为Hexo是一个基于Node.js的静态博客程序，所以首先安装Node.js。 点击进入Node.js官网 我们选择左边的通用版，点击下载后，设置安装路径然后默认安装就可以了。 4. 安装Hexo以上环境配好了之后，那么恭喜您！接下来只需要使用npm即可完成Hexo的安装。 打开终端，输入： 1npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。 1npm config set registry https://registry.npm.taobao.org 安装好Hexo以后，在终端输入： 1hexo 若出现下图，说明hexo安装成功： 三、使用Hexo建站1. 初始化博客新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。比如我在终端进入到G:Github目录，输入hexo init hexo，则在该目录下创建了hexo博客文件夹。 1hexo init [folder] 接下来进入到博客文件夹，这里是E:Github/hexo，执行如下命令，根据该目录下的package.json中既定的dependencies配置安装所有的依赖包 1npm install 2. 配置网站的主配置文件为hexo根目录下的_config.yml文件： 默认配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle:description:author: John Doelanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 这些配置项所代表的意思可以参考Hexo中文网：_config.yml配置 ，我们需要修改的配置只有这几项，拿我自己修改的配置作为示例。 1). 修改网站相关信息123456title: 新日三少的博客 subtitle: Big big pig description: Love Coding,Enjoy Lifeauthor: 新日三少language: zh-CN #themes主题文件夹下的languages下面有很多语言可选timezone: Asia/Shanghai 注意：每一项的填写，其:后面都要保留一个空格，下同。 2). 配置统一资源定位符（个人域名）1url: http://www.wangxinri.cn 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。如无个人域名，无需修改这一项。 3). 配置部署1234deploy: type: git repo: https://github.com/xinrisanshao/xinrisanshao.github.io.git branch: master 其中repo项是之前Github上创建好的仓库的地址，，可以通过如下图所示的方式得到： 3. 本地发布博客接下来，在网站中建立第一篇文章，打开终端，进入到博客文件夹根目录，这里是E:Github/hexo，然后输入 1hexo new "文章标题" 我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。通过Markdown编辑器对我们文章进行编辑，我这采用的是Markdownpad2编辑器。 MarkdownPad2：点击下载 Markdown语法：Markdown中文网 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1npm install hexo-deployer-git --save 接下来,我们进行本地发布：12hexo generatehexo server 执行完后，打开浏览器，输入：1http://localhost:4000/ 我们可以在浏览器端看到我们搭建好的博客和发布的文章，如果访问失败，可能端口被占用，更换端口 hexo server -p 5000 ,将默认4000端口换成5000。 4. 发布博客至github仓库但是毕竟我们目前发布的博客只有本机看得到，怎么让其他人看到我们写的博客呢？这时候我们来看看博客的部署。 打开终端，进入到博客文件夹根目录，这里还是E:Github/hexo，执行如下命令： 12hexo generatehexo deploy 输入我们的网址：xinrisanshao.github.io ,即可访问博客了。 此时查看github中的仓库，发现我们博客文件夹根目录中的public文件夹里面的文件已经发布到仓库中了。 此时搭建的博客还只是入门，外观确实一般般，接下来将更进一步，比如如何更换主题、如何管理博客等等。 好累啊，先休息下，果然还是写博客最累啊。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>